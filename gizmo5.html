<!DOCTYPE html>
<html lang="en">
    <head>
        <script>
            !function(e, t, n, o) {
                "use strict";
                var i, r, c = !1, u = {};
                function s(e, t, n, o, i) {
                    o = o || 0,
                    i = i || 0,
                    this.identifier = t,
                    this.target = e,
                    this.clientX = n.clientX + o,
                    this.clientY = n.clientY + i,
                    this.screenX = n.screenX + o,
                    this.screenY = n.screenY + i,
                    this.pageX = n.pageX + o,
                    this.pageY = n.pageY + i
                }
                function a() {
                    var e = [];
                    return e.item = function(e) {
                        return this[e] || null
                    }
                    ,
                    e.identifiedTouch = function(e) {
                        return this[e + 1] || null
                    }
                    ,
                    e
                }
                function d(e) {
                    e.preventDefault(),
                    e.stopPropagation()
                }
                function h(e) {
                    return function(t) {
                        d(t),
                        1 === t.which && (("mousedown" == t.type || !r || r && !r.dispatchEvent) && (r = t.target),
                        c && !t.shiftKey && (l("touchend", t),
                        c = !1),
                        l(e, t),
                        !c && t.shiftKey && (c = !0,
                        i = {
                            pageX: t.pageX,
                            pageY: t.pageY,
                            clientX: t.clientX,
                            clientY: t.clientY,
                            screenX: t.screenX,
                            screenY: t.screenY
                        },
                        l("touchstart", t)),
                        "mouseup" == t.type && (i = null,
                        c = !1,
                        r = null))
                    }
                }
                function l(e, n) {
                    var o = t.createEvent("Event");
                    o.initEvent(e, !0, !0),
                    o.altKey = n.altKey,
                    o.ctrlKey = n.ctrlKey,
                    o.metaKey = n.metaKey,
                    o.shiftKey = n.shiftKey,
                    o.touches = p(n, e),
                    o.targetTouches = p(n, e),
                    o.changedTouches = function(e, t) {
                        var n = f(e);
                        !c || "mouseup" == e.type || "touchstart" != t && "touchend" != t || n.splice(0, 1);
                        return n
                    }(n, e),
                    r.dispatchEvent(o)
                }
                function f(e) {
                    var t = new a;
                    if (c) {
                        var n = m.multiTouchOffset
                          , o = i.pageX - e.pageX
                          , u = i.pageY - e.pageY;
                        t.push(new s(r,1,i,-1 * o - n,-1 * u + n)),
                        t.push(new s(r,2,i,o + n,u - n))
                    } else
                        t.push(new s(r,1,e,0,0));
                    return t
                }
                function p(e, t) {
                    if ("mouseup" == e.type)
                        return new a;
                    var n = f(e);
                    return c && "mouseup" != e.type && "touchend" == t && n.splice(1, 1),
                    n
                }
                function v(e) {
                    var n, o, i, r;
                    for (o = 0; o < e.touches.length; o++)
                        for (var c in n = e.touches[o],
                        (i = u[n.identifier]) || (i = u[n.identifier] = t.createElement("div"),
                        t.body.appendChild(i)),
                        r = m.template(n))
                            i.style[c] = r[c];
                    if ("touchend" == e.type || "touchcancel" == e.type)
                        for (o = 0; o < e.changedTouches.length; o++)
                            n = e.changedTouches[o],
                            (i = u[n.identifier]) && (i.parentNode.removeChild(i),
                            delete u[n.identifier])
                }
                function m() {
                    "ontouchstart"in e || e.Modernizr && e.Modernizr.touch || (navigator.msMaxTouchPoints || navigator.maxTouchPoints) > 2 || (!function() {
                        for (var n = [e, t.documentElement], i = ["ontouchstart", "ontouchmove", "ontouchcancel", "ontouchend"], r = 0; r < n.length; r++)
                            for (var c = 0; c < i.length; c++)
                                n[r] && n[r][i[c]] == o && (n[r][i[c]] = null)
                    }(),
                    e.addEventListener("mousedown", h("touchstart"), !0),
                    e.addEventListener("mousemove", h("touchmove"), !0),
                    e.addEventListener("mouseup", h("touchend"), !0),
                    e.addEventListener("mouseenter", d, !0),
                    e.addEventListener("mouseleave", d, !0),
                    e.addEventListener("mouseout", d, !0),
                    e.addEventListener("mouseover", d, !0),
                    e.addEventListener("touchstart", v, !1),
                    e.addEventListener("touchmove", v, !1),
                    e.addEventListener("touchend", v, !1),
                    e.addEventListener("touchcancel", v, !1))
                }
                t.createTouch || (t.createTouch = function(t, n, i, r, c, u, a, d, h) {
                    return d != o && h != o || (d = r - e.pageXOffset,
                    h = c - e.pageYOffset),
                    new s(n,i,{
                        pageX: r,
                        pageY: c,
                        screenX: u,
                        screenY: a,
                        clientX: d,
                        clientY: h
                    })
                }
                ),
                t.createTouchList || (t.createTouchList = function() {
                    for (var e = new a, t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    return e.length = arguments.length,
                    e
                }
                ),
                m.multiTouchOffset = 75,
                m.template = function(e) {
                    var t = "translate(" + (e.clientX - 15) + "px, " + (e.clientY - 15) + "px)";
                    return {
                        position: "fixed",
                        left: 0,
                        top: 0,
                        background: "#fff",
                        border: "solid 1px #999",
                        opacity: .6,
                        borderRadius: "100%",
                        height: "30px",
                        width: "30px",
                        padding: 0,
                        margin: 0,
                        display: "block",
                        overflow: "hidden",
                        pointerEvents: "none",
                        webkitUserSelect: "none",
                        mozUserSelect: "none",
                        userSelect: "none",
                        webkitTransform: t,
                        mozTransform: t,
                        transform: t
                    }
                }
                ,
                "function" == typeof define && define.amd ? define((function() {
                    return m
                }
                )) : "undefined" != typeof module && module.exports ? module.exports = m : e.TouchEmulator = m
            }(window, document);
            TouchEmulator();
        </script>
        <meta charset="utf-8">
        <meta content="width=device-width,minimum-scale=1.0" name="viewport">
        <title>Gizmo</title>
        <style>
            *,:after,:before {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            ::backdrop {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            /*
! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com
*/
            *,:after,:before {
                border: 0 solid #e5e7eb;
                box-sizing: border-box
            }

            :after,:before {
                --tw-content: ""
            }

            :host,html {
                line-height: 1.5;
                -webkit-text-size-adjust: 100%;
                font-family: ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;
                font-feature-settings: normal;
                font-variation-settings: normal;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
                -webkit-tap-highlight-color: transparent;
                width: 100%;
                height: 100%;
                overflow: hidden;
                position: fixed
            }

            body {
                line-height: inherit;
                margin: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                position: fixed
            }

            hr {
                border-top-width: 1px;
                color: inherit;
                height: 0
            }

            abbr:where([title]) {
                -webkit-text-decoration: underline dotted;
                text-decoration: underline dotted
            }

            h1,h2,h3,h4,h5,h6 {
                font-size: inherit;
                font-weight: inherit
            }

            a {
                color: inherit;
                text-decoration: inherit
            }

            b,strong {
                font-weight: bolder
            }

            code,kbd,pre,samp {
                font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;
                font-feature-settings: normal;
                font-size: 1em;
                font-variation-settings: normal
            }

            small {
                font-size: 80%
            }

            sub,sup {
                font-size: 75%;
                line-height: 0;
                position: relative;
                vertical-align: baseline
            }

            sub {
                bottom: -.25em
            }

            sup {
                top: -.5em
            }

            table {
                border-collapse: collapse;
                border-color: inherit;
                text-indent: 0
            }

            button,input,optgroup,select,textarea {
                color: inherit;
                font-family: inherit;
                font-feature-settings: inherit;
                font-size: 100%;
                font-variation-settings: inherit;
                font-weight: inherit;
                letter-spacing: inherit;
                line-height: inherit;
                margin: 0;
                padding: 0
            }

            button,select {
                text-transform: none
            }

            button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]) {
                -webkit-appearance: button;
                background-color: transparent;
                background-image: none
            }

            :-moz-focusring {
                outline: auto
            }

            :-moz-ui-invalid {
                box-shadow: none
            }

            progress {
                vertical-align: baseline
            }

            ::-webkit-inner-spin-button,::-webkit-outer-spin-button {
                height: auto
            }

            [type=search] {
                -webkit-appearance: textfield;
                outline-offset: -2px
            }

            ::-webkit-search-decoration {
                -webkit-appearance: none
            }

            ::-webkit-file-upload-button {
                -webkit-appearance: button;
                font: inherit
            }

            summary {
                display: list-item
            }

            blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre {
                margin: 0
            }

            fieldset {
                margin: 0
            }

            fieldset,legend {
                padding: 0
            }

            menu,ol,ul {
                list-style: none;
                margin: 0;
                padding: 0
            }

            dialog {
                padding: 0
            }

            textarea {
                resize: vertical
            }

            input::-moz-placeholder,textarea::-moz-placeholder {
                color: #9ca3af;
                opacity: 1
            }

            input::placeholder,textarea::placeholder {
                color: #9ca3af;
                opacity: 1
            }

            [role=button],button {
                cursor: pointer
            }

            :disabled {
                cursor: default
            }

            audio,canvas,embed,iframe,img,object,svg,video {
                display: block;
                vertical-align: middle
            }

            img,video {
                height: auto;
                max-width: 100%
            }

            [hidden]:where(:not([hidden=until-found])) {
                display: none
            }

            .fixed {
                position: fixed
            }

            .absolute {
                position: absolute
            }

            .inset-0 {
                inset: 0
            }

            .-z-10 {
                z-index: -10
            }

            .transform {
                transform: translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
            }

            .touch-none {
                touch-action: none
            }

            * {
                -webkit-user-select: none;
                -moz-user-select: none;
                user-select: none
            }

            img {
                pointer-events: none;
                -webkit-touch-callout: none
            }

            /*# sourceMappingURL=app.css.map */
        </style>
        <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' blob: data: *.gizmo.party *.content.gizmo.party; media-src 'self' data: *.gizmo.party *.content.gizmo.party; connect-src 'self' blob: *.gizmo.party *.content.gizmo.party; script-src 'self' blob: 'unsafe-eval' 'unsafe-inline' runtime.gizmo.party; style-src 'self' 'unsafe-inline'; worker-src 'self' blob:; font-src 'self' data:; object-src 'none'; base-uri 'none'; upgrade-insecure-requests; block-all-mixed-content">
    </head>
    <body>
        <div id="application">
            <script type="module">
                var H3 = Object.create
                  , rA = Object.defineProperty
                  , V3 = Object.getOwnPropertyDescriptor
                  , tE = Object.getOwnPropertyNames
                  , G3 = Object.getPrototypeOf
                  , k3 = Object.prototype.hasOwnProperty
                  , cn = (e, t) => function() {
                    return t || (0,
                    e[tE(e)[0]])((t = {
                        exports: {}
                    }).exports, t),
                    t.exports
                }
                  , X3 = e => {
                    let t = {};
                    for (var n in e)
                        rA(t, n, {
                            get: e[n],
                            enumerable: !0
                        });
                    return t
                }
                  , q3 = (e, t, n, i) => {
                    if (t && typeof t == "object" || typeof t == "function")
                        for (var s = tE(t), r = 0, l = s.length, h; r < l; r++)
                            h = s[r],
                            !k3.call(e, h) && h !== n && rA(e, h, {
                                get: (d => t[d]).bind(null, h),
                                enumerable: !(i = V3(t, h)) || i.enumerable
                            });
                    return e
                }
                  , tr = (e, t, n) => (n = e != null ? H3(G3(e)) : {},
                q3(t || !e || !e.__esModule ? rA(n, "default", {
                    value: e,
                    enumerable: !0
                }) : n, e))
                  , oA = cn({
                    "node_modules/@gizmo/runtime/dist/src/utils/cancellable.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.setTimeoutCancellable = n;
                        var t = class {
                            callback;
                            _cancelled = !1;
                            constructor(i) {
                                this.callback = i
                            }
                            cancel = () => {
                                if (this._cancelled)
                                    return;
                                this._cancelled = !0;
                                const i = this.callback;
                                this.callback = void 0,
                                i?.()
                            }
                            ;
                            get isCancelled() {
                                return this._cancelled
                            }
                        }
                        ;
                        e.Cancellable = t;
                        function n(i, s) {
                            const r = setTimeout(i, s);
                            return new t( () => {
                                clearTimeout(r)
                            }
                            )
                        }
                    }
                    )
                })
                  , nE = cn({
                    "node_modules/@gizmo/runtime/dist/src/utils/emitter.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        var t = class extends EventTarget {
                            emit(i, s) {
                                this.dispatchEvent(new n(i,s))
                            }
                        }
                        ;
                        e.EventEmitter = t;
                        var n = class extends Event {
                            payload;
                            constructor(i, s) {
                                super(i),
                                this.payload = s
                            }
                        }
                        ;
                        e.EventEmitterEvent = n
                    }
                    )
                })
                  , Y3 = cn({
                    "node_modules/@gizmo/runtime/dist/src/channel.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        const t = oA()
                          , n = nE();
                        var i = class {
                            emitter = new n.EventEmitter;
                            emit(s) {
                                this.emitter.emit(s.endpoint, s.payload)
                            }
                            subscribe(s, r) {
                                const l = h => {
                                    const d = h.payload;
                                    r(d)
                                }
                                ;
                                return this.emitter.addEventListener(s, l),
                                new t.Cancellable( () => {
                                    this.emitter.removeEventListener(s, l)
                                }
                                )
                            }
                            once(s, r) {
                                const l = this.subscribe(s, h => {
                                    l.cancel(),
                                    r(h)
                                }
                                );
                                return l
                            }
                        }
                        ;
                        e.ReceiveChannel = i
                    }
                    )
                })
                  , iE = cn({
                    "node_modules/@gizmo/runtime/dist/src/utils/observable.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        const t = oA()
                          , n = nE();
                        var i = class {
                            emitter = new n.EventEmitter;
                            send(s) {
                                this.emitter.emit("value", s)
                            }
                            subscribe(s) {
                                const r = l => {
                                    const h = l.payload;
                                    s(h)
                                }
                                ;
                                return this.emitter.addEventListener("value", r),
                                new t.Cancellable( () => {
                                    this.emitter.removeEventListener("value", r)
                                }
                                )
                            }
                        }
                        ;
                        e.PassthroughSubject = i
                    }
                    )
                })
                  , sE = cn({
                    "node_modules/@gizmo/runtime/dist/src/tweaks/color.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.colorToHexString = t,
                        e.colorFromString = n;
                        function t(m) {
                            return m.a === 1 ? `#${r(m).toString(16).padStart(6, "0").toUpperCase()}` : `#${l(m).toString(16).padStart(8, "0").toUpperCase()}`
                        }
                        function n(m) {
                            if (m) {
                                if (m.startsWith("rgb(") || m.startsWith("rgba("))
                                    return h(m);
                                if (m.startsWith("#") && (m = m.slice(1)),
                                m.length === 6)
                                    return i(parseInt(m, 16));
                                if (m.length === 8)
                                    return s(parseInt(m, 16))
                            }
                        }
                        function i(m) {
                            m >>>= 0;
                            const v = (m & 16711680) >>> 16
                              , _ = (m & 65280) >>> 8
                              , x = m & 255;
                            return {
                                r: v,
                                g: _,
                                b: x,
                                a: 1
                            }
                        }
                        function s(m) {
                            m >>>= 0;
                            const v = (m & 4278190080) >>> 24
                              , _ = (m & 16711680) >>> 16
                              , x = (m & 65280) >>> 8
                              , b = m & 255;
                            return {
                                r: v,
                                g: _,
                                b: x,
                                a: b / 255
                            }
                        }
                        function r(m) {
                            let v = (m.r & 255) << 16;
                            return v = v | (m.g & 255) << 8,
                            v = v | m.b & 255,
                            v >>> 0
                        }
                        function l(m) {
                            let v = (m.r & 255) << 24;
                            return v = v | (m.g & 255) << 16,
                            v = v | (m.b & 255) << 8,
                            v = v | m.a * 255 & 255,
                            v >>> 0
                        }
                        function h(m) {
                            if (m) {
                                if (m.startsWith("rgb(") && m.endsWith(")")) {
                                    const v = m.substring(4, m.length - 1).split(", ");
                                    return p(+(v[0] ?? 0), +(v[1] ?? 0), +(v[2] ?? 0), 1)
                                }
                                if (m.startsWith("rgba(") && m.endsWith(")")) {
                                    const v = m.substring(5, m.length - 1).split(", ");
                                    return p(+(v[0] ?? 0), +(v[1] ?? 0), +(v[2] ?? 0), +(v[3] ?? 1))
                                }
                            }
                        }
                        function d(m, v, _) {
                            return Math.max(Math.min(m, _), v)
                        }
                        function p(m, v, _, x) {
                            return {
                                r: d(m, 0, 255),
                                g: d(v, 0, 255),
                                b: d(_, 0, 255),
                                a: d(x, 0, 1)
                            }
                        }
                    }
                    )
                })
                  , W3 = cn({
                    "node_modules/@gizmo/runtime/dist/src/tweaks/validation.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.processConfig = n;
                        const t = sE();
                        function n(v) {
                            const _ = {};
                            for (const [x,b] of Object.entries(v))
                                try {
                                    _[x] = i(x, b)
                                } catch (E) {
                                    console.error("Error validating tweaks config:", E)
                                }
                            return _
                        }
                        function i(v, _) {
                            switch (p(_, v, "name", "string"),
                            p(_, v, "index", "number"),
                            _.type) {
                            case "slider":
                                return s(v, _);
                            case "toggle":
                                return r(v, _);
                            case "color":
                                return l(v, _);
                            case "text":
                                return h(v, _);
                            default:
                                throw new Error(`Invalid config type: ${_.type}`)
                            }
                        }
                        function s(v, _) {
                            if (d(_, v, "value", "number"),
                            d(_, v, "min", "number"),
                            d(_, v, "max", "number"),
                            d(_, v, "step", "number"),
                            _.min >= _.max)
                                throw new Error(`Invalid slider config for "${v}", expected min (${_.min}) < max (${_.max})`);
                            if (_.step <= 0)
                                throw new Error(`Invalid slider config for "${v}", expected step (${_.step}) > 0`);
                            if (_.value < _.min)
                                throw new Error(`Invalid slider config for "${v}", expected value (${_.value}) >= min (${_.min})`);
                            if (_.value > _.max)
                                throw new Error(`Invalid slider config for "${v}", expected value (${_.value}) <= max (${_.max})`);
                            return _
                        }
                        function r(v, _) {
                            return d(_, v, "value", "boolean"),
                            _
                        }
                        function l(v, _) {
                            d(_, v, "value", "string");
                            const x = (0,
                            t.colorFromString)(_.value);
                            if (!x)
                                throw new Error(`Tweaks config has incorrect color value for ${v}, got ${_.value} but expected color hex, rgb(), rgba()`);
                            return {
                                ..._,
                                value: (0,
                                t.colorToHexString)(x)
                            }
                        }
                        function h(v, _) {
                            return d(_, v, "value", "string"),
                            _
                        }
                        function d(v, _, x, b) {
                            const E = v[x];
                            if (typeof E !== b)
                                throw new m(_,x,b,E)
                        }
                        function p(v, _, x, b) {
                            const E = v[x];
                            if (E !== void 0 && typeof E !== b)
                                throw new m(_,x,b,E)
                        }
                        var m = class extends Error {
                            constructor(v, _, x, b) {
                                super(`Tweaks config has incorrect value type for ${v} ${_}, expected ${x} got ${typeof b}`)
                            }
                        }
                    }
                    )
                })
                  , j3 = cn({
                    "node_modules/@gizmo/runtime/dist/src/tweaks/tweaks.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.createTweaks = s;
                        const t = iE()
                          , n = sE()
                          , i = W3();
                        function s(d, p) {
                            const m = (0,
                            i.processConfig)(d)
                              , v = new r(p,m)
                              , _ = {};
                            for (const x of Object.keys(d))
                                _[x] = {
                                    useState: () => v.useState(x)
                                };
                            return [_, m]
                        }
                        var r = class {
                            observable;
                            values;
                            subject = new t.PassthroughSubject;
                            constructor(d, p) {
                                this.observable = d,
                                this.values = l(p),
                                this.observable.subscribe(m => {
                                    for (const [v,_] of Object.entries(m.values)) {
                                        const x = p[v];
                                        if (x === void 0)
                                            return;
                                        const b = h(x, _);
                                        if (b === void 0)
                                            return;
                                        this.values[v] !== b && (this.values[v] = b,
                                        this.subject.send(v))
                                    }
                                }
                                )
                            }
                            getValue(d) {
                                const p = this.values[d];
                                if (p === void 0)
                                    throw new Error(`Tweak key not found in values: ${d}`);
                                return p
                            }
                            useState(d) {
                                const p = window.React;
                                if (!p || !p.useReducer || !p.useEffect)
                                    return console.warn("React not found on window"),
                                    this.getValue(d);
                                const [m,v] = p.useReducer( () => this.getValue(d), this.getValue(d));
                                return p.useEffect( () => {
                                    const _ = this.subject.subscribe(x => {
                                        x === d && v()
                                    }
                                    );
                                    return () => {
                                        _.cancel()
                                    }
                                }
                                ),
                                m
                            }
                        }
                        ;
                        function l(d) {
                            const p = {};
                            for (const m of Object.entries(d))
                                p[m[0]] = m[1].value;
                            return p
                        }
                        function h(d, p) {
                            switch (d.type) {
                            case "slider":
                                {
                                    const m = parseFloat(p);
                                    return isNaN(m) ? void 0 : m
                                }
                            case "toggle":
                                return p === "true";
                            case "color":
                                {
                                    const m = (0,
                                    n.colorFromString)(p);
                                    return m ? (0,
                                    n.colorToHexString)(m) : void 0
                                }
                            case "text":
                                return p
                            }
                        }
                    }
                    )
                })
                  , aE = cn({
                    "node_modules/@gizmo/runtime/dist/src/index.js": (e => {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                        const t = Y3()
                          , n = j3()
                          , i = oA()
                          , s = iE();
                        var r = class {
                            receiveChannel = new t.ReceiveChannel;
                            seq = 0;
                            tweaksListener = void 0;
                            tweaksInstance = void 0;
                            tweaksDidWarn = !1;
                            tweaks(l) {
                                if (this.tweaksInstance)
                                    return this.tweaksDidWarn || (this.tweaksDidWarn = !0,
                                    console.warn("tweaks() is expected to only be called once, returning previous value")),
                                    this.tweaksInstance;
                                const h = new s.PassthroughSubject
                                  , [d,p] = (0,
                                n.createTweaks)(l, h);
                                return this.tweaksInstance = d,
                                this.tweaksListener?.cancel(),
                                this.tweaksListener = this.addTweaksListener(p, m => {
                                    h.send(m)
                                }
                                ),
                                d
                            }
                            receiveMessage(l) {
                                return this.receiveChannel.emit(l),
                                Promise.resolve()
                            }
                            performHaptic(l) {
                                typeof l == "object" && "style"in l && typeof l.style == "string" && (l = l.style),
                                window.webkit?.messageHandlers?.hapticHandler?.postMessage(this.makeMessage({
                                    kind: "impact",
                                    style: l
                                }))
                            }
                            generateText(l) {
                                const h = window.webkit?.messageHandlers?.textGenerationHandler;
                                return h ? this.performHandlerRequest(h, {
                                    prompt: l.prompt,
                                    imageData: l.imageData
                                }, 3e4) : Promise.reject(new Error("Not available"))
                            }
                            addShakeListener(l) {
                                const h = window.webkit?.messageHandlers?.deviceMotionHandler;
                                if (!h)
                                    return console.warn("Shake handler not available"),
                                    () => {}
                                    ;
                                const d = this.createSubscription(h, {
                                    type: "shake"
                                }, () => {
                                    l()
                                }
                                );
                                return () => {
                                    d.cancel()
                                }
                            }
                            addMotionListener(l) {
                                const h = window.webkit?.messageHandlers?.deviceMotionHandler;
                                if (!h)
                                    return console.warn("Motion handler not available"),
                                    () => {}
                                    ;
                                const d = this.createSubscription(h, {
                                    type: "motion"
                                }, p => {
                                    p.motion && l(p.motion)
                                }
                                );
                                return () => {
                                    d.cancel()
                                }
                            }
                            addTweaksListener(l, h) {
                                const d = window.webkit?.messageHandlers?.tweaksHandler;
                                return d ? this.createSubscription(d, {
                                    type: "initialize",
                                    config: JSON.stringify(l)
                                }, p => {
                                    h(p)
                                }
                                ) : new i.Cancellable(void 0)
                            }
                            createSubscription(l, h, d) {
                                const p = this.makeSubscriptionMessage(h)
                                  , m = this.receiveChannel.subscribe(p.endpoint, v => {
                                    if (v.error !== void 0) {
                                        console.error(`Subscription error: ${v.error}`);
                                        return
                                    }
                                    d(v)
                                }
                                );
                                return l.postMessage(p),
                                new i.Cancellable( () => {
                                    m.cancel(),
                                    l.postMessage({
                                        endpoint: p.endpoint,
                                        payload: "unsubscribe"
                                    })
                                }
                                )
                            }
                            performHandlerRequest(l, h, d) {
                                return new Promise( (p, m) => {
                                    const v = this.makeMessage(h)
                                      , _ = this.receiveChannel.once(v.endpoint, b => {
                                        x.cancel(),
                                        b.error !== void 0 ? m(new Error(`Error: ${b.error}`)) : p(b)
                                    }
                                    )
                                      , x = (0,
                                    i.setTimeoutCancellable)( () => {
                                        _.cancel(),
                                        m(new Error("Request timed out"))
                                    }
                                    , d);
                                    l.postMessage(v)
                                }
                                )
                            }
                            makeMessage(l) {
                                return {
                                    endpoint: (this.seq++).toString(),
                                    payload: l
                                }
                            }
                            makeSubscriptionMessage(l) {
                                return {
                                    endpoint: (this.seq++).toString(),
                                    payload: {
                                        subscribe: l
                                    }
                                }
                            }
                        }
                        ;
                        e.gizmoRuntime = new r
                    }
                    )
                })
                  , Q3 = cn({
                    "node_modules/react/cjs/react.production.js": (e => {
                        var t = Symbol.for("react.transitional.element")
                          , n = Symbol.for("react.portal")
                          , i = Symbol.for("react.fragment")
                          , s = Symbol.for("react.strict_mode")
                          , r = Symbol.for("react.profiler")
                          , l = Symbol.for("react.consumer")
                          , h = Symbol.for("react.context")
                          , d = Symbol.for("react.forward_ref")
                          , p = Symbol.for("react.suspense")
                          , m = Symbol.for("react.memo")
                          , v = Symbol.for("react.lazy")
                          , _ = Symbol.iterator;
                        function x(X) {
                            return X === null || typeof X != "object" ? null : (X = _ && X[_] || X["@@iterator"],
                            typeof X == "function" ? X : null)
                        }
                        var b = {
                            isMounted: function() {
                                return !1
                            },
                            enqueueForceUpdate: function() {},
                            enqueueReplaceState: function() {},
                            enqueueSetState: function() {}
                        }
                          , E = Object.assign
                          , T = {};
                        function M(X, J, ze) {
                            this.props = X,
                            this.context = J,
                            this.refs = T,
                            this.updater = ze || b
                        }
                        M.prototype.isReactComponent = {},
                        M.prototype.setState = function(X, J) {
                            if (typeof X != "object" && typeof X != "function" && X != null)
                                throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
                            this.updater.enqueueSetState(this, X, J, "setState")
                        }
                        ,
                        M.prototype.forceUpdate = function(X) {
                            this.updater.enqueueForceUpdate(this, X, "forceUpdate")
                        }
                        ;
                        function D() {}
                        D.prototype = M.prototype;
                        function R(X, J, ze) {
                            this.props = X,
                            this.context = J,
                            this.refs = T,
                            this.updater = ze || b
                        }
                        var O = R.prototype = new D;
                        O.constructor = R,
                        E(O, M.prototype),
                        O.isPureReactComponent = !0;
                        var U = Array.isArray
                          , B = {
                            H: null,
                            A: null,
                            T: null,
                            S: null,
                            V: null
                        }
                          , I = Object.prototype.hasOwnProperty;
                        function F(X, J, ze, xe, le, Ne) {
                            return ze = Ne.ref,
                            {
                                $$typeof: t,
                                type: X,
                                key: J,
                                ref: ze !== void 0 ? ze : null,
                                props: Ne
                            }
                        }
                        function P(X, J) {
                            return F(X.type, J, void 0, void 0, void 0, X.props)
                        }
                        function L(X) {
                            return typeof X == "object" && X !== null && X.$$typeof === t
                        }
                        function H(X) {
                            var J = {
                                "=": "=0",
                                ":": "=2"
                            };
                            return "$" + X.replace(/[=:]/g, function(ze) {
                                return J[ze]
                            })
                        }
                        var Z = /\/+/g;
                        function K(X, J) {
                            return typeof X == "object" && X !== null && X.key != null ? H("" + X.key) : J.toString(36)
                        }
                        function te() {}
                        function ce(X) {
                            switch (X.status) {
                            case "fulfilled":
                                return X.value;
                            case "rejected":
                                throw X.reason;
                            default:
                                switch (typeof X.status == "string" ? X.then(te, te) : (X.status = "pending",
                                X.then(function(J) {
                                    X.status === "pending" && (X.status = "fulfilled",
                                    X.value = J)
                                }, function(J) {
                                    X.status === "pending" && (X.status = "rejected",
                                    X.reason = J)
                                })),
                                X.status) {
                                case "fulfilled":
                                    return X.value;
                                case "rejected":
                                    throw X.reason
                                }
                            }
                            throw X
                        }
                        function G(X, J, ze, xe, le) {
                            var Ne = typeof X;
                            (Ne === "undefined" || Ne === "boolean") && (X = null);
                            var be = !1;
                            if (X === null)
                                be = !0;
                            else
                                switch (Ne) {
                                case "bigint":
                                case "string":
                                case "number":
                                    be = !0;
                                    break;
                                case "object":
                                    switch (X.$$typeof) {
                                    case t:
                                    case n:
                                        be = !0;
                                        break;
                                    case v:
                                        return be = X._init,
                                        G(be(X._payload), J, ze, xe, le)
                                    }
                                }
                            if (be)
                                return le = le(X),
                                be = xe === "" ? "." + K(X, 0) : xe,
                                U(le) ? (ze = "",
                                be != null && (ze = be.replace(Z, "$&/") + "/"),
                                G(le, J, ze, "", function(rt) {
                                    return rt
                                })) : le != null && (L(le) && (le = P(le, ze + (le.key == null || X && X.key === le.key ? "" : ("" + le.key).replace(Z, "$&/") + "/") + be)),
                                J.push(le)),
                                1;
                            be = 0;
                            var Ue = xe === "" ? "." : xe + ":";
                            if (U(X))
                                for (var $e = 0; $e < X.length; $e++)
                                    xe = X[$e],
                                    Ne = Ue + K(xe, $e),
                                    be += G(xe, J, ze, Ne, le);
                            else if ($e = x(X),
                            typeof $e == "function")
                                for (X = $e.call(X),
                                $e = 0; !(xe = X.next()).done; )
                                    xe = xe.value,
                                    Ne = Ue + K(xe, $e++),
                                    be += G(xe, J, ze, Ne, le);
                            else if (Ne === "object") {
                                if (typeof X.then == "function")
                                    return G(ce(X), J, ze, xe, le);
                                throw J = String(X),
                                Error("Objects are not valid as a React child (found: " + (J === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : J) + "). If you meant to render a collection of children, use an array instead.")
                            }
                            return be
                        }
                        function V(X, J, ze) {
                            if (X == null)
                                return X;
                            var xe = []
                              , le = 0;
                            return G(X, xe, "", "", function(Ne) {
                                return J.call(ze, Ne, le++)
                            }),
                            xe
                        }
                        function q(X) {
                            if (X._status === -1) {
                                var J = X._result;
                                J = J(),
                                J.then(function(ze) {
                                    (X._status === 0 || X._status === -1) && (X._status = 1,
                                    X._result = ze)
                                }, function(ze) {
                                    (X._status === 0 || X._status === -1) && (X._status = 2,
                                    X._result = ze)
                                }),
                                X._status === -1 && (X._status = 0,
                                X._result = J)
                            }
                            if (X._status === 1)
                                return X._result.default;
                            throw X._result
                        }
                        var ee = typeof reportError == "function" ? reportError : function(X) {
                            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                var J = new window.ErrorEvent("error",{
                                    bubbles: !0,
                                    cancelable: !0,
                                    message: typeof X == "object" && X !== null && typeof X.message == "string" ? String(X.message) : String(X),
                                    error: X
                                });
                                if (!window.dispatchEvent(J))
                                    return
                            } else if (typeof process == "object" && typeof process.emit == "function") {
                                process.emit("uncaughtException", X);
                                return
                            }
                            console.error(X)
                        }
                        ;
                        function se() {}
                        e.Children = {
                            map: V,
                            forEach: function(X, J, ze) {
                                V(X, function() {
                                    J.apply(this, arguments)
                                }, ze)
                            },
                            count: function(X) {
                                var J = 0;
                                return V(X, function() {
                                    J++
                                }),
                                J
                            },
                            toArray: function(X) {
                                return V(X, function(J) {
                                    return J
                                }) || []
                            },
                            only: function(X) {
                                if (!L(X))
                                    throw Error("React.Children.only expected to receive a single React element child.");
                                return X
                            }
                        },
                        e.Component = M,
                        e.Fragment = i,
                        e.Profiler = r,
                        e.PureComponent = R,
                        e.StrictMode = s,
                        e.Suspense = p,
                        e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = B,
                        e.__COMPILER_RUNTIME = {
                            __proto__: null,
                            c: function(X) {
                                return B.H.useMemoCache(X)
                            }
                        },
                        e.cache = function(X) {
                            return function() {
                                return X.apply(null, arguments)
                            }
                        }
                        ,
                        e.cloneElement = function(X, J, ze) {
                            if (X == null)
                                throw Error("The argument must be a React element, but you passed " + X + ".");
                            var xe = E({}, X.props)
                              , le = X.key
                              , Ne = void 0;
                            if (J != null)
                                for (be in J.ref !== void 0 && (Ne = void 0),
                                J.key !== void 0 && (le = "" + J.key),
                                J)
                                    !I.call(J, be) || be === "key" || be === "__self" || be === "__source" || be === "ref" && J.ref === void 0 || (xe[be] = J[be]);
                            var be = arguments.length - 2;
                            if (be === 1)
                                xe.children = ze;
                            else if (1 < be) {
                                for (var Ue = Array(be), $e = 0; $e < be; $e++)
                                    Ue[$e] = arguments[$e + 2];
                                xe.children = Ue
                            }
                            return F(X.type, le, void 0, void 0, Ne, xe)
                        }
                        ,
                        e.createContext = function(X) {
                            return X = {
                                $$typeof: h,
                                _currentValue: X,
                                _currentValue2: X,
                                _threadCount: 0,
                                Provider: null,
                                Consumer: null
                            },
                            X.Provider = X,
                            X.Consumer = {
                                $$typeof: l,
                                _context: X
                            },
                            X
                        }
                        ,
                        e.createElement = function(X, J, ze) {
                            var xe, le = {}, Ne = null;
                            if (J != null)
                                for (xe in J.key !== void 0 && (Ne = "" + J.key),
                                J)
                                    I.call(J, xe) && xe !== "key" && xe !== "__self" && xe !== "__source" && (le[xe] = J[xe]);
                            var be = arguments.length - 2;
                            if (be === 1)
                                le.children = ze;
                            else if (1 < be) {
                                for (var Ue = Array(be), $e = 0; $e < be; $e++)
                                    Ue[$e] = arguments[$e + 2];
                                le.children = Ue
                            }
                            if (X && X.defaultProps)
                                for (xe in be = X.defaultProps,
                                be)
                                    le[xe] === void 0 && (le[xe] = be[xe]);
                            return F(X, Ne, void 0, void 0, null, le)
                        }
                        ,
                        e.createRef = function() {
                            return {
                                current: null
                            }
                        }
                        ,
                        e.forwardRef = function(X) {
                            return {
                                $$typeof: d,
                                render: X
                            }
                        }
                        ,
                        e.isValidElement = L,
                        e.lazy = function(X) {
                            return {
                                $$typeof: v,
                                _payload: {
                                    _status: -1,
                                    _result: X
                                },
                                _init: q
                            }
                        }
                        ,
                        e.memo = function(X, J) {
                            return {
                                $$typeof: m,
                                type: X,
                                compare: J === void 0 ? null : J
                            }
                        }
                        ,
                        e.startTransition = function(X) {
                            var J = B.T
                              , ze = {};
                            B.T = ze;
                            try {
                                var xe = X()
                                  , le = B.S;
                                le !== null && le(ze, xe),
                                typeof xe == "object" && xe !== null && typeof xe.then == "function" && xe.then(se, ee)
                            } catch (Ne) {
                                ee(Ne)
                            } finally {
                                B.T = J
                            }
                        }
                        ,
                        e.unstable_useCacheRefresh = function() {
                            return B.H.useCacheRefresh()
                        }
                        ,
                        e.use = function(X) {
                            return B.H.use(X)
                        }
                        ,
                        e.useActionState = function(X, J, ze) {
                            return B.H.useActionState(X, J, ze)
                        }
                        ,
                        e.useCallback = function(X, J) {
                            return B.H.useCallback(X, J)
                        }
                        ,
                        e.useContext = function(X) {
                            return B.H.useContext(X)
                        }
                        ,
                        e.useDebugValue = function() {}
                        ,
                        e.useDeferredValue = function(X, J) {
                            return B.H.useDeferredValue(X, J)
                        }
                        ,
                        e.useEffect = function(X, J, ze) {
                            var xe = B.H;
                            if (typeof ze == "function")
                                throw Error("useEffect CRUD overload is not enabled in this build of React.");
                            return xe.useEffect(X, J)
                        }
                        ,
                        e.useId = function() {
                            return B.H.useId()
                        }
                        ,
                        e.useImperativeHandle = function(X, J, ze) {
                            return B.H.useImperativeHandle(X, J, ze)
                        }
                        ,
                        e.useInsertionEffect = function(X, J) {
                            return B.H.useInsertionEffect(X, J)
                        }
                        ,
                        e.useLayoutEffect = function(X, J) {
                            return B.H.useLayoutEffect(X, J)
                        }
                        ,
                        e.useMemo = function(X, J) {
                            return B.H.useMemo(X, J)
                        }
                        ,
                        e.useOptimistic = function(X, J) {
                            return B.H.useOptimistic(X, J)
                        }
                        ,
                        e.useReducer = function(X, J, ze) {
                            return B.H.useReducer(X, J, ze)
                        }
                        ,
                        e.useRef = function(X) {
                            return B.H.useRef(X)
                        }
                        ,
                        e.useState = function(X) {
                            return B.H.useState(X)
                        }
                        ,
                        e.useSyncExternalStore = function(X, J, ze) {
                            return B.H.useSyncExternalStore(X, J, ze)
                        }
                        ,
                        e.useTransition = function() {
                            return B.H.useTransition()
                        }
                        ,
                        e.version = "19.1.1"
                    }
                    )
                })
                  , Jd = cn({
                    "node_modules/react/index.js": ( (e, t) => {
                        t.exports = Q3()
                    }
                    )
                })
                  , Z3 = cn({
                    "node_modules/react-dom/node_modules/scheduler/cjs/scheduler.production.js": (e => {
                        function t(G, V) {
                            var q = G.length;
                            G.push(V);
                            e: for (; 0 < q; ) {
                                var ee = q - 1 >>> 1
                                  , se = G[ee];
                                if (0 < s(se, V))
                                    G[ee] = V,
                                    G[q] = se,
                                    q = ee;
                                else
                                    break e
                            }
                        }
                        function n(G) {
                            return G.length === 0 ? null : G[0]
                        }
                        function i(G) {
                            if (G.length === 0)
                                return null;
                            var V = G[0]
                              , q = G.pop();
                            if (q !== V) {
                                G[0] = q;
                                e: for (var ee = 0, se = G.length, X = se >>> 1; ee < X; ) {
                                    var J = 2 * (ee + 1) - 1
                                      , ze = G[J]
                                      , xe = J + 1
                                      , le = G[xe];
                                    if (0 > s(ze, q))
                                        xe < se && 0 > s(le, ze) ? (G[ee] = le,
                                        G[xe] = q,
                                        ee = xe) : (G[ee] = ze,
                                        G[J] = q,
                                        ee = J);
                                    else if (xe < se && 0 > s(le, q))
                                        G[ee] = le,
                                        G[xe] = q,
                                        ee = xe;
                                    else
                                        break e
                                }
                            }
                            return V
                        }
                        function s(G, V) {
                            var q = G.sortIndex - V.sortIndex;
                            return q !== 0 ? q : G.id - V.id
                        }
                        if (typeof performance == "object" && typeof performance.now == "function") {
                            var r = performance;
                            e.unstable_now = function() {
                                return r.now()
                            }
                        } else {
                            var l = Date
                              , h = l.now();
                            e.unstable_now = function() {
                                return l.now() - h
                            }
                        }
                        var d = []
                          , p = []
                          , m = 1
                          , v = null
                          , _ = 3
                          , x = !1
                          , b = !1
                          , E = !1
                          , T = !1
                          , M = typeof setTimeout == "function" ? setTimeout : null
                          , D = typeof clearTimeout == "function" ? clearTimeout : null
                          , R = typeof setImmediate < "u" ? setImmediate : null;
                        function O(G) {
                            for (var V = n(p); V !== null; ) {
                                if (V.callback === null)
                                    i(p);
                                else if (V.startTime <= G)
                                    i(p),
                                    V.sortIndex = V.expirationTime,
                                    t(d, V);
                                else
                                    break;
                                V = n(p)
                            }
                        }
                        function U(G) {
                            if (E = !1,
                            O(G),
                            !b)
                                if (n(d) !== null)
                                    b = !0,
                                    B || (B = !0,
                                    Z());
                                else {
                                    var V = n(p);
                                    V !== null && ce(U, V.startTime - G)
                                }
                        }
                        var B = !1
                          , I = -1
                          , F = 5
                          , P = -1;
                        function L() {
                            return T ? !0 : !(e.unstable_now() - P < F)
                        }
                        function H() {
                            if (T = !1,
                            B) {
                                var G = e.unstable_now();
                                P = G;
                                var V = !0;
                                try {
                                    e: {
                                        b = !1,
                                        E && (E = !1,
                                        D(I),
                                        I = -1),
                                        x = !0;
                                        var q = _;
                                        try {
                                            t: {
                                                for (O(G),
                                                v = n(d); v !== null && !(v.expirationTime > G && L()); ) {
                                                    var ee = v.callback;
                                                    if (typeof ee == "function") {
                                                        v.callback = null,
                                                        _ = v.priorityLevel;
                                                        var se = ee(v.expirationTime <= G);
                                                        if (G = e.unstable_now(),
                                                        typeof se == "function") {
                                                            v.callback = se,
                                                            O(G),
                                                            V = !0;
                                                            break t
                                                        }
                                                        v === n(d) && i(d),
                                                        O(G)
                                                    } else
                                                        i(d);
                                                    v = n(d)
                                                }
                                                if (v !== null)
                                                    V = !0;
                                                else {
                                                    var X = n(p);
                                                    X !== null && ce(U, X.startTime - G),
                                                    V = !1
                                                }
                                            }
                                            break e
                                        } finally {
                                            v = null,
                                            _ = q,
                                            x = !1
                                        }
                                        V = void 0
                                    }
                                } finally {
                                    V ? Z() : B = !1
                                }
                            }
                        }
                        var Z;
                        if (typeof R == "function")
                            Z = function() {
                                R(H)
                            }
                            ;
                        else if (typeof MessageChannel < "u") {
                            var K = new MessageChannel
                              , te = K.port2;
                            K.port1.onmessage = H,
                            Z = function() {
                                te.postMessage(null)
                            }
                        } else
                            Z = function() {
                                M(H, 0)
                            }
                            ;
                        function ce(G, V) {
                            I = M(function() {
                                G(e.unstable_now())
                            }, V)
                        }
                        e.unstable_IdlePriority = 5,
                        e.unstable_ImmediatePriority = 1,
                        e.unstable_LowPriority = 4,
                        e.unstable_NormalPriority = 3,
                        e.unstable_Profiling = null,
                        e.unstable_UserBlockingPriority = 2,
                        e.unstable_cancelCallback = function(G) {
                            G.callback = null
                        }
                        ,
                        e.unstable_forceFrameRate = function(G) {
                            0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < G ? Math.floor(1e3 / G) : 5
                        }
                        ,
                        e.unstable_getCurrentPriorityLevel = function() {
                            return _
                        }
                        ,
                        e.unstable_next = function(G) {
                            switch (_) {
                            case 1:
                            case 2:
                            case 3:
                                var V = 3;
                                break;
                            default:
                                V = _
                            }
                            var q = _;
                            _ = V;
                            try {
                                return G()
                            } finally {
                                _ = q
                            }
                        }
                        ,
                        e.unstable_requestPaint = function() {
                            T = !0
                        }
                        ,
                        e.unstable_runWithPriority = function(G, V) {
                            switch (G) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                G = 3
                            }
                            var q = _;
                            _ = G;
                            try {
                                return V()
                            } finally {
                                _ = q
                            }
                        }
                        ,
                        e.unstable_scheduleCallback = function(G, V, q) {
                            var ee = e.unstable_now();
                            switch (typeof q == "object" && q !== null ? (q = q.delay,
                            q = typeof q == "number" && 0 < q ? ee + q : ee) : q = ee,
                            G) {
                            case 1:
                                var se = -1;
                                break;
                            case 2:
                                se = 250;
                                break;
                            case 5:
                                se = 1073741823;
                                break;
                            case 4:
                                se = 1e4;
                                break;
                            default:
                                se = 5e3
                            }
                            return se = q + se,
                            G = {
                                id: m++,
                                callback: V,
                                priorityLevel: G,
                                startTime: q,
                                expirationTime: se,
                                sortIndex: -1
                            },
                            q > ee ? (G.sortIndex = q,
                            t(p, G),
                            n(d) === null && G === n(p) && (E ? (D(I),
                            I = -1) : E = !0,
                            ce(U, q - ee))) : (G.sortIndex = se,
                            t(d, G),
                            b || x || (b = !0,
                            B || (B = !0,
                            Z()))),
                            G
                        }
                        ,
                        e.unstable_shouldYield = L,
                        e.unstable_wrapCallback = function(G) {
                            var V = _;
                            return function() {
                                var q = _;
                                _ = V;
                                try {
                                    return G.apply(this, arguments)
                                } finally {
                                    _ = q
                                }
                            }
                        }
                    }
                    )
                })
                  , K3 = cn({
                    "node_modules/react-dom/node_modules/scheduler/index.js": ( (e, t) => {
                        t.exports = Z3()
                    }
                    )
                })
                  , J3 = cn({
                    "node_modules/react-dom/cjs/react-dom.production.js": (e => {
                        var t = Jd();
                        function n(p) {
                            var m = "https://react.dev/errors/" + p;
                            if (1 < arguments.length) {
                                m += "?args[]=" + encodeURIComponent(arguments[1]);
                                for (var v = 2; v < arguments.length; v++)
                                    m += "&args[]=" + encodeURIComponent(arguments[v])
                            }
                            return "Minified React error #" + p + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                        }
                        function i() {}
                        var s = {
                            d: {
                                f: i,
                                r: function() {
                                    throw Error(n(522))
                                },
                                D: i,
                                C: i,
                                L: i,
                                m: i,
                                X: i,
                                S: i,
                                M: i
                            },
                            p: 0,
                            findDOMNode: null
                        }
                          , r = Symbol.for("react.portal");
                        function l(p, m, v) {
                            var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                            return {
                                $$typeof: r,
                                key: _ == null ? null : "" + _,
                                children: p,
                                containerInfo: m,
                                implementation: v
                            }
                        }
                        var h = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
                        function d(p, m) {
                            if (p === "font")
                                return "";
                            if (typeof m == "string")
                                return m === "use-credentials" ? m : ""
                        }
                        e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = s,
                        e.createPortal = function(p, m) {
                            var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
                            if (!m || m.nodeType !== 1 && m.nodeType !== 9 && m.nodeType !== 11)
                                throw Error(n(299));
                            return l(p, m, null, v)
                        }
                        ,
                        e.flushSync = function(p) {
                            var m = h.T
                              , v = s.p;
                            try {
                                if (h.T = null,
                                s.p = 2,
                                p)
                                    return p()
                            } finally {
                                h.T = m,
                                s.p = v,
                                s.d.f()
                            }
                        }
                        ,
                        e.preconnect = function(p, m) {
                            typeof p == "string" && (m ? (m = m.crossOrigin,
                            m = typeof m == "string" ? m === "use-credentials" ? m : "" : void 0) : m = null,
                            s.d.C(p, m))
                        }
                        ,
                        e.prefetchDNS = function(p) {
                            typeof p == "string" && s.d.D(p)
                        }
                        ,
                        e.preinit = function(p, m) {
                            if (typeof p == "string" && m && typeof m.as == "string") {
                                var v = m.as
                                  , _ = d(v, m.crossOrigin)
                                  , x = typeof m.integrity == "string" ? m.integrity : void 0
                                  , b = typeof m.fetchPriority == "string" ? m.fetchPriority : void 0;
                                v === "style" ? s.d.S(p, typeof m.precedence == "string" ? m.precedence : void 0, {
                                    crossOrigin: _,
                                    integrity: x,
                                    fetchPriority: b
                                }) : v === "script" && s.d.X(p, {
                                    crossOrigin: _,
                                    integrity: x,
                                    fetchPriority: b,
                                    nonce: typeof m.nonce == "string" ? m.nonce : void 0
                                })
                            }
                        }
                        ,
                        e.preinitModule = function(p, m) {
                            if (typeof p == "string")
                                if (typeof m == "object" && m !== null) {
                                    if (m.as == null || m.as === "script") {
                                        var v = d(m.as, m.crossOrigin);
                                        s.d.M(p, {
                                            crossOrigin: v,
                                            integrity: typeof m.integrity == "string" ? m.integrity : void 0,
                                            nonce: typeof m.nonce == "string" ? m.nonce : void 0
                                        })
                                    }
                                } else
                                    m ?? s.d.M(p)
                        }
                        ,
                        e.preload = function(p, m) {
                            if (typeof p == "string" && typeof m == "object" && m !== null && typeof m.as == "string") {
                                var v = m.as
                                  , _ = d(v, m.crossOrigin);
                                s.d.L(p, v, {
                                    crossOrigin: _,
                                    integrity: typeof m.integrity == "string" ? m.integrity : void 0,
                                    nonce: typeof m.nonce == "string" ? m.nonce : void 0,
                                    type: typeof m.type == "string" ? m.type : void 0,
                                    fetchPriority: typeof m.fetchPriority == "string" ? m.fetchPriority : void 0,
                                    referrerPolicy: typeof m.referrerPolicy == "string" ? m.referrerPolicy : void 0,
                                    imageSrcSet: typeof m.imageSrcSet == "string" ? m.imageSrcSet : void 0,
                                    imageSizes: typeof m.imageSizes == "string" ? m.imageSizes : void 0,
                                    media: typeof m.media == "string" ? m.media : void 0
                                })
                            }
                        }
                        ,
                        e.preloadModule = function(p, m) {
                            if (typeof p == "string")
                                if (m) {
                                    var v = d(m.as, m.crossOrigin);
                                    s.d.m(p, {
                                        as: typeof m.as == "string" && m.as !== "script" ? m.as : void 0,
                                        crossOrigin: v,
                                        integrity: typeof m.integrity == "string" ? m.integrity : void 0
                                    })
                                } else
                                    s.d.m(p)
                        }
                        ,
                        e.requestFormReset = function(p) {
                            s.d.r(p)
                        }
                        ,
                        e.unstable_batchedUpdates = function(p, m) {
                            return p(m)
                        }
                        ,
                        e.useFormState = function(p, m, v) {
                            return h.H.useFormState(p, m, v)
                        }
                        ,
                        e.useFormStatus = function() {
                            return h.H.useHostTransitionStatus()
                        }
                        ,
                        e.version = "19.1.1"
                    }
                    )
                })
                  , $3 = cn({
                    "node_modules/react-dom/index.js": ( (e, t) => {
                        function n() {
                            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                                try {
                                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                                } catch (i) {
                                    console.error(i)
                                }
                        }
                        n(),
                        t.exports = J3()
                    }
                    )
                })
                  , eU = cn({
                    "node_modules/react-dom/cjs/react-dom-client.production.js": (e => {
                        var t = K3()
                          , n = Jd()
                          , i = $3();
                        function s(a) {
                            var o = "https://react.dev/errors/" + a;
                            if (1 < arguments.length) {
                                o += "?args[]=" + encodeURIComponent(arguments[1]);
                                for (var f = 2; f < arguments.length; f++)
                                    o += "&args[]=" + encodeURIComponent(arguments[f])
                            }
                            return "Minified React error #" + a + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                        }
                        function r(a) {
                            return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11)
                        }
                        function l(a) {
                            var o = a
                              , f = a;
                            if (a.alternate)
                                for (; o.return; )
                                    o = o.return;
                            else {
                                a = o;
                                do
                                    o = a,
                                    (o.flags & 4098) !== 0 && (f = o.return),
                                    a = o.return;
                                while (a)
                            }
                            return o.tag === 3 ? f : null
                        }
                        function h(a) {
                            if (a.tag === 13) {
                                var o = a.memoizedState;
                                if (o === null && (a = a.alternate,
                                a !== null && (o = a.memoizedState)),
                                o !== null)
                                    return o.dehydrated
                            }
                            return null
                        }
                        function d(a) {
                            if (l(a) !== a)
                                throw Error(s(188))
                        }
                        function p(a) {
                            var o = a.alternate;
                            if (!o) {
                                if (o = l(a),
                                o === null)
                                    throw Error(s(188));
                                return o !== a ? null : a
                            }
                            for (var f = a, g = o; ; ) {
                                var S = f.return;
                                if (S === null)
                                    break;
                                var w = S.alternate;
                                if (w === null) {
                                    if (g = S.return,
                                    g !== null) {
                                        f = g;
                                        continue
                                    }
                                    break
                                }
                                if (S.child === w.child) {
                                    for (w = S.child; w; ) {
                                        if (w === f)
                                            return d(S),
                                            a;
                                        if (w === g)
                                            return d(S),
                                            o;
                                        w = w.sibling
                                    }
                                    throw Error(s(188))
                                }
                                if (f.return !== g.return)
                                    f = S,
                                    g = w;
                                else {
                                    for (var z = !1, Y = S.child; Y; ) {
                                        if (Y === f) {
                                            z = !0,
                                            f = S,
                                            g = w;
                                            break
                                        }
                                        if (Y === g) {
                                            z = !0,
                                            g = S,
                                            f = w;
                                            break
                                        }
                                        Y = Y.sibling
                                    }
                                    if (!z) {
                                        for (Y = w.child; Y; ) {
                                            if (Y === f) {
                                                z = !0,
                                                f = w,
                                                g = S;
                                                break
                                            }
                                            if (Y === g) {
                                                z = !0,
                                                g = w,
                                                f = S;
                                                break
                                            }
                                            Y = Y.sibling
                                        }
                                        if (!z)
                                            throw Error(s(189))
                                    }
                                }
                                if (f.alternate !== g)
                                    throw Error(s(190))
                            }
                            if (f.tag !== 3)
                                throw Error(s(188));
                            return f.stateNode.current === f ? a : o
                        }
                        function m(a) {
                            var o = a.tag;
                            if (o === 5 || o === 26 || o === 27 || o === 6)
                                return a;
                            for (a = a.child; a !== null; ) {
                                if (o = m(a),
                                o !== null)
                                    return o;
                                a = a.sibling
                            }
                            return null
                        }
                        var v = Object.assign
                          , _ = Symbol.for("react.element")
                          , x = Symbol.for("react.transitional.element")
                          , b = Symbol.for("react.portal")
                          , E = Symbol.for("react.fragment")
                          , T = Symbol.for("react.strict_mode")
                          , M = Symbol.for("react.profiler")
                          , D = Symbol.for("react.provider")
                          , R = Symbol.for("react.consumer")
                          , O = Symbol.for("react.context")
                          , U = Symbol.for("react.forward_ref")
                          , B = Symbol.for("react.suspense")
                          , I = Symbol.for("react.suspense_list")
                          , F = Symbol.for("react.memo")
                          , P = Symbol.for("react.lazy")
                          , L = Symbol.for("react.activity")
                          , H = Symbol.for("react.memo_cache_sentinel")
                          , Z = Symbol.iterator;
                        function K(a) {
                            return a === null || typeof a != "object" ? null : (a = Z && a[Z] || a["@@iterator"],
                            typeof a == "function" ? a : null)
                        }
                        var te = Symbol.for("react.client.reference");
                        function ce(a) {
                            if (a == null)
                                return null;
                            if (typeof a == "function")
                                return a.$$typeof === te ? null : a.displayName || a.name || null;
                            if (typeof a == "string")
                                return a;
                            switch (a) {
                            case E:
                                return "Fragment";
                            case M:
                                return "Profiler";
                            case T:
                                return "StrictMode";
                            case B:
                                return "Suspense";
                            case I:
                                return "SuspenseList";
                            case L:
                                return "Activity"
                            }
                            if (typeof a == "object")
                                switch (a.$$typeof) {
                                case b:
                                    return "Portal";
                                case O:
                                    return (a.displayName || "Context") + ".Provider";
                                case R:
                                    return (a._context.displayName || "Context") + ".Consumer";
                                case U:
                                    var o = a.render;
                                    return a = a.displayName,
                                    a || (a = o.displayName || o.name || "",
                                    a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"),
                                    a;
                                case F:
                                    return o = a.displayName || null,
                                    o !== null ? o : ce(a.type) || "Memo";
                                case P:
                                    o = a._payload,
                                    a = a._init;
                                    try {
                                        return ce(a(o))
                                    } catch {}
                                }
                            return null
                        }
                        var G = Array.isArray
                          , V = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                          , q = i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                          , ee = {
                            pending: !1,
                            data: null,
                            method: null,
                            action: null
                        }
                          , se = []
                          , X = -1;
                        function J(a) {
                            return {
                                current: a
                            }
                        }
                        function ze(a) {
                            0 > X || (a.current = se[X],
                            se[X] = null,
                            X--)
                        }
                        function xe(a, o) {
                            X++,
                            se[X] = a.current,
                            a.current = o
                        }
                        var le = J(null)
                          , Ne = J(null)
                          , be = J(null)
                          , Ue = J(null);
                        function $e(a, o) {
                            switch (xe(be, o),
                            xe(Ne, a),
                            xe(le, null),
                            o.nodeType) {
                            case 9:
                            case 11:
                                a = (a = o.documentElement) && (a = a.namespaceURI) ? Ob(a) : 0;
                                break;
                            default:
                                if (a = o.tagName,
                                o = o.namespaceURI)
                                    o = Ob(o),
                                    a = Nb(o, a);
                                else
                                    switch (a) {
                                    case "svg":
                                        a = 1;
                                        break;
                                    case "math":
                                        a = 2;
                                        break;
                                    default:
                                        a = 0
                                    }
                            }
                            ze(le),
                            xe(le, a)
                        }
                        function rt() {
                            ze(le),
                            ze(Ne),
                            ze(be)
                        }
                        function Et(a) {
                            a.memoizedState !== null && xe(Ue, a);
                            var o = le.current
                              , f = Nb(o, a.type);
                            o !== f && (xe(Ne, a),
                            xe(le, f))
                        }
                        function ne(a) {
                            Ne.current === a && (ze(le),
                            ze(Ne)),
                            Ue.current === a && (ze(Ue),
                            Eg._currentValue = ee)
                        }
                        var Ve = Object.prototype.hasOwnProperty
                          , de = t.unstable_scheduleCallback
                          , Te = t.unstable_cancelCallback
                          , Pe = t.unstable_shouldYield
                          , Ye = t.unstable_requestPaint
                          , Ie = t.unstable_now
                          , Fe = t.unstable_getCurrentPriorityLevel
                          , xt = t.unstable_ImmediatePriority
                          , yt = t.unstable_UserBlockingPriority
                          , wt = t.unstable_NormalPriority
                          , $ = t.unstable_LowPriority
                          , k = t.unstable_IdlePriority
                          , pe = t.log
                          , Ge = t.unstable_setDisableYieldValue
                          , Qe = null
                          , Be = null;
                        function ct(a) {
                            if (typeof pe == "function" && Ge(a),
                            Be && typeof Be.setStrictMode == "function")
                                try {
                                    Be.setStrictMode(Qe, a)
                                } catch {}
                        }
                        var Ke = Math.clz32 ? Math.clz32 : et
                          , _t = Math.log
                          , Ct = Math.LN2;
                        function et(a) {
                            return a >>>= 0,
                            a === 0 ? 32 : 31 - (_t(a) / Ct | 0) | 0
                        }
                        var st = 256
                          , ie = 4194304;
                        function Re(a) {
                            var o = a & 42;
                            if (o !== 0)
                                return o;
                            switch (a & -a) {
                            case 1:
                                return 1;
                            case 2:
                                return 2;
                            case 4:
                                return 4;
                            case 8:
                                return 8;
                            case 16:
                                return 16;
                            case 32:
                                return 32;
                            case 64:
                                return 64;
                            case 128:
                                return 128;
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return a & 4194048;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                return a & 62914560;
                            case 67108864:
                                return 67108864;
                            case 134217728:
                                return 134217728;
                            case 268435456:
                                return 268435456;
                            case 536870912:
                                return 536870912;
                            case 1073741824:
                                return 0;
                            default:
                                return a
                            }
                        }
                        function He(a, o, f) {
                            var g = a.pendingLanes;
                            if (g === 0)
                                return 0;
                            var S = 0
                              , w = a.suspendedLanes
                              , z = a.pingedLanes;
                            a = a.warmLanes;
                            var Y = g & 134217727;
                            return Y !== 0 ? (g = Y & ~w,
                            g !== 0 ? S = Re(g) : (z &= Y,
                            z !== 0 ? S = Re(z) : f || (f = Y & ~a,
                            f !== 0 && (S = Re(f))))) : (Y = g & ~w,
                            Y !== 0 ? S = Re(Y) : z !== 0 ? S = Re(z) : f || (f = g & ~a,
                            f !== 0 && (S = Re(f)))),
                            S === 0 ? 0 : o !== 0 && o !== S && (o & w) === 0 && (w = S & -S,
                            f = o & -o,
                            w >= f || w === 32 && (f & 4194048) !== 0) ? o : S
                        }
                        function lt(a, o) {
                            return (a.pendingLanes & ~(a.suspendedLanes & ~a.pingedLanes) & o) === 0
                        }
                        function ae(a, o) {
                            switch (a) {
                            case 1:
                            case 2:
                            case 4:
                            case 8:
                            case 64:
                                return o + 250;
                            case 16:
                            case 32:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return o + 5e3;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                return -1;
                            case 67108864:
                            case 134217728:
                            case 268435456:
                            case 536870912:
                            case 1073741824:
                                return -1;
                            default:
                                return -1
                            }
                        }
                        function ot() {
                            var a = st;
                            return st <<= 1,
                            (st & 4194048) === 0 && (st = 256),
                            a
                        }
                        function tt() {
                            var a = ie;
                            return ie <<= 1,
                            (ie & 62914560) === 0 && (ie = 4194304),
                            a
                        }
                        function gt(a) {
                            for (var o = [], f = 0; 31 > f; f++)
                                o.push(a);
                            return o
                        }
                        function Je(a, o) {
                            a.pendingLanes |= o,
                            o !== 268435456 && (a.suspendedLanes = 0,
                            a.pingedLanes = 0,
                            a.warmLanes = 0)
                        }
                        function ke(a, o, f, g, S, w) {
                            var z = a.pendingLanes;
                            a.pendingLanes = f,
                            a.suspendedLanes = 0,
                            a.pingedLanes = 0,
                            a.warmLanes = 0,
                            a.expiredLanes &= f,
                            a.entangledLanes &= f,
                            a.errorRecoveryDisabledLanes &= f,
                            a.shellSuspendCounter = 0;
                            var Y = a.entanglements
                              , re = a.expirationTimes
                              , Ae = a.hiddenUpdates;
                            for (f = z & ~f; 0 < f; ) {
                                var qe = 31 - Ke(f)
                                  , je = 1 << qe;
                                Y[qe] = 0,
                                re[qe] = -1;
                                var we = Ae[qe];
                                if (we !== null)
                                    for (Ae[qe] = null,
                                    qe = 0; qe < we.length; qe++) {
                                        var De = we[qe];
                                        De !== null && (De.lane &= -536870913)
                                    }
                                f &= ~je
                            }
                            g !== 0 && ht(a, g, 0),
                            w !== 0 && S === 0 && a.tag !== 0 && (a.suspendedLanes |= w & ~(z & ~o))
                        }
                        function ht(a, o, f) {
                            a.pendingLanes |= o,
                            a.suspendedLanes &= ~o;
                            var g = 31 - Ke(o);
                            a.entangledLanes |= o,
                            a.entanglements[g] = a.entanglements[g] | 1073741824 | f & 4194090
                        }
                        function Mt(a, o) {
                            var f = a.entangledLanes |= o;
                            for (a = a.entanglements; f; ) {
                                var g = 31 - Ke(f)
                                  , S = 1 << g;
                                S & o | a[g] & o && (a[g] |= o),
                                f &= ~S
                            }
                        }
                        function Tn(a) {
                            switch (a) {
                            case 2:
                                a = 1;
                                break;
                            case 8:
                                a = 4;
                                break;
                            case 32:
                                a = 16;
                                break;
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                                a = 128;
                                break;
                            case 268435456:
                                a = 134217728;
                                break;
                            default:
                                a = 0
                            }
                            return a
                        }
                        function Zt(a) {
                            return a &= -a,
                            2 < a ? 8 < a ? (a & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                        }
                        function Ai() {
                            var a = q.p;
                            return a !== 0 ? a : (a = window.event,
                            a === void 0 ? 32 : Qb(a.type))
                        }
                        function pa(a, o) {
                            var f = q.p;
                            try {
                                return q.p = a,
                                o()
                            } finally {
                                q.p = f
                            }
                        }
                        var os = Math.random().toString(36).slice(2)
                          , Ti = "__reactFiber$" + os
                          , ki = "__reactProps$" + os
                          , Pr = "__reactContainer$" + os
                          , Bs = "__reactEvents$" + os
                          , rh = "__reactListeners$" + os
                          , ma = "__reactHandles$" + os
                          , ga = "__reactResources$" + os
                          , cr = "__reactMarker$" + os;
                        function si(a) {
                            delete a[Ti],
                            delete a[ki],
                            delete a[Bs],
                            delete a[rh],
                            delete a[ma]
                        }
                        function Ir(a) {
                            var o = a[Ti];
                            if (o)
                                return o;
                            for (var f = a.parentNode; f; ) {
                                if (o = f[Pr] || f[Ti]) {
                                    if (f = o.alternate,
                                    o.child !== null || f !== null && f.child !== null)
                                        for (a = Ib(a); a !== null; ) {
                                            if (f = a[Ti])
                                                return f;
                                            a = Ib(a)
                                        }
                                    return o
                                }
                                a = f,
                                f = a.parentNode
                            }
                            return null
                        }
                        function Lr(a) {
                            if (a = a[Ti] || a[Pr]) {
                                var o = a.tag;
                                if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3)
                                    return a
                            }
                            return null
                        }
                        function $o(a) {
                            var o = a.tag;
                            if (o === 5 || o === 26 || o === 27 || o === 6)
                                return a.stateNode;
                            throw Error(s(33))
                        }
                        function ho(a) {
                            var o = a[ga];
                            return o || (o = a[ga] = {
                                hoistableStyles: new Map,
                                hoistableScripts: new Map
                            }),
                            o
                        }
                        function Bi(a) {
                            a[cr] = !0
                        }
                        var j = new Set
                          , me = {};
                        function Ee(a, o) {
                            Se(a, o),
                            Se(a + "Capture", o)
                        }
                        function Se(a, o) {
                            for (me[a] = o,
                            a = 0; a < o.length; a++)
                                j.add(o[a])
                        }
                        var he = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
                          , Ze = {}
                          , ft = {};
                        function vt(a) {
                            return Ve.call(ft, a) ? !0 : Ve.call(Ze, a) ? !1 : he.test(a) ? ft[a] = !0 : (Ze[a] = !0,
                            !1)
                        }
                        function ut(a, o, f) {
                            if (vt(o))
                                if (f === null)
                                    a.removeAttribute(o);
                                else {
                                    switch (typeof f) {
                                    case "undefined":
                                    case "function":
                                    case "symbol":
                                        a.removeAttribute(o);
                                        return;
                                    case "boolean":
                                        var g = o.toLowerCase().slice(0, 5);
                                        if (g !== "data-" && g !== "aria-") {
                                            a.removeAttribute(o);
                                            return
                                        }
                                    }
                                    a.setAttribute(o, "" + f)
                                }
                        }
                        function Dt(a, o, f) {
                            if (f === null)
                                a.removeAttribute(o);
                            else {
                                switch (typeof f) {
                                case "undefined":
                                case "function":
                                case "symbol":
                                case "boolean":
                                    a.removeAttribute(o);
                                    return
                                }
                                a.setAttribute(o, "" + f)
                            }
                        }
                        function bt(a, o, f, g) {
                            if (g === null)
                                a.removeAttribute(f);
                            else {
                                switch (typeof g) {
                                case "undefined":
                                case "function":
                                case "symbol":
                                case "boolean":
                                    a.removeAttribute(f);
                                    return
                                }
                                a.setAttributeNS(o, f, "" + g)
                            }
                        }
                        var Nt, un;
                        function yn(a) {
                            if (Nt === void 0)
                                try {
                                    throw Error()
                                } catch (f) {
                                    var o = f.stack.trim().match(/\n( *(at )?)/);
                                    Nt = o && o[1] || "",
                                    un = -1 < f.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < f.stack.indexOf("@") ? "@unknown:0:0" : ""
                                }
                            return `
` + Nt + a + un
                        }
                        var Cn = !1;
                        function Ln(a, o) {
                            if (!a || Cn)
                                return "";
                            Cn = !0;
                            var f = Error.prepareStackTrace;
                            Error.prepareStackTrace = void 0;
                            try {
                                var g = {
                                    DetermineComponentFrameRoot: function() {
                                        try {
                                            if (o) {
                                                var je = function() {
                                                    throw Error()
                                                };
                                                if (Object.defineProperty(je.prototype, "props", {
                                                    set: function() {
                                                        throw Error()
                                                    }
                                                }),
                                                typeof Reflect == "object" && Reflect.construct) {
                                                    try {
                                                        Reflect.construct(je, [])
                                                    } catch (De) {
                                                        var we = De
                                                    }
                                                    Reflect.construct(a, [], je)
                                                } else {
                                                    try {
                                                        je.call()
                                                    } catch (De) {
                                                        we = De
                                                    }
                                                    a.call(je.prototype)
                                                }
                                            } else {
                                                try {
                                                    throw Error()
                                                } catch (De) {
                                                    we = De
                                                }
                                                (je = a()) && typeof je.catch == "function" && je.catch(function() {})
                                            }
                                        } catch (De) {
                                            if (De && we && typeof De.stack == "string")
                                                return [De.stack, we.stack]
                                        }
                                        return [null, null]
                                    }
                                };
                                g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                                var S = Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot, "name");
                                S && S.configurable && Object.defineProperty(g.DetermineComponentFrameRoot, "name", {
                                    value: "DetermineComponentFrameRoot"
                                });
                                var w = g.DetermineComponentFrameRoot()
                                  , z = w[0]
                                  , Y = w[1];
                                if (z && Y) {
                                    var re = z.split(`
`)
                                      , Ae = Y.split(`
`);
                                    for (S = g = 0; g < re.length && !re[g].includes("DetermineComponentFrameRoot"); )
                                        g++;
                                    for (; S < Ae.length && !Ae[S].includes("DetermineComponentFrameRoot"); )
                                        S++;
                                    if (g === re.length || S === Ae.length)
                                        for (g = re.length - 1,
                                        S = Ae.length - 1; 1 <= g && 0 <= S && re[g] !== Ae[S]; )
                                            S--;
                                    for (; 1 <= g && 0 <= S; g--,
                                    S--)
                                        if (re[g] !== Ae[S]) {
                                            if (g !== 1 || S !== 1)
                                                do
                                                    if (g--,
                                                    S--,
                                                    0 > S || re[g] !== Ae[S]) {
                                                        var qe = `
` + re[g].replace(" at new ", " at ");
                                                        return a.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", a.displayName)),
                                                        qe
                                                    }
                                                while (1 <= g && 0 <= S);
                                            break
                                        }
                                }
                            } finally {
                                Cn = !1,
                                Error.prepareStackTrace = f
                            }
                            return (f = a ? a.displayName || a.name : "") ? yn(f) : ""
                        }
                        function Pn(a) {
                            switch (a.tag) {
                            case 26:
                            case 27:
                            case 5:
                                return yn(a.type);
                            case 16:
                                return yn("Lazy");
                            case 13:
                                return yn("Suspense");
                            case 19:
                                return yn("SuspenseList");
                            case 0:
                            case 15:
                                return Ln(a.type, !1);
                            case 11:
                                return Ln(a.type.render, !1);
                            case 1:
                                return Ln(a.type, !0);
                            case 31:
                                return yn("Activity");
                            default:
                                return ""
                            }
                        }
                        function Tt(a) {
                            try {
                                var o = "";
                                do
                                    o += Pn(a),
                                    a = a.return;
                                while (a);
                                return o
                            } catch (f) {
                                return `
Error generating stack: ` + f.message + `
` + f.stack
                            }
                        }
                        function Mn(a) {
                            switch (typeof a) {
                            case "bigint":
                            case "boolean":
                            case "number":
                            case "string":
                            case "undefined":
                                return a;
                            case "object":
                                return a;
                            default:
                                return ""
                            }
                        }
                        function dn(a) {
                            var o = a.type;
                            return (a = a.nodeName) && a.toLowerCase() === "input" && (o === "checkbox" || o === "radio")
                        }
                        function va(a) {
                            var o = dn(a) ? "checked" : "value"
                              , f = Object.getOwnPropertyDescriptor(a.constructor.prototype, o)
                              , g = "" + a[o];
                            if (!a.hasOwnProperty(o) && typeof f < "u" && typeof f.get == "function" && typeof f.set == "function") {
                                var S = f.get
                                  , w = f.set;
                                return Object.defineProperty(a, o, {
                                    configurable: !0,
                                    get: function() {
                                        return S.call(this)
                                    },
                                    set: function(z) {
                                        g = "" + z,
                                        w.call(this, z)
                                    }
                                }),
                                Object.defineProperty(a, o, {
                                    enumerable: f.enumerable
                                }),
                                {
                                    getValue: function() {
                                        return g
                                    },
                                    setValue: function(z) {
                                        g = "" + z
                                    },
                                    stopTracking: function() {
                                        a._valueTracker = null,
                                        delete a[o]
                                    }
                                }
                            }
                        }
                        function Va(a) {
                            a._valueTracker || (a._valueTracker = va(a))
                        }
                        function ls(a) {
                            if (!a)
                                return !1;
                            var o = a._valueTracker;
                            if (!o)
                                return !0;
                            var f = o.getValue()
                              , g = "";
                            return a && (g = dn(a) ? a.checked ? "true" : "false" : a.value),
                            a = g,
                            a !== f ? (o.setValue(a),
                            !0) : !1
                        }
                        function ur(a) {
                            if (a = a || (typeof document < "u" ? document : void 0),
                            typeof a > "u")
                                return null;
                            try {
                                return a.activeElement || a.body
                            } catch {
                                return a.body
                            }
                        }
                        var Gn = /[\n"\\]/g;
                        function Qn(a) {
                            return a.replace(Gn, function(o) {
                                return "\\" + o.charCodeAt(0).toString(16) + " "
                            })
                        }
                        function cs(a, o, f, g, S, w, z, Y) {
                            a.name = "",
                            z != null && typeof z != "function" && typeof z != "symbol" && typeof z != "boolean" ? a.type = z : a.removeAttribute("type"),
                            o != null ? z === "number" ? (o === 0 && a.value === "" || a.value != o) && (a.value = "" + Mn(o)) : a.value !== "" + Mn(o) && (a.value = "" + Mn(o)) : z !== "submit" && z !== "reset" || a.removeAttribute("value"),
                            o != null ? bs(a, z, Mn(o)) : f != null ? bs(a, z, Mn(f)) : g != null && a.removeAttribute("value"),
                            S == null && w != null && (a.defaultChecked = !!w),
                            S != null && (a.checked = S && typeof S != "function" && typeof S != "symbol"),
                            Y != null && typeof Y != "function" && typeof Y != "symbol" && typeof Y != "boolean" ? a.name = "" + Mn(Y) : a.removeAttribute("name")
                        }
                        function Mi(a, o, f, g, S, w, z, Y) {
                            if (w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" && (a.type = w),
                            o != null || f != null) {
                                if (!(w !== "submit" && w !== "reset" || o != null))
                                    return;
                                f = f != null ? "" + Mn(f) : "",
                                o = o != null ? "" + Mn(o) : f,
                                Y || o === a.value || (a.value = o),
                                a.defaultValue = o
                            }
                            g = g ?? S,
                            g = typeof g != "function" && typeof g != "symbol" && !!g,
                            a.checked = Y ? a.checked : !!g,
                            a.defaultChecked = !!g,
                            z != null && typeof z != "function" && typeof z != "symbol" && typeof z != "boolean" && (a.name = z)
                        }
                        function bs(a, o, f) {
                            o === "number" && ur(a.ownerDocument) === a || a.defaultValue === "" + f || (a.defaultValue = "" + f)
                        }
                        function hr(a, o, f, g) {
                            if (a = a.options,
                            o) {
                                o = {};
                                for (var S = 0; S < f.length; S++)
                                    o["$" + f[S]] = !0;
                                for (f = 0; f < a.length; f++)
                                    S = o.hasOwnProperty("$" + a[f].value),
                                    a[f].selected !== S && (a[f].selected = S),
                                    S && g && (a[f].defaultSelected = !0)
                            } else {
                                for (f = "" + Mn(f),
                                o = null,
                                S = 0; S < a.length; S++) {
                                    if (a[S].value === f) {
                                        a[S].selected = !0,
                                        g && (a[S].defaultSelected = !0);
                                        return
                                    }
                                    o !== null || a[S].disabled || (o = a[S])
                                }
                                o !== null && (o.selected = !0)
                            }
                        }
                        function zr(a, o, f) {
                            if (o != null && (o = "" + Mn(o),
                            o !== a.value && (a.value = o),
                            f == null)) {
                                a.defaultValue !== o && (a.defaultValue = o);
                                return
                            }
                            a.defaultValue = f != null ? "" + Mn(f) : ""
                        }
                        function gm(a, o, f, g) {
                            if (o == null) {
                                if (g != null) {
                                    if (f != null)
                                        throw Error(s(92));
                                    if (G(g)) {
                                        if (1 < g.length)
                                            throw Error(s(93));
                                        g = g[0]
                                    }
                                    f = g
                                }
                                f ??= "",
                                o = f
                            }
                            f = Mn(o),
                            a.defaultValue = f,
                            g = a.textContent,
                            g === f && g !== "" && g !== null && (a.value = g)
                        }
                        function fr(a, o) {
                            if (o) {
                                var f = a.firstChild;
                                if (f && f === a.lastChild && f.nodeType === 3) {
                                    f.nodeValue = o;
                                    return
                                }
                            }
                            a.textContent = o
                        }
                        var s0 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
                        function oh(a, o, f) {
                            var g = o.indexOf("--") === 0;
                            f == null || typeof f == "boolean" || f === "" ? g ? a.setProperty(o, "") : o === "float" ? a.cssFloat = "" : a[o] = "" : g ? a.setProperty(o, f) : typeof f != "number" || f === 0 || s0.has(o) ? o === "float" ? a.cssFloat = f : a[o] = ("" + f).trim() : a[o] = f + "px"
                        }
                        function lh(a, o, f) {
                            if (o != null && typeof o != "object")
                                throw Error(s(62));
                            if (a = a.style,
                            f != null) {
                                for (var g in f)
                                    !f.hasOwnProperty(g) || o != null && o.hasOwnProperty(g) || (g.indexOf("--") === 0 ? a.setProperty(g, "") : g === "float" ? a.cssFloat = "" : a[g] = "");
                                for (var S in o)
                                    g = o[S],
                                    o.hasOwnProperty(S) && f[S] !== g && oh(a, S, g)
                            } else
                                for (var w in o)
                                    o.hasOwnProperty(w) && oh(a, w, o[w])
                        }
                        function Kf(a) {
                            if (a.indexOf("-") === -1)
                                return !1;
                            switch (a) {
                            case "annotation-xml":
                            case "color-profile":
                            case "font-face":
                            case "font-face-src":
                            case "font-face-uri":
                            case "font-face-format":
                            case "font-face-name":
                            case "missing-glyph":
                                return !1;
                            default:
                                return !0
                            }
                        }
                        var vm = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
                          , a0 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
                        function ch(a) {
                            return a0.test("" + a) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : a
                        }
                        var Jf = null;
                        function $f(a) {
                            return a = a.target || a.srcElement || window,
                            a.correspondingUseElement && (a = a.correspondingUseElement),
                            a.nodeType === 3 ? a.parentNode : a
                        }
                        var el = null
                          , Zl = null;
                        function ym(a) {
                            var o = Lr(a);
                            if (o && (a = o.stateNode)) {
                                var f = a[ki] || null;
                                e: switch (a = o.stateNode,
                                o.type) {
                                case "input":
                                    if (cs(a, f.value, f.defaultValue, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name),
                                    o = f.name,
                                    f.type === "radio" && o != null) {
                                        for (f = a; f.parentNode; )
                                            f = f.parentNode;
                                        for (f = f.querySelectorAll('input[name="' + Qn("" + o) + '"][type="radio"]'),
                                        o = 0; o < f.length; o++) {
                                            var g = f[o];
                                            if (g !== a && g.form === a.form) {
                                                var S = g[ki] || null;
                                                if (!S)
                                                    throw Error(s(90));
                                                cs(g, S.value, S.defaultValue, S.defaultValue, S.checked, S.defaultChecked, S.type, S.name)
                                            }
                                        }
                                        for (o = 0; o < f.length; o++)
                                            g = f[o],
                                            g.form === a.form && ls(g)
                                    }
                                    break e;
                                case "textarea":
                                    zr(a, f.value, f.defaultValue);
                                    break e;
                                case "select":
                                    o = f.value,
                                    o != null && hr(a, !!f.multiple, o, !1)
                                }
                            }
                        }
                        var uh = !1;
                        function _m(a, o, f) {
                            if (uh)
                                return a(o, f);
                            uh = !0;
                            try {
                                return a(o)
                            } finally {
                                if (uh = !1,
                                (el !== null || Zl !== null) && ($r(),
                                el && (o = el,
                                a = Zl,
                                Zl = el = null,
                                ym(o),
                                a)))
                                    for (o = 0; o < a.length; o++)
                                        ym(a[o])
                            }
                        }
                        function Fc(a, o) {
                            var f = a.stateNode;
                            if (f === null)
                                return null;
                            var g = f[ki] || null;
                            if (g === null)
                                return null;
                            f = g[o];
                            e: switch (o) {
                            case "onClick":
                            case "onClickCapture":
                            case "onDoubleClick":
                            case "onDoubleClickCapture":
                            case "onMouseDown":
                            case "onMouseDownCapture":
                            case "onMouseMove":
                            case "onMouseMoveCapture":
                            case "onMouseUp":
                            case "onMouseUpCapture":
                            case "onMouseEnter":
                                (g = !g.disabled) || (a = a.type,
                                g = !(a === "button" || a === "input" || a === "select" || a === "textarea")),
                                a = !g;
                                break e;
                            default:
                                a = !1
                            }
                            if (a)
                                return null;
                            if (f && typeof f != "function")
                                throw Error(s(231, o, typeof f));
                            return f
                        }
                        var Fr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
                          , hh = !1;
                        if (Fr)
                            try {
                                var Hc = {};
                                Object.defineProperty(Hc, "passive", {
                                    get: function() {
                                        hh = !0
                                    }
                                }),
                                window.addEventListener("test", Hc, Hc),
                                window.removeEventListener("test", Hc, Hc)
                            } catch {
                                hh = !1
                            }
                        var fo = null
                          , xm = null
                          , ed = null;
                        function Sm() {
                            if (ed)
                                return ed;
                            var a, o = xm, f = o.length, g, S = "value"in fo ? fo.value : fo.textContent, w = S.length;
                            for (a = 0; a < f && o[a] === S[a]; a++)
                                ;
                            var z = f - a;
                            for (g = 1; g <= z && o[f - g] === S[w - g]; g++)
                                ;
                            return ed = S.slice(a, 1 < g ? 1 - g : void 0)
                        }
                        function tl(a) {
                            var o = a.keyCode;
                            return "charCode"in a ? (a = a.charCode,
                            a === 0 && o === 13 && (a = 13)) : a = o,
                            a === 10 && (a = 13),
                            32 <= a || a === 13 ? a : 0
                        }
                        function Vc() {
                            return !0
                        }
                        function fh() {
                            return !1
                        }
                        function Ps(a) {
                            function o(f, g, S, w, z) {
                                this._reactName = f,
                                this._targetInst = S,
                                this.type = g,
                                this.nativeEvent = w,
                                this.target = z,
                                this.currentTarget = null;
                                for (var Y in a)
                                    a.hasOwnProperty(Y) && (f = a[Y],
                                    this[Y] = f ? f(w) : w[Y]);
                                return this.isDefaultPrevented = (w.defaultPrevented != null ? w.defaultPrevented : w.returnValue === !1) ? Vc : fh,
                                this.isPropagationStopped = fh,
                                this
                            }
                            return v(o.prototype, {
                                preventDefault: function() {
                                    this.defaultPrevented = !0;
                                    var f = this.nativeEvent;
                                    f && (f.preventDefault ? f.preventDefault() : typeof f.returnValue != "unknown" && (f.returnValue = !1),
                                    this.isDefaultPrevented = Vc)
                                },
                                stopPropagation: function() {
                                    var f = this.nativeEvent;
                                    f && (f.stopPropagation ? f.stopPropagation() : typeof f.cancelBubble != "unknown" && (f.cancelBubble = !0),
                                    this.isPropagationStopped = Vc)
                                },
                                persist: function() {},
                                isPersistent: Vc
                            }),
                            o
                        }
                        var nl = {
                            eventPhase: 0,
                            bubbles: 0,
                            cancelable: 0,
                            timeStamp: function(a) {
                                return a.timeStamp || Date.now()
                            },
                            defaultPrevented: 0,
                            isTrusted: 0
                        }, Gc = Ps(nl), kc = v({}, nl, {
                            view: 0,
                            detail: 0
                        }), r0 = Ps(kc), po, Xc, qc, Yc = v({}, kc, {
                            screenX: 0,
                            screenY: 0,
                            clientX: 0,
                            clientY: 0,
                            pageX: 0,
                            pageY: 0,
                            ctrlKey: 0,
                            shiftKey: 0,
                            altKey: 0,
                            metaKey: 0,
                            getModifierState: ph,
                            button: 0,
                            buttons: 0,
                            relatedTarget: function(a) {
                                return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget
                            },
                            movementX: function(a) {
                                return "movementX"in a ? a.movementX : (a !== qc && (qc && a.type === "mousemove" ? (po = a.screenX - qc.screenX,
                                Xc = a.screenY - qc.screenY) : Xc = po = 0,
                                qc = a),
                                po)
                            },
                            movementY: function(a) {
                                return "movementY"in a ? a.movementY : Xc
                            }
                        }), Am = Ps(Yc), o0 = v({}, Yc, {
                            dataTransfer: 0
                        }), TS = Ps(o0), us = v({}, kc, {
                            relatedTarget: 0
                        }), td = Ps(us), l0 = v({}, nl, {
                            animationName: 0,
                            elapsedTime: 0,
                            pseudoElement: 0
                        }), c0 = Ps(l0), u0 = v({}, nl, {
                            clipboardData: function(a) {
                                return "clipboardData"in a ? a.clipboardData : window.clipboardData
                            }
                        }), h0 = Ps(u0), dh = v({}, nl, {
                            data: 0
                        }), nd = Ps(dh), f0 = {
                            Esc: "Escape",
                            Spacebar: " ",
                            Left: "ArrowLeft",
                            Up: "ArrowUp",
                            Right: "ArrowRight",
                            Down: "ArrowDown",
                            Del: "Delete",
                            Win: "OS",
                            Menu: "ContextMenu",
                            Apps: "ContextMenu",
                            Scroll: "ScrollLock",
                            MozPrintableKey: "Unidentified"
                        }, d0 = {
                            8: "Backspace",
                            9: "Tab",
                            12: "Clear",
                            13: "Enter",
                            16: "Shift",
                            17: "Control",
                            18: "Alt",
                            19: "Pause",
                            20: "CapsLock",
                            27: "Escape",
                            32: " ",
                            33: "PageUp",
                            34: "PageDown",
                            35: "End",
                            36: "Home",
                            37: "ArrowLeft",
                            38: "ArrowUp",
                            39: "ArrowRight",
                            40: "ArrowDown",
                            45: "Insert",
                            46: "Delete",
                            112: "F1",
                            113: "F2",
                            114: "F3",
                            115: "F4",
                            116: "F5",
                            117: "F6",
                            118: "F7",
                            119: "F8",
                            120: "F9",
                            121: "F10",
                            122: "F11",
                            123: "F12",
                            144: "NumLock",
                            145: "ScrollLock",
                            224: "Meta"
                        }, p0 = {
                            Alt: "altKey",
                            Control: "ctrlKey",
                            Meta: "metaKey",
                            Shift: "shiftKey"
                        };
                        function Tm(a) {
                            var o = this.nativeEvent;
                            return o.getModifierState ? o.getModifierState(a) : (a = p0[a]) ? !!o[a] : !1
                        }
                        function ph() {
                            return Tm
                        }
                        var m0 = v({}, kc, {
                            key: function(a) {
                                if (a.key) {
                                    var o = f0[a.key] || a.key;
                                    if (o !== "Unidentified")
                                        return o
                                }
                                return a.type === "keypress" ? (a = tl(a),
                                a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? d0[a.keyCode] || "Unidentified" : ""
                            },
                            code: 0,
                            location: 0,
                            ctrlKey: 0,
                            shiftKey: 0,
                            altKey: 0,
                            metaKey: 0,
                            repeat: 0,
                            locale: 0,
                            getModifierState: ph,
                            charCode: function(a) {
                                return a.type === "keypress" ? tl(a) : 0
                            },
                            keyCode: function(a) {
                                return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0
                            },
                            which: function(a) {
                                return a.type === "keypress" ? tl(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0
                            }
                        })
                          , Mm = Ps(m0)
                          , bm = v({}, Yc, {
                            pointerId: 0,
                            width: 0,
                            height: 0,
                            pressure: 0,
                            tangentialPressure: 0,
                            tiltX: 0,
                            tiltY: 0,
                            twist: 0,
                            pointerType: 0,
                            isPrimary: 0
                        })
                          , id = Ps(bm)
                          , g0 = v({}, kc, {
                            touches: 0,
                            targetTouches: 0,
                            changedTouches: 0,
                            altKey: 0,
                            metaKey: 0,
                            ctrlKey: 0,
                            shiftKey: 0,
                            getModifierState: ph
                        })
                          , Em = Ps(g0)
                          , v0 = v({}, nl, {
                            propertyName: 0,
                            elapsedTime: 0,
                            pseudoElement: 0
                        })
                          , mo = Ps(v0)
                          , wm = v({}, Yc, {
                            deltaX: function(a) {
                                return "deltaX"in a ? a.deltaX : "wheelDeltaX"in a ? -a.wheelDeltaX : 0
                            },
                            deltaY: function(a) {
                                return "deltaY"in a ? a.deltaY : "wheelDeltaY"in a ? -a.wheelDeltaY : "wheelDelta"in a ? -a.wheelDelta : 0
                            },
                            deltaZ: 0,
                            deltaMode: 0
                        })
                          , MS = Ps(wm)
                          , y0 = v({}, nl, {
                            newState: 0,
                            oldState: 0
                        })
                          , il = Ps(y0)
                          , go = [9, 13, 27, 32]
                          , mh = Fr && "CompositionEvent"in window
                          , Kl = null;
                        Fr && "documentMode"in document && (Kl = document.documentMode);
                        var gh = Fr && "TextEvent"in window && !Kl
                          , vh = Fr && (!mh || Kl && 8 < Kl && 11 >= Kl)
                          , sl = " "
                          , hs = !1;
                        function yh(a, o) {
                            switch (a) {
                            case "keyup":
                                return go.indexOf(o.keyCode) !== -1;
                            case "keydown":
                                return o.keyCode !== 229;
                            case "keypress":
                            case "mousedown":
                            case "focusout":
                                return !0;
                            default:
                                return !1
                            }
                        }
                        function Cm(a) {
                            return a = a.detail,
                            typeof a == "object" && "data"in a ? a.data : null
                        }
                        var al = !1;
                        function _h(a, o) {
                            switch (a) {
                            case "compositionend":
                                return Cm(o);
                            case "keypress":
                                return o.which !== 32 ? null : (hs = !0,
                                sl);
                            case "textInput":
                                return a = o.data,
                                a === sl && hs ? null : a;
                            default:
                                return null
                            }
                        }
                        function Rm(a, o) {
                            if (al)
                                return a === "compositionend" || !mh && yh(a, o) ? (a = Sm(),
                                ed = xm = fo = null,
                                al = !1,
                                a) : null;
                            switch (a) {
                            case "paste":
                                return null;
                            case "keypress":
                                if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
                                    if (o.char && 1 < o.char.length)
                                        return o.char;
                                    if (o.which)
                                        return String.fromCharCode(o.which)
                                }
                                return null;
                            case "compositionend":
                                return vh && o.locale !== "ko" ? null : o.data;
                            default:
                                return null
                            }
                        }
                        var sd = {
                            color: !0,
                            date: !0,
                            datetime: !0,
                            "datetime-local": !0,
                            email: !0,
                            month: !0,
                            number: !0,
                            password: !0,
                            range: !0,
                            search: !0,
                            tel: !0,
                            text: !0,
                            time: !0,
                            url: !0,
                            week: !0
                        };
                        function Dm(a) {
                            var o = a && a.nodeName && a.nodeName.toLowerCase();
                            return o === "input" ? !!sd[a.type] : o === "textarea"
                        }
                        function Zs(a, o, f, g) {
                            el ? Zl ? Zl.push(g) : Zl = [g] : el = g,
                            o = gy(o, "onChange"),
                            0 < o.length && (f = new Gc("onChange","change",null,f,g),
                            a.push({
                                event: f,
                                listeners: o
                            }))
                        }
                        var Wc = null
                          , Jl = null;
                        function _0(a) {
                            bb(a, 0)
                        }
                        function xh(a) {
                            var o = $o(a);
                            if (ls(o))
                                return a
                        }
                        function ad(a, o) {
                            if (a === "change")
                                return o
                        }
                        var rd = !1;
                        if (Fr) {
                            var od;
                            if (Fr) {
                                var jc = "oninput"in document;
                                if (!jc) {
                                    var Qc = document.createElement("div");
                                    Qc.setAttribute("oninput", "return;"),
                                    jc = typeof Qc.oninput == "function"
                                }
                                od = jc
                            } else
                                od = !1;
                            rd = od && (!document.documentMode || 9 < document.documentMode)
                        }
                        function ci() {
                            Wc && (Wc.detachEvent("onpropertychange", x0),
                            Jl = Wc = null)
                        }
                        function x0(a) {
                            if (a.propertyName === "value" && xh(Jl)) {
                                var o = [];
                                Zs(o, Jl, a, $f(a)),
                                _m(_0, o)
                            }
                        }
                        function bS(a, o, f) {
                            a === "focusin" ? (ci(),
                            Wc = o,
                            Jl = f,
                            Wc.attachEvent("onpropertychange", x0)) : a === "focusout" && ci()
                        }
                        function S0(a) {
                            if (a === "selectionchange" || a === "keyup" || a === "keydown")
                                return xh(Jl)
                        }
                        function Sh(a, o) {
                            if (a === "click")
                                return xh(o)
                        }
                        function rl(a, o) {
                            if (a === "input" || a === "change")
                                return xh(o)
                        }
                        function A0(a, o) {
                            return a === o && (a !== 0 || 1 / a === 1 / o) || a !== a && o !== o
                        }
                        var Ks = typeof Object.is == "function" ? Object.is : A0;
                        function dr(a, o) {
                            if (Ks(a, o))
                                return !0;
                            if (typeof a != "object" || a === null || typeof o != "object" || o === null)
                                return !1;
                            var f = Object.keys(a)
                              , g = Object.keys(o);
                            if (f.length !== g.length)
                                return !1;
                            for (g = 0; g < f.length; g++) {
                                var S = f[g];
                                if (!Ve.call(o, S) || !Ks(a[S], o[S]))
                                    return !1
                            }
                            return !0
                        }
                        function Js(a) {
                            for (; a && a.firstChild; )
                                a = a.firstChild;
                            return a
                        }
                        function Om(a, o) {
                            var f = Js(a);
                            a = 0;
                            for (var g; f; ) {
                                if (f.nodeType === 3) {
                                    if (g = a + f.textContent.length,
                                    a <= o && g >= o)
                                        return {
                                            node: f,
                                            offset: o - a
                                        };
                                    a = g
                                }
                                e: {
                                    for (; f; ) {
                                        if (f.nextSibling) {
                                            f = f.nextSibling;
                                            break e
                                        }
                                        f = f.parentNode
                                    }
                                    f = void 0
                                }
                                f = Js(f)
                            }
                        }
                        function Nm(a, o) {
                            return a && o ? a === o ? !0 : a && a.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Nm(a, o.parentNode) : "contains"in a ? a.contains(o) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(o) & 16) : !1 : !1
                        }
                        function Um(a) {
                            a = a != null && a.ownerDocument != null && a.ownerDocument.defaultView != null ? a.ownerDocument.defaultView : window;
                            for (var o = ur(a.document); o instanceof a.HTMLIFrameElement; ) {
                                try {
                                    var f = typeof o.contentWindow.location.href == "string"
                                } catch {
                                    f = !1
                                }
                                if (f)
                                    a = o.contentWindow;
                                else
                                    break;
                                o = ur(a.document)
                            }
                            return o
                        }
                        function Ah(a) {
                            var o = a && a.nodeName && a.nodeName.toLowerCase();
                            return o && (o === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || o === "textarea" || a.contentEditable === "true")
                        }
                        var Bm = Fr && "documentMode"in document && 11 >= document.documentMode
                          , vo = null
                          , ld = null
                          , Th = null
                          , cd = !1;
                        function Pm(a, o, f) {
                            var g = f.window === f ? f.document : f.nodeType === 9 ? f : f.ownerDocument;
                            cd || vo == null || vo !== ur(g) || (g = vo,
                            "selectionStart"in g && Ah(g) ? g = {
                                start: g.selectionStart,
                                end: g.selectionEnd
                            } : (g = (g.ownerDocument && g.ownerDocument.defaultView || window).getSelection(),
                            g = {
                                anchorNode: g.anchorNode,
                                anchorOffset: g.anchorOffset,
                                focusNode: g.focusNode,
                                focusOffset: g.focusOffset
                            }),
                            Th && dr(Th, g) || (Th = g,
                            g = gy(ld, "onSelect"),
                            0 < g.length && (o = new Gc("onSelect","select",null,o,f),
                            a.push({
                                event: o,
                                listeners: g
                            }),
                            o.target = vo)))
                        }
                        function fs(a, o) {
                            var f = {};
                            return f[a.toLowerCase()] = o.toLowerCase(),
                            f["Webkit" + a] = "webkit" + o,
                            f["Moz" + a] = "moz" + o,
                            f
                        }
                        var ol = {
                            animationend: fs("Animation", "AnimationEnd"),
                            animationiteration: fs("Animation", "AnimationIteration"),
                            animationstart: fs("Animation", "AnimationStart"),
                            transitionrun: fs("Transition", "TransitionRun"),
                            transitionstart: fs("Transition", "TransitionStart"),
                            transitioncancel: fs("Transition", "TransitionCancel"),
                            transitionend: fs("Transition", "TransitionEnd")
                        }
                          , ud = {}
                          , T0 = {};
                        Fr && (T0 = document.createElement("div").style,
                        "AnimationEvent"in window || (delete ol.animationend.animation,
                        delete ol.animationiteration.animation,
                        delete ol.animationstart.animation),
                        "TransitionEvent"in window || delete ol.transitionend.transition);
                        function yo(a) {
                            if (ud[a])
                                return ud[a];
                            if (!ol[a])
                                return a;
                            var o = ol[a], f;
                            for (f in o)
                                if (o.hasOwnProperty(f) && f in T0)
                                    return ud[a] = o[f];
                            return a
                        }
                        var Is = yo("animationend")
                          , Im = yo("animationiteration")
                          , $s = yo("animationstart")
                          , M0 = yo("transitionrun")
                          , _o = yo("transitionstart")
                          , Zc = yo("transitioncancel")
                          , xo = yo("transitionend")
                          , hd = new Map
                          , Mh = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
                        Mh.push("scrollEnd");
                        function $i(a, o) {
                            hd.set(a, o),
                            Ee(o, [a])
                        }
                        var Lm = new WeakMap;
                        function ds(a, o) {
                            if (typeof a == "object" && a !== null) {
                                var f = Lm.get(a);
                                return f !== void 0 ? f : (o = {
                                    value: a,
                                    source: o,
                                    stack: Tt(o)
                                },
                                Lm.set(a, o),
                                o)
                            }
                            return {
                                value: a,
                                source: o,
                                stack: Tt(o)
                            }
                        }
                        var Es = []
                          , Ga = 0
                          , fd = 0;
                        function bh() {
                            for (var a = Ga, o = fd = Ga = 0; o < a; ) {
                                var f = Es[o];
                                Es[o++] = null;
                                var g = Es[o];
                                Es[o++] = null;
                                var S = Es[o];
                                Es[o++] = null;
                                var w = Es[o];
                                if (Es[o++] = null,
                                g !== null && S !== null) {
                                    var z = g.pending;
                                    z === null ? S.next = S : (S.next = z.next,
                                    z.next = S),
                                    g.pending = S
                                }
                                w !== 0 && zm(f, S, w)
                            }
                        }
                        function ll(a, o, f, g) {
                            Es[Ga++] = a,
                            Es[Ga++] = o,
                            Es[Ga++] = f,
                            Es[Ga++] = g,
                            fd |= g,
                            a.lanes |= g,
                            a = a.alternate,
                            a !== null && (a.lanes |= g)
                        }
                        function dd(a, o, f, g) {
                            return ll(a, o, f, g),
                            Kc(a)
                        }
                        function So(a, o) {
                            return ll(a, null, null, o),
                            Kc(a)
                        }
                        function zm(a, o, f) {
                            a.lanes |= f;
                            var g = a.alternate;
                            g !== null && (g.lanes |= f);
                            for (var S = !1, w = a.return; w !== null; )
                                w.childLanes |= f,
                                g = w.alternate,
                                g !== null && (g.childLanes |= f),
                                w.tag === 22 && (a = w.stateNode,
                                a === null || a._visibility & 1 || (S = !0)),
                                a = w,
                                w = w.return;
                            return a.tag === 3 ? (w = a.stateNode,
                            S && o !== null && (S = 31 - Ke(f),
                            a = w.hiddenUpdates,
                            g = a[S],
                            g === null ? a[S] = [o] : g.push(o),
                            o.lane = f | 536870912),
                            w) : null
                        }
                        function Kc(a) {
                            if (50 < Jr)
                                throw Jr = 0,
                                gc = null,
                                Error(s(185));
                            for (var o = a.return; o !== null; )
                                a = o,
                                o = a.return;
                            return a.tag === 3 ? a.stateNode : null
                        }
                        var cl = {};
                        function Fm(a, o, f, g) {
                            this.tag = a,
                            this.key = f,
                            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                            this.index = 0,
                            this.refCleanup = this.ref = null,
                            this.pendingProps = o,
                            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                            this.mode = g,
                            this.subtreeFlags = this.flags = 0,
                            this.deletions = null,
                            this.childLanes = this.lanes = 0,
                            this.alternate = null
                        }
                        function ea(a, o, f, g) {
                            return new Fm(a,o,f,g)
                        }
                        function Eh(a) {
                            return a = a.prototype,
                            !(!a || !a.isReactComponent)
                        }
                        function bi(a, o) {
                            var f = a.alternate;
                            return f === null ? (f = ea(a.tag, o, a.key, a.mode),
                            f.elementType = a.elementType,
                            f.type = a.type,
                            f.stateNode = a.stateNode,
                            f.alternate = a,
                            a.alternate = f) : (f.pendingProps = o,
                            f.type = a.type,
                            f.flags = 0,
                            f.subtreeFlags = 0,
                            f.deletions = null),
                            f.flags = a.flags & 65011712,
                            f.childLanes = a.childLanes,
                            f.lanes = a.lanes,
                            f.child = a.child,
                            f.memoizedProps = a.memoizedProps,
                            f.memoizedState = a.memoizedState,
                            f.updateQueue = a.updateQueue,
                            o = a.dependencies,
                            f.dependencies = o === null ? null : {
                                lanes: o.lanes,
                                firstContext: o.firstContext
                            },
                            f.sibling = a.sibling,
                            f.index = a.index,
                            f.ref = a.ref,
                            f.refCleanup = a.refCleanup,
                            f
                        }
                        function Hm(a, o) {
                            a.flags &= 65011714;
                            var f = a.alternate;
                            return f === null ? (a.childLanes = 0,
                            a.lanes = o,
                            a.child = null,
                            a.subtreeFlags = 0,
                            a.memoizedProps = null,
                            a.memoizedState = null,
                            a.updateQueue = null,
                            a.dependencies = null,
                            a.stateNode = null) : (a.childLanes = f.childLanes,
                            a.lanes = f.lanes,
                            a.child = f.child,
                            a.subtreeFlags = 0,
                            a.deletions = null,
                            a.memoizedProps = f.memoizedProps,
                            a.memoizedState = f.memoizedState,
                            a.updateQueue = f.updateQueue,
                            a.type = f.type,
                            o = f.dependencies,
                            a.dependencies = o === null ? null : {
                                lanes: o.lanes,
                                firstContext: o.firstContext
                            }),
                            a
                        }
                        function es(a, o, f, g, S, w) {
                            var z = 0;
                            if (g = a,
                            typeof a == "function")
                                Eh(a) && (z = 1);
                            else if (typeof a == "string")
                                z = b3(a, f, le.current) ? 26 : a === "html" || a === "head" || a === "body" ? 27 : 5;
                            else
                                e: switch (a) {
                                case L:
                                    return a = ea(31, f, o, S),
                                    a.elementType = L,
                                    a.lanes = w,
                                    a;
                                case E:
                                    return ul(f.children, S, w, o);
                                case T:
                                    z = 8,
                                    S |= 24;
                                    break;
                                case M:
                                    return a = ea(12, f, o, S | 2),
                                    a.elementType = M,
                                    a.lanes = w,
                                    a;
                                case B:
                                    return a = ea(13, f, o, S),
                                    a.elementType = B,
                                    a.lanes = w,
                                    a;
                                case I:
                                    return a = ea(19, f, o, S),
                                    a.elementType = I,
                                    a.lanes = w,
                                    a;
                                default:
                                    if (typeof a == "object" && a !== null)
                                        switch (a.$$typeof) {
                                        case D:
                                        case O:
                                            z = 10;
                                            break e;
                                        case R:
                                            z = 9;
                                            break e;
                                        case U:
                                            z = 11;
                                            break e;
                                        case F:
                                            z = 14;
                                            break e;
                                        case P:
                                            z = 16,
                                            g = null;
                                            break e
                                        }
                                    z = 29,
                                    f = Error(s(130, a === null ? "null" : typeof a, "")),
                                    g = null
                                }
                            return o = ea(z, f, o, S),
                            o.elementType = a,
                            o.type = g,
                            o.lanes = w,
                            o
                        }
                        function ul(a, o, f, g) {
                            return a = ea(7, a, g, o),
                            a.lanes = f,
                            a
                        }
                        function wh(a, o, f) {
                            return a = ea(6, a, null, o),
                            a.lanes = f,
                            a
                        }
                        function pd(a, o, f) {
                            return o = ea(4, a.children !== null ? a.children : [], a.key, o),
                            o.lanes = f,
                            o.stateNode = {
                                containerInfo: a.containerInfo,
                                pendingChildren: null,
                                implementation: a.implementation
                            },
                            o
                        }
                        var Jc = []
                          , ta = 0
                          , Ch = null
                          , $c = 0
                          , ps = []
                          , ya = 0
                          , hl = null
                          , Hr = 1
                          , Vr = "";
                        function Ao(a, o) {
                            Jc[ta++] = $c,
                            Jc[ta++] = Ch,
                            Ch = a,
                            $c = o
                        }
                        function md(a, o, f) {
                            ps[ya++] = Hr,
                            ps[ya++] = Vr,
                            ps[ya++] = hl,
                            hl = a;
                            var g = Hr;
                            a = Vr;
                            var S = 32 - Ke(g) - 1;
                            g &= ~(1 << S),
                            f += 1;
                            var w = 32 - Ke(o) + S;
                            if (30 < w) {
                                var z = S - S % 5;
                                w = (g & (1 << z) - 1).toString(32),
                                g >>= z,
                                S -= z,
                                Hr = 1 << 32 - Ke(o) + S | f << S | g,
                                Vr = w + a
                            } else
                                Hr = 1 << w | f << S | g,
                                Vr = a
                        }
                        function Vm(a) {
                            a.return !== null && (Ao(a, 1),
                            md(a, 1, 0))
                        }
                        function Gm(a) {
                            for (; a === Ch; )
                                Ch = Jc[--ta],
                                Jc[ta] = null,
                                $c = Jc[--ta],
                                Jc[ta] = null;
                            for (; a === hl; )
                                hl = ps[--ya],
                                ps[ya] = null,
                                Vr = ps[--ya],
                                ps[ya] = null,
                                Hr = ps[--ya],
                                ps[ya] = null
                        }
                        var Ls = null
                          , di = null
                          , bn = !1
                          , ka = null
                          , _a = !1
                          , gd = Error(s(519));
                        function fl(a) {
                            var o = Error(s(418, ""));
                            throw $l(ds(o, a)),
                            gd
                        }
                        function b0(a) {
                            var o = a.stateNode
                              , f = a.type
                              , g = a.memoizedProps;
                            switch (o[Ti] = a,
                            o[ki] = g,
                            f) {
                            case "dialog":
                                vn("cancel", o),
                                vn("close", o);
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                vn("load", o);
                                break;
                            case "video":
                            case "audio":
                                for (f = 0; f < xg.length; f++)
                                    vn(xg[f], o);
                                break;
                            case "source":
                                vn("error", o);
                                break;
                            case "img":
                            case "image":
                            case "link":
                                vn("error", o),
                                vn("load", o);
                                break;
                            case "details":
                                vn("toggle", o);
                                break;
                            case "input":
                                vn("invalid", o),
                                Mi(o, g.value, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name, !0),
                                Va(o);
                                break;
                            case "select":
                                vn("invalid", o);
                                break;
                            case "textarea":
                                vn("invalid", o),
                                gm(o, g.value, g.defaultValue, g.children),
                                Va(o)
                            }
                            f = g.children,
                            typeof f != "string" && typeof f != "number" && typeof f != "bigint" || o.textContent === "" + f || g.suppressHydrationWarning === !0 || Db(o.textContent, f) ? (g.popover != null && (vn("beforetoggle", o),
                            vn("toggle", o)),
                            g.onScroll != null && vn("scroll", o),
                            g.onScrollEnd != null && vn("scrollend", o),
                            g.onClick != null && (o.onclick = vy),
                            o = !0) : o = !1,
                            o || fl(a)
                        }
                        function km(a) {
                            for (Ls = a.return; Ls; )
                                switch (Ls.tag) {
                                case 5:
                                case 13:
                                    _a = !1;
                                    return;
                                case 27:
                                case 3:
                                    _a = !0;
                                    return;
                                default:
                                    Ls = Ls.return
                                }
                        }
                        function pr(a) {
                            if (a !== Ls)
                                return !1;
                            if (!bn)
                                return km(a),
                                bn = !0,
                                !1;
                            var o = a.tag, f;
                            if ((f = o !== 3 && o !== 27) && ((f = o === 5) && (f = a.type,
                            f = !(f !== "form" && f !== "button") || qS(a.type, a.memoizedProps)),
                            f = !f),
                            f && di && fl(a),
                            km(a),
                            o === 13) {
                                if (a = a.memoizedState,
                                a = a !== null ? a.dehydrated : null,
                                !a)
                                    throw Error(s(317));
                                e: {
                                    for (a = a.nextSibling,
                                    o = 0; a; ) {
                                        if (a.nodeType === 8)
                                            if (f = a.data,
                                            f === "/$") {
                                                if (o === 0) {
                                                    di = Io(a.nextSibling);
                                                    break e
                                                }
                                                o--
                                            } else
                                                f !== "$" && f !== "$!" && f !== "$?" || o++;
                                        a = a.nextSibling
                                    }
                                    di = null
                                }
                            } else
                                o === 27 ? (o = di,
                                Mu(a.type) ? (a = QS,
                                QS = null,
                                di = a) : di = o) : di = Ls ? Io(a.stateNode.nextSibling) : null;
                            return !0
                        }
                        function eu() {
                            di = Ls = null,
                            bn = !1
                        }
                        function Rn() {
                            var a = ka;
                            return a !== null && (Lt === null ? Lt = a : Lt.push.apply(Lt, a),
                            ka = null),
                            a
                        }
                        function $l(a) {
                            ka === null ? ka = [a] : ka.push(a)
                        }
                        var Xm = J(null)
                          , dl = null
                          , To = null;
                        function pl(a, o, f) {
                            xe(Xm, o._currentValue),
                            o._currentValue = f
                        }
                        function Mo(a) {
                            a._currentValue = Xm.current,
                            ze(Xm)
                        }
                        function qm(a, o, f) {
                            for (; a !== null; ) {
                                var g = a.alternate;
                                if ((a.childLanes & o) !== o ? (a.childLanes |= o,
                                g !== null && (g.childLanes |= o)) : g !== null && (g.childLanes & o) !== o && (g.childLanes |= o),
                                a === f)
                                    break;
                                a = a.return
                            }
                        }
                        function Rh(a, o, f, g) {
                            var S = a.child;
                            for (S !== null && (S.return = a); S !== null; ) {
                                var w = S.dependencies;
                                if (w !== null) {
                                    var z = S.child;
                                    w = w.firstContext;
                                    e: for (; w !== null; ) {
                                        var Y = w;
                                        w = S;
                                        for (var re = 0; re < o.length; re++)
                                            if (Y.context === o[re]) {
                                                w.lanes |= f,
                                                Y = w.alternate,
                                                Y !== null && (Y.lanes |= f),
                                                qm(w.return, f, a),
                                                g || (z = null);
                                                break e
                                            }
                                        w = Y.next
                                    }
                                } else if (S.tag === 18) {
                                    if (z = S.return,
                                    z === null)
                                        throw Error(s(341));
                                    z.lanes |= f,
                                    w = z.alternate,
                                    w !== null && (w.lanes |= f),
                                    qm(z, f, a),
                                    z = null
                                } else
                                    z = S.child;
                                if (z !== null)
                                    z.return = S;
                                else
                                    for (z = S; z !== null; ) {
                                        if (z === a) {
                                            z = null;
                                            break
                                        }
                                        if (S = z.sibling,
                                        S !== null) {
                                            S.return = z.return,
                                            z = S;
                                            break
                                        }
                                        z = z.return
                                    }
                                S = z
                            }
                        }
                        function Xa(a, o, f, g) {
                            a = null;
                            for (var S = o, w = !1; S !== null; ) {
                                if (!w) {
                                    if ((S.flags & 524288) !== 0)
                                        w = !0;
                                    else if ((S.flags & 262144) !== 0)
                                        break
                                }
                                if (S.tag === 10) {
                                    var z = S.alternate;
                                    if (z === null)
                                        throw Error(s(387));
                                    if (z = z.memoizedProps,
                                    z !== null) {
                                        var Y = S.type;
                                        Ks(S.pendingProps.value, z.value) || (a !== null ? a.push(Y) : a = [Y])
                                    }
                                } else if (S === Ue.current) {
                                    if (z = S.alternate,
                                    z === null)
                                        throw Error(s(387));
                                    z.memoizedState.memoizedState !== S.memoizedState.memoizedState && (a !== null ? a.push(Eg) : a = [Eg])
                                }
                                S = S.return
                            }
                            a !== null && Rh(o, a, f, g),
                            o.flags |= 262144
                        }
                        function Dh(a) {
                            for (a = a.firstContext; a !== null; ) {
                                if (!Ks(a.context._currentValue, a.memoizedValue))
                                    return !0;
                                a = a.next
                            }
                            return !1
                        }
                        function Gr(a) {
                            dl = a,
                            To = null,
                            a = a.dependencies,
                            a !== null && (a.firstContext = null)
                        }
                        function vi(a) {
                            return vd(dl, a)
                        }
                        function Oh(a, o) {
                            return dl === null && Gr(a),
                            vd(a, o)
                        }
                        function vd(a, o) {
                            var f = o._currentValue;
                            if (o = {
                                context: o,
                                memoizedValue: f,
                                next: null
                            },
                            To === null) {
                                if (a === null)
                                    throw Error(s(308));
                                To = o,
                                a.dependencies = {
                                    lanes: 0,
                                    firstContext: o
                                },
                                a.flags |= 524288
                            } else
                                To = To.next = o;
                            return f
                        }
                        var Ym = typeof AbortController < "u" ? AbortController : function() {
                            var a = []
                              , o = this.signal = {
                                aborted: !1,
                                addEventListener: function(f, g) {
                                    a.push(g)
                                }
                            };
                            this.abort = function() {
                                o.aborted = !0,
                                a.forEach(function(f) {
                                    return f()
                                })
                            }
                        }
                          , ES = t.unstable_scheduleCallback
                          , E0 = t.unstable_NormalPriority
                          , Pi = {
                            $$typeof: O,
                            Consumer: null,
                            Provider: null,
                            _currentValue: null,
                            _currentValue2: null,
                            _threadCount: 0
                        };
                        function yd() {
                            return {
                                controller: new Ym,
                                data: new Map,
                                refCount: 0
                            }
                        }
                        function tu(a) {
                            a.refCount--,
                            a.refCount === 0 && ES(E0, function() {
                                a.controller.abort()
                            })
                        }
                        var nu = null
                          , Nh = 0
                          , Kt = 0
                          , iu = null;
                        function xa(a, o) {
                            if (nu === null) {
                                var f = nu = [];
                                Nh = 0,
                                Kt = LS(),
                                iu = {
                                    status: "pending",
                                    value: void 0,
                                    then: function(g) {
                                        f.push(g)
                                    }
                                }
                            }
                            return Nh++,
                            o.then(_d, _d),
                            o
                        }
                        function _d() {
                            if (--Nh === 0 && nu !== null) {
                                iu !== null && (iu.status = "fulfilled");
                                var a = nu;
                                nu = null,
                                Kt = 0,
                                iu = null;
                                for (var o = 0; o < a.length; o++)
                                    (0,
                                    a[o])()
                            }
                        }
                        function wS(a, o) {
                            var f = []
                              , g = {
                                status: "pending",
                                value: null,
                                reason: null,
                                then: function(S) {
                                    f.push(S)
                                }
                            };
                            return a.then(function() {
                                g.status = "fulfilled",
                                g.value = o;
                                for (var S = 0; S < f.length; S++)
                                    (0,
                                    f[S])(o)
                            }, function(S) {
                                for (g.status = "rejected",
                                g.reason = S,
                                S = 0; S < f.length; S++)
                                    (0,
                                    f[S])(void 0)
                            }),
                            g
                        }
                        var Uh = V.S;
                        V.S = function(a, o) {
                            typeof o == "object" && o !== null && typeof o.then == "function" && xa(a, o),
                            Uh !== null && Uh(a, o)
                        }
                        ;
                        var qa = J(null);
                        function ml() {
                            var a = qa.current;
                            return a !== null ? a : jt.pooledCache
                        }
                        function Bh(a, o) {
                            o === null ? xe(qa, qa.current) : xe(qa, o.pool)
                        }
                        function xd() {
                            var a = ml();
                            return a === null ? null : {
                                parent: Pi._currentValue,
                                pool: a
                            }
                        }
                        var Ph = Error(s(460))
                          , Wm = Error(s(474))
                          , mr = Error(s(542))
                          , Ih = {
                            then: function() {}
                        };
                        function Sd(a) {
                            return a = a.status,
                            a === "fulfilled" || a === "rejected"
                        }
                        function su() {}
                        function Ad(a, o, f) {
                            switch (f = a[f],
                            f === void 0 ? a.push(o) : f !== o && (o.then(su, su),
                            o = f),
                            o.status) {
                            case "fulfilled":
                                return o.value;
                            case "rejected":
                                throw a = o.reason,
                                w0(a),
                                a;
                            default:
                                if (typeof o.status == "string")
                                    o.then(su, su);
                                else {
                                    if (a = jt,
                                    a !== null && 100 < a.shellSuspendCounter)
                                        throw Error(s(482));
                                    a = o,
                                    a.status = "pending",
                                    a.then(function(g) {
                                        if (o.status === "pending") {
                                            var S = o;
                                            S.status = "fulfilled",
                                            S.value = g
                                        }
                                    }, function(g) {
                                        if (o.status === "pending") {
                                            var S = o;
                                            S.status = "rejected",
                                            S.reason = g
                                        }
                                    })
                                }
                                switch (o.status) {
                                case "fulfilled":
                                    return o.value;
                                case "rejected":
                                    throw a = o.reason,
                                    w0(a),
                                    a
                                }
                                throw Ya = o,
                                Ph
                            }
                        }
                        var Ya = null;
                        function jm() {
                            if (Ya === null)
                                throw Error(s(459));
                            var a = Ya;
                            return Ya = null,
                            a
                        }
                        function w0(a) {
                            if (a === Ph || a === mr)
                                throw Error(s(483))
                        }
                        var bo = !1;
                        function Qm(a) {
                            a.updateQueue = {
                                baseState: a.memoizedState,
                                firstBaseUpdate: null,
                                lastBaseUpdate: null,
                                shared: {
                                    pending: null,
                                    lanes: 0,
                                    hiddenCallbacks: null
                                },
                                callbacks: null
                            }
                        }
                        function Vt(a, o) {
                            a = a.updateQueue,
                            o.updateQueue === a && (o.updateQueue = {
                                baseState: a.baseState,
                                firstBaseUpdate: a.firstBaseUpdate,
                                lastBaseUpdate: a.lastBaseUpdate,
                                shared: a.shared,
                                callbacks: null
                            })
                        }
                        function Eo(a) {
                            return {
                                lane: a,
                                tag: 0,
                                payload: null,
                                callback: null,
                                next: null
                            }
                        }
                        function gl(a, o, f) {
                            var g = a.updateQueue;
                            if (g === null)
                                return null;
                            if (g = g.shared,
                            (Dn & 2) !== 0) {
                                var S = g.pending;
                                return S === null ? o.next = o : (o.next = S.next,
                                S.next = o),
                                g.pending = o,
                                o = Kc(a),
                                zm(a, null, f),
                                o
                            }
                            return ll(a, g, o, f),
                            Kc(a)
                        }
                        function ec(a, o, f) {
                            if (o = o.updateQueue,
                            o !== null && (o = o.shared,
                            (f & 4194048) !== 0)) {
                                var g = o.lanes;
                                g &= a.pendingLanes,
                                f |= g,
                                o.lanes = f,
                                Mt(a, f)
                            }
                        }
                        function au(a, o) {
                            var f = a.updateQueue
                              , g = a.alternate;
                            if (g !== null && (g = g.updateQueue,
                            f === g)) {
                                var S = null
                                  , w = null;
                                if (f = f.firstBaseUpdate,
                                f !== null) {
                                    do {
                                        var z = {
                                            lane: f.lane,
                                            tag: f.tag,
                                            payload: f.payload,
                                            callback: null,
                                            next: null
                                        };
                                        w === null ? S = w = z : w = w.next = z,
                                        f = f.next
                                    } while (f !== null);
                                    w === null ? S = w = o : w = w.next = o
                                } else
                                    S = w = o;
                                f = {
                                    baseState: g.baseState,
                                    firstBaseUpdate: S,
                                    lastBaseUpdate: w,
                                    shared: g.shared,
                                    callbacks: g.callbacks
                                },
                                a.updateQueue = f;
                                return
                            }
                            a = f.lastBaseUpdate,
                            a === null ? f.firstBaseUpdate = o : a.next = o,
                            f.lastBaseUpdate = o
                        }
                        var Zm = !1;
                        function Lh() {
                            if (Zm) {
                                var a = iu;
                                if (a !== null)
                                    throw a
                            }
                        }
                        function ru(a, o, f, g) {
                            Zm = !1;
                            var S = a.updateQueue;
                            bo = !1;
                            var w = S.firstBaseUpdate
                              , z = S.lastBaseUpdate
                              , Y = S.shared.pending;
                            if (Y !== null) {
                                S.shared.pending = null;
                                var re = Y
                                  , Ae = re.next;
                                re.next = null,
                                z === null ? w = Ae : z.next = Ae,
                                z = re;
                                var qe = a.alternate;
                                qe !== null && (qe = qe.updateQueue,
                                Y = qe.lastBaseUpdate,
                                Y !== z && (Y === null ? qe.firstBaseUpdate = Ae : Y.next = Ae,
                                qe.lastBaseUpdate = re))
                            }
                            if (w !== null) {
                                var je = S.baseState;
                                z = 0,
                                qe = Ae = re = null,
                                Y = w;
                                do {
                                    var we = Y.lane & -536870913
                                      , De = we !== Y.lane;
                                    if (De ? (Bt & we) === we : (g & we) === we) {
                                        we !== 0 && we === Kt && (Zm = !0),
                                        qe !== null && (qe = qe.next = {
                                            lane: 0,
                                            tag: Y.tag,
                                            payload: Y.payload,
                                            callback: null,
                                            next: null
                                        });
                                        e: {
                                            var qt = a
                                              , Ft = Y;
                                            we = o;
                                            var ei = f;
                                            switch (Ft.tag) {
                                            case 1:
                                                if (qt = Ft.payload,
                                                typeof qt == "function") {
                                                    je = qt.call(ei, je, we);
                                                    break e
                                                }
                                                je = qt;
                                                break e;
                                            case 3:
                                                qt.flags = qt.flags & -65537 | 128;
                                            case 0:
                                                if (qt = Ft.payload,
                                                we = typeof qt == "function" ? qt.call(ei, je, we) : qt,
                                                we == null)
                                                    break e;
                                                je = v({}, je, we);
                                                break e;
                                            case 2:
                                                bo = !0
                                            }
                                        }
                                        we = Y.callback,
                                        we !== null && (a.flags |= 64,
                                        De && (a.flags |= 8192),
                                        De = S.callbacks,
                                        De === null ? S.callbacks = [we] : De.push(we))
                                    } else
                                        De = {
                                            lane: we,
                                            tag: Y.tag,
                                            payload: Y.payload,
                                            callback: Y.callback,
                                            next: null
                                        },
                                        qe === null ? (Ae = qe = De,
                                        re = je) : qe = qe.next = De,
                                        z |= we;
                                    if (Y = Y.next,
                                    Y === null) {
                                        if (Y = S.shared.pending,
                                        Y === null)
                                            break;
                                        De = Y,
                                        Y = De.next,
                                        De.next = null,
                                        S.lastBaseUpdate = De,
                                        S.shared.pending = null
                                    }
                                } while (!0);
                                qe === null && (re = je),
                                S.baseState = re,
                                S.firstBaseUpdate = Ae,
                                S.lastBaseUpdate = qe,
                                w === null && (S.shared.lanes = 0),
                                Tr |= z,
                                a.lanes = z,
                                a.memoizedState = je
                            }
                        }
                        function ou(a, o) {
                            if (typeof a != "function")
                                throw Error(s(191, a));
                            a.call(o)
                        }
                        function C0(a, o) {
                            var f = a.callbacks;
                            if (f !== null)
                                for (a.callbacks = null,
                                a = 0; a < f.length; a++)
                                    ou(f[a], o)
                        }
                        var lu = J(null)
                          , Td = J(0);
                        function R0(a, o) {
                            a = Ja,
                            xe(Td, a),
                            xe(lu, o),
                            Ja = a | o.baseLanes
                        }
                        function Km() {
                            xe(Td, Ja),
                            xe(lu, lu.current)
                        }
                        function zh() {
                            Ja = Td.current,
                            ze(lu),
                            ze(Td)
                        }
                        var wo = 0
                          , Jt = null
                          , In = null
                          , Ii = null
                          , Md = !1
                          , vl = !1
                          , zs = !1
                          , Xi = 0
                          , Wa = 0
                          , ms = null
                          , D0 = 0;
                        function Ei() {
                            throw Error(s(321))
                        }
                        function ws(a, o) {
                            if (o === null)
                                return !1;
                            for (var f = 0; f < o.length && f < a.length; f++)
                                if (!Ks(a[f], o[f]))
                                    return !1;
                            return !0
                        }
                        function Co(a, o, f, g, S, w) {
                            return wo = w,
                            Jt = o,
                            o.memoizedState = null,
                            o.updateQueue = null,
                            o.lanes = 0,
                            V.H = a === null || a.memoizedState === null ? Ud : dg,
                            zs = !1,
                            w = f(g, S),
                            zs = !1,
                            vl && (w = N0(o, f, g, S)),
                            O0(a),
                            w
                        }
                        function O0(a) {
                            V.H = Vh;
                            var o = In !== null && In.next !== null;
                            if (wo = 0,
                            Ii = In = Jt = null,
                            Md = !1,
                            Wa = 0,
                            ms = null,
                            o)
                                throw Error(s(300));
                            a === null || ts || (a = a.dependencies,
                            a !== null && Dh(a) && (ts = !0))
                        }
                        function N0(a, o, f, g) {
                            Jt = a;
                            var S = 0;
                            do {
                                if (vl && (ms = null),
                                Wa = 0,
                                vl = !1,
                                25 <= S)
                                    throw Error(s(301));
                                if (S += 1,
                                Ii = In = null,
                                a.updateQueue != null) {
                                    var w = a.updateQueue;
                                    w.lastEffect = null,
                                    w.events = null,
                                    w.stores = null,
                                    w.memoCache != null && (w.memoCache.index = 0)
                                }
                                V.H = sy,
                                w = o(f, g)
                            } while (vl);
                            return w
                        }
                        function CS() {
                            var a = V.H
                              , o = a.useState()[0];
                            return o = typeof o.then == "function" ? gr(o) : o,
                            a = a.useState()[0],
                            (In !== null ? In.memoizedState : null) !== a && (Jt.flags |= 1024),
                            o
                        }
                        function Jm() {
                            var a = Xi !== 0;
                            return Xi = 0,
                            a
                        }
                        function bd(a, o, f) {
                            o.updateQueue = a.updateQueue,
                            o.flags &= -2053,
                            a.lanes &= ~f
                        }
                        function $m(a) {
                            if (Md) {
                                for (a = a.memoizedState; a !== null; ) {
                                    var o = a.queue;
                                    o !== null && (o.pending = null),
                                    a = a.next
                                }
                                Md = !1
                            }
                            wo = 0,
                            Ii = In = Jt = null,
                            vl = !1,
                            Wa = Xi = 0,
                            ms = null
                        }
                        function Fs() {
                            var a = {
                                memoizedState: null,
                                baseState: null,
                                baseQueue: null,
                                queue: null,
                                next: null
                            };
                            return Ii === null ? Jt.memoizedState = Ii = a : Ii = Ii.next = a,
                            Ii
                        }
                        function Li() {
                            if (In === null) {
                                var a = Jt.alternate;
                                a = a !== null ? a.memoizedState : null
                            } else
                                a = In.next;
                            var o = Ii === null ? Jt.memoizedState : Ii.next;
                            if (o !== null)
                                Ii = o,
                                In = a;
                            else {
                                if (a === null)
                                    throw Jt.alternate === null ? Error(s(467)) : Error(s(310));
                                In = a,
                                a = {
                                    memoizedState: In.memoizedState,
                                    baseState: In.baseState,
                                    baseQueue: In.baseQueue,
                                    queue: In.queue,
                                    next: null
                                },
                                Ii === null ? Jt.memoizedState = Ii = a : Ii = Ii.next = a
                            }
                            return Ii
                        }
                        function yl() {
                            return {
                                lastEffect: null,
                                events: null,
                                stores: null,
                                memoCache: null
                            }
                        }
                        function gr(a) {
                            var o = Wa;
                            return Wa += 1,
                            ms === null && (ms = []),
                            a = Ad(ms, a, o),
                            o = Jt,
                            (Ii === null ? o.memoizedState : Ii.next) === null && (o = o.alternate,
                            V.H = o === null || o.memoizedState === null ? Ud : dg),
                            a
                        }
                        function Ed(a) {
                            if (a !== null && typeof a == "object") {
                                if (typeof a.then == "function")
                                    return gr(a);
                                if (a.$$typeof === O)
                                    return vi(a)
                            }
                            throw Error(s(438, String(a)))
                        }
                        function eg(a) {
                            var o = null
                              , f = Jt.updateQueue;
                            if (f !== null && (o = f.memoCache),
                            o == null) {
                                var g = Jt.alternate;
                                g !== null && (g = g.updateQueue,
                                g !== null && (g = g.memoCache,
                                g != null && (o = {
                                    data: g.data.map(function(S) {
                                        return S.slice()
                                    }),
                                    index: 0
                                })))
                            }
                            if (o ??= {
                                data: [],
                                index: 0
                            },
                            f === null && (f = yl(),
                            Jt.updateQueue = f),
                            f.memoCache = o,
                            f = o.data[o.index],
                            f === void 0)
                                for (f = o.data[o.index] = Array(a),
                                g = 0; g < a; g++)
                                    f[g] = H;
                            return o.index++,
                            f
                        }
                        function Ro(a, o) {
                            return typeof o == "function" ? o(a) : o
                        }
                        function _l(a) {
                            var o = Li();
                            return tg(o, In, a)
                        }
                        function tg(a, o, f) {
                            var g = a.queue;
                            if (g === null)
                                throw Error(s(311));
                            g.lastRenderedReducer = f;
                            var S = a.baseQueue
                              , w = g.pending;
                            if (w !== null) {
                                if (S !== null) {
                                    var z = S.next;
                                    S.next = w.next,
                                    w.next = z
                                }
                                o.baseQueue = S = w,
                                g.pending = null
                            }
                            if (w = a.baseState,
                            S === null)
                                a.memoizedState = w;
                            else {
                                o = S.next;
                                var Y = z = null
                                  , re = null
                                  , Ae = o
                                  , qe = !1;
                                do {
                                    var je = Ae.lane & -536870913;
                                    if (je !== Ae.lane ? (Bt & je) === je : (wo & je) === je) {
                                        var we = Ae.revertLane;
                                        if (we === 0)
                                            re !== null && (re = re.next = {
                                                lane: 0,
                                                revertLane: 0,
                                                action: Ae.action,
                                                hasEagerState: Ae.hasEagerState,
                                                eagerState: Ae.eagerState,
                                                next: null
                                            }),
                                            je === Kt && (qe = !0);
                                        else if ((wo & we) === we) {
                                            Ae = Ae.next,
                                            we === Kt && (qe = !0);
                                            continue
                                        } else
                                            je = {
                                                lane: 0,
                                                revertLane: Ae.revertLane,
                                                action: Ae.action,
                                                hasEagerState: Ae.hasEagerState,
                                                eagerState: Ae.eagerState,
                                                next: null
                                            },
                                            re === null ? (Y = re = je,
                                            z = w) : re = re.next = je,
                                            Jt.lanes |= we,
                                            Tr |= we;
                                        je = Ae.action,
                                        zs && f(w, je),
                                        w = Ae.hasEagerState ? Ae.eagerState : f(w, je)
                                    } else
                                        we = {
                                            lane: je,
                                            revertLane: Ae.revertLane,
                                            action: Ae.action,
                                            hasEagerState: Ae.hasEagerState,
                                            eagerState: Ae.eagerState,
                                            next: null
                                        },
                                        re === null ? (Y = re = we,
                                        z = w) : re = re.next = we,
                                        Jt.lanes |= je,
                                        Tr |= je;
                                    Ae = Ae.next
                                } while (Ae !== null && Ae !== o);
                                if (re === null ? z = w : re.next = Y,
                                !Ks(w, a.memoizedState) && (ts = !0,
                                qe && (f = iu,
                                f !== null)))
                                    throw f;
                                a.memoizedState = w,
                                a.baseState = z,
                                a.baseQueue = re,
                                g.lastRenderedState = w
                            }
                            return S === null && (g.lanes = 0),
                            [a.memoizedState, g.dispatch]
                        }
                        function ng(a) {
                            var o = Li()
                              , f = o.queue;
                            if (f === null)
                                throw Error(s(311));
                            f.lastRenderedReducer = a;
                            var g = f.dispatch
                              , S = f.pending
                              , w = o.memoizedState;
                            if (S !== null) {
                                f.pending = null;
                                var z = S = S.next;
                                do
                                    w = a(w, z.action),
                                    z = z.next;
                                while (z !== S);
                                Ks(w, o.memoizedState) || (ts = !0),
                                o.memoizedState = w,
                                o.baseQueue === null && (o.baseState = w),
                                f.lastRenderedState = w
                            }
                            return [w, g]
                        }
                        function U0(a, o, f) {
                            var g = Jt
                              , S = Li()
                              , w = bn;
                            if (w) {
                                if (f === void 0)
                                    throw Error(s(407));
                                f = f()
                            } else
                                f = o();
                            var z = !Ks((In || S).memoizedState, f);
                            z && (S.memoizedState = f,
                            ts = !0),
                            S = S.queue;
                            var Y = P0.bind(null, g, S, a);
                            if (hu(2048, 8, Y, [a]),
                            S.getSnapshot !== o || z || Ii !== null && Ii.memoizedState.tag & 1) {
                                if (g.flags |= 2048,
                                uu(9, Fh(), B0.bind(null, g, S, f, o), null),
                                jt === null)
                                    throw Error(s(349));
                                w || (wo & 124) !== 0 || cu(g, o, f)
                            }
                            return f
                        }
                        function cu(a, o, f) {
                            a.flags |= 16384,
                            a = {
                                getSnapshot: o,
                                value: f
                            },
                            o = Jt.updateQueue,
                            o === null ? (o = yl(),
                            Jt.updateQueue = o,
                            o.stores = [a]) : (f = o.stores,
                            f === null ? o.stores = [a] : f.push(a))
                        }
                        function B0(a, o, f, g) {
                            o.value = f,
                            o.getSnapshot = g,
                            I0(o) && L0(a)
                        }
                        function P0(a, o, f) {
                            return f(function() {
                                I0(o) && L0(a)
                            })
                        }
                        function I0(a) {
                            var o = a.getSnapshot;
                            a = a.value;
                            try {
                                var f = o();
                                return !Ks(a, f)
                            } catch {
                                return !0
                            }
                        }
                        function L0(a) {
                            var o = So(a, 2);
                            o !== null && Gs(o, a, 2)
                        }
                        function ig(a) {
                            var o = Fs();
                            if (typeof a == "function") {
                                var f = a;
                                if (a = f(),
                                zs) {
                                    ct(!0);
                                    try {
                                        f()
                                    } finally {
                                        ct(!1)
                                    }
                                }
                            }
                            return o.memoizedState = o.baseState = a,
                            o.queue = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: Ro,
                                lastRenderedState: a
                            },
                            o
                        }
                        function z0(a, o, f, g) {
                            return a.baseState = f,
                            tg(a, In, typeof g == "function" ? g : Ro)
                        }
                        function RS(a, o, f, g, S) {
                            if (Nd(a))
                                throw Error(s(485));
                            if (a = o.action,
                            a !== null) {
                                var w = {
                                    payload: S,
                                    action: a,
                                    next: null,
                                    isTransition: !0,
                                    status: "pending",
                                    value: null,
                                    reason: null,
                                    listeners: [],
                                    then: function(z) {
                                        w.listeners.push(z)
                                    }
                                };
                                V.T !== null ? f(!0) : w.isTransition = !1,
                                g(w),
                                f = o.pending,
                                f === null ? (w.next = o.pending = w,
                                F0(o, w)) : (w.next = f.next,
                                o.pending = f.next = w)
                            }
                        }
                        function F0(a, o) {
                            var f = o.action
                              , g = o.payload
                              , S = a.state;
                            if (o.isTransition) {
                                var w = V.T
                                  , z = {};
                                V.T = z;
                                try {
                                    var Y = f(S, g)
                                      , re = V.S;
                                    re !== null && re(z, Y),
                                    H0(a, o, Y)
                                } catch (Ae) {
                                    sg(a, o, Ae)
                                } finally {
                                    V.T = w
                                }
                            } else
                                try {
                                    w = f(S, g),
                                    H0(a, o, w)
                                } catch (Ae) {
                                    sg(a, o, Ae)
                                }
                        }
                        function H0(a, o, f) {
                            f !== null && typeof f == "object" && typeof f.then == "function" ? f.then(function(g) {
                                V0(a, o, g)
                            }, function(g) {
                                return sg(a, o, g)
                            }) : V0(a, o, f)
                        }
                        function V0(a, o, f) {
                            o.status = "fulfilled",
                            o.value = f,
                            G0(o),
                            a.state = f,
                            o = a.pending,
                            o !== null && (f = o.next,
                            f === o ? a.pending = null : (f = f.next,
                            o.next = f,
                            F0(a, f)))
                        }
                        function sg(a, o, f) {
                            var g = a.pending;
                            if (a.pending = null,
                            g !== null) {
                                g = g.next;
                                do
                                    o.status = "rejected",
                                    o.reason = f,
                                    G0(o),
                                    o = o.next;
                                while (o !== g)
                            }
                            a.action = null
                        }
                        function G0(a) {
                            a = a.listeners;
                            for (var o = 0; o < a.length; o++)
                                (0,
                                a[o])()
                        }
                        function ag(a, o) {
                            return o
                        }
                        function k0(a, o) {
                            if (bn) {
                                var f = jt.formState;
                                if (f !== null) {
                                    e: {
                                        var g = Jt;
                                        if (bn) {
                                            if (di) {
                                                t: {
                                                    for (var S = di, w = _a; S.nodeType !== 8; ) {
                                                        if (!w) {
                                                            S = null;
                                                            break t
                                                        }
                                                        if (S = Io(S.nextSibling),
                                                        S === null) {
                                                            S = null;
                                                            break t
                                                        }
                                                    }
                                                    w = S.data,
                                                    S = w === "F!" || w === "F" ? S : null
                                                }
                                                if (S) {
                                                    di = Io(S.nextSibling),
                                                    g = S.data === "F!";
                                                    break e
                                                }
                                            }
                                            fl(g)
                                        }
                                        g = !1
                                    }
                                    g && (o = f[0])
                                }
                            }
                            return f = Fs(),
                            f.memoizedState = f.baseState = o,
                            g = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: ag,
                                lastRenderedState: o
                            },
                            f.queue = g,
                            f = ny.bind(null, Jt, g),
                            g.dispatch = f,
                            g = ig(!1),
                            w = Od.bind(null, Jt, !1, g.queue),
                            g = Fs(),
                            S = {
                                state: o,
                                dispatch: null,
                                action: a,
                                pending: null
                            },
                            g.queue = S,
                            f = RS.bind(null, Jt, S, w, f),
                            S.dispatch = f,
                            g.memoizedState = a,
                            [o, f, !1]
                        }
                        function X0(a) {
                            var o = Li();
                            return q0(o, In, a)
                        }
                        function q0(a, o, f) {
                            if (o = tg(a, o, ag)[0],
                            a = _l(Ro)[0],
                            typeof o == "object" && o !== null && typeof o.then == "function")
                                try {
                                    var g = gr(o)
                                } catch (z) {
                                    throw z === Ph ? mr : z
                                }
                            else
                                g = o;
                            o = Li();
                            var S = o.queue
                              , w = S.dispatch;
                            return f !== o.memoizedState && (Jt.flags |= 2048,
                            uu(9, Fh(), DS.bind(null, S, f), null)),
                            [g, w, a]
                        }
                        function DS(a, o) {
                            a.action = o
                        }
                        function Y0(a) {
                            var o = Li()
                              , f = In;
                            if (f !== null)
                                return q0(o, f, a);
                            Li(),
                            o = o.memoizedState,
                            f = Li();
                            var g = f.queue.dispatch;
                            return f.memoizedState = a,
                            [o, g, !1]
                        }
                        function uu(a, o, f, g) {
                            return a = {
                                tag: a,
                                create: f,
                                deps: g,
                                inst: o,
                                next: null
                            },
                            o = Jt.updateQueue,
                            o === null && (o = yl(),
                            Jt.updateQueue = o),
                            f = o.lastEffect,
                            f === null ? o.lastEffect = a.next = a : (g = f.next,
                            f.next = a,
                            a.next = g,
                            o.lastEffect = a),
                            a
                        }
                        function Fh() {
                            return {
                                destroy: void 0,
                                resource: void 0
                            }
                        }
                        function rg() {
                            return Li().memoizedState
                        }
                        function wd(a, o, f, g) {
                            var S = Fs();
                            g = g === void 0 ? null : g,
                            Jt.flags |= a,
                            S.memoizedState = uu(1 | o, Fh(), f, g)
                        }
                        function hu(a, o, f, g) {
                            var S = Li();
                            g = g === void 0 ? null : g;
                            var w = S.memoizedState.inst;
                            In !== null && g !== null && ws(g, In.memoizedState.deps) ? S.memoizedState = uu(o, w, f, g) : (Jt.flags |= a,
                            S.memoizedState = uu(1 | o, w, f, g))
                        }
                        function og(a, o) {
                            wd(8390656, 8, a, o)
                        }
                        function lg(a, o) {
                            hu(2048, 8, a, o)
                        }
                        function Cd(a, o) {
                            return hu(4, 2, a, o)
                        }
                        function Rd(a, o) {
                            return hu(4, 4, a, o)
                        }
                        function W0(a, o) {
                            if (typeof o == "function") {
                                a = a();
                                var f = o(a);
                                return function() {
                                    typeof f == "function" ? f() : o(null)
                                }
                            }
                            if (o != null)
                                return a = a(),
                                o.current = a,
                                function() {
                                    o.current = null
                                }
                        }
                        function j0(a, o, f) {
                            f = f != null ? f.concat([a]) : null,
                            hu(4, 4, W0.bind(null, o, a), f)
                        }
                        function cg() {}
                        function Q0(a, o) {
                            var f = Li();
                            o = o === void 0 ? null : o;
                            var g = f.memoizedState;
                            return o !== null && ws(o, g[1]) ? g[0] : (f.memoizedState = [a, o],
                            a)
                        }
                        function ug(a, o) {
                            var f = Li();
                            o = o === void 0 ? null : o;
                            var g = f.memoizedState;
                            if (o !== null && ws(o, g[1]))
                                return g[0];
                            if (g = a(),
                            zs) {
                                ct(!0);
                                try {
                                    a()
                                } finally {
                                    ct(!1)
                                }
                            }
                            return f.memoizedState = [g, o],
                            g
                        }
                        function Dd(a, o, f) {
                            return f === void 0 || (wo & 1073741824) !== 0 ? a.memoizedState = o : (a.memoizedState = f,
                            a = Xd(),
                            Jt.lanes |= a,
                            Tr |= a,
                            f)
                        }
                        function Z0(a, o, f, g) {
                            return Ks(f, o) ? f : lu.current !== null ? (a = Dd(a, f, g),
                            Ks(a, o) || (ts = !0),
                            a) : (wo & 42) === 0 ? (ts = !0,
                            a.memoizedState = f) : (a = Xd(),
                            Jt.lanes |= a,
                            Tr |= a,
                            o)
                        }
                        function K0(a, o, f, g, S) {
                            var w = q.p;
                            q.p = w !== 0 && 8 > w ? w : 8;
                            var z = V.T
                              , Y = {};
                            V.T = Y,
                            Od(a, !1, o, f);
                            try {
                                var re = S()
                                  , Ae = V.S;
                                if (Ae !== null && Ae(Y, re),
                                re !== null && typeof re == "object" && typeof re.then == "function") {
                                    var qe = wS(re, g);
                                    Hh(a, o, qe, Ri(a))
                                } else
                                    Hh(a, o, g, Ri(a))
                            } catch (je) {
                                Hh(a, o, {
                                    then: function() {},
                                    status: "rejected",
                                    reason: je
                                }, Ri())
                            } finally {
                                q.p = w,
                                V.T = z
                            }
                        }
                        function OS() {}
                        function hg(a, o, f, g) {
                            if (a.tag !== 5)
                                throw Error(s(476));
                            var S = J0(a).queue;
                            K0(a, S, o, ee, f === null ? OS : function() {
                                return $0(a),
                                f(g)
                            }
                            )
                        }
                        function J0(a) {
                            var o = a.memoizedState;
                            if (o !== null)
                                return o;
                            o = {
                                memoizedState: ee,
                                baseState: ee,
                                baseQueue: null,
                                queue: {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: Ro,
                                    lastRenderedState: ee
                                },
                                next: null
                            };
                            var f = {};
                            return o.next = {
                                memoizedState: f,
                                baseState: f,
                                baseQueue: null,
                                queue: {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: Ro,
                                    lastRenderedState: f
                                },
                                next: null
                            },
                            a.memoizedState = o,
                            a = a.alternate,
                            a !== null && (a.memoizedState = o),
                            o
                        }
                        function $0(a) {
                            var o = J0(a).next.queue;
                            Hh(a, o, {}, Ri())
                        }
                        function fg() {
                            return vi(Eg)
                        }
                        function ey() {
                            return Li().memoizedState
                        }
                        function ty() {
                            return Li().memoizedState
                        }
                        function NS(a) {
                            for (var o = a.return; o !== null; ) {
                                switch (o.tag) {
                                case 24:
                                case 3:
                                    var f = Ri();
                                    a = Eo(f);
                                    var g = gl(o, a, f);
                                    g !== null && (Gs(g, o, f),
                                    ec(g, o, f)),
                                    o = {
                                        cache: yd()
                                    },
                                    a.payload = o;
                                    return
                                }
                                o = o.return
                            }
                        }
                        function US(a, o, f) {
                            var g = Ri();
                            f = {
                                lane: g,
                                revertLane: 0,
                                action: f,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            },
                            Nd(a) ? iy(o, f) : (f = dd(a, o, f, g),
                            f !== null && (Gs(f, a, g),
                            Sa(f, o, g)))
                        }
                        function ny(a, o, f) {
                            var g = Ri();
                            Hh(a, o, f, g)
                        }
                        function Hh(a, o, f, g) {
                            var S = {
                                lane: g,
                                revertLane: 0,
                                action: f,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            };
                            if (Nd(a))
                                iy(o, S);
                            else {
                                var w = a.alternate;
                                if (a.lanes === 0 && (w === null || w.lanes === 0) && (w = o.lastRenderedReducer,
                                w !== null))
                                    try {
                                        var z = o.lastRenderedState
                                          , Y = w(z, f);
                                        if (S.hasEagerState = !0,
                                        S.eagerState = Y,
                                        Ks(Y, z))
                                            return ll(a, o, S, 0),
                                            jt === null && bh(),
                                            !1
                                    } catch {}
                                if (f = dd(a, o, S, g),
                                f !== null)
                                    return Gs(f, a, g),
                                    Sa(f, o, g),
                                    !0
                            }
                            return !1
                        }
                        function Od(a, o, f, g) {
                            if (g = {
                                lane: 2,
                                revertLane: LS(),
                                action: g,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            },
                            Nd(a)) {
                                if (o)
                                    throw Error(s(479))
                            } else
                                o = dd(a, f, g, 2),
                                o !== null && Gs(o, a, 2)
                        }
                        function Nd(a) {
                            var o = a.alternate;
                            return a === Jt || o !== null && o === Jt
                        }
                        function iy(a, o) {
                            vl = Md = !0;
                            var f = a.pending;
                            f === null ? o.next = o : (o.next = f.next,
                            f.next = o),
                            a.pending = o
                        }
                        function Sa(a, o, f) {
                            if ((f & 4194048) !== 0) {
                                var g = o.lanes;
                                g &= a.pendingLanes,
                                f |= g,
                                o.lanes = f,
                                Mt(a, f)
                            }
                        }
                        var Vh = {
                            readContext: vi,
                            use: Ed,
                            useCallback: Ei,
                            useContext: Ei,
                            useEffect: Ei,
                            useImperativeHandle: Ei,
                            useLayoutEffect: Ei,
                            useInsertionEffect: Ei,
                            useMemo: Ei,
                            useReducer: Ei,
                            useRef: Ei,
                            useState: Ei,
                            useDebugValue: Ei,
                            useDeferredValue: Ei,
                            useTransition: Ei,
                            useSyncExternalStore: Ei,
                            useId: Ei,
                            useHostTransitionStatus: Ei,
                            useFormState: Ei,
                            useActionState: Ei,
                            useOptimistic: Ei,
                            useMemoCache: Ei,
                            useCacheRefresh: Ei
                        }
                          , Ud = {
                            readContext: vi,
                            use: Ed,
                            useCallback: function(a, o) {
                                return Fs().memoizedState = [a, o === void 0 ? null : o],
                                a
                            },
                            useContext: vi,
                            useEffect: og,
                            useImperativeHandle: function(a, o, f) {
                                f = f != null ? f.concat([a]) : null,
                                wd(4194308, 4, W0.bind(null, o, a), f)
                            },
                            useLayoutEffect: function(a, o) {
                                return wd(4194308, 4, a, o)
                            },
                            useInsertionEffect: function(a, o) {
                                wd(4, 2, a, o)
                            },
                            useMemo: function(a, o) {
                                var f = Fs();
                                o = o === void 0 ? null : o;
                                var g = a();
                                if (zs) {
                                    ct(!0);
                                    try {
                                        a()
                                    } finally {
                                        ct(!1)
                                    }
                                }
                                return f.memoizedState = [g, o],
                                g
                            },
                            useReducer: function(a, o, f) {
                                var g = Fs();
                                if (f !== void 0) {
                                    var S = f(o);
                                    if (zs) {
                                        ct(!0);
                                        try {
                                            f(o)
                                        } finally {
                                            ct(!1)
                                        }
                                    }
                                } else
                                    S = o;
                                return g.memoizedState = g.baseState = S,
                                a = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: a,
                                    lastRenderedState: S
                                },
                                g.queue = a,
                                a = a.dispatch = US.bind(null, Jt, a),
                                [g.memoizedState, a]
                            },
                            useRef: function(a) {
                                var o = Fs();
                                return a = {
                                    current: a
                                },
                                o.memoizedState = a
                            },
                            useState: function(a) {
                                a = ig(a);
                                var o = a.queue
                                  , f = ny.bind(null, Jt, o);
                                return o.dispatch = f,
                                [a.memoizedState, f]
                            },
                            useDebugValue: cg,
                            useDeferredValue: function(a, o) {
                                var f = Fs();
                                return Dd(f, a, o)
                            },
                            useTransition: function() {
                                var a = ig(!1);
                                return a = K0.bind(null, Jt, a.queue, !0, !1),
                                Fs().memoizedState = a,
                                [!1, a]
                            },
                            useSyncExternalStore: function(a, o, f) {
                                var g = Jt
                                  , S = Fs();
                                if (bn) {
                                    if (f === void 0)
                                        throw Error(s(407));
                                    f = f()
                                } else {
                                    if (f = o(),
                                    jt === null)
                                        throw Error(s(349));
                                    (Bt & 124) !== 0 || cu(g, o, f)
                                }
                                S.memoizedState = f;
                                var w = {
                                    value: f,
                                    getSnapshot: o
                                };
                                return S.queue = w,
                                og(P0.bind(null, g, w, a), [a]),
                                g.flags |= 2048,
                                uu(9, Fh(), B0.bind(null, g, w, f, o), null),
                                f
                            },
                            useId: function() {
                                var a = Fs()
                                  , o = jt.identifierPrefix;
                                if (bn) {
                                    var f = Vr
                                      , g = Hr;
                                    f = (g & ~(1 << 32 - Ke(g) - 1)).toString(32) + f,
                                    o = "\xAB" + o + "R" + f,
                                    f = Xi++,
                                    0 < f && (o += "H" + f.toString(32)),
                                    o += "\xBB"
                                } else
                                    f = D0++,
                                    o = "\xAB" + o + "r" + f.toString(32) + "\xBB";
                                return a.memoizedState = o
                            },
                            useHostTransitionStatus: fg,
                            useFormState: k0,
                            useActionState: k0,
                            useOptimistic: function(a) {
                                var o = Fs();
                                o.memoizedState = o.baseState = a;
                                var f = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: null,
                                    lastRenderedState: null
                                };
                                return o.queue = f,
                                o = Od.bind(null, Jt, !0, f),
                                f.dispatch = o,
                                [a, o]
                            },
                            useMemoCache: eg,
                            useCacheRefresh: function() {
                                return Fs().memoizedState = NS.bind(null, Jt)
                            }
                        }
                          , dg = {
                            readContext: vi,
                            use: Ed,
                            useCallback: Q0,
                            useContext: vi,
                            useEffect: lg,
                            useImperativeHandle: j0,
                            useInsertionEffect: Cd,
                            useLayoutEffect: Rd,
                            useMemo: ug,
                            useReducer: _l,
                            useRef: rg,
                            useState: function() {
                                return _l(Ro)
                            },
                            useDebugValue: cg,
                            useDeferredValue: function(a, o) {
                                var f = Li();
                                return Z0(f, In.memoizedState, a, o)
                            },
                            useTransition: function() {
                                var a = _l(Ro)[0]
                                  , o = Li().memoizedState;
                                return [typeof a == "boolean" ? a : gr(a), o]
                            },
                            useSyncExternalStore: U0,
                            useId: ey,
                            useHostTransitionStatus: fg,
                            useFormState: X0,
                            useActionState: X0,
                            useOptimistic: function(a, o) {
                                var f = Li();
                                return z0(f, In, a, o)
                            },
                            useMemoCache: eg,
                            useCacheRefresh: ty
                        }
                          , sy = {
                            readContext: vi,
                            use: Ed,
                            useCallback: Q0,
                            useContext: vi,
                            useEffect: lg,
                            useImperativeHandle: j0,
                            useInsertionEffect: Cd,
                            useLayoutEffect: Rd,
                            useMemo: ug,
                            useReducer: ng,
                            useRef: rg,
                            useState: function() {
                                return ng(Ro)
                            },
                            useDebugValue: cg,
                            useDeferredValue: function(a, o) {
                                var f = Li();
                                return In === null ? Dd(f, a, o) : Z0(f, In.memoizedState, a, o)
                            },
                            useTransition: function() {
                                var a = ng(Ro)[0]
                                  , o = Li().memoizedState;
                                return [typeof a == "boolean" ? a : gr(a), o]
                            },
                            useSyncExternalStore: U0,
                            useId: ey,
                            useHostTransitionStatus: fg,
                            useFormState: Y0,
                            useActionState: Y0,
                            useOptimistic: function(a, o) {
                                var f = Li();
                                return In !== null ? z0(f, In, a, o) : (f.baseState = a,
                                [a, f.queue.dispatch])
                            },
                            useMemoCache: eg,
                            useCacheRefresh: ty
                        }
                          , tc = null
                          , Gh = 0;
                        function kh(a) {
                            var o = Gh;
                            return Gh += 1,
                            tc === null && (tc = []),
                            Ad(tc, a, o)
                        }
                        function fu(a, o) {
                            o = o.props.ref,
                            a.ref = o !== void 0 ? o : null
                        }
                        function Bd(a, o) {
                            throw o.$$typeof === _ ? Error(s(525)) : (a = Object.prototype.toString.call(o),
                            Error(s(31, a === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : a)))
                        }
                        function ay(a) {
                            var o = a._init;
                            return o(a._payload)
                        }
                        function ry(a) {
                            function o(ge, fe) {
                                if (a) {
                                    var _e = ge.deletions;
                                    _e === null ? (ge.deletions = [fe],
                                    ge.flags |= 16) : _e.push(fe)
                                }
                            }
                            function f(ge, fe) {
                                if (!a)
                                    return null;
                                for (; fe !== null; )
                                    o(ge, fe),
                                    fe = fe.sibling;
                                return null
                            }
                            function g(ge) {
                                for (var fe = new Map; ge !== null; )
                                    ge.key !== null ? fe.set(ge.key, ge) : fe.set(ge.index, ge),
                                    ge = ge.sibling;
                                return fe
                            }
                            function S(ge, fe) {
                                return ge = bi(ge, fe),
                                ge.index = 0,
                                ge.sibling = null,
                                ge
                            }
                            function w(ge, fe, _e) {
                                return ge.index = _e,
                                a ? (_e = ge.alternate,
                                _e !== null ? (_e = _e.index,
                                _e < fe ? (ge.flags |= 67108866,
                                fe) : _e) : (ge.flags |= 67108866,
                                fe)) : (ge.flags |= 1048576,
                                fe)
                            }
                            function z(ge) {
                                return a && ge.alternate === null && (ge.flags |= 67108866),
                                ge
                            }
                            function Y(ge, fe, _e, We) {
                                return fe === null || fe.tag !== 6 ? (fe = wh(_e, ge.mode, We),
                                fe.return = ge,
                                fe) : (fe = S(fe, _e),
                                fe.return = ge,
                                fe)
                            }
                            function re(ge, fe, _e, We) {
                                var St = _e.type;
                                return St === E ? qe(ge, fe, _e.props.children, We, _e.key) : fe !== null && (fe.elementType === St || typeof St == "object" && St !== null && St.$$typeof === P && ay(St) === fe.type) ? (fe = S(fe, _e.props),
                                fu(fe, _e),
                                fe.return = ge,
                                fe) : (fe = es(_e.type, _e.key, _e.props, null, ge.mode, We),
                                fu(fe, _e),
                                fe.return = ge,
                                fe)
                            }
                            function Ae(ge, fe, _e, We) {
                                return fe === null || fe.tag !== 4 || fe.stateNode.containerInfo !== _e.containerInfo || fe.stateNode.implementation !== _e.implementation ? (fe = pd(_e, ge.mode, We),
                                fe.return = ge,
                                fe) : (fe = S(fe, _e.children || []),
                                fe.return = ge,
                                fe)
                            }
                            function qe(ge, fe, _e, We, St) {
                                return fe === null || fe.tag !== 7 ? (fe = ul(_e, ge.mode, We, St),
                                fe.return = ge,
                                fe) : (fe = S(fe, _e),
                                fe.return = ge,
                                fe)
                            }
                            function je(ge, fe, _e) {
                                if (typeof fe == "string" && fe !== "" || typeof fe == "number" || typeof fe == "bigint")
                                    return fe = wh("" + fe, ge.mode, _e),
                                    fe.return = ge,
                                    fe;
                                if (typeof fe == "object" && fe !== null) {
                                    switch (fe.$$typeof) {
                                    case x:
                                        return _e = es(fe.type, fe.key, fe.props, null, ge.mode, _e),
                                        fu(_e, fe),
                                        _e.return = ge,
                                        _e;
                                    case b:
                                        return fe = pd(fe, ge.mode, _e),
                                        fe.return = ge,
                                        fe;
                                    case P:
                                        var We = fe._init;
                                        return fe = We(fe._payload),
                                        je(ge, fe, _e)
                                    }
                                    if (G(fe) || K(fe))
                                        return fe = ul(fe, ge.mode, _e, null),
                                        fe.return = ge,
                                        fe;
                                    if (typeof fe.then == "function")
                                        return je(ge, kh(fe), _e);
                                    if (fe.$$typeof === O)
                                        return je(ge, Oh(ge, fe), _e);
                                    Bd(ge, fe)
                                }
                                return null
                            }
                            function we(ge, fe, _e, We) {
                                var St = fe !== null ? fe.key : null;
                                if (typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint")
                                    return St !== null ? null : Y(ge, fe, "" + _e, We);
                                if (typeof _e == "object" && _e !== null) {
                                    switch (_e.$$typeof) {
                                    case x:
                                        return _e.key === St ? re(ge, fe, _e, We) : null;
                                    case b:
                                        return _e.key === St ? Ae(ge, fe, _e, We) : null;
                                    case P:
                                        return St = _e._init,
                                        _e = St(_e._payload),
                                        we(ge, fe, _e, We)
                                    }
                                    if (G(_e) || K(_e))
                                        return St !== null ? null : qe(ge, fe, _e, We, null);
                                    if (typeof _e.then == "function")
                                        return we(ge, fe, kh(_e), We);
                                    if (_e.$$typeof === O)
                                        return we(ge, fe, Oh(ge, _e), We);
                                    Bd(ge, _e)
                                }
                                return null
                            }
                            function De(ge, fe, _e, We, St) {
                                if (typeof We == "string" && We !== "" || typeof We == "number" || typeof We == "bigint")
                                    return ge = ge.get(_e) || null,
                                    Y(fe, ge, "" + We, St);
                                if (typeof We == "object" && We !== null) {
                                    switch (We.$$typeof) {
                                    case x:
                                        return ge = ge.get(We.key === null ? _e : We.key) || null,
                                        re(fe, ge, We, St);
                                    case b:
                                        return ge = ge.get(We.key === null ? _e : We.key) || null,
                                        Ae(fe, ge, We, St);
                                    case P:
                                        var mn = We._init;
                                        return We = mn(We._payload),
                                        De(ge, fe, _e, We, St)
                                    }
                                    if (G(We) || K(We))
                                        return ge = ge.get(_e) || null,
                                        qe(fe, ge, We, St, null);
                                    if (typeof We.then == "function")
                                        return De(ge, fe, _e, kh(We), St);
                                    if (We.$$typeof === O)
                                        return De(ge, fe, _e, Oh(fe, We), St);
                                    Bd(fe, We)
                                }
                                return null
                            }
                            function qt(ge, fe, _e, We) {
                                for (var St = null, mn = null, Ot = fe, Ht = fe = 0, Ds = null; Ot !== null && Ht < _e.length; Ht++) {
                                    Ot.index > Ht ? (Ds = Ot,
                                    Ot = null) : Ds = Ot.sibling;
                                    var Nn = we(ge, Ot, _e[Ht], We);
                                    if (Nn === null) {
                                        Ot === null && (Ot = Ds);
                                        break
                                    }
                                    a && Ot && Nn.alternate === null && o(ge, Ot),
                                    fe = w(Nn, fe, Ht),
                                    mn === null ? St = Nn : mn.sibling = Nn,
                                    mn = Nn,
                                    Ot = Ds
                                }
                                if (Ht === _e.length)
                                    return f(ge, Ot),
                                    bn && Ao(ge, Ht),
                                    St;
                                if (Ot === null) {
                                    for (; Ht < _e.length; Ht++)
                                        Ot = je(ge, _e[Ht], We),
                                        Ot !== null && (fe = w(Ot, fe, Ht),
                                        mn === null ? St = Ot : mn.sibling = Ot,
                                        mn = Ot);
                                    return bn && Ao(ge, Ht),
                                    St
                                }
                                for (Ot = g(Ot); Ht < _e.length; Ht++)
                                    Ds = De(Ot, ge, Ht, _e[Ht], We),
                                    Ds !== null && (a && Ds.alternate !== null && Ot.delete(Ds.key === null ? Ht : Ds.key),
                                    fe = w(Ds, fe, Ht),
                                    mn === null ? St = Ds : mn.sibling = Ds,
                                    mn = Ds);
                                return a && Ot.forEach(function(Ru) {
                                    return o(ge, Ru)
                                }),
                                bn && Ao(ge, Ht),
                                St
                            }
                            function Ft(ge, fe, _e, We) {
                                if (_e == null)
                                    throw Error(s(151));
                                for (var St = null, mn = null, Ot = fe, Ht = fe = 0, Ds = null, Nn = _e.next(); Ot !== null && !Nn.done; Ht++,
                                Nn = _e.next()) {
                                    Ot.index > Ht ? (Ds = Ot,
                                    Ot = null) : Ds = Ot.sibling;
                                    var Ru = we(ge, Ot, Nn.value, We);
                                    if (Ru === null) {
                                        Ot === null && (Ot = Ds);
                                        break
                                    }
                                    a && Ot && Ru.alternate === null && o(ge, Ot),
                                    fe = w(Ru, fe, Ht),
                                    mn === null ? St = Ru : mn.sibling = Ru,
                                    mn = Ru,
                                    Ot = Ds
                                }
                                if (Nn.done)
                                    return f(ge, Ot),
                                    bn && Ao(ge, Ht),
                                    St;
                                if (Ot === null) {
                                    for (; !Nn.done; Ht++,
                                    Nn = _e.next())
                                        Nn = je(ge, Nn.value, We),
                                        Nn !== null && (fe = w(Nn, fe, Ht),
                                        mn === null ? St = Nn : mn.sibling = Nn,
                                        mn = Nn);
                                    return bn && Ao(ge, Ht),
                                    St
                                }
                                for (Ot = g(Ot); !Nn.done; Ht++,
                                Nn = _e.next())
                                    Nn = De(Ot, ge, Ht, Nn.value, We),
                                    Nn !== null && (a && Nn.alternate !== null && Ot.delete(Nn.key === null ? Ht : Nn.key),
                                    fe = w(Nn, fe, Ht),
                                    mn === null ? St = Nn : mn.sibling = Nn,
                                    mn = Nn);
                                return a && Ot.forEach(function(F3) {
                                    return o(ge, F3)
                                }),
                                bn && Ao(ge, Ht),
                                St
                            }
                            function ei(ge, fe, _e, We) {
                                if (typeof _e == "object" && _e !== null && _e.type === E && _e.key === null && (_e = _e.props.children),
                                typeof _e == "object" && _e !== null) {
                                    switch (_e.$$typeof) {
                                    case x:
                                        e: {
                                            for (var St = _e.key; fe !== null; ) {
                                                if (fe.key === St) {
                                                    if (St = _e.type,
                                                    St === E) {
                                                        if (fe.tag === 7) {
                                                            f(ge, fe.sibling),
                                                            We = S(fe, _e.props.children),
                                                            We.return = ge,
                                                            ge = We;
                                                            break e
                                                        }
                                                    } else if (fe.elementType === St || typeof St == "object" && St !== null && St.$$typeof === P && ay(St) === fe.type) {
                                                        f(ge, fe.sibling),
                                                        We = S(fe, _e.props),
                                                        fu(We, _e),
                                                        We.return = ge,
                                                        ge = We;
                                                        break e
                                                    }
                                                    f(ge, fe);
                                                    break
                                                } else
                                                    o(ge, fe);
                                                fe = fe.sibling
                                            }
                                            _e.type === E ? (We = ul(_e.props.children, ge.mode, We, _e.key),
                                            We.return = ge,
                                            ge = We) : (We = es(_e.type, _e.key, _e.props, null, ge.mode, We),
                                            fu(We, _e),
                                            We.return = ge,
                                            ge = We)
                                        }
                                        return z(ge);
                                    case b:
                                        e: {
                                            for (St = _e.key; fe !== null; ) {
                                                if (fe.key === St)
                                                    if (fe.tag === 4 && fe.stateNode.containerInfo === _e.containerInfo && fe.stateNode.implementation === _e.implementation) {
                                                        f(ge, fe.sibling),
                                                        We = S(fe, _e.children || []),
                                                        We.return = ge,
                                                        ge = We;
                                                        break e
                                                    } else {
                                                        f(ge, fe);
                                                        break
                                                    }
                                                else
                                                    o(ge, fe);
                                                fe = fe.sibling
                                            }
                                            We = pd(_e, ge.mode, We),
                                            We.return = ge,
                                            ge = We
                                        }
                                        return z(ge);
                                    case P:
                                        return St = _e._init,
                                        _e = St(_e._payload),
                                        ei(ge, fe, _e, We)
                                    }
                                    if (G(_e))
                                        return qt(ge, fe, _e, We);
                                    if (K(_e)) {
                                        if (St = K(_e),
                                        typeof St != "function")
                                            throw Error(s(150));
                                        return _e = St.call(_e),
                                        Ft(ge, fe, _e, We)
                                    }
                                    if (typeof _e.then == "function")
                                        return ei(ge, fe, kh(_e), We);
                                    if (_e.$$typeof === O)
                                        return ei(ge, fe, Oh(ge, _e), We);
                                    Bd(ge, _e)
                                }
                                return typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint" ? (_e = "" + _e,
                                fe !== null && fe.tag === 6 ? (f(ge, fe.sibling),
                                We = S(fe, _e),
                                We.return = ge,
                                ge = We) : (f(ge, fe),
                                We = wh(_e, ge.mode, We),
                                We.return = ge,
                                ge = We),
                                z(ge)) : f(ge, fe)
                            }
                            return function(ge, fe, _e, We) {
                                try {
                                    Gh = 0;
                                    var St = ei(ge, fe, _e, We);
                                    return tc = null,
                                    St
                                } catch (Ot) {
                                    if (Ot === Ph || Ot === mr)
                                        throw Ot;
                                    var mn = ea(29, Ot, null, ge.mode);
                                    return mn.lanes = We,
                                    mn.return = ge,
                                    mn
                                }
                            }
                        }
                        var nc = ry(!0)
                          , oy = ry(!1)
                          , kn = J(null)
                          , vr = null;
                        function xl(a) {
                            var o = a.alternate;
                            xe(wi, wi.current & 1),
                            xe(kn, a),
                            vr === null && (o === null || lu.current !== null || o.memoizedState !== null) && (vr = a)
                        }
                        function ly(a) {
                            if (a.tag === 22) {
                                if (xe(wi, wi.current),
                                xe(kn, a),
                                vr === null) {
                                    var o = a.alternate;
                                    o !== null && o.memoizedState !== null && (vr = a)
                                }
                            } else
                                Sl(a)
                        }
                        function Sl() {
                            xe(wi, wi.current),
                            xe(kn, kn.current)
                        }
                        function kr(a) {
                            ze(kn),
                            vr === a && (vr = null),
                            ze(wi)
                        }
                        var wi = J(0);
                        function Do(a) {
                            for (var o = a; o !== null; ) {
                                if (o.tag === 13) {
                                    var f = o.memoizedState;
                                    if (f !== null && (f = f.dehydrated,
                                    f === null || f.data === "$?" || jS(f)))
                                        return o
                                } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
                                    if ((o.flags & 128) !== 0)
                                        return o
                                } else if (o.child !== null) {
                                    o.child.return = o,
                                    o = o.child;
                                    continue
                                }
                                if (o === a)
                                    break;
                                for (; o.sibling === null; ) {
                                    if (o.return === null || o.return === a)
                                        return null;
                                    o = o.return
                                }
                                o.sibling.return = o.return,
                                o = o.sibling
                            }
                            return null
                        }
                        function Al(a, o, f, g) {
                            o = a.memoizedState,
                            f = f(g, o),
                            f = f == null ? o : v({}, o, f),
                            a.memoizedState = f,
                            a.lanes === 0 && (a.updateQueue.baseState = f)
                        }
                        var Hs = {
                            enqueueSetState: function(a, o, f) {
                                a = a._reactInternals;
                                var g = Ri()
                                  , S = Eo(g);
                                S.payload = o,
                                f != null && (S.callback = f),
                                o = gl(a, S, g),
                                o !== null && (Gs(o, a, g),
                                ec(o, a, g))
                            },
                            enqueueReplaceState: function(a, o, f) {
                                a = a._reactInternals;
                                var g = Ri()
                                  , S = Eo(g);
                                S.tag = 1,
                                S.payload = o,
                                f != null && (S.callback = f),
                                o = gl(a, S, g),
                                o !== null && (Gs(o, a, g),
                                ec(o, a, g))
                            },
                            enqueueForceUpdate: function(a, o) {
                                a = a._reactInternals;
                                var f = Ri()
                                  , g = Eo(f);
                                g.tag = 2,
                                o != null && (g.callback = o),
                                o = gl(a, g, f),
                                o !== null && (Gs(o, a, f),
                                ec(o, a, f))
                            }
                        };
                        function cy(a, o, f, g, S, w, z) {
                            return a = a.stateNode,
                            typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(g, w, z) : o.prototype && o.prototype.isPureReactComponent ? !dr(f, g) || !dr(S, w) : !0
                        }
                        function uy(a, o, f, g) {
                            a = o.state,
                            typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(f, g),
                            typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(f, g),
                            o.state !== a && Hs.enqueueReplaceState(o, o.state, null)
                        }
                        function Xr(a, o) {
                            var f = o;
                            if ("ref"in o) {
                                f = {};
                                for (var g in o)
                                    g !== "ref" && (f[g] = o[g])
                            }
                            if (a = a.defaultProps) {
                                f === o && (f = v({}, f));
                                for (var S in a)
                                    f[S] === void 0 && (f[S] = a[S])
                            }
                            return f
                        }
                        var ic = typeof reportError == "function" ? reportError : function(a) {
                            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                var o = new window.ErrorEvent("error",{
                                    bubbles: !0,
                                    cancelable: !0,
                                    message: typeof a == "object" && a !== null && typeof a.message == "string" ? String(a.message) : String(a),
                                    error: a
                                });
                                if (!window.dispatchEvent(o))
                                    return
                            } else if (typeof process == "object" && typeof process.emit == "function") {
                                process.emit("uncaughtException", a);
                                return
                            }
                            console.error(a)
                        }
                        ;
                        function Pd(a) {
                            ic(a)
                        }
                        function pg(a) {
                            console.error(a)
                        }
                        function BS(a) {
                            ic(a)
                        }
                        function Id(a, o) {
                            try {
                                var f = a.onUncaughtError;
                                f(o.value, {
                                    componentStack: o.stack
                                })
                            } catch (g) {
                                setTimeout(function() {
                                    throw g
                                })
                            }
                        }
                        function ja(a, o, f) {
                            try {
                                var g = a.onCaughtError;
                                g(f.value, {
                                    componentStack: f.stack,
                                    errorBoundary: o.tag === 1 ? o.stateNode : null
                                })
                            } catch (S) {
                                setTimeout(function() {
                                    throw S
                                })
                            }
                        }
                        function Ld(a, o, f) {
                            return f = Eo(f),
                            f.tag = 3,
                            f.payload = {
                                element: null
                            },
                            f.callback = function() {
                                Id(a, o)
                            }
                            ,
                            f
                        }
                        function hy(a) {
                            return a = Eo(a),
                            a.tag = 3,
                            a
                        }
                        function zd(a, o, f, g) {
                            var S = f.type.getDerivedStateFromError;
                            if (typeof S == "function") {
                                var w = g.value;
                                a.payload = function() {
                                    return S(w)
                                }
                                ,
                                a.callback = function() {
                                    ja(o, f, g)
                                }
                            }
                            var z = f.stateNode;
                            z !== null && typeof z.componentDidCatch == "function" && (a.callback = function() {
                                ja(o, f, g),
                                typeof S != "function" && (Ra === null ? Ra = new Set([this]) : Ra.add(this));
                                var Y = g.stack;
                                this.componentDidCatch(g.value, {
                                    componentStack: Y !== null ? Y : ""
                                })
                            }
                            )
                        }
                        function PS(a, o, f, g, S) {
                            if (f.flags |= 32768,
                            g !== null && typeof g == "object" && typeof g.then == "function") {
                                if (o = f.alternate,
                                o !== null && Xa(o, f, S, !0),
                                f = kn.current,
                                f !== null) {
                                    switch (f.tag) {
                                    case 13:
                                        return vr === null ? c() : f.alternate === null && ai === 0 && (ai = 3),
                                        f.flags &= -257,
                                        f.flags |= 65536,
                                        f.lanes = S,
                                        g === Ih ? f.flags |= 16384 : (o = f.updateQueue,
                                        o === null ? f.updateQueue = new Set([g]) : o.add(g),
                                        Oe(a, g, S)),
                                        !1;
                                    case 22:
                                        return f.flags |= 65536,
                                        g === Ih ? f.flags |= 16384 : (o = f.updateQueue,
                                        o === null ? (o = {
                                            transitions: null,
                                            markerInstances: null,
                                            retryQueue: new Set([g])
                                        },
                                        f.updateQueue = o) : (f = o.retryQueue,
                                        f === null ? o.retryQueue = new Set([g]) : f.add(g)),
                                        Oe(a, g, S)),
                                        !1
                                    }
                                    throw Error(s(435, f.tag))
                                }
                                return Oe(a, g, S),
                                c(),
                                !1
                            }
                            if (bn)
                                return o = kn.current,
                                o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256),
                                o.flags |= 65536,
                                o.lanes = S,
                                g !== gd && (a = Error(s(422), {
                                    cause: g
                                }),
                                $l(ds(a, f)))) : (g !== gd && (o = Error(s(423), {
                                    cause: g
                                }),
                                $l(ds(o, f))),
                                a = a.current.alternate,
                                a.flags |= 65536,
                                S &= -S,
                                a.lanes |= S,
                                g = ds(g, f),
                                S = Ld(a.stateNode, g, S),
                                au(a, S),
                                ai !== 4 && (ai = 2)),
                                !1;
                            var w = Error(s(520), {
                                cause: g
                            });
                            if (w = ds(w, f),
                            On === null ? On = [w] : On.push(w),
                            ai !== 4 && (ai = 2),
                            o === null)
                                return !0;
                            g = ds(g, f),
                            f = o;
                            do {
                                switch (f.tag) {
                                case 3:
                                    return f.flags |= 65536,
                                    a = S & -S,
                                    f.lanes |= a,
                                    a = Ld(f.stateNode, g, a),
                                    au(f, a),
                                    !1;
                                case 1:
                                    if (o = f.type,
                                    w = f.stateNode,
                                    (f.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (Ra === null || !Ra.has(w))))
                                        return f.flags |= 65536,
                                        S &= -S,
                                        f.lanes |= S,
                                        S = hy(S),
                                        zd(S, a, f, g),
                                        au(f, S),
                                        !1
                                }
                                f = f.return
                            } while (f !== null);
                            return !1
                        }
                        var fy = Error(s(461))
                          , ts = !1;
                        function Ci(a, o, f, g) {
                            o.child = a === null ? oy(o, null, f, g) : nc(o, a.child, f, g)
                        }
                        function na(a, o, f, g, S) {
                            f = f.render;
                            var w = o.ref;
                            if ("ref"in g) {
                                var z = {};
                                for (var Y in g)
                                    Y !== "ref" && (z[Y] = g[Y])
                            } else
                                z = g;
                            return Gr(o),
                            g = Co(a, o, f, z, w, S),
                            Y = Jm(),
                            a !== null && !ts ? (bd(a, o, S),
                            ns(a, o, S)) : (bn && Y && Vm(o),
                            o.flags |= 1,
                            Ci(a, o, g, S),
                            o.child)
                        }
                        function ia(a, o, f, g, S) {
                            if (a === null) {
                                var w = f.type;
                                return typeof w == "function" && !Eh(w) && w.defaultProps === void 0 && f.compare === null ? (o.tag = 15,
                                o.type = w,
                                mg(a, o, w, g, S)) : (a = es(f.type, null, g, o, o.mode, S),
                                a.ref = o.ref,
                                a.return = o,
                                o.child = a)
                            }
                            if (w = a.child,
                            !Xh(a, S)) {
                                var z = w.memoizedProps;
                                if (f = f.compare,
                                f = f !== null ? f : dr,
                                f(z, g) && a.ref === o.ref)
                                    return ns(a, o, S)
                            }
                            return o.flags |= 1,
                            a = bi(w, g),
                            a.ref = o.ref,
                            a.return = o,
                            o.child = a
                        }
                        function mg(a, o, f, g, S) {
                            if (a !== null) {
                                var w = a.memoizedProps;
                                if (dr(w, g) && a.ref === o.ref)
                                    if (ts = !1,
                                    o.pendingProps = g = w,
                                    Xh(a, S))
                                        (a.flags & 131072) !== 0 && (ts = !0);
                                    else
                                        return o.lanes = a.lanes,
                                        ns(a, o, S)
                            }
                            return du(a, o, f, g, S)
                        }
                        function sc(a, o, f) {
                            var g = o.pendingProps
                              , S = g.children
                              , w = a !== null ? a.memoizedState : null;
                            if (g.mode === "hidden") {
                                if ((o.flags & 128) !== 0) {
                                    if (g = w !== null ? w.baseLanes | f : f,
                                    a !== null) {
                                        for (S = o.child = a.child,
                                        w = 0; S !== null; )
                                            w = w | S.lanes | S.childLanes,
                                            S = S.sibling;
                                        o.childLanes = w & ~g
                                    } else
                                        o.childLanes = 0,
                                        o.child = null;
                                    return ac(a, o, g, f)
                                }
                                if ((f & 536870912) !== 0)
                                    o.memoizedState = {
                                        baseLanes: 0,
                                        cachePool: null
                                    },
                                    a !== null && Bh(o, w !== null ? w.cachePool : null),
                                    w !== null ? R0(o, w) : Km(),
                                    ly(o);
                                else
                                    return o.lanes = o.childLanes = 536870912,
                                    ac(a, o, w !== null ? w.baseLanes | f : f, f)
                            } else
                                w !== null ? (Bh(o, w.cachePool),
                                R0(o, w),
                                Sl(o),
                                o.memoizedState = null) : (a !== null && Bh(o, null),
                                Km(),
                                Sl(o));
                            return Ci(a, o, S, f),
                            o.child
                        }
                        function ac(a, o, f, g) {
                            var S = ml();
                            return S = S === null ? null : {
                                parent: Pi._currentValue,
                                pool: S
                            },
                            o.memoizedState = {
                                baseLanes: f,
                                cachePool: S
                            },
                            a !== null && Bh(o, null),
                            Km(),
                            ly(o),
                            a !== null && Xa(a, o, g, !0),
                            null
                        }
                        function rc(a, o) {
                            var f = o.ref;
                            if (f === null)
                                a !== null && a.ref !== null && (o.flags |= 4194816);
                            else {
                                if (typeof f != "function" && typeof f != "object")
                                    throw Error(s(284));
                                (a === null || a.ref !== f) && (o.flags |= 4194816)
                            }
                        }
                        function du(a, o, f, g, S) {
                            return Gr(o),
                            f = Co(a, o, f, g, void 0, S),
                            g = Jm(),
                            a !== null && !ts ? (bd(a, o, S),
                            ns(a, o, S)) : (bn && g && Vm(o),
                            o.flags |= 1,
                            Ci(a, o, f, S),
                            o.child)
                        }
                        function Aa(a, o, f, g, S, w) {
                            return Gr(o),
                            o.updateQueue = null,
                            f = N0(o, g, f, S),
                            O0(a),
                            g = Jm(),
                            a !== null && !ts ? (bd(a, o, w),
                            ns(a, o, w)) : (bn && g && Vm(o),
                            o.flags |= 1,
                            Ci(a, o, f, w),
                            o.child)
                        }
                        function Ta(a, o, f, g, S) {
                            if (Gr(o),
                            o.stateNode === null) {
                                var w = cl
                                  , z = f.contextType;
                                typeof z == "object" && z !== null && (w = vi(z)),
                                w = new f(g,w),
                                o.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null,
                                w.updater = Hs,
                                o.stateNode = w,
                                w._reactInternals = o,
                                w = o.stateNode,
                                w.props = g,
                                w.state = o.memoizedState,
                                w.refs = {},
                                Qm(o),
                                z = f.contextType,
                                w.context = typeof z == "object" && z !== null ? vi(z) : cl,
                                w.state = o.memoizedState,
                                z = f.getDerivedStateFromProps,
                                typeof z == "function" && (Al(o, f, z, g),
                                w.state = o.memoizedState),
                                typeof f.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (z = w.state,
                                typeof w.componentWillMount == "function" && w.componentWillMount(),
                                typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(),
                                z !== w.state && Hs.enqueueReplaceState(w, w.state, null),
                                ru(o, g, w, S),
                                Lh(),
                                w.state = o.memoizedState),
                                typeof w.componentDidMount == "function" && (o.flags |= 4194308),
                                g = !0
                            } else if (a === null) {
                                w = o.stateNode;
                                var Y = o.memoizedProps
                                  , re = Xr(f, Y);
                                w.props = re;
                                var Ae = w.context
                                  , qe = f.contextType;
                                z = cl,
                                typeof qe == "object" && qe !== null && (z = vi(qe));
                                var je = f.getDerivedStateFromProps;
                                qe = typeof je == "function" || typeof w.getSnapshotBeforeUpdate == "function",
                                Y = o.pendingProps !== Y,
                                qe || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (Y || Ae !== z) && uy(o, w, g, z),
                                bo = !1;
                                var we = o.memoizedState;
                                w.state = we,
                                ru(o, g, w, S),
                                Lh(),
                                Ae = o.memoizedState,
                                Y || we !== Ae || bo ? (typeof je == "function" && (Al(o, f, je, g),
                                Ae = o.memoizedState),
                                (re = bo || cy(o, f, re, g, we, Ae, z)) ? (qe || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(),
                                typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()),
                                typeof w.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (o.flags |= 4194308),
                                o.memoizedProps = g,
                                o.memoizedState = Ae),
                                w.props = g,
                                w.state = Ae,
                                w.context = z,
                                g = re) : (typeof w.componentDidMount == "function" && (o.flags |= 4194308),
                                g = !1)
                            } else {
                                w = o.stateNode,
                                Vt(a, o),
                                z = o.memoizedProps,
                                qe = Xr(f, z),
                                w.props = qe,
                                je = o.pendingProps,
                                we = w.context,
                                Ae = f.contextType,
                                re = cl,
                                typeof Ae == "object" && Ae !== null && (re = vi(Ae)),
                                Y = f.getDerivedStateFromProps,
                                (Ae = typeof Y == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (z !== je || we !== re) && uy(o, w, g, re),
                                bo = !1,
                                we = o.memoizedState,
                                w.state = we,
                                ru(o, g, w, S),
                                Lh();
                                var De = o.memoizedState;
                                z !== je || we !== De || bo || a !== null && a.dependencies !== null && Dh(a.dependencies) ? (typeof Y == "function" && (Al(o, f, Y, g),
                                De = o.memoizedState),
                                (qe = bo || cy(o, f, qe, g, we, De, re) || a !== null && a.dependencies !== null && Dh(a.dependencies)) ? (Ae || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(g, De, re),
                                typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(g, De, re)),
                                typeof w.componentDidUpdate == "function" && (o.flags |= 4),
                                typeof w.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || z === a.memoizedProps && we === a.memoizedState || (o.flags |= 4),
                                typeof w.getSnapshotBeforeUpdate != "function" || z === a.memoizedProps && we === a.memoizedState || (o.flags |= 1024),
                                o.memoizedProps = g,
                                o.memoizedState = De),
                                w.props = g,
                                w.state = De,
                                w.context = re,
                                g = qe) : (typeof w.componentDidUpdate != "function" || z === a.memoizedProps && we === a.memoizedState || (o.flags |= 4),
                                typeof w.getSnapshotBeforeUpdate != "function" || z === a.memoizedProps && we === a.memoizedState || (o.flags |= 1024),
                                g = !1)
                            }
                            return w = g,
                            rc(a, o),
                            g = (o.flags & 128) !== 0,
                            w || g ? (w = o.stateNode,
                            f = g && typeof f.getDerivedStateFromError != "function" ? null : w.render(),
                            o.flags |= 1,
                            a !== null && g ? (o.child = nc(o, a.child, null, S),
                            o.child = nc(o, null, f, S)) : Ci(a, o, f, S),
                            o.memoizedState = w.state,
                            a = o.child) : a = ns(a, o, S),
                            a
                        }
                        function Tl(a, o, f, g) {
                            return eu(),
                            o.flags |= 256,
                            Ci(a, o, f, g),
                            o.child
                        }
                        var yr = {
                            dehydrated: null,
                            treeContext: null,
                            retryLane: 0,
                            hydrationErrors: null
                        };
                        function _r(a) {
                            return {
                                baseLanes: a,
                                cachePool: xd()
                            }
                        }
                        function qi(a, o, f) {
                            return a = a !== null ? a.childLanes & ~f : 0,
                            o && (a |= $a),
                            a
                        }
                        function pu(a, o, f) {
                            var g = o.pendingProps, S = !1, w = (o.flags & 128) !== 0, z;
                            if ((z = w) || (z = a !== null && a.memoizedState === null ? !1 : (wi.current & 2) !== 0),
                            z && (S = !0,
                            o.flags &= -129),
                            z = (o.flags & 32) !== 0,
                            o.flags &= -33,
                            a === null) {
                                if (bn) {
                                    if (S ? xl(o) : Sl(o),
                                    bn) {
                                        var Y = di, re;
                                        if (re = Y) {
                                            e: {
                                                for (re = Y,
                                                Y = _a; re.nodeType !== 8; ) {
                                                    if (!Y) {
                                                        Y = null;
                                                        break e
                                                    }
                                                    if (re = Io(re.nextSibling),
                                                    re === null) {
                                                        Y = null;
                                                        break e
                                                    }
                                                }
                                                Y = re
                                            }
                                            Y !== null ? (o.memoizedState = {
                                                dehydrated: Y,
                                                treeContext: hl !== null ? {
                                                    id: Hr,
                                                    overflow: Vr
                                                } : null,
                                                retryLane: 536870912,
                                                hydrationErrors: null
                                            },
                                            re = ea(18, null, null, 0),
                                            re.stateNode = Y,
                                            re.return = o,
                                            o.child = re,
                                            Ls = o,
                                            di = null,
                                            re = !0) : re = !1
                                        }
                                        re || fl(o)
                                    }
                                    if (Y = o.memoizedState,
                                    Y !== null && (Y = Y.dehydrated,
                                    Y !== null))
                                        return jS(Y) ? o.lanes = 32 : o.lanes = 536870912,
                                        null;
                                    kr(o)
                                }
                                return Y = g.children,
                                g = g.fallback,
                                S ? (Sl(o),
                                S = o.mode,
                                Y = oc({
                                    mode: "hidden",
                                    children: Y
                                }, S),
                                g = ul(g, S, f, null),
                                Y.return = o,
                                g.return = o,
                                Y.sibling = g,
                                o.child = Y,
                                S = o.child,
                                S.memoizedState = _r(f),
                                S.childLanes = qi(a, z, f),
                                o.memoizedState = yr,
                                g) : (xl(o),
                                qr(o, Y))
                            }
                            if (re = a.memoizedState,
                            re !== null && (Y = re.dehydrated,
                            Y !== null)) {
                                if (w)
                                    o.flags & 256 ? (xl(o),
                                    o.flags &= -257,
                                    o = gs(a, o, f)) : o.memoizedState !== null ? (Sl(o),
                                    o.child = a.child,
                                    o.flags |= 128,
                                    o = null) : (Sl(o),
                                    S = g.fallback,
                                    Y = o.mode,
                                    g = oc({
                                        mode: "visible",
                                        children: g.children
                                    }, Y),
                                    S = ul(S, Y, f, null),
                                    S.flags |= 2,
                                    g.return = o,
                                    S.return = o,
                                    g.sibling = S,
                                    o.child = g,
                                    nc(o, a.child, null, f),
                                    g = o.child,
                                    g.memoizedState = _r(f),
                                    g.childLanes = qi(a, z, f),
                                    o.memoizedState = yr,
                                    o = S);
                                else if (xl(o),
                                jS(Y)) {
                                    if (z = Y.nextSibling && Y.nextSibling.dataset,
                                    z)
                                        var Ae = z.dgst;
                                    z = Ae,
                                    g = Error(s(419)),
                                    g.stack = "",
                                    g.digest = z,
                                    $l({
                                        value: g,
                                        source: null,
                                        stack: null
                                    }),
                                    o = gs(a, o, f)
                                } else if (ts || Xa(a, o, f, !1),
                                z = (f & a.childLanes) !== 0,
                                ts || z) {
                                    if (z = jt,
                                    z !== null && (g = f & -f,
                                    g = (g & 42) !== 0 ? 1 : Tn(g),
                                    g = (g & (z.suspendedLanes | f)) !== 0 ? 0 : g,
                                    g !== 0 && g !== re.retryLane))
                                        throw re.retryLane = g,
                                        So(a, g),
                                        Gs(z, a, g),
                                        fy;
                                    Y.data === "$?" || c(),
                                    o = gs(a, o, f)
                                } else
                                    Y.data === "$?" ? (o.flags |= 192,
                                    o.child = a.child,
                                    o = null) : (a = re.treeContext,
                                    di = Io(Y.nextSibling),
                                    Ls = o,
                                    bn = !0,
                                    ka = null,
                                    _a = !1,
                                    a !== null && (ps[ya++] = Hr,
                                    ps[ya++] = Vr,
                                    ps[ya++] = hl,
                                    Hr = a.id,
                                    Vr = a.overflow,
                                    hl = o),
                                    o = qr(o, g.children),
                                    o.flags |= 4096);
                                return o
                            }
                            return S ? (Sl(o),
                            S = g.fallback,
                            Y = o.mode,
                            re = a.child,
                            Ae = re.sibling,
                            g = bi(re, {
                                mode: "hidden",
                                children: g.children
                            }),
                            g.subtreeFlags = re.subtreeFlags & 65011712,
                            Ae !== null ? S = bi(Ae, S) : (S = ul(S, Y, f, null),
                            S.flags |= 2),
                            S.return = o,
                            g.return = o,
                            g.sibling = S,
                            o.child = g,
                            g = S,
                            S = o.child,
                            Y = a.child.memoizedState,
                            Y === null ? Y = _r(f) : (re = Y.cachePool,
                            re !== null ? (Ae = Pi._currentValue,
                            re = re.parent !== Ae ? {
                                parent: Ae,
                                pool: Ae
                            } : re) : re = xd(),
                            Y = {
                                baseLanes: Y.baseLanes | f,
                                cachePool: re
                            }),
                            S.memoizedState = Y,
                            S.childLanes = qi(a, z, f),
                            o.memoizedState = yr,
                            g) : (xl(o),
                            f = a.child,
                            a = f.sibling,
                            f = bi(f, {
                                mode: "visible",
                                children: g.children
                            }),
                            f.return = o,
                            f.sibling = null,
                            a !== null && (z = o.deletions,
                            z === null ? (o.deletions = [a],
                            o.flags |= 16) : z.push(a)),
                            o.child = f,
                            o.memoizedState = null,
                            f)
                        }
                        function qr(a, o) {
                            return o = oc({
                                mode: "visible",
                                children: o
                            }, a.mode),
                            o.return = a,
                            a.child = o
                        }
                        function oc(a, o) {
                            return a = ea(22, a, null, o),
                            a.lanes = 0,
                            a.stateNode = {
                                _visibility: 1,
                                _pendingMarkers: null,
                                _retryCache: null,
                                _transitions: null
                            },
                            a
                        }
                        function gs(a, o, f) {
                            return nc(o, a.child, null, f),
                            a = qr(o, o.pendingProps.children),
                            a.flags |= 2,
                            o.memoizedState = null,
                            a
                        }
                        function vs(a, o, f) {
                            a.lanes |= o;
                            var g = a.alternate;
                            g !== null && (g.lanes |= o),
                            qm(a.return, o, f)
                        }
                        function _n(a, o, f, g, S) {
                            var w = a.memoizedState;
                            w === null ? a.memoizedState = {
                                isBackwards: o,
                                rendering: null,
                                renderingStartTime: 0,
                                last: g,
                                tail: f,
                                tailMode: S
                            } : (w.isBackwards = o,
                            w.rendering = null,
                            w.renderingStartTime = 0,
                            w.last = g,
                            w.tail = f,
                            w.tailMode = S)
                        }
                        function Qa(a, o, f) {
                            var g = o.pendingProps
                              , S = g.revealOrder
                              , w = g.tail;
                            if (Ci(a, o, g.children, f),
                            g = wi.current,
                            (g & 2) !== 0)
                                g = g & 1 | 2,
                                o.flags |= 128;
                            else {
                                if (a !== null && (a.flags & 128) !== 0)
                                    e: for (a = o.child; a !== null; ) {
                                        if (a.tag === 13)
                                            a.memoizedState !== null && vs(a, f, o);
                                        else if (a.tag === 19)
                                            vs(a, f, o);
                                        else if (a.child !== null) {
                                            a.child.return = a,
                                            a = a.child;
                                            continue
                                        }
                                        if (a === o)
                                            break e;
                                        for (; a.sibling === null; ) {
                                            if (a.return === null || a.return === o)
                                                break e;
                                            a = a.return
                                        }
                                        a.sibling.return = a.return,
                                        a = a.sibling
                                    }
                                g &= 1
                            }
                            switch (xe(wi, g),
                            S) {
                            case "forwards":
                                for (f = o.child,
                                S = null; f !== null; )
                                    a = f.alternate,
                                    a !== null && Do(a) === null && (S = f),
                                    f = f.sibling;
                                f = S,
                                f === null ? (S = o.child,
                                o.child = null) : (S = f.sibling,
                                f.sibling = null),
                                _n(o, !1, S, f, w);
                                break;
                            case "backwards":
                                for (f = null,
                                S = o.child,
                                o.child = null; S !== null; ) {
                                    if (a = S.alternate,
                                    a !== null && Do(a) === null) {
                                        o.child = S;
                                        break
                                    }
                                    a = S.sibling,
                                    S.sibling = f,
                                    f = S,
                                    S = a
                                }
                                _n(o, !0, f, null, w);
                                break;
                            case "together":
                                _n(o, !1, null, null, void 0);
                                break;
                            default:
                                o.memoizedState = null
                            }
                            return o.child
                        }
                        function ns(a, o, f) {
                            if (a !== null && (o.dependencies = a.dependencies),
                            Tr |= o.lanes,
                            (f & o.childLanes) === 0)
                                if (a !== null) {
                                    if (Xa(a, o, f, !1),
                                    (f & o.childLanes) === 0)
                                        return null
                                } else
                                    return null;
                            if (a !== null && o.child !== a.child)
                                throw Error(s(153));
                            if (o.child !== null) {
                                for (a = o.child,
                                f = bi(a, a.pendingProps),
                                o.child = f,
                                f.return = o; a.sibling !== null; )
                                    a = a.sibling,
                                    f = f.sibling = bi(a, a.pendingProps),
                                    f.return = o;
                                f.sibling = null
                            }
                            return o.child
                        }
                        function Xh(a, o) {
                            return (a.lanes & o) !== 0 ? !0 : (a = a.dependencies,
                            !!(a !== null && Dh(a)))
                        }
                        function Za(a, o, f) {
                            switch (o.tag) {
                            case 3:
                                $e(o, o.stateNode.containerInfo),
                                pl(o, Pi, a.memoizedState.cache),
                                eu();
                                break;
                            case 27:
                            case 5:
                                Et(o);
                                break;
                            case 4:
                                $e(o, o.stateNode.containerInfo);
                                break;
                            case 10:
                                pl(o, o.type, o.memoizedProps.value);
                                break;
                            case 13:
                                var g = o.memoizedState;
                                if (g !== null)
                                    return g.dehydrated !== null ? (xl(o),
                                    o.flags |= 128,
                                    null) : (f & o.child.childLanes) !== 0 ? pu(a, o, f) : (xl(o),
                                    a = ns(a, o, f),
                                    a !== null ? a.sibling : null);
                                xl(o);
                                break;
                            case 19:
                                var S = (a.flags & 128) !== 0;
                                if (g = (f & o.childLanes) !== 0,
                                g || (Xa(a, o, f, !1),
                                g = (f & o.childLanes) !== 0),
                                S) {
                                    if (g)
                                        return Qa(a, o, f);
                                    o.flags |= 128
                                }
                                if (S = o.memoizedState,
                                S !== null && (S.rendering = null,
                                S.tail = null,
                                S.lastEffect = null),
                                xe(wi, wi.current),
                                g)
                                    break;
                                return null;
                            case 22:
                            case 23:
                                return o.lanes = 0,
                                sc(a, o, f);
                            case 24:
                                pl(o, Pi, a.memoizedState.cache)
                            }
                            return ns(a, o, f)
                        }
                        function lc(a, o, f) {
                            if (a !== null)
                                if (a.memoizedProps !== o.pendingProps)
                                    ts = !0;
                                else {
                                    if (!Xh(a, f) && (o.flags & 128) === 0)
                                        return ts = !1,
                                        Za(a, o, f);
                                    ts = (a.flags & 131072) !== 0
                                }
                            else
                                ts = !1,
                                bn && (o.flags & 1048576) !== 0 && md(o, $c, o.index);
                            switch (o.lanes = 0,
                            o.tag) {
                            case 16:
                                e: {
                                    a = o.pendingProps;
                                    var g = o.elementType
                                      , S = g._init;
                                    if (g = S(g._payload),
                                    o.type = g,
                                    typeof g == "function")
                                        Eh(g) ? (a = Xr(g, a),
                                        o.tag = 1,
                                        o = Ta(null, o, g, a, f)) : (o.tag = 0,
                                        o = du(null, o, g, a, f));
                                    else {
                                        if (g != null) {
                                            if (S = g.$$typeof,
                                            S === U) {
                                                o.tag = 11,
                                                o = na(null, o, g, a, f);
                                                break e
                                            } else if (S === F) {
                                                o.tag = 14,
                                                o = ia(null, o, g, a, f);
                                                break e
                                            }
                                        }
                                        throw o = ce(g) || g,
                                        Error(s(306, o, ""))
                                    }
                                }
                                return o;
                            case 0:
                                return du(a, o, o.type, o.pendingProps, f);
                            case 1:
                                return g = o.type,
                                S = Xr(g, o.pendingProps),
                                Ta(a, o, g, S, f);
                            case 3:
                                e: {
                                    if ($e(o, o.stateNode.containerInfo),
                                    a === null)
                                        throw Error(s(387));
                                    g = o.pendingProps;
                                    var w = o.memoizedState;
                                    S = w.element,
                                    Vt(a, o),
                                    ru(o, g, null, f);
                                    var z = o.memoizedState;
                                    if (g = z.cache,
                                    pl(o, Pi, g),
                                    g !== w.cache && Rh(o, [Pi], f, !0),
                                    Lh(),
                                    g = z.element,
                                    w.isDehydrated)
                                        if (w = {
                                            element: g,
                                            isDehydrated: !1,
                                            cache: z.cache
                                        },
                                        o.updateQueue.baseState = w,
                                        o.memoizedState = w,
                                        o.flags & 256) {
                                            o = Tl(a, o, g, f);
                                            break e
                                        } else if (g !== S) {
                                            S = ds(Error(s(424)), o),
                                            $l(S),
                                            o = Tl(a, o, g, f);
                                            break e
                                        } else {
                                            switch (a = o.stateNode.containerInfo,
                                            a.nodeType) {
                                            case 9:
                                                a = a.body;
                                                break;
                                            default:
                                                a = a.nodeName === "HTML" ? a.ownerDocument.body : a
                                            }
                                            for (di = Io(a.firstChild),
                                            Ls = o,
                                            bn = !0,
                                            ka = null,
                                            _a = !0,
                                            f = oy(o, null, g, f),
                                            o.child = f; f; )
                                                f.flags = f.flags & -3 | 4096,
                                                f = f.sibling
                                        }
                                    else {
                                        if (eu(),
                                        g === S) {
                                            o = ns(a, o, f);
                                            break e
                                        }
                                        Ci(a, o, g, f)
                                    }
                                    o = o.child
                                }
                                return o;
                            case 26:
                                return rc(a, o),
                                a === null ? (f = Hb(o.type, null, o.pendingProps, null)) ? o.memoizedState = f : bn || (f = o.type,
                                a = o.pendingProps,
                                g = yy(be.current).createElement(f),
                                g[Ti] = o,
                                g[ki] = a,
                                ks(g, f, a),
                                Bi(g),
                                o.stateNode = g) : o.memoizedState = Hb(o.type, a.memoizedProps, o.pendingProps, a.memoizedState),
                                null;
                            case 27:
                                return Et(o),
                                a === null && bn && (g = o.stateNode = Lb(o.type, o.pendingProps, be.current),
                                Ls = o,
                                _a = !0,
                                S = di,
                                Mu(o.type) ? (QS = S,
                                di = Io(g.firstChild)) : di = S),
                                Ci(a, o, o.pendingProps.children, f),
                                rc(a, o),
                                a === null && (o.flags |= 4194304),
                                o.child;
                            case 5:
                                return a === null && bn && ((S = g = di) && (g = f3(g, o.type, o.pendingProps, _a),
                                g !== null ? (o.stateNode = g,
                                Ls = o,
                                di = Io(g.firstChild),
                                _a = !1,
                                S = !0) : S = !1),
                                S || fl(o)),
                                Et(o),
                                S = o.type,
                                w = o.pendingProps,
                                z = a !== null ? a.memoizedProps : null,
                                g = w.children,
                                qS(S, w) ? g = null : z !== null && qS(S, z) && (o.flags |= 32),
                                o.memoizedState !== null && (S = Co(a, o, CS, null, null, f),
                                Eg._currentValue = S),
                                rc(a, o),
                                Ci(a, o, g, f),
                                o.child;
                            case 6:
                                return a === null && bn && ((a = f = di) && (f = d3(f, o.pendingProps, _a),
                                f !== null ? (o.stateNode = f,
                                Ls = o,
                                di = null,
                                a = !0) : a = !1),
                                a || fl(o)),
                                null;
                            case 13:
                                return pu(a, o, f);
                            case 4:
                                return $e(o, o.stateNode.containerInfo),
                                g = o.pendingProps,
                                a === null ? o.child = nc(o, null, g, f) : Ci(a, o, g, f),
                                o.child;
                            case 11:
                                return na(a, o, o.type, o.pendingProps, f);
                            case 7:
                                return Ci(a, o, o.pendingProps, f),
                                o.child;
                            case 8:
                                return Ci(a, o, o.pendingProps.children, f),
                                o.child;
                            case 12:
                                return Ci(a, o, o.pendingProps.children, f),
                                o.child;
                            case 10:
                                return g = o.pendingProps,
                                pl(o, o.type, g.value),
                                Ci(a, o, g.children, f),
                                o.child;
                            case 9:
                                return S = o.type._context,
                                g = o.pendingProps.children,
                                Gr(o),
                                S = vi(S),
                                g = g(S),
                                o.flags |= 1,
                                Ci(a, o, g, f),
                                o.child;
                            case 14:
                                return ia(a, o, o.type, o.pendingProps, f);
                            case 15:
                                return mg(a, o, o.type, o.pendingProps, f);
                            case 19:
                                return Qa(a, o, f);
                            case 31:
                                return g = o.pendingProps,
                                f = o.mode,
                                g = {
                                    mode: g.mode,
                                    children: g.children
                                },
                                a === null ? (f = oc(g, f),
                                f.ref = o.ref,
                                o.child = f,
                                f.return = o,
                                o = f) : (f = bi(a.child, g),
                                f.ref = o.ref,
                                o.child = f,
                                f.return = o,
                                o = f),
                                o;
                            case 22:
                                return sc(a, o, f);
                            case 24:
                                return Gr(o),
                                g = vi(Pi),
                                a === null ? (S = ml(),
                                S === null && (S = jt,
                                w = yd(),
                                S.pooledCache = w,
                                w.refCount++,
                                w !== null && (S.pooledCacheLanes |= f),
                                S = w),
                                o.memoizedState = {
                                    parent: g,
                                    cache: S
                                },
                                Qm(o),
                                pl(o, Pi, S)) : ((a.lanes & f) !== 0 && (Vt(a, o),
                                ru(o, null, null, f),
                                Lh()),
                                S = a.memoizedState,
                                w = o.memoizedState,
                                S.parent !== g ? (S = {
                                    parent: g,
                                    cache: g
                                },
                                o.memoizedState = S,
                                o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = S),
                                pl(o, Pi, g)) : (g = w.cache,
                                pl(o, Pi, g),
                                g !== S.cache && Rh(o, [Pi], f, !0))),
                                Ci(a, o, o.pendingProps.children, f),
                                o.child;
                            case 29:
                                throw o.pendingProps
                            }
                            throw Error(s(156, o.tag))
                        }
                        function xr(a) {
                            a.flags |= 4
                        }
                        function qh(a, o) {
                            if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0)
                                a.flags &= -16777217;
                            else if (a.flags |= 16777216,
                            !qb(o)) {
                                if (o = kn.current,
                                o !== null && ((Bt & 4194048) === Bt ? vr !== null : (Bt & 62914560) !== Bt && (Bt & 536870912) === 0 || o !== vr))
                                    throw Ya = Ih,
                                    Wm;
                                a.flags |= 8192
                            }
                        }
                        function Oo(a, o) {
                            o !== null && (a.flags |= 4),
                            a.flags & 16384 && (o = a.tag !== 22 ? tt() : 536870912,
                            a.lanes |= o,
                            Sn |= o)
                        }
                        function cc(a, o) {
                            if (!bn)
                                switch (a.tailMode) {
                                case "hidden":
                                    o = a.tail;
                                    for (var f = null; o !== null; )
                                        o.alternate !== null && (f = o),
                                        o = o.sibling;
                                    f === null ? a.tail = null : f.sibling = null;
                                    break;
                                case "collapsed":
                                    f = a.tail;
                                    for (var g = null; f !== null; )
                                        f.alternate !== null && (g = f),
                                        f = f.sibling;
                                    g === null ? o || a.tail === null ? a.tail = null : a.tail.sibling = null : g.sibling = null
                                }
                        }
                        function Zn(a) {
                            var o = a.alternate !== null && a.alternate.child === a.child
                              , f = 0
                              , g = 0;
                            if (o)
                                for (var S = a.child; S !== null; )
                                    f |= S.lanes | S.childLanes,
                                    g |= S.subtreeFlags & 65011712,
                                    g |= S.flags & 65011712,
                                    S.return = a,
                                    S = S.sibling;
                            else
                                for (S = a.child; S !== null; )
                                    f |= S.lanes | S.childLanes,
                                    g |= S.subtreeFlags,
                                    g |= S.flags,
                                    S.return = a,
                                    S = S.sibling;
                            return a.subtreeFlags |= g,
                            a.childLanes = f,
                            o
                        }
                        function gg(a, o, f) {
                            var g = o.pendingProps;
                            switch (Gm(o),
                            o.tag) {
                            case 31:
                            case 16:
                            case 15:
                            case 0:
                            case 11:
                            case 7:
                            case 8:
                            case 12:
                            case 9:
                            case 14:
                                return Zn(o),
                                null;
                            case 1:
                                return Zn(o),
                                null;
                            case 3:
                                return f = o.stateNode,
                                g = null,
                                a !== null && (g = a.memoizedState.cache),
                                o.memoizedState.cache !== g && (o.flags |= 2048),
                                Mo(Pi),
                                rt(),
                                f.pendingContext && (f.context = f.pendingContext,
                                f.pendingContext = null),
                                (a === null || a.child === null) && (pr(o) ? xr(o) : a === null || a.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024,
                                Rn())),
                                Zn(o),
                                null;
                            case 26:
                                return f = o.memoizedState,
                                a === null ? (xr(o),
                                f !== null ? (Zn(o),
                                qh(o, f)) : (Zn(o),
                                o.flags &= -16777217)) : f ? f !== a.memoizedState ? (xr(o),
                                Zn(o),
                                qh(o, f)) : (Zn(o),
                                o.flags &= -16777217) : (a.memoizedProps !== g && xr(o),
                                Zn(o),
                                o.flags &= -16777217),
                                null;
                            case 27:
                                ne(o),
                                f = be.current;
                                var S = o.type;
                                if (a !== null && o.stateNode != null)
                                    a.memoizedProps !== g && xr(o);
                                else {
                                    if (!g) {
                                        if (o.stateNode === null)
                                            throw Error(s(166));
                                        return Zn(o),
                                        null
                                    }
                                    a = le.current,
                                    pr(o) ? b0(o, a) : (a = Lb(S, g, f),
                                    o.stateNode = a,
                                    xr(o))
                                }
                                return Zn(o),
                                null;
                            case 5:
                                if (ne(o),
                                f = o.type,
                                a !== null && o.stateNode != null)
                                    a.memoizedProps !== g && xr(o);
                                else {
                                    if (!g) {
                                        if (o.stateNode === null)
                                            throw Error(s(166));
                                        return Zn(o),
                                        null
                                    }
                                    if (a = le.current,
                                    pr(o))
                                        b0(o, a);
                                    else {
                                        switch (S = yy(be.current),
                                        a) {
                                        case 1:
                                            a = S.createElementNS("http://www.w3.org/2000/svg", f);
                                            break;
                                        case 2:
                                            a = S.createElementNS("http://www.w3.org/1998/Math/MathML", f);
                                            break;
                                        default:
                                            switch (f) {
                                            case "svg":
                                                a = S.createElementNS("http://www.w3.org/2000/svg", f);
                                                break;
                                            case "math":
                                                a = S.createElementNS("http://www.w3.org/1998/Math/MathML", f);
                                                break;
                                            case "script":
                                                a = S.createElement("div"),
                                                a.innerHTML = "<script><\/script>",
                                                a = a.removeChild(a.firstChild);
                                                break;
                                            case "select":
                                                a = typeof g.is == "string" ? S.createElement("select", {
                                                    is: g.is
                                                }) : S.createElement("select"),
                                                g.multiple ? a.multiple = !0 : g.size && (a.size = g.size);
                                                break;
                                            default:
                                                a = typeof g.is == "string" ? S.createElement(f, {
                                                    is: g.is
                                                }) : S.createElement(f)
                                            }
                                        }
                                        a[Ti] = o,
                                        a[ki] = g;
                                        e: for (S = o.child; S !== null; ) {
                                            if (S.tag === 5 || S.tag === 6)
                                                a.appendChild(S.stateNode);
                                            else if (S.tag !== 4 && S.tag !== 27 && S.child !== null) {
                                                S.child.return = S,
                                                S = S.child;
                                                continue
                                            }
                                            if (S === o)
                                                break e;
                                            for (; S.sibling === null; ) {
                                                if (S.return === null || S.return === o)
                                                    break e;
                                                S = S.return
                                            }
                                            S.sibling.return = S.return,
                                            S = S.sibling
                                        }
                                        o.stateNode = a;
                                        e: switch (ks(a, f, g),
                                        f) {
                                        case "button":
                                        case "input":
                                        case "select":
                                        case "textarea":
                                            a = !!g.autoFocus;
                                            break e;
                                        case "img":
                                            a = !0;
                                            break e;
                                        default:
                                            a = !1
                                        }
                                        a && xr(o)
                                    }
                                }
                                return Zn(o),
                                o.flags &= -16777217,
                                null;
                            case 6:
                                if (a && o.stateNode != null)
                                    a.memoizedProps !== g && xr(o);
                                else {
                                    if (typeof g != "string" && o.stateNode === null)
                                        throw Error(s(166));
                                    if (a = be.current,
                                    pr(o)) {
                                        if (a = o.stateNode,
                                        f = o.memoizedProps,
                                        g = null,
                                        S = Ls,
                                        S !== null)
                                            switch (S.tag) {
                                            case 27:
                                            case 5:
                                                g = S.memoizedProps
                                            }
                                        a[Ti] = o,
                                        a = !!(a.nodeValue === f || g !== null && g.suppressHydrationWarning === !0 || Db(a.nodeValue, f)),
                                        a || fl(o)
                                    } else
                                        a = yy(a).createTextNode(g),
                                        a[Ti] = o,
                                        o.stateNode = a
                                }
                                return Zn(o),
                                null;
                            case 13:
                                if (g = o.memoizedState,
                                a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
                                    if (S = pr(o),
                                    g !== null && g.dehydrated !== null) {
                                        if (a === null) {
                                            if (!S)
                                                throw Error(s(318));
                                            if (S = o.memoizedState,
                                            S = S !== null ? S.dehydrated : null,
                                            !S)
                                                throw Error(s(317));
                                            S[Ti] = o
                                        } else
                                            eu(),
                                            (o.flags & 128) === 0 && (o.memoizedState = null),
                                            o.flags |= 4;
                                        Zn(o),
                                        S = !1
                                    } else
                                        S = Rn(),
                                        a !== null && a.memoizedState !== null && (a.memoizedState.hydrationErrors = S),
                                        S = !0;
                                    if (!S)
                                        return o.flags & 256 ? (kr(o),
                                        o) : (kr(o),
                                        null)
                                }
                                if (kr(o),
                                (o.flags & 128) !== 0)
                                    return o.lanes = f,
                                    o;
                                if (f = g !== null,
                                a = a !== null && a.memoizedState !== null,
                                f) {
                                    g = o.child,
                                    S = null,
                                    g.alternate !== null && g.alternate.memoizedState !== null && g.alternate.memoizedState.cachePool !== null && (S = g.alternate.memoizedState.cachePool.pool);
                                    var w = null;
                                    g.memoizedState !== null && g.memoizedState.cachePool !== null && (w = g.memoizedState.cachePool.pool),
                                    w !== S && (g.flags |= 2048)
                                }
                                return f !== a && f && (o.child.flags |= 8192),
                                Oo(o, o.updateQueue),
                                Zn(o),
                                null;
                            case 4:
                                return rt(),
                                a === null && Eb(o.stateNode.containerInfo),
                                Zn(o),
                                null;
                            case 10:
                                return Mo(o.type),
                                Zn(o),
                                null;
                            case 19:
                                if (ze(wi),
                                S = o.memoizedState,
                                S === null)
                                    return Zn(o),
                                    null;
                                if (g = (o.flags & 128) !== 0,
                                w = S.rendering,
                                w === null)
                                    if (g)
                                        cc(S, !1);
                                    else {
                                        if (ai !== 0 || a !== null && (a.flags & 128) !== 0)
                                            for (a = o.child; a !== null; ) {
                                                if (w = Do(a),
                                                w !== null) {
                                                    for (o.flags |= 128,
                                                    cc(S, !1),
                                                    a = w.updateQueue,
                                                    o.updateQueue = a,
                                                    Oo(o, a),
                                                    o.subtreeFlags = 0,
                                                    a = f,
                                                    f = o.child; f !== null; )
                                                        Hm(f, a),
                                                        f = f.sibling;
                                                    return xe(wi, wi.current & 1 | 2),
                                                    o.child
                                                }
                                                a = a.sibling
                                            }
                                        S.tail !== null && Ie() > Cs && (o.flags |= 128,
                                        g = !0,
                                        cc(S, !1),
                                        o.lanes = 4194304)
                                    }
                                else {
                                    if (!g)
                                        if (a = Do(w),
                                        a !== null) {
                                            if (o.flags |= 128,
                                            g = !0,
                                            a = a.updateQueue,
                                            o.updateQueue = a,
                                            Oo(o, a),
                                            cc(S, !0),
                                            S.tail === null && S.tailMode === "hidden" && !w.alternate && !bn)
                                                return Zn(o),
                                                null
                                        } else
                                            2 * Ie() - S.renderingStartTime > Cs && f !== 536870912 && (o.flags |= 128,
                                            g = !0,
                                            cc(S, !1),
                                            o.lanes = 4194304);
                                    S.isBackwards ? (w.sibling = o.child,
                                    o.child = w) : (a = S.last,
                                    a !== null ? a.sibling = w : o.child = w,
                                    S.last = w)
                                }
                                return S.tail !== null ? (o = S.tail,
                                S.rendering = o,
                                S.tail = o.sibling,
                                S.renderingStartTime = Ie(),
                                o.sibling = null,
                                a = wi.current,
                                xe(wi, g ? a & 1 | 2 : a & 1),
                                o) : (Zn(o),
                                null);
                            case 22:
                            case 23:
                                return kr(o),
                                zh(),
                                g = o.memoizedState !== null,
                                a !== null ? a.memoizedState !== null !== g && (o.flags |= 8192) : g && (o.flags |= 8192),
                                g ? (f & 536870912) !== 0 && (o.flags & 128) === 0 && (Zn(o),
                                o.subtreeFlags & 6 && (o.flags |= 8192)) : Zn(o),
                                f = o.updateQueue,
                                f !== null && Oo(o, f.retryQueue),
                                f = null,
                                a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool),
                                g = null,
                                o.memoizedState !== null && o.memoizedState.cachePool !== null && (g = o.memoizedState.cachePool.pool),
                                g !== f && (o.flags |= 2048),
                                a !== null && ze(qa),
                                null;
                            case 24:
                                return f = null,
                                a !== null && (f = a.memoizedState.cache),
                                o.memoizedState.cache !== f && (o.flags |= 2048),
                                Mo(Pi),
                                Zn(o),
                                null;
                            case 25:
                                return null;
                            case 30:
                                return null
                            }
                            throw Error(s(156, o.tag))
                        }
                        function mu(a, o) {
                            switch (Gm(o),
                            o.tag) {
                            case 1:
                                return a = o.flags,
                                a & 65536 ? (o.flags = a & -65537 | 128,
                                o) : null;
                            case 3:
                                return Mo(Pi),
                                rt(),
                                a = o.flags,
                                (a & 65536) !== 0 && (a & 128) === 0 ? (o.flags = a & -65537 | 128,
                                o) : null;
                            case 26:
                            case 27:
                            case 5:
                                return ne(o),
                                null;
                            case 13:
                                if (kr(o),
                                a = o.memoizedState,
                                a !== null && a.dehydrated !== null) {
                                    if (o.alternate === null)
                                        throw Error(s(340));
                                    eu()
                                }
                                return a = o.flags,
                                a & 65536 ? (o.flags = a & -65537 | 128,
                                o) : null;
                            case 19:
                                return ze(wi),
                                null;
                            case 4:
                                return rt(),
                                null;
                            case 10:
                                return Mo(o.type),
                                null;
                            case 22:
                            case 23:
                                return kr(o),
                                zh(),
                                a !== null && ze(qa),
                                a = o.flags,
                                a & 65536 ? (o.flags = a & -65537 | 128,
                                o) : null;
                            case 24:
                                return Mo(Pi),
                                null;
                            case 25:
                                return null;
                            default:
                                return null
                            }
                        }
                        function gu(a, o) {
                            switch (Gm(o),
                            o.tag) {
                            case 3:
                                Mo(Pi),
                                rt();
                                break;
                            case 26:
                            case 27:
                            case 5:
                                ne(o);
                                break;
                            case 4:
                                rt();
                                break;
                            case 13:
                                kr(o);
                                break;
                            case 19:
                                ze(wi);
                                break;
                            case 10:
                                Mo(o.type);
                                break;
                            case 22:
                            case 23:
                                kr(o),
                                zh(),
                                a !== null && ze(qa);
                                break;
                            case 24:
                                Mo(Pi)
                            }
                        }
                        function uc(a, o) {
                            try {
                                var f = o.updateQueue
                                  , g = f !== null ? f.lastEffect : null;
                                if (g !== null) {
                                    var S = g.next;
                                    f = S;
                                    do {
                                        if ((f.tag & a) === a) {
                                            g = void 0;
                                            var w = f.create
                                              , z = f.inst;
                                            g = w(),
                                            z.destroy = g
                                        }
                                        f = f.next
                                    } while (f !== S)
                                }
                            } catch (Y) {
                                ue(o, o.return, Y)
                            }
                        }
                        function Ma(a, o, f) {
                            try {
                                var g = o.updateQueue
                                  , S = g !== null ? g.lastEffect : null;
                                if (S !== null) {
                                    var w = S.next;
                                    g = w;
                                    do {
                                        if ((g.tag & a) === a) {
                                            var z = g.inst
                                              , Y = z.destroy;
                                            if (Y !== void 0) {
                                                z.destroy = void 0,
                                                S = o;
                                                var re = f
                                                  , Ae = Y;
                                                try {
                                                    Ae()
                                                } catch (qe) {
                                                    ue(S, re, qe)
                                                }
                                            }
                                        }
                                        g = g.next
                                    } while (g !== w)
                                }
                            } catch (qe) {
                                ue(o, o.return, qe)
                            }
                        }
                        function hc(a) {
                            var o = a.updateQueue;
                            if (o !== null) {
                                var f = a.stateNode;
                                try {
                                    C0(o, f)
                                } catch (g) {
                                    ue(a, a.return, g)
                                }
                            }
                        }
                        function No(a, o, f) {
                            f.props = Xr(a.type, a.memoizedProps),
                            f.state = a.memoizedState;
                            try {
                                f.componentWillUnmount()
                            } catch (g) {
                                ue(a, o, g)
                            }
                        }
                        function fc(a, o) {
                            try {
                                var f = a.ref;
                                if (f !== null) {
                                    switch (a.tag) {
                                    case 26:
                                    case 27:
                                    case 5:
                                        var g = a.stateNode;
                                        break;
                                    case 30:
                                        g = a.stateNode;
                                        break;
                                    default:
                                        g = a.stateNode
                                    }
                                    typeof f == "function" ? a.refCleanup = f(g) : f.current = g
                                }
                            } catch (S) {
                                ue(a, o, S)
                            }
                        }
                        function Yr(a, o) {
                            var f = a.ref
                              , g = a.refCleanup;
                            if (f !== null)
                                if (typeof g == "function")
                                    try {
                                        g()
                                    } catch (S) {
                                        ue(a, o, S)
                                    } finally {
                                        a.refCleanup = null,
                                        a = a.alternate,
                                        a != null && (a.refCleanup = null)
                                    }
                                else if (typeof f == "function")
                                    try {
                                        f(null)
                                    } catch (S) {
                                        ue(a, o, S)
                                    }
                                else
                                    f.current = null
                        }
                        function vu(a) {
                            var o = a.type
                              , f = a.memoizedProps
                              , g = a.stateNode;
                            try {
                                e: switch (o) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    f.autoFocus && g.focus();
                                    break e;
                                case "img":
                                    f.src ? g.src = f.src : f.srcSet && (g.srcset = f.srcSet)
                                }
                            } catch (S) {
                                ue(a, a.return, S)
                            }
                        }
                        function Yh(a, o, f) {
                            try {
                                var g = a.stateNode;
                                o3(g, a.type, f, o),
                                g[ki] = o
                            } catch (S) {
                                ue(a, a.return, S)
                            }
                        }
                        function Wh(a) {
                            return a.tag === 5 || a.tag === 3 || a.tag === 26 || a.tag === 27 && Mu(a.type) || a.tag === 4
                        }
                        function Ml(a) {
                            e: for (; ; ) {
                                for (; a.sibling === null; ) {
                                    if (a.return === null || Wh(a.return))
                                        return null;
                                    a = a.return
                                }
                                for (a.sibling.return = a.return,
                                a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
                                    if (a.tag === 27 && Mu(a.type) || a.flags & 2 || a.child === null || a.tag === 4)
                                        continue e;
                                    a.child.return = a,
                                    a = a.child
                                }
                                if (!(a.flags & 2))
                                    return a.stateNode
                            }
                        }
                        function bl(a, o, f) {
                            var g = a.tag;
                            if (g === 5 || g === 6)
                                a = a.stateNode,
                                o ? (f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f).insertBefore(a, o) : (o = f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f,
                                o.appendChild(a),
                                f = f._reactRootContainer,
                                f != null || o.onclick !== null || (o.onclick = vy));
                            else if (g !== 4 && (g === 27 && Mu(a.type) && (f = a.stateNode,
                            o = null),
                            a = a.child,
                            a !== null))
                                for (bl(a, o, f),
                                a = a.sibling; a !== null; )
                                    bl(a, o, f),
                                    a = a.sibling
                        }
                        function El(a, o, f) {
                            var g = a.tag;
                            if (g === 5 || g === 6)
                                a = a.stateNode,
                                o ? f.insertBefore(a, o) : f.appendChild(a);
                            else if (g !== 4 && (g === 27 && Mu(a.type) && (f = a.stateNode),
                            a = a.child,
                            a !== null))
                                for (El(a, o, f),
                                a = a.sibling; a !== null; )
                                    El(a, o, f),
                                    a = a.sibling
                        }
                        function wl(a) {
                            var o = a.stateNode
                              , f = a.memoizedProps;
                            try {
                                for (var g = a.type, S = o.attributes; S.length; )
                                    o.removeAttributeNode(S[0]);
                                ks(o, g, f),
                                o[Ti] = a,
                                o[ki] = f
                            } catch (w) {
                                ue(a, a.return, w)
                            }
                        }
                        var Wr = !1
                          , Kn = !1
                          , yu = !1
                          , ba = typeof WeakSet == "function" ? WeakSet : Set
                          , Xn = null;
                        function Yi(a, o) {
                            if (a = a.containerInfo,
                            kS = My,
                            a = Um(a),
                            Ah(a)) {
                                if ("selectionStart"in a)
                                    var f = {
                                        start: a.selectionStart,
                                        end: a.selectionEnd
                                    };
                                else
                                    e: {
                                        f = (f = a.ownerDocument) && f.defaultView || window;
                                        var g = f.getSelection && f.getSelection();
                                        if (g && g.rangeCount !== 0) {
                                            f = g.anchorNode;
                                            var S = g.anchorOffset
                                              , w = g.focusNode;
                                            g = g.focusOffset;
                                            try {
                                                f.nodeType,
                                                w.nodeType
                                            } catch {
                                                f = null;
                                                break e
                                            }
                                            var z = 0
                                              , Y = -1
                                              , re = -1
                                              , Ae = 0
                                              , qe = 0
                                              , je = a
                                              , we = null;
                                            t: for (; ; ) {
                                                for (var De; je !== f || S !== 0 && je.nodeType !== 3 || (Y = z + S),
                                                je !== w || g !== 0 && je.nodeType !== 3 || (re = z + g),
                                                je.nodeType === 3 && (z += je.nodeValue.length),
                                                (De = je.firstChild) !== null; )
                                                    we = je,
                                                    je = De;
                                                for (; ; ) {
                                                    if (je === a)
                                                        break t;
                                                    if (we === f && ++Ae === S && (Y = z),
                                                    we === w && ++qe === g && (re = z),
                                                    (De = je.nextSibling) !== null)
                                                        break;
                                                    je = we,
                                                    we = je.parentNode
                                                }
                                                je = De
                                            }
                                            f = Y === -1 || re === -1 ? null : {
                                                start: Y,
                                                end: re
                                            }
                                        } else
                                            f = null
                                    }
                                f = f || {
                                    start: 0,
                                    end: 0
                                }
                            } else
                                f = null;
                            for (XS = {
                                focusedElem: a,
                                selectionRange: f
                            },
                            My = !1,
                            Xn = o; Xn !== null; )
                                if (o = Xn,
                                a = o.child,
                                (o.subtreeFlags & 1024) !== 0 && a !== null)
                                    a.return = o,
                                    Xn = a;
                                else
                                    for (; Xn !== null; ) {
                                        switch (o = Xn,
                                        w = o.alternate,
                                        a = o.flags,
                                        o.tag) {
                                        case 0:
                                            break;
                                        case 11:
                                        case 15:
                                            break;
                                        case 1:
                                            if ((a & 1024) !== 0 && w !== null) {
                                                a = void 0,
                                                f = o,
                                                S = w.memoizedProps,
                                                w = w.memoizedState,
                                                g = f.stateNode;
                                                try {
                                                    var qt = Xr(f.type, S, f.elementType === f.type);
                                                    a = g.getSnapshotBeforeUpdate(qt, w),
                                                    g.__reactInternalSnapshotBeforeUpdate = a
                                                } catch (Ft) {
                                                    ue(f, f.return, Ft)
                                                }
                                            }
                                            break;
                                        case 3:
                                            if ((a & 1024) !== 0) {
                                                if (a = o.stateNode.containerInfo,
                                                f = a.nodeType,
                                                f === 9)
                                                    WS(a);
                                                else if (f === 1)
                                                    switch (a.nodeName) {
                                                    case "HEAD":
                                                    case "HTML":
                                                    case "BODY":
                                                        WS(a);
                                                        break;
                                                    default:
                                                        a.textContent = ""
                                                    }
                                            }
                                            break;
                                        case 5:
                                        case 26:
                                        case 27:
                                        case 6:
                                        case 4:
                                        case 17:
                                            break;
                                        default:
                                            if ((a & 1024) !== 0)
                                                throw Error(s(163))
                                        }
                                        if (a = o.sibling,
                                        a !== null) {
                                            a.return = o.return,
                                            Xn = a;
                                            break
                                        }
                                        Xn = o.return
                                    }
                        }
                        function Uo(a, o, f) {
                            var g = f.flags;
                            switch (f.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Vs(a, f),
                                g & 4 && uc(5, f);
                                break;
                            case 1:
                                if (Vs(a, f),
                                g & 4)
                                    if (a = f.stateNode,
                                    o === null)
                                        try {
                                            a.componentDidMount()
                                        } catch (z) {
                                            ue(f, f.return, z)
                                        }
                                    else {
                                        var S = Xr(f.type, o.memoizedProps);
                                        o = o.memoizedState;
                                        try {
                                            a.componentDidUpdate(S, o, a.__reactInternalSnapshotBeforeUpdate)
                                        } catch (z) {
                                            ue(f, f.return, z)
                                        }
                                    }
                                g & 64 && hc(f),
                                g & 512 && fc(f, f.return);
                                break;
                            case 3:
                                if (Vs(a, f),
                                g & 64 && (a = f.updateQueue,
                                a !== null)) {
                                    if (o = null,
                                    f.child !== null)
                                        switch (f.child.tag) {
                                        case 27:
                                        case 5:
                                            o = f.child.stateNode;
                                            break;
                                        case 1:
                                            o = f.child.stateNode
                                        }
                                    try {
                                        C0(a, o)
                                    } catch (z) {
                                        ue(f, f.return, z)
                                    }
                                }
                                break;
                            case 27:
                                o === null && g & 4 && wl(f);
                            case 26:
                            case 5:
                                Vs(a, f),
                                o === null && g & 4 && vu(f),
                                g & 512 && fc(f, f.return);
                                break;
                            case 12:
                                Vs(a, f);
                                break;
                            case 13:
                                Vs(a, f),
                                g & 4 && Cl(a, f),
                                g & 64 && (a = f.memoizedState,
                                a !== null && (a = a.dehydrated,
                                a !== null && (f = ri.bind(null, f),
                                p3(a, f))));
                                break;
                            case 22:
                                if (g = f.memoizedState !== null || Wr,
                                !g) {
                                    o = o !== null && o.memoizedState !== null || Kn,
                                    S = Wr;
                                    var w = Kn;
                                    Wr = g,
                                    (Kn = o) && !w ? jr(a, f, (f.subtreeFlags & 8772) !== 0) : Vs(a, f),
                                    Wr = S,
                                    Kn = w
                                }
                                break;
                            case 30:
                                break;
                            default:
                                Vs(a, f)
                            }
                        }
                        function nn(a) {
                            var o = a.alternate;
                            o !== null && (a.alternate = null,
                            nn(o)),
                            a.child = null,
                            a.deletions = null,
                            a.sibling = null,
                            a.tag === 5 && (o = a.stateNode,
                            o !== null && si(o)),
                            a.stateNode = null,
                            a.return = null,
                            a.dependencies = null,
                            a.memoizedProps = null,
                            a.memoizedState = null,
                            a.pendingProps = null,
                            a.stateNode = null,
                            a.updateQueue = null
                        }
                        var It = null
                          , xn = !1;
                        function Ka(a, o, f) {
                            for (f = f.child; f !== null; )
                                dc(a, o, f),
                                f = f.sibling
                        }
                        function dc(a, o, f) {
                            if (Be && typeof Be.onCommitFiberUnmount == "function")
                                try {
                                    Be.onCommitFiberUnmount(Qe, f)
                                } catch {}
                            switch (f.tag) {
                            case 26:
                                Kn || Yr(f, o),
                                Ka(a, o, f),
                                f.memoizedState ? f.memoizedState.count-- : f.stateNode && (f = f.stateNode,
                                f.parentNode.removeChild(f));
                                break;
                            case 27:
                                Kn || Yr(f, o);
                                var g = It
                                  , S = xn;
                                Mu(f.type) && (It = f.stateNode,
                                xn = !1),
                                Ka(a, o, f),
                                Ag(f.stateNode),
                                It = g,
                                xn = S;
                                break;
                            case 5:
                                Kn || Yr(f, o);
                            case 6:
                                if (g = It,
                                S = xn,
                                It = null,
                                Ka(a, o, f),
                                It = g,
                                xn = S,
                                It !== null)
                                    if (xn)
                                        try {
                                            (It.nodeType === 9 ? It.body : It.nodeName === "HTML" ? It.ownerDocument.body : It).removeChild(f.stateNode)
                                        } catch (w) {
                                            ue(f, o, w)
                                        }
                                    else
                                        try {
                                            It.removeChild(f.stateNode)
                                        } catch (w) {
                                            ue(f, o, w)
                                        }
                                break;
                            case 18:
                                It !== null && (xn ? (a = It,
                                Pb(a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a, f.stateNode),
                                Dg(a)) : Pb(It, f.stateNode));
                                break;
                            case 4:
                                g = It,
                                S = xn,
                                It = f.stateNode.containerInfo,
                                xn = !0,
                                Ka(a, o, f),
                                It = g,
                                xn = S;
                                break;
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Kn || Ma(2, f, o),
                                Kn || Ma(4, f, o),
                                Ka(a, o, f);
                                break;
                            case 1:
                                Kn || (Yr(f, o),
                                g = f.stateNode,
                                typeof g.componentWillUnmount == "function" && No(f, o, g)),
                                Ka(a, o, f);
                                break;
                            case 21:
                                Ka(a, o, f);
                                break;
                            case 22:
                                Kn = (g = Kn) || f.memoizedState !== null,
                                Ka(a, o, f),
                                Kn = g;
                                break;
                            default:
                                Ka(a, o, f)
                            }
                        }
                        function Cl(a, o) {
                            if (o.memoizedState === null && (a = o.alternate,
                            a !== null && (a = a.memoizedState,
                            a !== null && (a = a.dehydrated,
                            a !== null))))
                                try {
                                    Dg(a)
                                } catch (f) {
                                    ue(o, o.return, f)
                                }
                        }
                        function Fd(a) {
                            switch (a.tag) {
                            case 13:
                            case 19:
                                var o = a.stateNode;
                                return o === null && (o = a.stateNode = new ba),
                                o;
                            case 22:
                                return a = a.stateNode,
                                o = a._retryCache,
                                o === null && (o = a._retryCache = new ba),
                                o;
                            default:
                                throw Error(s(435, a.tag))
                            }
                        }
                        function pc(a, o) {
                            var f = Fd(a);
                            o.forEach(function(g) {
                                var S = Gt.bind(null, a, g);
                                f.has(g) || (f.add(g),
                                g.then(S, S))
                            })
                        }
                        function is(a, o) {
                            var f = o.deletions;
                            if (f !== null)
                                for (var g = 0; g < f.length; g++) {
                                    var S = f[g]
                                      , w = a
                                      , z = o
                                      , Y = z;
                                    e: for (; Y !== null; ) {
                                        switch (Y.tag) {
                                        case 27:
                                            if (Mu(Y.type)) {
                                                It = Y.stateNode,
                                                xn = !1;
                                                break e
                                            }
                                            break;
                                        case 5:
                                            It = Y.stateNode,
                                            xn = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            It = Y.stateNode.containerInfo,
                                            xn = !0;
                                            break e
                                        }
                                        Y = Y.return
                                    }
                                    if (It === null)
                                        throw Error(s(160));
                                    dc(w, z, S),
                                    It = null,
                                    xn = !1,
                                    w = S.alternate,
                                    w !== null && (w.return = null),
                                    S.return = null
                                }
                            if (o.subtreeFlags & 13878)
                                for (o = o.child; o !== null; )
                                    Hd(o, a),
                                    o = o.sibling
                        }
                        var Sr = null;
                        function Hd(a, o) {
                            var f = a.alternate
                              , g = a.flags;
                            switch (a.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                is(o, a),
                                yi(a),
                                g & 4 && (Ma(3, a, a.return),
                                uc(3, a),
                                Ma(5, a, a.return));
                                break;
                            case 1:
                                is(o, a),
                                yi(a),
                                g & 512 && (Kn || f === null || Yr(f, f.return)),
                                g & 64 && Wr && (a = a.updateQueue,
                                a !== null && (g = a.callbacks,
                                g !== null && (f = a.shared.hiddenCallbacks,
                                a.shared.hiddenCallbacks = f === null ? g : f.concat(g))));
                                break;
                            case 26:
                                var S = Sr;
                                if (is(o, a),
                                yi(a),
                                g & 512 && (Kn || f === null || Yr(f, f.return)),
                                g & 4) {
                                    var w = f !== null ? f.memoizedState : null;
                                    if (g = a.memoizedState,
                                    f === null)
                                        if (g === null)
                                            if (a.stateNode === null) {
                                                e: {
                                                    g = a.type,
                                                    f = a.memoizedProps,
                                                    S = S.ownerDocument || S;
                                                    t: switch (g) {
                                                    case "title":
                                                        w = S.getElementsByTagName("title")[0],
                                                        (!w || w[cr] || w[Ti] || w.namespaceURI === "http://www.w3.org/2000/svg" || w.hasAttribute("itemprop")) && (w = S.createElement(g),
                                                        S.head.insertBefore(w, S.querySelector("head > title"))),
                                                        ks(w, g, f),
                                                        w[Ti] = a,
                                                        Bi(w),
                                                        g = w;
                                                        break e;
                                                    case "link":
                                                        var z = kb("link", "href", S).get(g + (f.href || ""));
                                                        if (z) {
                                                            for (var Y = 0; Y < z.length; Y++)
                                                                if (w = z[Y],
                                                                w.getAttribute("href") === (f.href == null || f.href === "" ? null : f.href) && w.getAttribute("rel") === (f.rel == null ? null : f.rel) && w.getAttribute("title") === (f.title == null ? null : f.title) && w.getAttribute("crossorigin") === (f.crossOrigin == null ? null : f.crossOrigin)) {
                                                                    z.splice(Y, 1);
                                                                    break t
                                                                }
                                                        }
                                                        w = S.createElement(g),
                                                        ks(w, g, f),
                                                        S.head.appendChild(w);
                                                        break;
                                                    case "meta":
                                                        if (z = kb("meta", "content", S).get(g + (f.content || ""))) {
                                                            for (Y = 0; Y < z.length; Y++)
                                                                if (w = z[Y],
                                                                w.getAttribute("content") === (f.content == null ? null : "" + f.content) && w.getAttribute("name") === (f.name == null ? null : f.name) && w.getAttribute("property") === (f.property == null ? null : f.property) && w.getAttribute("http-equiv") === (f.httpEquiv == null ? null : f.httpEquiv) && w.getAttribute("charset") === (f.charSet == null ? null : f.charSet)) {
                                                                    z.splice(Y, 1);
                                                                    break t
                                                                }
                                                        }
                                                        w = S.createElement(g),
                                                        ks(w, g, f),
                                                        S.head.appendChild(w);
                                                        break;
                                                    default:
                                                        throw Error(s(468, g))
                                                    }
                                                    w[Ti] = a,
                                                    Bi(w),
                                                    g = w
                                                }
                                                a.stateNode = g
                                            } else
                                                Xb(S, a.type, a.stateNode);
                                        else
                                            a.stateNode = Gb(S, g, a.memoizedProps);
                                    else
                                        w !== g ? (w === null ? f.stateNode !== null && (f = f.stateNode,
                                        f.parentNode.removeChild(f)) : w.count--,
                                        g === null ? Xb(S, a.type, a.stateNode) : Gb(S, g, a.memoizedProps)) : g === null && a.stateNode !== null && Yh(a, a.memoizedProps, f.memoizedProps)
                                }
                                break;
                            case 27:
                                is(o, a),
                                yi(a),
                                g & 512 && (Kn || f === null || Yr(f, f.return)),
                                f !== null && g & 4 && Yh(a, a.memoizedProps, f.memoizedProps);
                                break;
                            case 5:
                                if (is(o, a),
                                yi(a),
                                g & 512 && (Kn || f === null || Yr(f, f.return)),
                                a.flags & 32) {
                                    S = a.stateNode;
                                    try {
                                        fr(S, "")
                                    } catch (De) {
                                        ue(a, a.return, De)
                                    }
                                }
                                g & 4 && a.stateNode != null && (S = a.memoizedProps,
                                Yh(a, S, f !== null ? f.memoizedProps : S)),
                                g & 1024 && (yu = !0);
                                break;
                            case 6:
                                if (is(o, a),
                                yi(a),
                                g & 4) {
                                    if (a.stateNode === null)
                                        throw Error(s(162));
                                    g = a.memoizedProps,
                                    f = a.stateNode;
                                    try {
                                        f.nodeValue = g
                                    } catch (De) {
                                        ue(a, a.return, De)
                                    }
                                }
                                break;
                            case 3:
                                if (Sy = null,
                                S = Sr,
                                Sr = _y(o.containerInfo),
                                is(o, a),
                                Sr = S,
                                yi(a),
                                g & 4 && f !== null && f.memoizedState.isDehydrated)
                                    try {
                                        Dg(o.containerInfo)
                                    } catch (De) {
                                        ue(a, a.return, De)
                                    }
                                yu && (yu = !1,
                                Rl(a));
                                break;
                            case 4:
                                g = Sr,
                                Sr = _y(a.stateNode.containerInfo),
                                is(o, a),
                                yi(a),
                                Sr = g;
                                break;
                            case 12:
                                is(o, a),
                                yi(a);
                                break;
                            case 13:
                                is(o, a),
                                yi(a),
                                a.child.flags & 8192 && a.memoizedState !== null != (f !== null && f.memoizedState !== null) && (zn = Ie()),
                                g & 4 && (g = a.updateQueue,
                                g !== null && (a.updateQueue = null,
                                pc(a, g)));
                                break;
                            case 22:
                                S = a.memoizedState !== null;
                                var re = f !== null && f.memoizedState !== null
                                  , Ae = Wr
                                  , qe = Kn;
                                if (Wr = Ae || S,
                                Kn = qe || re,
                                is(o, a),
                                Kn = qe,
                                Wr = Ae,
                                yi(a),
                                g & 8192)
                                    e: for (o = a.stateNode,
                                    o._visibility = S ? o._visibility & -2 : o._visibility | 1,
                                    S && (f === null || re || Wr || Kn || Ea(a)),
                                    f = null,
                                    o = a; ; ) {
                                        if (o.tag === 5 || o.tag === 26) {
                                            if (f === null) {
                                                re = f = o;
                                                try {
                                                    if (w = re.stateNode,
                                                    S)
                                                        z = w.style,
                                                        typeof z.setProperty == "function" ? z.setProperty("display", "none", "important") : z.display = "none";
                                                    else {
                                                        Y = re.stateNode;
                                                        var je = re.memoizedProps.style
                                                          , we = je != null && je.hasOwnProperty("display") ? je.display : null;
                                                        Y.style.display = we == null || typeof we == "boolean" ? "" : ("" + we).trim()
                                                    }
                                                } catch (De) {
                                                    ue(re, re.return, De)
                                                }
                                            }
                                        } else if (o.tag === 6) {
                                            if (f === null) {
                                                re = o;
                                                try {
                                                    re.stateNode.nodeValue = S ? "" : re.memoizedProps
                                                } catch (De) {
                                                    ue(re, re.return, De)
                                                }
                                            }
                                        } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === a) && o.child !== null) {
                                            o.child.return = o,
                                            o = o.child;
                                            continue
                                        }
                                        if (o === a)
                                            break e;
                                        for (; o.sibling === null; ) {
                                            if (o.return === null || o.return === a)
                                                break e;
                                            f === o && (f = null),
                                            o = o.return
                                        }
                                        f === o && (f = null),
                                        o.sibling.return = o.return,
                                        o = o.sibling
                                    }
                                g & 4 && (g = a.updateQueue,
                                g !== null && (f = g.retryQueue,
                                f !== null && (g.retryQueue = null,
                                pc(a, f))));
                                break;
                            case 19:
                                is(o, a),
                                yi(a),
                                g & 4 && (g = a.updateQueue,
                                g !== null && (a.updateQueue = null,
                                pc(a, g)));
                                break;
                            case 30:
                                break;
                            case 21:
                                break;
                            default:
                                is(o, a),
                                yi(a)
                            }
                        }
                        function yi(a) {
                            var o = a.flags;
                            if (o & 2) {
                                try {
                                    for (var f, g = a.return; g !== null; ) {
                                        if (Wh(g)) {
                                            f = g;
                                            break
                                        }
                                        g = g.return
                                    }
                                    if (f == null)
                                        throw Error(s(160));
                                    switch (f.tag) {
                                    case 27:
                                        var S = f.stateNode
                                          , w = Ml(a);
                                        El(a, w, S);
                                        break;
                                    case 5:
                                        var z = f.stateNode;
                                        f.flags & 32 && (fr(z, ""),
                                        f.flags &= -33);
                                        var Y = Ml(a);
                                        El(a, Y, z);
                                        break;
                                    case 3:
                                    case 4:
                                        var re = f.stateNode.containerInfo
                                          , Ae = Ml(a);
                                        bl(a, Ae, re);
                                        break;
                                    default:
                                        throw Error(s(161))
                                    }
                                } catch (qe) {
                                    ue(a, a.return, qe)
                                }
                                a.flags &= -3
                            }
                            o & 4096 && (a.flags &= -4097)
                        }
                        function Rl(a) {
                            if (a.subtreeFlags & 1024)
                                for (a = a.child; a !== null; ) {
                                    var o = a;
                                    Rl(o),
                                    o.tag === 5 && o.flags & 1024 && o.stateNode.reset(),
                                    a = a.sibling
                                }
                        }
                        function Vs(a, o) {
                            if (o.subtreeFlags & 8772)
                                for (o = o.child; o !== null; )
                                    Uo(a, o.alternate, o),
                                    o = o.sibling
                        }
                        function Ea(a) {
                            for (a = a.child; a !== null; ) {
                                var o = a;
                                switch (o.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Ma(4, o, o.return),
                                    Ea(o);
                                    break;
                                case 1:
                                    Yr(o, o.return);
                                    var f = o.stateNode;
                                    typeof f.componentWillUnmount == "function" && No(o, o.return, f),
                                    Ea(o);
                                    break;
                                case 27:
                                    Ag(o.stateNode);
                                case 26:
                                case 5:
                                    Yr(o, o.return),
                                    Ea(o);
                                    break;
                                case 22:
                                    o.memoizedState === null && Ea(o);
                                    break;
                                case 30:
                                    Ea(o);
                                    break;
                                default:
                                    Ea(o)
                                }
                                a = a.sibling
                            }
                        }
                        function jr(a, o, f) {
                            for (f = f && (o.subtreeFlags & 8772) !== 0,
                            o = o.child; o !== null; ) {
                                var g = o.alternate
                                  , S = a
                                  , w = o
                                  , z = w.flags;
                                switch (w.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    jr(S, w, f),
                                    uc(4, w);
                                    break;
                                case 1:
                                    if (jr(S, w, f),
                                    g = w,
                                    S = g.stateNode,
                                    typeof S.componentDidMount == "function")
                                        try {
                                            S.componentDidMount()
                                        } catch (Ae) {
                                            ue(g, g.return, Ae)
                                        }
                                    if (g = w,
                                    S = g.updateQueue,
                                    S !== null) {
                                        var Y = g.stateNode;
                                        try {
                                            var re = S.shared.hiddenCallbacks;
                                            if (re !== null)
                                                for (S.shared.hiddenCallbacks = null,
                                                S = 0; S < re.length; S++)
                                                    ou(re[S], Y)
                                        } catch (Ae) {
                                            ue(g, g.return, Ae)
                                        }
                                    }
                                    f && z & 64 && hc(w),
                                    fc(w, w.return);
                                    break;
                                case 27:
                                    wl(w);
                                case 26:
                                case 5:
                                    jr(S, w, f),
                                    f && g === null && z & 4 && vu(w),
                                    fc(w, w.return);
                                    break;
                                case 12:
                                    jr(S, w, f);
                                    break;
                                case 13:
                                    jr(S, w, f),
                                    f && z & 4 && Cl(S, w);
                                    break;
                                case 22:
                                    w.memoizedState === null && jr(S, w, f),
                                    fc(w, w.return);
                                    break;
                                case 30:
                                    break;
                                default:
                                    jr(S, w, f)
                                }
                                o = o.sibling
                            }
                        }
                        function Vd(a, o) {
                            var f = null;
                            a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool),
                            a = null,
                            o.memoizedState !== null && o.memoizedState.cachePool !== null && (a = o.memoizedState.cachePool.pool),
                            a !== f && (a != null && a.refCount++,
                            f != null && tu(f))
                        }
                        function Gd(a, o) {
                            a = null,
                            o.alternate !== null && (a = o.alternate.memoizedState.cache),
                            o = o.memoizedState.cache,
                            o !== a && (o.refCount++,
                            a != null && tu(a))
                        }
                        function qn(a, o, f, g) {
                            if (o.subtreeFlags & 10256)
                                for (o = o.child; o !== null; )
                                    kd(a, o, f, g),
                                    o = o.sibling
                        }
                        function kd(a, o, f, g) {
                            var S = o.flags;
                            switch (o.tag) {
                            case 0:
                            case 11:
                            case 15:
                                qn(a, o, f, g),
                                S & 2048 && uc(9, o);
                                break;
                            case 1:
                                qn(a, o, f, g);
                                break;
                            case 3:
                                qn(a, o, f, g),
                                S & 2048 && (a = null,
                                o.alternate !== null && (a = o.alternate.memoizedState.cache),
                                o = o.memoizedState.cache,
                                o !== a && (o.refCount++,
                                a != null && tu(a)));
                                break;
                            case 12:
                                if (S & 2048) {
                                    qn(a, o, f, g),
                                    a = o.stateNode;
                                    try {
                                        var w = o.memoizedProps
                                          , z = w.id
                                          , Y = w.onPostCommit;
                                        typeof Y == "function" && Y(z, o.alternate === null ? "mount" : "update", a.passiveEffectDuration, -0)
                                    } catch (re) {
                                        ue(o, o.return, re)
                                    }
                                } else
                                    qn(a, o, f, g);
                                break;
                            case 13:
                                qn(a, o, f, g);
                                break;
                            case 23:
                                break;
                            case 22:
                                w = o.stateNode,
                                z = o.alternate,
                                o.memoizedState !== null ? w._visibility & 2 ? qn(a, o, f, g) : Ar(a, o) : w._visibility & 2 ? qn(a, o, f, g) : (w._visibility |= 2,
                                Bo(a, o, f, g, (o.subtreeFlags & 10256) !== 0)),
                                S & 2048 && Vd(z, o);
                                break;
                            case 24:
                                qn(a, o, f, g),
                                S & 2048 && Gd(o.alternate, o);
                                break;
                            default:
                                qn(a, o, f, g)
                            }
                        }
                        function Bo(a, o, f, g, S) {
                            for (S = S && (o.subtreeFlags & 10256) !== 0,
                            o = o.child; o !== null; ) {
                                var w = a
                                  , z = o
                                  , Y = f
                                  , re = g
                                  , Ae = z.flags;
                                switch (z.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Bo(w, z, Y, re, S),
                                    uc(8, z);
                                    break;
                                case 23:
                                    break;
                                case 22:
                                    var qe = z.stateNode;
                                    z.memoizedState !== null ? qe._visibility & 2 ? Bo(w, z, Y, re, S) : Ar(w, z) : (qe._visibility |= 2,
                                    Bo(w, z, Y, re, S)),
                                    S && Ae & 2048 && Vd(z.alternate, z);
                                    break;
                                case 24:
                                    Bo(w, z, Y, re, S),
                                    S && Ae & 2048 && Gd(z.alternate, z);
                                    break;
                                default:
                                    Bo(w, z, Y, re, S)
                                }
                                o = o.sibling
                            }
                        }
                        function Ar(a, o) {
                            if (o.subtreeFlags & 10256)
                                for (o = o.child; o !== null; ) {
                                    var f = a
                                      , g = o
                                      , S = g.flags;
                                    switch (g.tag) {
                                    case 22:
                                        Ar(f, g),
                                        S & 2048 && Vd(g.alternate, g);
                                        break;
                                    case 24:
                                        Ar(f, g),
                                        S & 2048 && Gd(g.alternate, g);
                                        break;
                                    default:
                                        Ar(f, g)
                                    }
                                    o = o.sibling
                                }
                        }
                        var wa = 8192;
                        function _u(a) {
                            if (a.subtreeFlags & wa)
                                for (a = a.child; a !== null; )
                                    dy(a),
                                    a = a.sibling
                        }
                        function dy(a) {
                            switch (a.tag) {
                            case 26:
                                _u(a),
                                a.flags & wa && a.memoizedState !== null && w3(Sr, a.memoizedState, a.memoizedProps);
                                break;
                            case 5:
                                _u(a);
                                break;
                            case 3:
                            case 4:
                                var o = Sr;
                                Sr = _y(a.stateNode.containerInfo),
                                _u(a),
                                Sr = o;
                                break;
                            case 22:
                                a.memoizedState === null && (o = a.alternate,
                                o !== null && o.memoizedState !== null ? (o = wa,
                                wa = 16777216,
                                _u(a),
                                wa = o) : _u(a));
                                break;
                            default:
                                _u(a)
                            }
                        }
                        function py(a) {
                            var o = a.alternate;
                            if (o !== null && (a = o.child,
                            a !== null)) {
                                o.child = null;
                                do
                                    o = a.sibling,
                                    a.sibling = null,
                                    a = o;
                                while (a !== null)
                            }
                        }
                        function Jn(a) {
                            var o = a.deletions;
                            if ((a.flags & 16) !== 0) {
                                if (o !== null)
                                    for (var f = 0; f < o.length; f++) {
                                        var g = o[f];
                                        Xn = g,
                                        Zr(g, a)
                                    }
                                py(a)
                            }
                            if (a.subtreeFlags & 10256)
                                for (a = a.child; a !== null; )
                                    vg(a),
                                    a = a.sibling
                        }
                        function vg(a) {
                            switch (a.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Jn(a),
                                a.flags & 2048 && Ma(9, a, a.return);
                                break;
                            case 3:
                                Jn(a);
                                break;
                            case 12:
                                Jn(a);
                                break;
                            case 22:
                                var o = a.stateNode;
                                a.memoizedState !== null && o._visibility & 2 && (a.return === null || a.return.tag !== 13) ? (o._visibility &= -3,
                                Qr(a)) : Jn(a);
                                break;
                            default:
                                Jn(a)
                            }
                        }
                        function Qr(a) {
                            var o = a.deletions;
                            if ((a.flags & 16) !== 0) {
                                if (o !== null)
                                    for (var f = 0; f < o.length; f++) {
                                        var g = o[f];
                                        Xn = g,
                                        Zr(g, a)
                                    }
                                py(a)
                            }
                            for (a = a.child; a !== null; ) {
                                switch (o = a,
                                o.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ma(8, o, o.return),
                                    Qr(o);
                                    break;
                                case 22:
                                    f = o.stateNode,
                                    f._visibility & 2 && (f._visibility &= -3,
                                    Qr(o));
                                    break;
                                default:
                                    Qr(o)
                                }
                                a = a.sibling
                            }
                        }
                        function Zr(a, o) {
                            for (; Xn !== null; ) {
                                var f = Xn;
                                switch (f.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ma(8, f, o);
                                    break;
                                case 23:
                                case 22:
                                    if (f.memoizedState !== null && f.memoizedState.cachePool !== null) {
                                        var g = f.memoizedState.cachePool.pool;
                                        g != null && g.refCount++
                                    }
                                    break;
                                case 24:
                                    tu(f.memoizedState.cache)
                                }
                                if (g = f.child,
                                g !== null)
                                    g.return = f,
                                    Xn = g;
                                else
                                    e: for (f = a; Xn !== null; ) {
                                        g = Xn;
                                        var S = g.sibling
                                          , w = g.return;
                                        if (nn(g),
                                        g === f) {
                                            Xn = null;
                                            break e
                                        }
                                        if (S !== null) {
                                            S.return = w,
                                            Xn = S;
                                            break e
                                        }
                                        Xn = w
                                    }
                            }
                        }
                        var _i = {
                            getCacheForType: function(a) {
                                var o = vi(Pi)
                                  , f = o.data.get(a);
                                return f === void 0 && (f = a(),
                                o.data.set(a, f)),
                                f
                            }
                        }
                          , yg = typeof WeakMap == "function" ? WeakMap : Map
                          , Dn = 0
                          , jt = null
                          , ln = null
                          , Bt = 0
                          , en = 0
                          , pi = null
                          , Ca = !1
                          , xu = !1
                          , Su = !1
                          , Ja = 0
                          , ai = 0
                          , Tr = 0
                          , Kr = 0
                          , mc = 0
                          , $a = 0
                          , Sn = 0
                          , On = null
                          , Lt = null
                          , pn = !1
                          , zn = 0
                          , Cs = 1 / 0
                          , er = null
                          , Ra = null
                          , Wi = 0
                          , Rs = null
                          , Yn = null
                          , Da = 0
                          , Po = 0
                          , jh = null
                          , Oa = null
                          , Jr = 0
                          , gc = null;
                        function Ri() {
                            if ((Dn & 2) !== 0 && Bt !== 0)
                                return Bt & -Bt;
                            if (V.T !== null) {
                                var a = Kt;
                                return a !== 0 ? a : LS()
                            }
                            return Ai()
                        }
                        function Xd() {
                            $a === 0 && ($a = (Bt & 536870912) === 0 || bn ? ot() : 536870912);
                            var a = kn.current;
                            return a !== null && (a.flags |= 32),
                            $a
                        }
                        function Gs(a, o, f) {
                            (a === jt && (en === 2 || en === 9) || a.cancelPendingCommit !== null) && (Ol(a, 0),
                            Mr(a, Bt, $a, !1)),
                            Je(a, f),
                            ((Dn & 2) === 0 || a !== jt) && (a === jt && ((Dn & 2) === 0 && (Kr |= f),
                            ai === 4 && Mr(a, Bt, $a, !1)),
                            yc(a))
                        }
                        function Au(a, o, f) {
                            if ((Dn & 6) !== 0)
                                throw Error(s(327));
                            var g = !f && (o & 124) === 0 && (o & a.expiredLanes) === 0 || lt(a, o)
                              , S = g ? A(a, o) : u(a, o, !0)
                              , w = g;
                            do {
                                if (S === 0) {
                                    xu && !g && Mr(a, o, 0, !1);
                                    break
                                } else {
                                    if (f = a.current.alternate,
                                    w && !Dl(f)) {
                                        S = u(a, o, !1),
                                        w = !1;
                                        continue
                                    }
                                    if (S === 2) {
                                        if (w = o,
                                        a.errorRecoveryDisabledLanes & w)
                                            var z = 0;
                                        else
                                            z = a.pendingLanes & -536870913,
                                            z = z !== 0 ? z : z & 536870912 ? 536870912 : 0;
                                        if (z !== 0) {
                                            o = z;
                                            e: {
                                                var Y = a;
                                                S = On;
                                                var re = Y.current.memoizedState.isDehydrated;
                                                if (re && (Ol(Y, z).flags |= 256),
                                                z = u(Y, z, !1),
                                                z !== 2) {
                                                    if (Su && !re) {
                                                        Y.errorRecoveryDisabledLanes |= w,
                                                        Kr |= w,
                                                        S = 4;
                                                        break e
                                                    }
                                                    w = Lt,
                                                    Lt = S,
                                                    w !== null && (Lt === null ? Lt = w : Lt.push.apply(Lt, w))
                                                }
                                                S = z
                                            }
                                            if (w = !1,
                                            S !== 2)
                                                continue
                                        }
                                    }
                                    if (S === 1) {
                                        Ol(a, 0),
                                        Mr(a, o, 0, !0);
                                        break
                                    }
                                    e: {
                                        switch (g = a,
                                        w = S,
                                        w) {
                                        case 0:
                                        case 1:
                                            throw Error(s(345));
                                        case 4:
                                            if ((o & 4194048) !== o)
                                                break;
                                        case 6:
                                            Mr(g, o, $a, !Ca);
                                            break e;
                                        case 2:
                                            Lt = null;
                                            break;
                                        case 3:
                                        case 5:
                                            break;
                                        default:
                                            throw Error(s(329))
                                        }
                                        if ((o & 62914560) === o && (S = zn + 300 - Ie(),
                                        10 < S)) {
                                            if (Mr(g, o, $a, !Ca),
                                            He(g, 0, !0) !== 0)
                                                break e;
                                            g.timeoutHandle = Ub(Qh.bind(null, g, f, Lt, er, pn, o, $a, Kr, Sn, Ca, w, 2, -0, 0), S);
                                            break e
                                        }
                                        Qh(g, f, Lt, er, pn, o, $a, Kr, Sn, Ca, w, 0, -0, 0)
                                    }
                                }
                                break
                            } while (!0);
                            yc(a)
                        }
                        function Qh(a, o, f, g, S, w, z, Y, re, Ae, qe, je, we, De) {
                            if (a.timeoutHandle = -1,
                            je = o.subtreeFlags,
                            (je & 8192 || (je & 16785408) === 16785408) && (bg = {
                                stylesheets: null,
                                count: 0,
                                unsuspend: E3
                            },
                            dy(o),
                            je = C3(),
                            je !== null)) {
                                a.cancelPendingCommit = je(it.bind(null, a, o, w, f, g, S, z, Y, re, qe, 1, we, De)),
                                Mr(a, w, z, !Ae);
                                return
                            }
                            it(a, o, w, f, g, S, z, Y, re)
                        }
                        function Dl(a) {
                            for (var o = a; ; ) {
                                var f = o.tag;
                                if ((f === 0 || f === 11 || f === 15) && o.flags & 16384 && (f = o.updateQueue,
                                f !== null && (f = f.stores,
                                f !== null)))
                                    for (var g = 0; g < f.length; g++) {
                                        var S = f[g]
                                          , w = S.getSnapshot;
                                        S = S.value;
                                        try {
                                            if (!Ks(w(), S))
                                                return !1
                                        } catch {
                                            return !1
                                        }
                                    }
                                if (f = o.child,
                                o.subtreeFlags & 16384 && f !== null)
                                    f.return = o,
                                    o = f;
                                else {
                                    if (o === a)
                                        break;
                                    for (; o.sibling === null; ) {
                                        if (o.return === null || o.return === a)
                                            return !0;
                                        o = o.return
                                    }
                                    o.sibling.return = o.return,
                                    o = o.sibling
                                }
                            }
                            return !0
                        }
                        function Mr(a, o, f, g) {
                            o &= ~mc,
                            o &= ~Kr,
                            a.suspendedLanes |= o,
                            a.pingedLanes &= ~o,
                            g && (a.warmLanes |= o),
                            g = a.expirationTimes;
                            for (var S = o; 0 < S; ) {
                                var w = 31 - Ke(S)
                                  , z = 1 << w;
                                g[w] = -1,
                                S &= ~z
                            }
                            f !== 0 && ht(a, f, o)
                        }
                        function $r() {
                            return (Dn & 6) === 0 ? (_g(0, !1),
                            !1) : !0
                        }
                        function vc() {
                            if (ln !== null) {
                                if (en === 0)
                                    var a = ln.return;
                                else
                                    a = ln,
                                    To = dl = null,
                                    $m(a),
                                    tc = null,
                                    Gh = 0,
                                    a = ln;
                                for (; a !== null; )
                                    gu(a.alternate, a),
                                    a = a.return;
                                ln = null
                            }
                        }
                        function Ol(a, o) {
                            var f = a.timeoutHandle;
                            f !== -1 && (a.timeoutHandle = -1,
                            c3(f)),
                            f = a.cancelPendingCommit,
                            f !== null && (a.cancelPendingCommit = null,
                            f()),
                            vc(),
                            jt = a,
                            ln = f = bi(a.current, null),
                            Bt = o,
                            en = 0,
                            pi = null,
                            Ca = !1,
                            xu = lt(a, o),
                            Su = !1,
                            Sn = $a = mc = Kr = Tr = ai = 0,
                            Lt = On = null,
                            pn = !1,
                            (o & 8) !== 0 && (o |= o & 32);
                            var g = a.entangledLanes;
                            if (g !== 0)
                                for (a = a.entanglements,
                                g &= o; 0 < g; ) {
                                    var S = 31 - Ke(g)
                                      , w = 1 << S;
                                    o |= a[S],
                                    g &= ~w
                                }
                            return Ja = o,
                            bh(),
                            f
                        }
                        function qd(a, o) {
                            Jt = null,
                            V.H = Vh,
                            o === Ph || o === mr ? (o = jm(),
                            en = 3) : o === Wm ? (o = jm(),
                            en = 4) : en = o === fy ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1,
                            pi = o,
                            ln === null && (ai = 1,
                            Id(a, ds(o, a.current)))
                        }
                        function Tu() {
                            var a = V.H;
                            return V.H = Vh,
                            a === null ? Vh : a
                        }
                        function Yd() {
                            var a = V.A;
                            return V.A = _i,
                            a
                        }
                        function c() {
                            ai = 4,
                            Ca || (Bt & 4194048) !== Bt && kn.current !== null || (xu = !0),
                            (Tr & 134217727) === 0 && (Kr & 134217727) === 0 || jt === null || Mr(jt, Bt, $a, !1)
                        }
                        function u(a, o, f) {
                            var g = Dn;
                            Dn |= 2;
                            var S = Tu()
                              , w = Yd();
                            (jt !== a || Bt !== o) && (er = null,
                            Ol(a, o)),
                            o = !1;
                            var z = ai;
                            e: do
                                try {
                                    if (en !== 0 && ln !== null) {
                                        var Y = ln
                                          , re = pi;
                                        switch (en) {
                                        case 8:
                                            vc(),
                                            z = 6;
                                            break e;
                                        case 3:
                                        case 2:
                                        case 9:
                                        case 6:
                                            kn.current === null && (o = !0);
                                            var Ae = en;
                                            if (en = 0,
                                            pi = null,
                                            oe(a, Y, re, Ae),
                                            f && xu) {
                                                z = 0;
                                                break e
                                            }
                                            break;
                                        default:
                                            Ae = en,
                                            en = 0,
                                            pi = null,
                                            oe(a, Y, re, Ae)
                                        }
                                    }
                                    y(),
                                    z = ai;
                                    break
                                } catch (qe) {
                                    qd(a, qe)
                                }
                            while (!0);
                            return o && a.shellSuspendCounter++,
                            To = dl = null,
                            Dn = g,
                            V.H = S,
                            V.A = w,
                            ln === null && (jt = null,
                            Bt = 0,
                            bh()),
                            z
                        }
                        function y() {
                            for (; ln !== null; )
                                N(ln)
                        }
                        function A(a, o) {
                            var f = Dn;
                            Dn |= 2;
                            var g = Tu()
                              , S = Yd();
                            jt !== a || Bt !== o ? (er = null,
                            Cs = Ie() + 500,
                            Ol(a, o)) : xu = lt(a, o);
                            e: do
                                try {
                                    if (en !== 0 && ln !== null) {
                                        o = ln;
                                        var w = pi;
                                        t: switch (en) {
                                        case 1:
                                            en = 0,
                                            pi = null,
                                            oe(a, o, w, 1);
                                            break;
                                        case 2:
                                        case 9:
                                            if (Sd(w)) {
                                                en = 0,
                                                pi = null,
                                                W(o);
                                                break
                                            }
                                            o = function() {
                                                en !== 2 && en !== 9 || jt !== a || (en = 7),
                                                yc(a)
                                            }
                                            ,
                                            w.then(o, o);
                                            break e;
                                        case 3:
                                            en = 7;
                                            break e;
                                        case 4:
                                            en = 5;
                                            break e;
                                        case 7:
                                            Sd(w) ? (en = 0,
                                            pi = null,
                                            W(o)) : (en = 0,
                                            pi = null,
                                            oe(a, o, w, 7));
                                            break;
                                        case 5:
                                            var z = null;
                                            switch (ln.tag) {
                                            case 26:
                                                z = ln.memoizedState;
                                            case 5:
                                            case 27:
                                                var Y = ln;
                                                if (!z || qb(z)) {
                                                    en = 0,
                                                    pi = null;
                                                    var re = Y.sibling;
                                                    if (re !== null)
                                                        ln = re;
                                                    else {
                                                        var Ae = Y.return;
                                                        Ae !== null ? (ln = Ae,
                                                        ve(Ae)) : ln = null
                                                    }
                                                    break t
                                                }
                                            }
                                            en = 0,
                                            pi = null,
                                            oe(a, o, w, 5);
                                            break;
                                        case 6:
                                            en = 0,
                                            pi = null,
                                            oe(a, o, w, 6);
                                            break;
                                        case 8:
                                            vc(),
                                            ai = 6;
                                            break e;
                                        default:
                                            throw Error(s(462))
                                        }
                                    }
                                    C();
                                    break
                                } catch (qe) {
                                    qd(a, qe)
                                }
                            while (!0);
                            return To = dl = null,
                            V.H = g,
                            V.A = S,
                            Dn = f,
                            ln !== null ? 0 : (jt = null,
                            Bt = 0,
                            bh(),
                            ai)
                        }
                        function C() {
                            for (; ln !== null && !Pe(); )
                                N(ln)
                        }
                        function N(a) {
                            var o = lc(a.alternate, a, Ja);
                            a.memoizedProps = a.pendingProps,
                            o === null ? ve(a) : ln = o
                        }
                        function W(a) {
                            var o = a
                              , f = o.alternate;
                            switch (o.tag) {
                            case 15:
                            case 0:
                                o = Aa(f, o, o.pendingProps, o.type, void 0, Bt);
                                break;
                            case 11:
                                o = Aa(f, o, o.pendingProps, o.type.render, o.ref, Bt);
                                break;
                            case 5:
                                $m(o);
                            default:
                                gu(f, o),
                                o = ln = Hm(o, Ja),
                                o = lc(f, o, Ja)
                            }
                            a.memoizedProps = a.pendingProps,
                            o === null ? ve(a) : ln = o
                        }
                        function oe(a, o, f, g) {
                            To = dl = null,
                            $m(o),
                            tc = null,
                            Gh = 0;
                            var S = o.return;
                            try {
                                if (PS(a, S, o, f, Bt)) {
                                    ai = 1,
                                    Id(a, ds(f, a.current)),
                                    ln = null;
                                    return
                                }
                            } catch (w) {
                                if (S !== null)
                                    throw ln = S,
                                    w;
                                ai = 1,
                                Id(a, ds(f, a.current)),
                                ln = null;
                                return
                            }
                            o.flags & 32768 ? (bn || g === 1 ? a = !0 : xu || (Bt & 536870912) !== 0 ? a = !1 : (Ca = a = !0,
                            (g === 2 || g === 9 || g === 3 || g === 6) && (g = kn.current,
                            g !== null && g.tag === 13 && (g.flags |= 16384))),
                            Xe(o, a)) : ve(o)
                        }
                        function ve(a) {
                            var o = a;
                            do {
                                if ((o.flags & 32768) !== 0) {
                                    Xe(o, Ca);
                                    return
                                }
                                a = o.return;
                                var f = gg(o.alternate, o, Ja);
                                if (f !== null) {
                                    ln = f;
                                    return
                                }
                                if (o = o.sibling,
                                o !== null) {
                                    ln = o;
                                    return
                                }
                                ln = o = a
                            } while (o !== null);
                            ai === 0 && (ai = 5)
                        }
                        function Xe(a, o) {
                            do {
                                var f = mu(a.alternate, a);
                                if (f !== null) {
                                    f.flags &= 32767,
                                    ln = f;
                                    return
                                }
                                if (f = a.return,
                                f !== null && (f.flags |= 32768,
                                f.subtreeFlags = 0,
                                f.deletions = null),
                                !o && (a = a.sibling,
                                a !== null)) {
                                    ln = a;
                                    return
                                }
                                ln = a = f
                            } while (a !== null);
                            ai = 6,
                            ln = null
                        }
                        function it(a, o, f, g, S, w, z, Y, re) {
                            a.cancelPendingCommit = null;
                            do
                                Nl();
                            while (Wi !== 0);
                            if ((Dn & 6) !== 0)
                                throw Error(s(327));
                            if (o !== null) {
                                if (o === a.current)
                                    throw Error(s(177));
                                if (w = o.lanes | o.childLanes,
                                w |= fd,
                                ke(a, f, w, z, Y, re),
                                a === jt && (ln = jt = null,
                                Bt = 0),
                                Yn = o,
                                Rs = a,
                                Da = f,
                                Po = w,
                                jh = S,
                                Oa = g,
                                (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (a.callbackNode = null,
                                a.callbackPriority = 0,
                                En(wt, function() {
                                    return Ul(!0),
                                    null
                                })) : (a.callbackNode = null,
                                a.callbackPriority = 0),
                                g = (o.flags & 13878) !== 0,
                                (o.subtreeFlags & 13878) !== 0 || g) {
                                    g = V.T,
                                    V.T = null,
                                    S = q.p,
                                    q.p = 2,
                                    z = Dn,
                                    Dn |= 4;
                                    try {
                                        Yi(a, o, f)
                                    } finally {
                                        Dn = z,
                                        q.p = S,
                                        V.T = g
                                    }
                                }
                                Wi = 1,
                                dt(),
                                mt(),
                                Qt()
                            }
                        }
                        function dt() {
                            if (Wi === 1) {
                                Wi = 0;
                                var a = Rs
                                  , o = Yn
                                  , f = (o.flags & 13878) !== 0;
                                if ((o.subtreeFlags & 13878) !== 0 || f) {
                                    f = V.T,
                                    V.T = null;
                                    var g = q.p;
                                    q.p = 2;
                                    var S = Dn;
                                    Dn |= 4;
                                    try {
                                        Hd(o, a);
                                        var w = XS
                                          , z = Um(a.containerInfo)
                                          , Y = w.focusedElem
                                          , re = w.selectionRange;
                                        if (z !== Y && Y && Y.ownerDocument && Nm(Y.ownerDocument.documentElement, Y)) {
                                            if (re !== null && Ah(Y)) {
                                                var Ae = re.start
                                                  , qe = re.end;
                                                if (qe === void 0 && (qe = Ae),
                                                "selectionStart"in Y)
                                                    Y.selectionStart = Ae,
                                                    Y.selectionEnd = Math.min(qe, Y.value.length);
                                                else {
                                                    var je = Y.ownerDocument || document
                                                      , we = je && je.defaultView || window;
                                                    if (we.getSelection) {
                                                        var De = we.getSelection()
                                                          , qt = Y.textContent.length
                                                          , Ft = Math.min(re.start, qt)
                                                          , ei = re.end === void 0 ? Ft : Math.min(re.end, qt);
                                                        !De.extend && Ft > ei && (z = ei,
                                                        ei = Ft,
                                                        Ft = z);
                                                        var ge = Om(Y, Ft)
                                                          , fe = Om(Y, ei);
                                                        if (ge && fe && (De.rangeCount !== 1 || De.anchorNode !== ge.node || De.anchorOffset !== ge.offset || De.focusNode !== fe.node || De.focusOffset !== fe.offset)) {
                                                            var _e = je.createRange();
                                                            _e.setStart(ge.node, ge.offset),
                                                            De.removeAllRanges(),
                                                            Ft > ei ? (De.addRange(_e),
                                                            De.extend(fe.node, fe.offset)) : (_e.setEnd(fe.node, fe.offset),
                                                            De.addRange(_e))
                                                        }
                                                    }
                                                }
                                            }
                                            for (je = [],
                                            De = Y; De = De.parentNode; )
                                                De.nodeType === 1 && je.push({
                                                    element: De,
                                                    left: De.scrollLeft,
                                                    top: De.scrollTop
                                                });
                                            for (typeof Y.focus == "function" && Y.focus(),
                                            Y = 0; Y < je.length; Y++) {
                                                var We = je[Y];
                                                We.element.scrollLeft = We.left,
                                                We.element.scrollTop = We.top
                                            }
                                        }
                                        My = !!kS,
                                        XS = kS = null
                                    } finally {
                                        Dn = S,
                                        q.p = g,
                                        V.T = f
                                    }
                                }
                                a.current = o,
                                Wi = 2
                            }
                        }
                        function mt() {
                            if (Wi === 2) {
                                Wi = 0;
                                var a = Rs
                                  , o = Yn
                                  , f = (o.flags & 8772) !== 0;
                                if ((o.subtreeFlags & 8772) !== 0 || f) {
                                    f = V.T,
                                    V.T = null;
                                    var g = q.p;
                                    q.p = 2;
                                    var S = Dn;
                                    Dn |= 4;
                                    try {
                                        Uo(a, o.alternate, o)
                                    } finally {
                                        Dn = S,
                                        q.p = g,
                                        V.T = f
                                    }
                                }
                                Wi = 3
                            }
                        }
                        function Qt() {
                            if (Wi === 4 || Wi === 3) {
                                Wi = 0,
                                Ye();
                                var a = Rs
                                  , o = Yn
                                  , f = Da
                                  , g = Oa;
                                (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? Wi = 5 : (Wi = 0,
                                Yn = Rs = null,
                                Na(a, a.pendingLanes));
                                var S = a.pendingLanes;
                                if (S === 0 && (Ra = null),
                                Zt(f),
                                o = o.stateNode,
                                Be && typeof Be.onCommitFiberRoot == "function")
                                    try {
                                        Be.onCommitFiberRoot(Qe, o, void 0, (o.current.flags & 128) === 128)
                                    } catch {}
                                if (g !== null) {
                                    o = V.T,
                                    S = q.p,
                                    q.p = 2,
                                    V.T = null;
                                    try {
                                        for (var w = a.onRecoverableError, z = 0; z < g.length; z++) {
                                            var Y = g[z];
                                            w(Y.value, {
                                                componentStack: Y.stack
                                            })
                                        }
                                    } finally {
                                        V.T = o,
                                        q.p = S
                                    }
                                }
                                (Da & 3) !== 0 && Nl(),
                                yc(a),
                                S = a.pendingLanes,
                                (f & 4194090) !== 0 && (S & 42) !== 0 ? a === gc ? Jr++ : (Jr = 0,
                                gc = a) : Jr = 0,
                                _g(0, !1)
                            }
                        }
                        function Na(a, o) {
                            (a.pooledCacheLanes &= o) === 0 && (o = a.pooledCache,
                            o != null && (a.pooledCache = null,
                            tu(o)))
                        }
                        function Nl(a) {
                            return dt(),
                            mt(),
                            Qt(),
                            Ul(a)
                        }
                        function Ul() {
                            if (Wi !== 5)
                                return !1;
                            var a = Rs
                              , o = Po;
                            Po = 0;
                            var f = Zt(Da)
                              , g = V.T
                              , S = q.p;
                            try {
                                q.p = 32 > f ? 32 : f,
                                V.T = null,
                                f = jh,
                                jh = null;
                                var w = Rs
                                  , z = Da;
                                if (Wi = 0,
                                Yn = Rs = null,
                                Da = 0,
                                (Dn & 6) !== 0)
                                    throw Error(s(331));
                                var Y = Dn;
                                if (Dn |= 4,
                                vg(w.current),
                                kd(w, w.current, z, f),
                                Dn = Y,
                                _g(0, !1),
                                Be && typeof Be.onPostCommitFiberRoot == "function")
                                    try {
                                        Be.onPostCommitFiberRoot(Qe, w)
                                    } catch {}
                                return !0
                            } finally {
                                q.p = S,
                                V.T = g,
                                Na(a, o)
                            }
                        }
                        function Me(a, o, f) {
                            o = ds(f, o),
                            o = Ld(a.stateNode, o, 2),
                            a = gl(a, o, 2),
                            a !== null && (Je(a, 2),
                            yc(a))
                        }
                        function ue(a, o, f) {
                            if (a.tag === 3)
                                Me(a, a, f);
                            else
                                for (; o !== null; ) {
                                    if (o.tag === 3) {
                                        Me(o, a, f);
                                        break
                                    } else if (o.tag === 1) {
                                        var g = o.stateNode;
                                        if (typeof o.type.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && (Ra === null || !Ra.has(g))) {
                                            a = ds(f, a),
                                            f = hy(2),
                                            g = gl(o, f, 2),
                                            g !== null && (zd(f, g, o, a),
                                            Je(g, 2),
                                            yc(g));
                                            break
                                        }
                                    }
                                    o = o.return
                                }
                        }
                        function Oe(a, o, f) {
                            var g = a.pingCache;
                            if (g === null) {
                                g = a.pingCache = new yg;
                                var S = new Set;
                                g.set(o, S)
                            } else
                                S = g.get(o),
                                S === void 0 && (S = new Set,
                                g.set(o, S));
                            S.has(f) || (Su = !0,
                            S.add(f),
                            a = nt.bind(null, a, o, f),
                            o.then(a, a))
                        }
                        function nt(a, o, f) {
                            var g = a.pingCache;
                            g !== null && g.delete(o),
                            a.pingedLanes |= a.suspendedLanes & f,
                            a.warmLanes &= ~f,
                            jt === a && (Bt & f) === f && (ai === 4 || ai === 3 && (Bt & 62914560) === Bt && 300 > Ie() - zn ? (Dn & 2) === 0 && Ol(a, 0) : mc |= f,
                            Sn === Bt && (Sn = 0)),
                            yc(a)
                        }
                        function Rt(a, o) {
                            o === 0 && (o = tt()),
                            a = So(a, o),
                            a !== null && (Je(a, o),
                            yc(a))
                        }
                        function ri(a) {
                            var o = a.memoizedState
                              , f = 0;
                            o !== null && (f = o.retryLane),
                            Rt(a, f)
                        }
                        function Gt(a, o) {
                            var f = 0;
                            switch (a.tag) {
                            case 13:
                                var g = a.stateNode
                                  , S = a.memoizedState;
                                S !== null && (f = S.retryLane);
                                break;
                            case 19:
                                g = a.stateNode;
                                break;
                            case 22:
                                g = a.stateNode._retryCache;
                                break;
                            default:
                                throw Error(s(314))
                            }
                            g !== null && g.delete(o),
                            Rt(a, f)
                        }
                        function En(a, o) {
                            return de(a, o)
                        }
                        var Di = null
                          , hn = null
                          , eo = !1
                          , Wd = !1
                          , IS = !1
                          , Zh = 0;
                        function yc(a) {
                            a !== hn && a.next === null && (hn === null ? Di = hn = a : hn = hn.next = a),
                            Wd = !0,
                            eo || (eo = !0,
                            e3())
                        }
                        function _g(a, o) {
                            if (!IS && Wd) {
                                IS = !0;
                                do
                                    for (var f = !1, g = Di; g !== null; ) {
                                        if (!o)
                                            if (a !== 0) {
                                                var S = g.pendingLanes;
                                                if (S === 0)
                                                    var w = 0;
                                                else {
                                                    var z = g.suspendedLanes
                                                      , Y = g.pingedLanes;
                                                    w = (1 << 31 - Ke(42 | a) + 1) - 1,
                                                    w &= S & ~(z & ~Y),
                                                    w = w & 201326741 ? w & 201326741 | 1 : w ? w | 2 : 0
                                                }
                                                w !== 0 && (f = !0,
                                                Ab(g, w))
                                            } else
                                                w = Bt,
                                                w = He(g, g === jt ? w : 0, g.cancelPendingCommit !== null || g.timeoutHandle !== -1),
                                                (w & 3) === 0 || lt(g, w) || (f = !0,
                                                Ab(g, w));
                                        g = g.next
                                    }
                                while (f);
                                IS = !1
                            }
                        }
                        function $N() {
                            _b()
                        }
                        function _b() {
                            Wd = eo = !1;
                            var a = 0;
                            Zh !== 0 && (l3() && (a = Zh),
                            Zh = 0);
                            for (var o = Ie(), f = null, g = Di; g !== null; ) {
                                var S = g.next
                                  , w = xb(g, o);
                                w === 0 ? (g.next = null,
                                f === null ? Di = S : f.next = S,
                                S === null && (hn = f)) : (f = g,
                                (a !== 0 || (w & 3) !== 0) && (Wd = !0)),
                                g = S
                            }
                            _g(a, !1)
                        }
                        function xb(a, o) {
                            for (var f = a.suspendedLanes, g = a.pingedLanes, S = a.expirationTimes, w = a.pendingLanes & -62914561; 0 < w; ) {
                                var z = 31 - Ke(w)
                                  , Y = 1 << z
                                  , re = S[z];
                                re === -1 ? ((Y & f) === 0 || (Y & g) !== 0) && (S[z] = ae(Y, o)) : re <= o && (a.expiredLanes |= Y),
                                w &= ~Y
                            }
                            if (o = jt,
                            f = Bt,
                            f = He(a, a === o ? f : 0, a.cancelPendingCommit !== null || a.timeoutHandle !== -1),
                            g = a.callbackNode,
                            f === 0 || a === o && (en === 2 || en === 9) || a.cancelPendingCommit !== null)
                                return g !== null && g !== null && Te(g),
                                a.callbackNode = null,
                                a.callbackPriority = 0;
                            if ((f & 3) === 0 || lt(a, f)) {
                                if (o = f & -f,
                                o === a.callbackPriority)
                                    return o;
                                switch (g !== null && Te(g),
                                Zt(f)) {
                                case 2:
                                case 8:
                                    f = yt;
                                    break;
                                case 32:
                                    f = wt;
                                    break;
                                case 268435456:
                                    f = k;
                                    break;
                                default:
                                    f = wt
                                }
                                return g = Sb.bind(null, a),
                                f = de(f, g),
                                a.callbackPriority = o,
                                a.callbackNode = f,
                                o
                            }
                            return g !== null && g !== null && Te(g),
                            a.callbackPriority = 2,
                            a.callbackNode = null,
                            2
                        }
                        function Sb(a, o) {
                            if (Wi !== 0 && Wi !== 5)
                                return a.callbackNode = null,
                                a.callbackPriority = 0,
                                null;
                            var f = a.callbackNode;
                            if (Nl(!0) && a.callbackNode !== f)
                                return null;
                            var g = Bt;
                            return g = He(a, a === jt ? g : 0, a.cancelPendingCommit !== null || a.timeoutHandle !== -1),
                            g === 0 ? null : (Au(a, g, o),
                            xb(a, Ie()),
                            a.callbackNode != null && a.callbackNode === f ? Sb.bind(null, a) : null)
                        }
                        function Ab(a, o) {
                            if (Nl())
                                return null;
                            Au(a, o, !0)
                        }
                        function e3() {
                            u3(function() {
                                (Dn & 6) !== 0 ? de(xt, $N) : _b()
                            })
                        }
                        function LS() {
                            return Zh === 0 && (Zh = ot()),
                            Zh
                        }
                        function Tb(a) {
                            return a == null || typeof a == "symbol" || typeof a == "boolean" ? null : typeof a == "function" ? a : ch("" + a)
                        }
                        function Mb(a, o) {
                            var f = o.ownerDocument.createElement("input");
                            return f.name = o.name,
                            f.value = o.value,
                            a.id && f.setAttribute("form", a.id),
                            o.parentNode.insertBefore(f, o),
                            a = new FormData(a),
                            f.parentNode.removeChild(f),
                            a
                        }
                        function t3(a, o, f, g, S) {
                            if (o === "submit" && f && f.stateNode === S) {
                                var w = Tb((S[ki] || null).action)
                                  , z = g.submitter;
                                z && (o = (o = z[ki] || null) ? Tb(o.formAction) : z.getAttribute("formAction"),
                                o !== null && (w = o,
                                z = null));
                                var Y = new Gc("action","action",null,g,S);
                                a.push({
                                    event: Y,
                                    listeners: [{
                                        instance: null,
                                        listener: function() {
                                            if (g.defaultPrevented) {
                                                if (Zh !== 0) {
                                                    var re = z ? Mb(S, z) : new FormData(S);
                                                    hg(f, {
                                                        pending: !0,
                                                        data: re,
                                                        method: S.method,
                                                        action: w
                                                    }, null, re)
                                                }
                                            } else
                                                typeof w == "function" && (Y.preventDefault(),
                                                re = z ? Mb(S, z) : new FormData(S),
                                                hg(f, {
                                                    pending: !0,
                                                    data: re,
                                                    method: S.method,
                                                    action: w
                                                }, w, re))
                                        },
                                        currentTarget: S
                                    }]
                                })
                            }
                        }
                        for (var zS = 0; zS < Mh.length; zS++) {
                            var FS = Mh[zS]
                              , n3 = FS.toLowerCase()
                              , i3 = FS[0].toUpperCase() + FS.slice(1);
                            $i(n3, "on" + i3)
                        }
                        $i(Is, "onAnimationEnd"),
                        $i(Im, "onAnimationIteration"),
                        $i($s, "onAnimationStart"),
                        $i("dblclick", "onDoubleClick"),
                        $i("focusin", "onFocus"),
                        $i("focusout", "onBlur"),
                        $i(M0, "onTransitionRun"),
                        $i(_o, "onTransitionStart"),
                        $i(Zc, "onTransitionCancel"),
                        $i(xo, "onTransitionEnd"),
                        Se("onMouseEnter", ["mouseout", "mouseover"]),
                        Se("onMouseLeave", ["mouseout", "mouseover"]),
                        Se("onPointerEnter", ["pointerout", "pointerover"]),
                        Se("onPointerLeave", ["pointerout", "pointerover"]),
                        Ee("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
                        Ee("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
                        Ee("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
                        Ee("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
                        Ee("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
                        Ee("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                        var xg = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
                          , s3 = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(xg));
                        function bb(a, o) {
                            o = (o & 4) !== 0;
                            for (var f = 0; f < a.length; f++) {
                                var g = a[f]
                                  , S = g.event;
                                g = g.listeners;
                                e: {
                                    var w = void 0;
                                    if (o)
                                        for (var z = g.length - 1; 0 <= z; z--) {
                                            var Y = g[z]
                                              , re = Y.instance
                                              , Ae = Y.currentTarget;
                                            if (Y = Y.listener,
                                            re !== w && S.isPropagationStopped())
                                                break e;
                                            w = Y,
                                            S.currentTarget = Ae;
                                            try {
                                                w(S)
                                            } catch (qe) {
                                                ic(qe)
                                            }
                                            S.currentTarget = null,
                                            w = re
                                        }
                                    else
                                        for (z = 0; z < g.length; z++) {
                                            if (Y = g[z],
                                            re = Y.instance,
                                            Ae = Y.currentTarget,
                                            Y = Y.listener,
                                            re !== w && S.isPropagationStopped())
                                                break e;
                                            w = Y,
                                            S.currentTarget = Ae;
                                            try {
                                                w(S)
                                            } catch (qe) {
                                                ic(qe)
                                            }
                                            S.currentTarget = null,
                                            w = re
                                        }
                                }
                            }
                        }
                        function vn(a, o) {
                            var f = o[Bs];
                            f === void 0 && (f = o[Bs] = new Set);
                            var g = a + "__bubble";
                            f.has(g) || (wb(o, a, 2, !1),
                            f.add(g))
                        }
                        function HS(a, o, f) {
                            var g = 0;
                            o && (g |= 4),
                            wb(f, a, g, o)
                        }
                        var my = "_reactListening" + Math.random().toString(36).slice(2);
                        function Eb(a) {
                            if (!a[my]) {
                                a[my] = !0,
                                j.forEach(function(f) {
                                    f !== "selectionchange" && (s3.has(f) || HS(f, !1, a),
                                    HS(f, !0, a))
                                });
                                var o = a.nodeType === 9 ? a : a.ownerDocument;
                                o === null || o[my] || (o[my] = !0,
                                HS("selectionchange", !1, o))
                            }
                        }
                        function wb(a, o, f, g) {
                            switch (Qb(o)) {
                            case 2:
                                var S = U3;
                                break;
                            case 8:
                                S = B3;
                                break;
                            default:
                                S = eA
                            }
                            f = S.bind(null, o, f, a),
                            S = void 0,
                            !hh || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (S = !0),
                            g ? S !== void 0 ? a.addEventListener(o, f, {
                                capture: !0,
                                passive: S
                            }) : a.addEventListener(o, f, !0) : S !== void 0 ? a.addEventListener(o, f, {
                                passive: S
                            }) : a.addEventListener(o, f, !1)
                        }
                        function VS(a, o, f, g, S) {
                            var w = g;
                            if ((o & 1) === 0 && (o & 2) === 0 && g !== null)
                                e: for (; ; ) {
                                    if (g === null)
                                        return;
                                    var z = g.tag;
                                    if (z === 3 || z === 4) {
                                        var Y = g.stateNode.containerInfo;
                                        if (Y === S)
                                            break;
                                        if (z === 4)
                                            for (z = g.return; z !== null; ) {
                                                var re = z.tag;
                                                if ((re === 3 || re === 4) && z.stateNode.containerInfo === S)
                                                    return;
                                                z = z.return
                                            }
                                        for (; Y !== null; ) {
                                            if (z = Ir(Y),
                                            z === null)
                                                return;
                                            if (re = z.tag,
                                            re === 5 || re === 6 || re === 26 || re === 27) {
                                                g = w = z;
                                                continue e
                                            }
                                            Y = Y.parentNode
                                        }
                                    }
                                    g = g.return
                                }
                            _m(function() {
                                var Ae = w
                                  , qe = $f(f)
                                  , je = [];
                                e: {
                                    var we = hd.get(a);
                                    if (we !== void 0) {
                                        var De = Gc
                                          , qt = a;
                                        switch (a) {
                                        case "keypress":
                                            if (tl(f) === 0)
                                                break e;
                                        case "keydown":
                                        case "keyup":
                                            De = Mm;
                                            break;
                                        case "focusin":
                                            qt = "focus",
                                            De = td;
                                            break;
                                        case "focusout":
                                            qt = "blur",
                                            De = td;
                                            break;
                                        case "beforeblur":
                                        case "afterblur":
                                            De = td;
                                            break;
                                        case "click":
                                            if (f.button === 2)
                                                break e;
                                        case "auxclick":
                                        case "dblclick":
                                        case "mousedown":
                                        case "mousemove":
                                        case "mouseup":
                                        case "mouseout":
                                        case "mouseover":
                                        case "contextmenu":
                                            De = Am;
                                            break;
                                        case "drag":
                                        case "dragend":
                                        case "dragenter":
                                        case "dragexit":
                                        case "dragleave":
                                        case "dragover":
                                        case "dragstart":
                                        case "drop":
                                            De = TS;
                                            break;
                                        case "touchcancel":
                                        case "touchend":
                                        case "touchmove":
                                        case "touchstart":
                                            De = Em;
                                            break;
                                        case Is:
                                        case Im:
                                        case $s:
                                            De = c0;
                                            break;
                                        case xo:
                                            De = mo;
                                            break;
                                        case "scroll":
                                        case "scrollend":
                                            De = r0;
                                            break;
                                        case "wheel":
                                            De = MS;
                                            break;
                                        case "copy":
                                        case "cut":
                                        case "paste":
                                            De = h0;
                                            break;
                                        case "gotpointercapture":
                                        case "lostpointercapture":
                                        case "pointercancel":
                                        case "pointerdown":
                                        case "pointermove":
                                        case "pointerout":
                                        case "pointerover":
                                        case "pointerup":
                                            De = id;
                                            break;
                                        case "toggle":
                                        case "beforetoggle":
                                            De = il
                                        }
                                        var Ft = (o & 4) !== 0
                                          , ei = !Ft && (a === "scroll" || a === "scrollend")
                                          , ge = Ft ? we !== null ? we + "Capture" : null : we;
                                        Ft = [];
                                        for (var fe = Ae, _e; fe !== null; ) {
                                            var We = fe;
                                            if (_e = We.stateNode,
                                            We = We.tag,
                                            We !== 5 && We !== 26 && We !== 27 || _e === null || ge === null || (We = Fc(fe, ge),
                                            We != null && Ft.push(Sg(fe, We, _e))),
                                            ei)
                                                break;
                                            fe = fe.return
                                        }
                                        0 < Ft.length && (we = new De(we,qt,null,f,qe),
                                        je.push({
                                            event: we,
                                            listeners: Ft
                                        }))
                                    }
                                }
                                if ((o & 7) === 0) {
                                    e: {
                                        if (we = a === "mouseover" || a === "pointerover",
                                        De = a === "mouseout" || a === "pointerout",
                                        we && f !== Jf && (qt = f.relatedTarget || f.fromElement) && (Ir(qt) || qt[Pr]))
                                            break e;
                                        if ((De || we) && (we = qe.window === qe ? qe : (we = qe.ownerDocument) ? we.defaultView || we.parentWindow : window,
                                        De ? (qt = f.relatedTarget || f.toElement,
                                        De = Ae,
                                        qt = qt ? Ir(qt) : null,
                                        qt !== null && (ei = l(qt),
                                        Ft = qt.tag,
                                        qt !== ei || Ft !== 5 && Ft !== 27 && Ft !== 6) && (qt = null)) : (De = null,
                                        qt = Ae),
                                        De !== qt)) {
                                            if (Ft = Am,
                                            We = "onMouseLeave",
                                            ge = "onMouseEnter",
                                            fe = "mouse",
                                            (a === "pointerout" || a === "pointerover") && (Ft = id,
                                            We = "onPointerLeave",
                                            ge = "onPointerEnter",
                                            fe = "pointer"),
                                            ei = De == null ? we : $o(De),
                                            _e = qt == null ? we : $o(qt),
                                            we = new Ft(We,fe + "leave",De,f,qe),
                                            we.target = ei,
                                            we.relatedTarget = _e,
                                            We = null,
                                            Ir(qe) === Ae && (Ft = new Ft(ge,fe + "enter",qt,f,qe),
                                            Ft.target = _e,
                                            Ft.relatedTarget = ei,
                                            We = Ft),
                                            ei = We,
                                            De && qt)
                                                t: {
                                                    for (Ft = De,
                                                    ge = qt,
                                                    fe = 0,
                                                    _e = Ft; _e; _e = jd(_e))
                                                        fe++;
                                                    for (_e = 0,
                                                    We = ge; We; We = jd(We))
                                                        _e++;
                                                    for (; 0 < fe - _e; )
                                                        Ft = jd(Ft),
                                                        fe--;
                                                    for (; 0 < _e - fe; )
                                                        ge = jd(ge),
                                                        _e--;
                                                    for (; fe--; ) {
                                                        if (Ft === ge || ge !== null && Ft === ge.alternate)
                                                            break t;
                                                        Ft = jd(Ft),
                                                        ge = jd(ge)
                                                    }
                                                    Ft = null
                                                }
                                            else
                                                Ft = null;
                                            De !== null && Cb(je, we, De, Ft, !1),
                                            qt !== null && ei !== null && Cb(je, ei, qt, Ft, !0)
                                        }
                                    }
                                    e: {
                                        if (we = Ae ? $o(Ae) : window,
                                        De = we.nodeName && we.nodeName.toLowerCase(),
                                        De === "select" || De === "input" && we.type === "file")
                                            var St = ad;
                                        else if (Dm(we))
                                            if (rd)
                                                St = rl;
                                            else {
                                                St = S0;
                                                var mn = bS
                                            }
                                        else
                                            De = we.nodeName,
                                            !De || De.toLowerCase() !== "input" || we.type !== "checkbox" && we.type !== "radio" ? Ae && Kf(Ae.elementType) && (St = ad) : St = Sh;
                                        if (St && (St = St(a, Ae))) {
                                            Zs(je, St, f, qe);
                                            break e
                                        }
                                        mn && mn(a, we, Ae),
                                        a === "focusout" && Ae && we.type === "number" && Ae.memoizedProps.value != null && bs(we, "number", we.value)
                                    }
                                    switch (mn = Ae ? $o(Ae) : window,
                                    a) {
                                    case "focusin":
                                        (Dm(mn) || mn.contentEditable === "true") && (vo = mn,
                                        ld = Ae,
                                        Th = null);
                                        break;
                                    case "focusout":
                                        Th = ld = vo = null;
                                        break;
                                    case "mousedown":
                                        cd = !0;
                                        break;
                                    case "contextmenu":
                                    case "mouseup":
                                    case "dragend":
                                        cd = !1,
                                        Pm(je, f, qe);
                                        break;
                                    case "selectionchange":
                                        if (Bm)
                                            break;
                                    case "keydown":
                                    case "keyup":
                                        Pm(je, f, qe)
                                    }
                                    var Ot;
                                    if (mh)
                                        e: {
                                            switch (a) {
                                            case "compositionstart":
                                                var Ht = "onCompositionStart";
                                                break e;
                                            case "compositionend":
                                                Ht = "onCompositionEnd";
                                                break e;
                                            case "compositionupdate":
                                                Ht = "onCompositionUpdate";
                                                break e
                                            }
                                            Ht = void 0
                                        }
                                    else
                                        al ? yh(a, f) && (Ht = "onCompositionEnd") : a === "keydown" && f.keyCode === 229 && (Ht = "onCompositionStart");
                                    Ht && (vh && f.locale !== "ko" && (al || Ht !== "onCompositionStart" ? Ht === "onCompositionEnd" && al && (Ot = Sm()) : (fo = qe,
                                    xm = "value"in fo ? fo.value : fo.textContent,
                                    al = !0)),
                                    mn = gy(Ae, Ht),
                                    0 < mn.length && (Ht = new nd(Ht,a,null,f,qe),
                                    je.push({
                                        event: Ht,
                                        listeners: mn
                                    }),
                                    Ot ? Ht.data = Ot : (Ot = Cm(f),
                                    Ot !== null && (Ht.data = Ot)))),
                                    (Ot = gh ? _h(a, f) : Rm(a, f)) && (Ht = gy(Ae, "onBeforeInput"),
                                    0 < Ht.length && (mn = new nd("onBeforeInput","beforeinput",null,f,qe),
                                    je.push({
                                        event: mn,
                                        listeners: Ht
                                    }),
                                    mn.data = Ot)),
                                    t3(je, a, Ae, f, qe)
                                }
                                bb(je, o)
                            })
                        }
                        function Sg(a, o, f) {
                            return {
                                instance: a,
                                listener: o,
                                currentTarget: f
                            }
                        }
                        function gy(a, o) {
                            for (var f = o + "Capture", g = []; a !== null; ) {
                                var S = a
                                  , w = S.stateNode;
                                if (S = S.tag,
                                S !== 5 && S !== 26 && S !== 27 || w === null || (S = Fc(a, f),
                                S != null && g.unshift(Sg(a, S, w)),
                                S = Fc(a, o),
                                S != null && g.push(Sg(a, S, w))),
                                a.tag === 3)
                                    return g;
                                a = a.return
                            }
                            return []
                        }
                        function jd(a) {
                            if (a === null)
                                return null;
                            do
                                a = a.return;
                            while (a && a.tag !== 5 && a.tag !== 27);
                            return a || null
                        }
                        function Cb(a, o, f, g, S) {
                            for (var w = o._reactName, z = []; f !== null && f !== g; ) {
                                var Y = f
                                  , re = Y.alternate
                                  , Ae = Y.stateNode;
                                if (Y = Y.tag,
                                re !== null && re === g)
                                    break;
                                Y !== 5 && Y !== 26 && Y !== 27 || Ae === null || (re = Ae,
                                S ? (Ae = Fc(f, w),
                                Ae != null && z.unshift(Sg(f, Ae, re))) : S || (Ae = Fc(f, w),
                                Ae != null && z.push(Sg(f, Ae, re)))),
                                f = f.return
                            }
                            z.length !== 0 && a.push({
                                event: o,
                                listeners: z
                            })
                        }
                        var a3 = /\r\n?/g
                          , r3 = /\u0000|\uFFFD/g;
                        function Rb(a) {
                            return (typeof a == "string" ? a : "" + a).replace(a3, `
`).replace(r3, "")
                        }
                        function Db(a, o) {
                            return o = Rb(o),
                            Rb(a) === o
                        }
                        function vy() {}
                        function $n(a, o, f, g, S, w) {
                            switch (f) {
                            case "children":
                                typeof g == "string" ? o === "body" || o === "textarea" && g === "" || fr(a, g) : (typeof g == "number" || typeof g == "bigint") && o !== "body" && fr(a, "" + g);
                                break;
                            case "className":
                                Dt(a, "class", g);
                                break;
                            case "tabIndex":
                                Dt(a, "tabindex", g);
                                break;
                            case "dir":
                            case "role":
                            case "viewBox":
                            case "width":
                            case "height":
                                Dt(a, f, g);
                                break;
                            case "style":
                                lh(a, g, w);
                                break;
                            case "data":
                                if (o !== "object") {
                                    Dt(a, "data", g);
                                    break
                                }
                            case "src":
                            case "href":
                                if (g === "" && (o !== "a" || f !== "href")) {
                                    a.removeAttribute(f);
                                    break
                                }
                                if (g == null || typeof g == "function" || typeof g == "symbol" || typeof g == "boolean") {
                                    a.removeAttribute(f);
                                    break
                                }
                                g = ch("" + g),
                                a.setAttribute(f, g);
                                break;
                            case "action":
                            case "formAction":
                                if (typeof g == "function") {
                                    a.setAttribute(f, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                                    break
                                } else
                                    typeof w == "function" && (f === "formAction" ? (o !== "input" && $n(a, o, "name", S.name, S, null),
                                    $n(a, o, "formEncType", S.formEncType, S, null),
                                    $n(a, o, "formMethod", S.formMethod, S, null),
                                    $n(a, o, "formTarget", S.formTarget, S, null)) : ($n(a, o, "encType", S.encType, S, null),
                                    $n(a, o, "method", S.method, S, null),
                                    $n(a, o, "target", S.target, S, null)));
                                if (g == null || typeof g == "symbol" || typeof g == "boolean") {
                                    a.removeAttribute(f);
                                    break
                                }
                                g = ch("" + g),
                                a.setAttribute(f, g);
                                break;
                            case "onClick":
                                g != null && (a.onclick = vy);
                                break;
                            case "onScroll":
                                g != null && vn("scroll", a);
                                break;
                            case "onScrollEnd":
                                g != null && vn("scrollend", a);
                                break;
                            case "dangerouslySetInnerHTML":
                                if (g != null) {
                                    if (typeof g != "object" || !("__html"in g))
                                        throw Error(s(61));
                                    if (f = g.__html,
                                    f != null) {
                                        if (S.children != null)
                                            throw Error(s(60));
                                        a.innerHTML = f
                                    }
                                }
                                break;
                            case "multiple":
                                a.multiple = g && typeof g != "function" && typeof g != "symbol";
                                break;
                            case "muted":
                                a.muted = g && typeof g != "function" && typeof g != "symbol";
                                break;
                            case "suppressContentEditableWarning":
                            case "suppressHydrationWarning":
                            case "defaultValue":
                            case "defaultChecked":
                            case "innerHTML":
                            case "ref":
                                break;
                            case "autoFocus":
                                break;
                            case "xlinkHref":
                                if (g == null || typeof g == "function" || typeof g == "boolean" || typeof g == "symbol") {
                                    a.removeAttribute("xlink:href");
                                    break
                                }
                                f = ch("" + g),
                                a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", f);
                                break;
                            case "contentEditable":
                            case "spellCheck":
                            case "draggable":
                            case "value":
                            case "autoReverse":
                            case "externalResourcesRequired":
                            case "focusable":
                            case "preserveAlpha":
                                g != null && typeof g != "function" && typeof g != "symbol" ? a.setAttribute(f, "" + g) : a.removeAttribute(f);
                                break;
                            case "inert":
                            case "allowFullScreen":
                            case "async":
                            case "autoPlay":
                            case "controls":
                            case "default":
                            case "defer":
                            case "disabled":
                            case "disablePictureInPicture":
                            case "disableRemotePlayback":
                            case "formNoValidate":
                            case "hidden":
                            case "loop":
                            case "noModule":
                            case "noValidate":
                            case "open":
                            case "playsInline":
                            case "readOnly":
                            case "required":
                            case "reversed":
                            case "scoped":
                            case "seamless":
                            case "itemScope":
                                g && typeof g != "function" && typeof g != "symbol" ? a.setAttribute(f, "") : a.removeAttribute(f);
                                break;
                            case "capture":
                            case "download":
                                g === !0 ? a.setAttribute(f, "") : g !== !1 && g != null && typeof g != "function" && typeof g != "symbol" ? a.setAttribute(f, g) : a.removeAttribute(f);
                                break;
                            case "cols":
                            case "rows":
                            case "size":
                            case "span":
                                g != null && typeof g != "function" && typeof g != "symbol" && !isNaN(g) && 1 <= g ? a.setAttribute(f, g) : a.removeAttribute(f);
                                break;
                            case "rowSpan":
                            case "start":
                                g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g) ? a.removeAttribute(f) : a.setAttribute(f, g);
                                break;
                            case "popover":
                                vn("beforetoggle", a),
                                vn("toggle", a),
                                ut(a, "popover", g);
                                break;
                            case "xlinkActuate":
                                bt(a, "http://www.w3.org/1999/xlink", "xlink:actuate", g);
                                break;
                            case "xlinkArcrole":
                                bt(a, "http://www.w3.org/1999/xlink", "xlink:arcrole", g);
                                break;
                            case "xlinkRole":
                                bt(a, "http://www.w3.org/1999/xlink", "xlink:role", g);
                                break;
                            case "xlinkShow":
                                bt(a, "http://www.w3.org/1999/xlink", "xlink:show", g);
                                break;
                            case "xlinkTitle":
                                bt(a, "http://www.w3.org/1999/xlink", "xlink:title", g);
                                break;
                            case "xlinkType":
                                bt(a, "http://www.w3.org/1999/xlink", "xlink:type", g);
                                break;
                            case "xmlBase":
                                bt(a, "http://www.w3.org/XML/1998/namespace", "xml:base", g);
                                break;
                            case "xmlLang":
                                bt(a, "http://www.w3.org/XML/1998/namespace", "xml:lang", g);
                                break;
                            case "xmlSpace":
                                bt(a, "http://www.w3.org/XML/1998/namespace", "xml:space", g);
                                break;
                            case "is":
                                ut(a, "is", g);
                                break;
                            case "innerText":
                            case "textContent":
                                break;
                            default:
                                (!(2 < f.length) || f[0] !== "o" && f[0] !== "O" || f[1] !== "n" && f[1] !== "N") && (f = vm.get(f) || f,
                                ut(a, f, g))
                            }
                        }
                        function GS(a, o, f, g, S, w) {
                            switch (f) {
                            case "style":
                                lh(a, g, w);
                                break;
                            case "dangerouslySetInnerHTML":
                                if (g != null) {
                                    if (typeof g != "object" || !("__html"in g))
                                        throw Error(s(61));
                                    if (f = g.__html,
                                    f != null) {
                                        if (S.children != null)
                                            throw Error(s(60));
                                        a.innerHTML = f
                                    }
                                }
                                break;
                            case "children":
                                typeof g == "string" ? fr(a, g) : (typeof g == "number" || typeof g == "bigint") && fr(a, "" + g);
                                break;
                            case "onScroll":
                                g != null && vn("scroll", a);
                                break;
                            case "onScrollEnd":
                                g != null && vn("scrollend", a);
                                break;
                            case "onClick":
                                g != null && (a.onclick = vy);
                                break;
                            case "suppressContentEditableWarning":
                            case "suppressHydrationWarning":
                            case "innerHTML":
                            case "ref":
                                break;
                            case "innerText":
                            case "textContent":
                                break;
                            default:
                                if (!me.hasOwnProperty(f))
                                    e: {
                                        if (f[0] === "o" && f[1] === "n" && (S = f.endsWith("Capture"),
                                        o = f.slice(2, S ? f.length - 7 : void 0),
                                        w = a[ki] || null,
                                        w = w != null ? w[f] : null,
                                        typeof w == "function" && a.removeEventListener(o, w, S),
                                        typeof g == "function")) {
                                            typeof w != "function" && w !== null && (f in a ? a[f] = null : a.hasAttribute(f) && a.removeAttribute(f)),
                                            a.addEventListener(o, g, S);
                                            break e
                                        }
                                        f in a ? a[f] = g : g === !0 ? a.setAttribute(f, "") : ut(a, f, g)
                                    }
                            }
                        }
                        function ks(a, o, f) {
                            switch (o) {
                            case "div":
                            case "span":
                            case "svg":
                            case "path":
                            case "a":
                            case "g":
                            case "p":
                            case "li":
                                break;
                            case "img":
                                vn("error", a),
                                vn("load", a);
                                var g = !1, S = !1, w;
                                for (w in f)
                                    if (f.hasOwnProperty(w)) {
                                        var z = f[w];
                                        if (z != null)
                                            switch (w) {
                                            case "src":
                                                g = !0;
                                                break;
                                            case "srcSet":
                                                S = !0;
                                                break;
                                            case "children":
                                            case "dangerouslySetInnerHTML":
                                                throw Error(s(137, o));
                                            default:
                                                $n(a, o, w, z, f, null)
                                            }
                                    }
                                S && $n(a, o, "srcSet", f.srcSet, f, null),
                                g && $n(a, o, "src", f.src, f, null);
                                return;
                            case "input":
                                vn("invalid", a);
                                var Y = w = z = S = null
                                  , re = null
                                  , Ae = null;
                                for (g in f)
                                    if (f.hasOwnProperty(g)) {
                                        var qe = f[g];
                                        if (qe != null)
                                            switch (g) {
                                            case "name":
                                                S = qe;
                                                break;
                                            case "type":
                                                z = qe;
                                                break;
                                            case "checked":
                                                re = qe;
                                                break;
                                            case "defaultChecked":
                                                Ae = qe;
                                                break;
                                            case "value":
                                                w = qe;
                                                break;
                                            case "defaultValue":
                                                Y = qe;
                                                break;
                                            case "children":
                                            case "dangerouslySetInnerHTML":
                                                if (qe != null)
                                                    throw Error(s(137, o));
                                                break;
                                            default:
                                                $n(a, o, g, qe, f, null)
                                            }
                                    }
                                Mi(a, w, Y, re, Ae, z, S, !1),
                                Va(a);
                                return;
                            case "select":
                                vn("invalid", a),
                                g = z = w = null;
                                for (S in f)
                                    if (f.hasOwnProperty(S) && (Y = f[S],
                                    Y != null))
                                        switch (S) {
                                        case "value":
                                            w = Y;
                                            break;
                                        case "defaultValue":
                                            z = Y;
                                            break;
                                        case "multiple":
                                            g = Y;
                                        default:
                                            $n(a, o, S, Y, f, null)
                                        }
                                o = w,
                                f = z,
                                a.multiple = !!g,
                                o != null ? hr(a, !!g, o, !1) : f != null && hr(a, !!g, f, !0);
                                return;
                            case "textarea":
                                vn("invalid", a),
                                w = S = g = null;
                                for (z in f)
                                    if (f.hasOwnProperty(z) && (Y = f[z],
                                    Y != null))
                                        switch (z) {
                                        case "value":
                                            g = Y;
                                            break;
                                        case "defaultValue":
                                            S = Y;
                                            break;
                                        case "children":
                                            w = Y;
                                            break;
                                        case "dangerouslySetInnerHTML":
                                            if (Y != null)
                                                throw Error(s(91));
                                            break;
                                        default:
                                            $n(a, o, z, Y, f, null)
                                        }
                                gm(a, g, S, w),
                                Va(a);
                                return;
                            case "option":
                                for (re in f)
                                    if (f.hasOwnProperty(re) && (g = f[re],
                                    g != null))
                                        switch (re) {
                                        case "selected":
                                            a.selected = g && typeof g != "function" && typeof g != "symbol";
                                            break;
                                        default:
                                            $n(a, o, re, g, f, null)
                                        }
                                return;
                            case "dialog":
                                vn("beforetoggle", a),
                                vn("toggle", a),
                                vn("cancel", a),
                                vn("close", a);
                                break;
                            case "iframe":
                            case "object":
                                vn("load", a);
                                break;
                            case "video":
                            case "audio":
                                for (g = 0; g < xg.length; g++)
                                    vn(xg[g], a);
                                break;
                            case "image":
                                vn("error", a),
                                vn("load", a);
                                break;
                            case "details":
                                vn("toggle", a);
                                break;
                            case "embed":
                            case "source":
                            case "link":
                                vn("error", a),
                                vn("load", a);
                            case "area":
                            case "base":
                            case "br":
                            case "col":
                            case "hr":
                            case "keygen":
                            case "meta":
                            case "param":
                            case "track":
                            case "wbr":
                            case "menuitem":
                                for (Ae in f)
                                    if (f.hasOwnProperty(Ae) && (g = f[Ae],
                                    g != null))
                                        switch (Ae) {
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            throw Error(s(137, o));
                                        default:
                                            $n(a, o, Ae, g, f, null)
                                        }
                                return;
                            default:
                                if (Kf(o)) {
                                    for (qe in f)
                                        f.hasOwnProperty(qe) && (g = f[qe],
                                        g !== void 0 && GS(a, o, qe, g, f, void 0));
                                    return
                                }
                            }
                            for (Y in f)
                                f.hasOwnProperty(Y) && (g = f[Y],
                                g != null && $n(a, o, Y, g, f, null))
                        }
                        function o3(a, o, f, g) {
                            switch (o) {
                            case "div":
                            case "span":
                            case "svg":
                            case "path":
                            case "a":
                            case "g":
                            case "p":
                            case "li":
                                break;
                            case "input":
                                var S = null
                                  , w = null
                                  , z = null
                                  , Y = null
                                  , re = null
                                  , Ae = null
                                  , qe = null;
                                for (De in f) {
                                    var je = f[De];
                                    if (f.hasOwnProperty(De) && je != null)
                                        switch (De) {
                                        case "checked":
                                            break;
                                        case "value":
                                            break;
                                        case "defaultValue":
                                            re = je;
                                        default:
                                            g.hasOwnProperty(De) || $n(a, o, De, null, g, je)
                                        }
                                }
                                for (var we in g) {
                                    var De = g[we];
                                    if (je = f[we],
                                    g.hasOwnProperty(we) && (De != null || je != null))
                                        switch (we) {
                                        case "type":
                                            w = De;
                                            break;
                                        case "name":
                                            S = De;
                                            break;
                                        case "checked":
                                            Ae = De;
                                            break;
                                        case "defaultChecked":
                                            qe = De;
                                            break;
                                        case "value":
                                            z = De;
                                            break;
                                        case "defaultValue":
                                            Y = De;
                                            break;
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            if (De != null)
                                                throw Error(s(137, o));
                                            break;
                                        default:
                                            De !== je && $n(a, o, we, De, g, je)
                                        }
                                }
                                cs(a, z, Y, re, Ae, qe, w, S);
                                return;
                            case "select":
                                De = z = Y = we = null;
                                for (w in f)
                                    if (re = f[w],
                                    f.hasOwnProperty(w) && re != null)
                                        switch (w) {
                                        case "value":
                                            break;
                                        case "multiple":
                                            De = re;
                                        default:
                                            g.hasOwnProperty(w) || $n(a, o, w, null, g, re)
                                        }
                                for (S in g)
                                    if (w = g[S],
                                    re = f[S],
                                    g.hasOwnProperty(S) && (w != null || re != null))
                                        switch (S) {
                                        case "value":
                                            we = w;
                                            break;
                                        case "defaultValue":
                                            Y = w;
                                            break;
                                        case "multiple":
                                            z = w;
                                        default:
                                            w !== re && $n(a, o, S, w, g, re)
                                        }
                                o = Y,
                                f = z,
                                g = De,
                                we != null ? hr(a, !!f, we, !1) : !!g != !!f && (o != null ? hr(a, !!f, o, !0) : hr(a, !!f, f ? [] : "", !1));
                                return;
                            case "textarea":
                                De = we = null;
                                for (Y in f)
                                    if (S = f[Y],
                                    f.hasOwnProperty(Y) && S != null && !g.hasOwnProperty(Y))
                                        switch (Y) {
                                        case "value":
                                            break;
                                        case "children":
                                            break;
                                        default:
                                            $n(a, o, Y, null, g, S)
                                        }
                                for (z in g)
                                    if (S = g[z],
                                    w = f[z],
                                    g.hasOwnProperty(z) && (S != null || w != null))
                                        switch (z) {
                                        case "value":
                                            we = S;
                                            break;
                                        case "defaultValue":
                                            De = S;
                                            break;
                                        case "children":
                                            break;
                                        case "dangerouslySetInnerHTML":
                                            if (S != null)
                                                throw Error(s(91));
                                            break;
                                        default:
                                            S !== w && $n(a, o, z, S, g, w)
                                        }
                                zr(a, we, De);
                                return;
                            case "option":
                                for (var qt in f)
                                    if (we = f[qt],
                                    f.hasOwnProperty(qt) && we != null && !g.hasOwnProperty(qt))
                                        switch (qt) {
                                        case "selected":
                                            a.selected = !1;
                                            break;
                                        default:
                                            $n(a, o, qt, null, g, we)
                                        }
                                for (re in g)
                                    if (we = g[re],
                                    De = f[re],
                                    g.hasOwnProperty(re) && we !== De && (we != null || De != null))
                                        switch (re) {
                                        case "selected":
                                            a.selected = we && typeof we != "function" && typeof we != "symbol";
                                            break;
                                        default:
                                            $n(a, o, re, we, g, De)
                                        }
                                return;
                            case "img":
                            case "link":
                            case "area":
                            case "base":
                            case "br":
                            case "col":
                            case "embed":
                            case "hr":
                            case "keygen":
                            case "meta":
                            case "param":
                            case "source":
                            case "track":
                            case "wbr":
                            case "menuitem":
                                for (var Ft in f)
                                    we = f[Ft],
                                    f.hasOwnProperty(Ft) && we != null && !g.hasOwnProperty(Ft) && $n(a, o, Ft, null, g, we);
                                for (Ae in g)
                                    if (we = g[Ae],
                                    De = f[Ae],
                                    g.hasOwnProperty(Ae) && we !== De && (we != null || De != null))
                                        switch (Ae) {
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            if (we != null)
                                                throw Error(s(137, o));
                                            break;
                                        default:
                                            $n(a, o, Ae, we, g, De)
                                        }
                                return;
                            default:
                                if (Kf(o)) {
                                    for (var ei in f)
                                        we = f[ei],
                                        f.hasOwnProperty(ei) && we !== void 0 && !g.hasOwnProperty(ei) && GS(a, o, ei, void 0, g, we);
                                    for (qe in g)
                                        we = g[qe],
                                        De = f[qe],
                                        !g.hasOwnProperty(qe) || we === De || we === void 0 && De === void 0 || GS(a, o, qe, we, g, De);
                                    return
                                }
                            }
                            for (var ge in f)
                                we = f[ge],
                                f.hasOwnProperty(ge) && we != null && !g.hasOwnProperty(ge) && $n(a, o, ge, null, g, we);
                            for (je in g)
                                we = g[je],
                                De = f[je],
                                !g.hasOwnProperty(je) || we === De || we == null && De == null || $n(a, o, je, we, g, De)
                        }
                        var kS = null
                          , XS = null;
                        function yy(a) {
                            return a.nodeType === 9 ? a : a.ownerDocument
                        }
                        function Ob(a) {
                            switch (a) {
                            case "http://www.w3.org/2000/svg":
                                return 1;
                            case "http://www.w3.org/1998/Math/MathML":
                                return 2;
                            default:
                                return 0
                            }
                        }
                        function Nb(a, o) {
                            if (a === 0)
                                switch (o) {
                                case "svg":
                                    return 1;
                                case "math":
                                    return 2;
                                default:
                                    return 0
                                }
                            return a === 1 && o === "foreignObject" ? 0 : a
                        }
                        function qS(a, o) {
                            return a === "textarea" || a === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null
                        }
                        var YS = null;
                        function l3() {
                            var a = window.event;
                            return a && a.type === "popstate" ? a === YS ? !1 : (YS = a,
                            !0) : (YS = null,
                            !1)
                        }
                        var Ub = typeof setTimeout == "function" ? setTimeout : void 0
                          , c3 = typeof clearTimeout == "function" ? clearTimeout : void 0
                          , Bb = typeof Promise == "function" ? Promise : void 0
                          , u3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Bb < "u" ? function(a) {
                            return Bb.resolve(null).then(a).catch(h3)
                        }
                        : Ub;
                        function h3(a) {
                            setTimeout(function() {
                                throw a
                            })
                        }
                        function Mu(a) {
                            return a === "head"
                        }
                        function Pb(a, o) {
                            var f = o
                              , g = 0
                              , S = 0;
                            do {
                                var w = f.nextSibling;
                                if (a.removeChild(f),
                                w && w.nodeType === 8)
                                    if (f = w.data,
                                    f === "/$") {
                                        if (0 < g && 8 > g) {
                                            f = g;
                                            var z = a.ownerDocument;
                                            if (f & 1 && Ag(z.documentElement),
                                            f & 2 && Ag(z.body),
                                            f & 4)
                                                for (f = z.head,
                                                Ag(f),
                                                z = f.firstChild; z; ) {
                                                    var Y = z.nextSibling
                                                      , re = z.nodeName;
                                                    z[cr] || re === "SCRIPT" || re === "STYLE" || re === "LINK" && z.rel.toLowerCase() === "stylesheet" || f.removeChild(z),
                                                    z = Y
                                                }
                                        }
                                        if (S === 0) {
                                            a.removeChild(w),
                                            Dg(o);
                                            return
                                        }
                                        S--
                                    } else
                                        f === "$" || f === "$?" || f === "$!" ? S++ : g = f.charCodeAt(0) - 48;
                                else
                                    g = 0;
                                f = w
                            } while (f);
                            Dg(o)
                        }
                        function WS(a) {
                            var o = a.firstChild;
                            for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
                                var f = o;
                                switch (o = o.nextSibling,
                                f.nodeName) {
                                case "HTML":
                                case "HEAD":
                                case "BODY":
                                    WS(f),
                                    si(f);
                                    continue;
                                case "SCRIPT":
                                case "STYLE":
                                    continue;
                                case "LINK":
                                    if (f.rel.toLowerCase() === "stylesheet")
                                        continue
                                }
                                a.removeChild(f)
                            }
                        }
                        function f3(a, o, f, g) {
                            for (; a.nodeType === 1; ) {
                                var S = f;
                                if (a.nodeName.toLowerCase() !== o.toLowerCase()) {
                                    if (!g && (a.nodeName !== "INPUT" || a.type !== "hidden"))
                                        break
                                } else if (g) {
                                    if (!a[cr])
                                        switch (o) {
                                        case "meta":
                                            if (!a.hasAttribute("itemprop"))
                                                break;
                                            return a;
                                        case "link":
                                            if (w = a.getAttribute("rel"),
                                            w === "stylesheet" && a.hasAttribute("data-precedence"))
                                                break;
                                            if (w !== S.rel || a.getAttribute("href") !== (S.href == null || S.href === "" ? null : S.href) || a.getAttribute("crossorigin") !== (S.crossOrigin == null ? null : S.crossOrigin) || a.getAttribute("title") !== (S.title == null ? null : S.title))
                                                break;
                                            return a;
                                        case "style":
                                            if (a.hasAttribute("data-precedence"))
                                                break;
                                            return a;
                                        case "script":
                                            if (w = a.getAttribute("src"),
                                            (w !== (S.src == null ? null : S.src) || a.getAttribute("type") !== (S.type == null ? null : S.type) || a.getAttribute("crossorigin") !== (S.crossOrigin == null ? null : S.crossOrigin)) && w && a.hasAttribute("async") && !a.hasAttribute("itemprop"))
                                                break;
                                            return a;
                                        default:
                                            return a
                                        }
                                } else if (o === "input" && a.type === "hidden") {
                                    var w = S.name == null ? null : "" + S.name;
                                    if (S.type === "hidden" && a.getAttribute("name") === w)
                                        return a
                                } else
                                    return a;
                                if (a = Io(a.nextSibling),
                                a === null)
                                    break
                            }
                            return null
                        }
                        function d3(a, o, f) {
                            if (o === "")
                                return null;
                            for (; a.nodeType !== 3; )
                                if ((a.nodeType !== 1 || a.nodeName !== "INPUT" || a.type !== "hidden") && !f || (a = Io(a.nextSibling),
                                a === null))
                                    return null;
                            return a
                        }
                        function jS(a) {
                            return a.data === "$!" || a.data === "$?" && a.ownerDocument.readyState === "complete"
                        }
                        function p3(a, o) {
                            var f = a.ownerDocument;
                            if (a.data !== "$?" || f.readyState === "complete")
                                o();
                            else {
                                var g = function() {
                                    o(),
                                    f.removeEventListener("DOMContentLoaded", g)
                                };
                                f.addEventListener("DOMContentLoaded", g),
                                a._reactRetry = g
                            }
                        }
                        function Io(a) {
                            for (; a != null; a = a.nextSibling) {
                                var o = a.nodeType;
                                if (o === 1 || o === 3)
                                    break;
                                if (o === 8) {
                                    if (o = a.data,
                                    o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F")
                                        break;
                                    if (o === "/$")
                                        return null
                                }
                            }
                            return a
                        }
                        var QS = null;
                        function Ib(a) {
                            a = a.previousSibling;
                            for (var o = 0; a; ) {
                                if (a.nodeType === 8) {
                                    var f = a.data;
                                    if (f === "$" || f === "$!" || f === "$?") {
                                        if (o === 0)
                                            return a;
                                        o--
                                    } else
                                        f === "/$" && o++
                                }
                                a = a.previousSibling
                            }
                            return null
                        }
                        function Lb(a, o, f) {
                            switch (o = yy(f),
                            a) {
                            case "html":
                                if (a = o.documentElement,
                                !a)
                                    throw Error(s(452));
                                return a;
                            case "head":
                                if (a = o.head,
                                !a)
                                    throw Error(s(453));
                                return a;
                            case "body":
                                if (a = o.body,
                                !a)
                                    throw Error(s(454));
                                return a;
                            default:
                                throw Error(s(451))
                            }
                        }
                        function Ag(a) {
                            for (var o = a.attributes; o.length; )
                                a.removeAttributeNode(o[0]);
                            si(a)
                        }
                        var to = new Map
                          , zb = new Set;
                        function _y(a) {
                            return typeof a.getRootNode == "function" ? a.getRootNode() : a.nodeType === 9 ? a : a.ownerDocument
                        }
                        var _c = q.d;
                        q.d = {
                            f: m3,
                            r: g3,
                            D: v3,
                            C: y3,
                            L: _3,
                            m: x3,
                            X: A3,
                            S: S3,
                            M: T3
                        };
                        function m3() {
                            var a = _c.f()
                              , o = $r();
                            return a || o
                        }
                        function g3(a) {
                            var o = Lr(a);
                            o !== null && o.tag === 5 && o.type === "form" ? $0(o) : _c.r(a)
                        }
                        var Qd = typeof document > "u" ? null : document;
                        function Fb(a, o, f) {
                            var g = Qd;
                            if (g && typeof o == "string" && o) {
                                var S = Qn(o);
                                S = 'link[rel="' + a + '"][href="' + S + '"]',
                                typeof f == "string" && (S += '[crossorigin="' + f + '"]'),
                                zb.has(S) || (zb.add(S),
                                a = {
                                    rel: a,
                                    crossOrigin: f,
                                    href: o
                                },
                                g.querySelector(S) === null && (o = g.createElement("link"),
                                ks(o, "link", a),
                                Bi(o),
                                g.head.appendChild(o)))
                            }
                        }
                        function v3(a) {
                            _c.D(a),
                            Fb("dns-prefetch", a, null)
                        }
                        function y3(a, o) {
                            _c.C(a, o),
                            Fb("preconnect", a, o)
                        }
                        function _3(a, o, f) {
                            _c.L(a, o, f);
                            var g = Qd;
                            if (g && a && o) {
                                var S = 'link[rel="preload"][as="' + Qn(o) + '"]';
                                o === "image" && f && f.imageSrcSet ? (S += '[imagesrcset="' + Qn(f.imageSrcSet) + '"]',
                                typeof f.imageSizes == "string" && (S += '[imagesizes="' + Qn(f.imageSizes) + '"]')) : S += '[href="' + Qn(a) + '"]';
                                var w = S;
                                switch (o) {
                                case "style":
                                    w = Zd(a);
                                    break;
                                case "script":
                                    w = Kd(a)
                                }
                                to.has(w) || (a = v({
                                    rel: "preload",
                                    href: o === "image" && f && f.imageSrcSet ? void 0 : a,
                                    as: o
                                }, f),
                                to.set(w, a),
                                g.querySelector(S) !== null || o === "style" && g.querySelector(Tg(w)) || o === "script" && g.querySelector(Mg(w)) || (o = g.createElement("link"),
                                ks(o, "link", a),
                                Bi(o),
                                g.head.appendChild(o)))
                            }
                        }
                        function x3(a, o) {
                            _c.m(a, o);
                            var f = Qd;
                            if (f && a) {
                                var g = o && typeof o.as == "string" ? o.as : "script"
                                  , S = 'link[rel="modulepreload"][as="' + Qn(g) + '"][href="' + Qn(a) + '"]'
                                  , w = S;
                                switch (g) {
                                case "audioworklet":
                                case "paintworklet":
                                case "serviceworker":
                                case "sharedworker":
                                case "worker":
                                case "script":
                                    w = Kd(a)
                                }
                                if (!to.has(w) && (a = v({
                                    rel: "modulepreload",
                                    href: a
                                }, o),
                                to.set(w, a),
                                f.querySelector(S) === null)) {
                                    switch (g) {
                                    case "audioworklet":
                                    case "paintworklet":
                                    case "serviceworker":
                                    case "sharedworker":
                                    case "worker":
                                    case "script":
                                        if (f.querySelector(Mg(w)))
                                            return
                                    }
                                    g = f.createElement("link"),
                                    ks(g, "link", a),
                                    Bi(g),
                                    f.head.appendChild(g)
                                }
                            }
                        }
                        function S3(a, o, f) {
                            _c.S(a, o, f);
                            var g = Qd;
                            if (g && a) {
                                var S = ho(g).hoistableStyles
                                  , w = Zd(a);
                                o = o || "default";
                                var z = S.get(w);
                                if (!z) {
                                    var Y = {
                                        loading: 0,
                                        preload: null
                                    };
                                    if (z = g.querySelector(Tg(w)))
                                        Y.loading = 5;
                                    else {
                                        a = v({
                                            rel: "stylesheet",
                                            href: a,
                                            "data-precedence": o
                                        }, f),
                                        (f = to.get(w)) && ZS(a, f);
                                        var re = z = g.createElement("link");
                                        Bi(re),
                                        ks(re, "link", a),
                                        re._p = new Promise(function(Ae, qe) {
                                            re.onload = Ae,
                                            re.onerror = qe
                                        }
                                        ),
                                        re.addEventListener("load", function() {
                                            Y.loading |= 1
                                        }),
                                        re.addEventListener("error", function() {
                                            Y.loading |= 2
                                        }),
                                        Y.loading |= 4,
                                        xy(z, o, g)
                                    }
                                    z = {
                                        type: "stylesheet",
                                        instance: z,
                                        count: 1,
                                        state: Y
                                    },
                                    S.set(w, z)
                                }
                            }
                        }
                        function A3(a, o) {
                            _c.X(a, o);
                            var f = Qd;
                            if (f && a) {
                                var g = ho(f).hoistableScripts
                                  , S = Kd(a)
                                  , w = g.get(S);
                                w || (w = f.querySelector(Mg(S)),
                                w || (a = v({
                                    src: a,
                                    async: !0
                                }, o),
                                (o = to.get(S)) && KS(a, o),
                                w = f.createElement("script"),
                                Bi(w),
                                ks(w, "link", a),
                                f.head.appendChild(w)),
                                w = {
                                    type: "script",
                                    instance: w,
                                    count: 1,
                                    state: null
                                },
                                g.set(S, w))
                            }
                        }
                        function T3(a, o) {
                            _c.M(a, o);
                            var f = Qd;
                            if (f && a) {
                                var g = ho(f).hoistableScripts
                                  , S = Kd(a)
                                  , w = g.get(S);
                                w || (w = f.querySelector(Mg(S)),
                                w || (a = v({
                                    src: a,
                                    async: !0,
                                    type: "module"
                                }, o),
                                (o = to.get(S)) && KS(a, o),
                                w = f.createElement("script"),
                                Bi(w),
                                ks(w, "link", a),
                                f.head.appendChild(w)),
                                w = {
                                    type: "script",
                                    instance: w,
                                    count: 1,
                                    state: null
                                },
                                g.set(S, w))
                            }
                        }
                        function Hb(a, o, f, g) {
                            var S = (S = be.current) ? _y(S) : null;
                            if (!S)
                                throw Error(s(446));
                            switch (a) {
                            case "meta":
                            case "title":
                                return null;
                            case "style":
                                return typeof f.precedence == "string" && typeof f.href == "string" ? (o = Zd(f.href),
                                f = ho(S).hoistableStyles,
                                g = f.get(o),
                                g || (g = {
                                    type: "style",
                                    instance: null,
                                    count: 0,
                                    state: null
                                },
                                f.set(o, g)),
                                g) : {
                                    type: "void",
                                    instance: null,
                                    count: 0,
                                    state: null
                                };
                            case "link":
                                if (f.rel === "stylesheet" && typeof f.href == "string" && typeof f.precedence == "string") {
                                    a = Zd(f.href);
                                    var w = ho(S).hoistableStyles
                                      , z = w.get(a);
                                    if (z || (S = S.ownerDocument || S,
                                    z = {
                                        type: "stylesheet",
                                        instance: null,
                                        count: 0,
                                        state: {
                                            loading: 0,
                                            preload: null
                                        }
                                    },
                                    w.set(a, z),
                                    (w = S.querySelector(Tg(a))) && !w._p && (z.instance = w,
                                    z.state.loading = 5),
                                    to.has(a) || (f = {
                                        rel: "preload",
                                        as: "style",
                                        href: f.href,
                                        crossOrigin: f.crossOrigin,
                                        integrity: f.integrity,
                                        media: f.media,
                                        hrefLang: f.hrefLang,
                                        referrerPolicy: f.referrerPolicy
                                    },
                                    to.set(a, f),
                                    w || M3(S, a, f, z.state))),
                                    o && g === null)
                                        throw Error(s(528, ""));
                                    return z
                                }
                                if (o && g !== null)
                                    throw Error(s(529, ""));
                                return null;
                            case "script":
                                return o = f.async,
                                f = f.src,
                                typeof f == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = Kd(f),
                                f = ho(S).hoistableScripts,
                                g = f.get(o),
                                g || (g = {
                                    type: "script",
                                    instance: null,
                                    count: 0,
                                    state: null
                                },
                                f.set(o, g)),
                                g) : {
                                    type: "void",
                                    instance: null,
                                    count: 0,
                                    state: null
                                };
                            default:
                                throw Error(s(444, a))
                            }
                        }
                        function Zd(a) {
                            return 'href="' + Qn(a) + '"'
                        }
                        function Tg(a) {
                            return 'link[rel="stylesheet"][' + a + "]"
                        }
                        function Vb(a) {
                            return v({}, a, {
                                "data-precedence": a.precedence,
                                precedence: null
                            })
                        }
                        function M3(a, o, f, g) {
                            a.querySelector('link[rel="preload"][as="style"][' + o + "]") ? g.loading = 1 : (o = a.createElement("link"),
                            g.preload = o,
                            o.addEventListener("load", function() {
                                return g.loading |= 1
                            }),
                            o.addEventListener("error", function() {
                                return g.loading |= 2
                            }),
                            ks(o, "link", f),
                            Bi(o),
                            a.head.appendChild(o))
                        }
                        function Kd(a) {
                            return '[src="' + Qn(a) + '"]'
                        }
                        function Mg(a) {
                            return "script[async]" + a
                        }
                        function Gb(a, o, f) {
                            if (o.count++,
                            o.instance === null)
                                switch (o.type) {
                                case "style":
                                    var g = a.querySelector('style[data-href~="' + Qn(f.href) + '"]');
                                    if (g)
                                        return o.instance = g,
                                        Bi(g),
                                        g;
                                    var S = v({}, f, {
                                        "data-href": f.href,
                                        "data-precedence": f.precedence,
                                        href: null,
                                        precedence: null
                                    });
                                    return g = (a.ownerDocument || a).createElement("style"),
                                    Bi(g),
                                    ks(g, "style", S),
                                    xy(g, f.precedence, a),
                                    o.instance = g;
                                case "stylesheet":
                                    S = Zd(f.href);
                                    var w = a.querySelector(Tg(S));
                                    if (w)
                                        return o.state.loading |= 4,
                                        o.instance = w,
                                        Bi(w),
                                        w;
                                    g = Vb(f),
                                    (S = to.get(S)) && ZS(g, S),
                                    w = (a.ownerDocument || a).createElement("link"),
                                    Bi(w);
                                    var z = w;
                                    return z._p = new Promise(function(Y, re) {
                                        z.onload = Y,
                                        z.onerror = re
                                    }
                                    ),
                                    ks(w, "link", g),
                                    o.state.loading |= 4,
                                    xy(w, f.precedence, a),
                                    o.instance = w;
                                case "script":
                                    return w = Kd(f.src),
                                    (S = a.querySelector(Mg(w))) ? (o.instance = S,
                                    Bi(S),
                                    S) : (g = f,
                                    (S = to.get(w)) && (g = v({}, f),
                                    KS(g, S)),
                                    a = a.ownerDocument || a,
                                    S = a.createElement("script"),
                                    Bi(S),
                                    ks(S, "link", g),
                                    a.head.appendChild(S),
                                    o.instance = S);
                                case "void":
                                    return null;
                                default:
                                    throw Error(s(443, o.type))
                                }
                            else
                                o.type === "stylesheet" && (o.state.loading & 4) === 0 && (g = o.instance,
                                o.state.loading |= 4,
                                xy(g, f.precedence, a));
                            return o.instance
                        }
                        function xy(a, o, f) {
                            for (var g = f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), S = g.length ? g[g.length - 1] : null, w = S, z = 0; z < g.length; z++) {
                                var Y = g[z];
                                if (Y.dataset.precedence === o)
                                    w = Y;
                                else if (w !== S)
                                    break
                            }
                            w ? w.parentNode.insertBefore(a, w.nextSibling) : (o = f.nodeType === 9 ? f.head : f,
                            o.insertBefore(a, o.firstChild))
                        }
                        function ZS(a, o) {
                            a.crossOrigin ??= o.crossOrigin,
                            a.referrerPolicy ??= o.referrerPolicy,
                            a.title ??= o.title
                        }
                        function KS(a, o) {
                            a.crossOrigin ??= o.crossOrigin,
                            a.referrerPolicy ??= o.referrerPolicy,
                            a.integrity ??= o.integrity
                        }
                        var Sy = null;
                        function kb(a, o, f) {
                            if (Sy === null) {
                                var g = new Map
                                  , S = Sy = new Map;
                                S.set(f, g)
                            } else
                                S = Sy,
                                g = S.get(f),
                                g || (g = new Map,
                                S.set(f, g));
                            if (g.has(a))
                                return g;
                            for (g.set(a, null),
                            f = f.getElementsByTagName(a),
                            S = 0; S < f.length; S++) {
                                var w = f[S];
                                if (!(w[cr] || w[Ti] || a === "link" && w.getAttribute("rel") === "stylesheet") && w.namespaceURI !== "http://www.w3.org/2000/svg") {
                                    var z = w.getAttribute(o) || "";
                                    z = a + z;
                                    var Y = g.get(z);
                                    Y ? Y.push(w) : g.set(z, [w])
                                }
                            }
                            return g
                        }
                        function Xb(a, o, f) {
                            a = a.ownerDocument || a,
                            a.head.insertBefore(f, o === "title" ? a.querySelector("head > title") : null)
                        }
                        function b3(a, o, f) {
                            if (f === 1 || o.itemProp != null)
                                return !1;
                            switch (a) {
                            case "meta":
                            case "title":
                                return !0;
                            case "style":
                                if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "")
                                    break;
                                return !0;
                            case "link":
                                if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError)
                                    break;
                                switch (o.rel) {
                                case "stylesheet":
                                    return a = o.disabled,
                                    typeof o.precedence == "string" && a == null;
                                default:
                                    return !0
                                }
                            case "script":
                                if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string")
                                    return !0
                            }
                            return !1
                        }
                        function qb(a) {
                            return !(a.type === "stylesheet" && (a.state.loading & 3) === 0)
                        }
                        var bg = null;
                        function E3() {}
                        function w3(a, o, f) {
                            if (bg === null)
                                throw Error(s(475));
                            var g = bg;
                            if (o.type === "stylesheet" && (typeof f.media != "string" || matchMedia(f.media).matches !== !1) && (o.state.loading & 4) === 0) {
                                if (o.instance === null) {
                                    var S = Zd(f.href)
                                      , w = a.querySelector(Tg(S));
                                    if (w) {
                                        a = w._p,
                                        a !== null && typeof a == "object" && typeof a.then == "function" && (g.count++,
                                        g = Ay.bind(g),
                                        a.then(g, g)),
                                        o.state.loading |= 4,
                                        o.instance = w,
                                        Bi(w);
                                        return
                                    }
                                    w = a.ownerDocument || a,
                                    f = Vb(f),
                                    (S = to.get(S)) && ZS(f, S),
                                    w = w.createElement("link"),
                                    Bi(w);
                                    var z = w;
                                    z._p = new Promise(function(Y, re) {
                                        z.onload = Y,
                                        z.onerror = re
                                    }
                                    ),
                                    ks(w, "link", f),
                                    o.instance = w
                                }
                                g.stylesheets === null && (g.stylesheets = new Map),
                                g.stylesheets.set(o, a),
                                (a = o.state.preload) && (o.state.loading & 3) === 0 && (g.count++,
                                o = Ay.bind(g),
                                a.addEventListener("load", o),
                                a.addEventListener("error", o))
                            }
                        }
                        function C3() {
                            if (bg === null)
                                throw Error(s(475));
                            var a = bg;
                            return a.stylesheets && a.count === 0 && JS(a, a.stylesheets),
                            0 < a.count ? function(o) {
                                var f = setTimeout(function() {
                                    if (a.stylesheets && JS(a, a.stylesheets),
                                    a.unsuspend) {
                                        var g = a.unsuspend;
                                        a.unsuspend = null,
                                        g()
                                    }
                                }, 6e4);
                                return a.unsuspend = o,
                                function() {
                                    a.unsuspend = null,
                                    clearTimeout(f)
                                }
                            }
                            : null
                        }
                        function Ay() {
                            if (this.count--,
                            this.count === 0) {
                                if (this.stylesheets)
                                    JS(this, this.stylesheets);
                                else if (this.unsuspend) {
                                    var a = this.unsuspend;
                                    this.unsuspend = null,
                                    a()
                                }
                            }
                        }
                        var Ty = null;
                        function JS(a, o) {
                            a.stylesheets = null,
                            a.unsuspend !== null && (a.count++,
                            Ty = new Map,
                            o.forEach(R3, a),
                            Ty = null,
                            Ay.call(a))
                        }
                        function R3(a, o) {
                            if (!(o.state.loading & 4)) {
                                var f = Ty.get(a);
                                if (f)
                                    var g = f.get(null);
                                else {
                                    f = new Map,
                                    Ty.set(a, f);
                                    for (var S = a.querySelectorAll("link[data-precedence],style[data-precedence]"), w = 0; w < S.length; w++) {
                                        var z = S[w];
                                        (z.nodeName === "LINK" || z.getAttribute("media") !== "not all") && (f.set(z.dataset.precedence, z),
                                        g = z)
                                    }
                                    g && f.set(null, g)
                                }
                                S = o.instance,
                                z = S.getAttribute("data-precedence"),
                                w = f.get(z) || g,
                                w === g && f.set(null, S),
                                f.set(z, S),
                                this.count++,
                                g = Ay.bind(this),
                                S.addEventListener("load", g),
                                S.addEventListener("error", g),
                                w ? w.parentNode.insertBefore(S, w.nextSibling) : (a = a.nodeType === 9 ? a.head : a,
                                a.insertBefore(S, a.firstChild)),
                                o.state.loading |= 4
                            }
                        }
                        var Eg = {
                            $$typeof: O,
                            Provider: null,
                            Consumer: null,
                            _currentValue: ee,
                            _currentValue2: ee,
                            _threadCount: 0
                        };
                        function D3(a, o, f, g, S, w, z, Y) {
                            this.tag = 1,
                            this.containerInfo = a,
                            this.pingCache = this.current = this.pendingChildren = null,
                            this.timeoutHandle = -1,
                            this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                            this.callbackPriority = 0,
                            this.expirationTimes = gt(-1),
                            this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                            this.entanglements = gt(0),
                            this.hiddenUpdates = gt(null),
                            this.identifierPrefix = g,
                            this.onUncaughtError = S,
                            this.onCaughtError = w,
                            this.onRecoverableError = z,
                            this.pooledCache = null,
                            this.pooledCacheLanes = 0,
                            this.formState = Y,
                            this.incompleteTransitions = new Map
                        }
                        function O3(a, o, f, g, S, w, z, Y, re, Ae, qe, je) {
                            return a = new D3(a,o,f,z,Y,re,Ae,je),
                            o = 1,
                            w === !0 && (o |= 24),
                            w = ea(3, null, null, o),
                            a.current = w,
                            w.stateNode = a,
                            o = yd(),
                            o.refCount++,
                            a.pooledCache = o,
                            o.refCount++,
                            w.memoizedState = {
                                element: g,
                                isDehydrated: f,
                                cache: o
                            },
                            Qm(w),
                            a
                        }
                        function N3(a) {
                            return a ? (a = cl,
                            a) : cl
                        }
                        function Yb(a, o, f, g, S, w) {
                            S = N3(S),
                            g.context === null ? g.context = S : g.pendingContext = S,
                            g = Eo(o),
                            g.payload = {
                                element: f
                            },
                            w = w === void 0 ? null : w,
                            w !== null && (g.callback = w),
                            f = gl(a, g, o),
                            f !== null && (Gs(f, a, o),
                            ec(f, a, o))
                        }
                        function Wb(a, o) {
                            if (a = a.memoizedState,
                            a !== null && a.dehydrated !== null) {
                                var f = a.retryLane;
                                a.retryLane = f !== 0 && f < o ? f : o
                            }
                        }
                        function $S(a, o) {
                            Wb(a, o),
                            (a = a.alternate) && Wb(a, o)
                        }
                        function jb(a) {
                            if (a.tag === 13) {
                                var o = So(a, 67108864);
                                o !== null && Gs(o, a, 67108864),
                                $S(a, 67108864)
                            }
                        }
                        var My = !0;
                        function U3(a, o, f, g) {
                            var S = V.T;
                            V.T = null;
                            var w = q.p;
                            try {
                                q.p = 2,
                                eA(a, o, f, g)
                            } finally {
                                q.p = w,
                                V.T = S
                            }
                        }
                        function B3(a, o, f, g) {
                            var S = V.T;
                            V.T = null;
                            var w = q.p;
                            try {
                                q.p = 8,
                                eA(a, o, f, g)
                            } finally {
                                q.p = w,
                                V.T = S
                            }
                        }
                        function eA(a, o, f, g) {
                            if (My) {
                                var S = tA(g);
                                if (S === null)
                                    VS(a, o, g, by, f),
                                    Zb(a, g);
                                else if (I3(S, a, o, f, g))
                                    g.stopPropagation();
                                else if (Zb(a, g),
                                o & 4 && -1 < P3.indexOf(a)) {
                                    for (; S !== null; ) {
                                        var w = Lr(S);
                                        if (w !== null)
                                            switch (w.tag) {
                                            case 3:
                                                if (w = w.stateNode,
                                                w.current.memoizedState.isDehydrated) {
                                                    var z = Re(w.pendingLanes);
                                                    if (z !== 0) {
                                                        var Y = w;
                                                        for (Y.pendingLanes |= 2,
                                                        Y.entangledLanes |= 2; z; ) {
                                                            var re = 1 << 31 - Ke(z);
                                                            Y.entanglements[1] |= re,
                                                            z &= ~re
                                                        }
                                                        yc(w),
                                                        (Dn & 6) === 0 && (Cs = Ie() + 500,
                                                        _g(0, !1))
                                                    }
                                                }
                                                break;
                                            case 13:
                                                Y = So(w, 2),
                                                Y !== null && Gs(Y, w, 2),
                                                $r(),
                                                $S(w, 2)
                                            }
                                        if (w = tA(g),
                                        w === null && VS(a, o, g, by, f),
                                        w === S)
                                            break;
                                        S = w
                                    }
                                    S !== null && g.stopPropagation()
                                } else
                                    VS(a, o, g, null, f)
                            }
                        }
                        function tA(a) {
                            return a = $f(a),
                            nA(a)
                        }
                        var by = null;
                        function nA(a) {
                            if (by = null,
                            a = Ir(a),
                            a !== null) {
                                var o = l(a);
                                if (o === null)
                                    a = null;
                                else {
                                    var f = o.tag;
                                    if (f === 13) {
                                        if (a = h(o),
                                        a !== null)
                                            return a;
                                        a = null
                                    } else if (f === 3) {
                                        if (o.stateNode.current.memoizedState.isDehydrated)
                                            return o.tag === 3 ? o.stateNode.containerInfo : null;
                                        a = null
                                    } else
                                        o !== a && (a = null)
                                }
                            }
                            return by = a,
                            null
                        }
                        function Qb(a) {
                            switch (a) {
                            case "beforetoggle":
                            case "cancel":
                            case "click":
                            case "close":
                            case "contextmenu":
                            case "copy":
                            case "cut":
                            case "auxclick":
                            case "dblclick":
                            case "dragend":
                            case "dragstart":
                            case "drop":
                            case "focusin":
                            case "focusout":
                            case "input":
                            case "invalid":
                            case "keydown":
                            case "keypress":
                            case "keyup":
                            case "mousedown":
                            case "mouseup":
                            case "paste":
                            case "pause":
                            case "play":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointerup":
                            case "ratechange":
                            case "reset":
                            case "resize":
                            case "seeked":
                            case "submit":
                            case "toggle":
                            case "touchcancel":
                            case "touchend":
                            case "touchstart":
                            case "volumechange":
                            case "change":
                            case "selectionchange":
                            case "textInput":
                            case "compositionstart":
                            case "compositionend":
                            case "compositionupdate":
                            case "beforeblur":
                            case "afterblur":
                            case "beforeinput":
                            case "blur":
                            case "fullscreenchange":
                            case "focus":
                            case "hashchange":
                            case "popstate":
                            case "select":
                            case "selectstart":
                                return 2;
                            case "drag":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "mousemove":
                            case "mouseout":
                            case "mouseover":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "scroll":
                            case "touchmove":
                            case "wheel":
                            case "mouseenter":
                            case "mouseleave":
                            case "pointerenter":
                            case "pointerleave":
                                return 8;
                            case "message":
                                switch (Fe()) {
                                case xt:
                                    return 2;
                                case yt:
                                    return 8;
                                case wt:
                                case $:
                                    return 32;
                                case k:
                                    return 268435456;
                                default:
                                    return 32
                                }
                            default:
                                return 32
                            }
                        }
                        var iA = !1
                          , bu = null
                          , Eu = null
                          , wu = null
                          , wg = new Map
                          , Cg = new Map
                          , Cu = []
                          , P3 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
                        function Zb(a, o) {
                            switch (a) {
                            case "focusin":
                            case "focusout":
                                bu = null;
                                break;
                            case "dragenter":
                            case "dragleave":
                                Eu = null;
                                break;
                            case "mouseover":
                            case "mouseout":
                                wu = null;
                                break;
                            case "pointerover":
                            case "pointerout":
                                wg.delete(o.pointerId);
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                                Cg.delete(o.pointerId)
                            }
                        }
                        function Rg(a, o, f, g, S, w) {
                            return a === null || a.nativeEvent !== w ? (a = {
                                blockedOn: o,
                                domEventName: f,
                                eventSystemFlags: g,
                                nativeEvent: w,
                                targetContainers: [S]
                            },
                            o !== null && (o = Lr(o),
                            o !== null && jb(o)),
                            a) : (a.eventSystemFlags |= g,
                            o = a.targetContainers,
                            S !== null && o.indexOf(S) === -1 && o.push(S),
                            a)
                        }
                        function I3(a, o, f, g, S) {
                            switch (o) {
                            case "focusin":
                                return bu = Rg(bu, a, o, f, g, S),
                                !0;
                            case "dragenter":
                                return Eu = Rg(Eu, a, o, f, g, S),
                                !0;
                            case "mouseover":
                                return wu = Rg(wu, a, o, f, g, S),
                                !0;
                            case "pointerover":
                                var w = S.pointerId;
                                return wg.set(w, Rg(wg.get(w) || null, a, o, f, g, S)),
                                !0;
                            case "gotpointercapture":
                                return w = S.pointerId,
                                Cg.set(w, Rg(Cg.get(w) || null, a, o, f, g, S)),
                                !0
                            }
                            return !1
                        }
                        function Kb(a) {
                            var o = Ir(a.target);
                            if (o !== null) {
                                var f = l(o);
                                if (f !== null) {
                                    if (o = f.tag,
                                    o === 13) {
                                        if (o = h(f),
                                        o !== null) {
                                            a.blockedOn = o,
                                            pa(a.priority, function() {
                                                if (f.tag === 13) {
                                                    var g = Ri();
                                                    g = Tn(g);
                                                    var S = So(f, g);
                                                    S !== null && Gs(S, f, g),
                                                    $S(f, g)
                                                }
                                            });
                                            return
                                        }
                                    } else if (o === 3 && f.stateNode.current.memoizedState.isDehydrated) {
                                        a.blockedOn = f.tag === 3 ? f.stateNode.containerInfo : null;
                                        return
                                    }
                                }
                            }
                            a.blockedOn = null
                        }
                        function Ey(a) {
                            if (a.blockedOn !== null)
                                return !1;
                            for (var o = a.targetContainers; 0 < o.length; ) {
                                var f = tA(a.nativeEvent);
                                if (f === null) {
                                    f = a.nativeEvent;
                                    var g = new f.constructor(f.type,f);
                                    Jf = g,
                                    f.target.dispatchEvent(g),
                                    Jf = null
                                } else
                                    return o = Lr(f),
                                    o !== null && jb(o),
                                    a.blockedOn = f,
                                    !1;
                                o.shift()
                            }
                            return !0
                        }
                        function Jb(a, o, f) {
                            Ey(a) && f.delete(o)
                        }
                        function L3() {
                            iA = !1,
                            bu !== null && Ey(bu) && (bu = null),
                            Eu !== null && Ey(Eu) && (Eu = null),
                            wu !== null && Ey(wu) && (wu = null),
                            wg.forEach(Jb),
                            Cg.forEach(Jb)
                        }
                        function wy(a, o) {
                            a.blockedOn === o && (a.blockedOn = null,
                            iA || (iA = !0,
                            t.unstable_scheduleCallback(t.unstable_NormalPriority, L3)))
                        }
                        var Cy = null;
                        function $b(a) {
                            Cy !== a && (Cy = a,
                            t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
                                Cy === a && (Cy = null);
                                for (var o = 0; o < a.length; o += 3) {
                                    var f = a[o]
                                      , g = a[o + 1]
                                      , S = a[o + 2];
                                    if (typeof g != "function") {
                                        if (nA(g || f) === null)
                                            continue;
                                        break
                                    }
                                    var w = Lr(f);
                                    w !== null && (a.splice(o, 3),
                                    o -= 3,
                                    hg(w, {
                                        pending: !0,
                                        data: S,
                                        method: f.method,
                                        action: g
                                    }, g, S))
                                }
                            }))
                        }
                        function Dg(a) {
                            function o(re) {
                                return wy(re, a)
                            }
                            bu !== null && wy(bu, a),
                            Eu !== null && wy(Eu, a),
                            wu !== null && wy(wu, a),
                            wg.forEach(o),
                            Cg.forEach(o);
                            for (var f = 0; f < Cu.length; f++) {
                                var g = Cu[f];
                                g.blockedOn === a && (g.blockedOn = null)
                            }
                            for (; 0 < Cu.length && (f = Cu[0],
                            f.blockedOn === null); )
                                Kb(f),
                                f.blockedOn === null && Cu.shift();
                            if (f = (a.ownerDocument || a).$$reactFormReplay,
                            f != null)
                                for (g = 0; g < f.length; g += 3) {
                                    var S = f[g]
                                      , w = f[g + 1]
                                      , z = S[ki] || null;
                                    if (typeof w == "function")
                                        z || $b(f);
                                    else if (z) {
                                        var Y = null;
                                        if (w && w.hasAttribute("formAction")) {
                                            if (S = w,
                                            z = w[ki] || null)
                                                Y = z.formAction;
                                            else if (nA(S) !== null)
                                                continue
                                        } else
                                            Y = z.action;
                                        typeof Y == "function" ? f[g + 1] = Y : (f.splice(g, 3),
                                        g -= 3),
                                        $b(f)
                                    }
                                }
                        }
                        function sA(a) {
                            this._internalRoot = a
                        }
                        aA.prototype.render = sA.prototype.render = function(a) {
                            var o = this._internalRoot;
                            if (o === null)
                                throw Error(s(409));
                            var f = o.current
                              , g = Ri();
                            Yb(f, g, a, o, null, null)
                        }
                        ,
                        aA.prototype.unmount = sA.prototype.unmount = function() {
                            var a = this._internalRoot;
                            if (a !== null) {
                                this._internalRoot = null;
                                var o = a.containerInfo;
                                Yb(a.current, 2, null, a, null, null),
                                $r(),
                                o[Pr] = null
                            }
                        }
                        ;
                        function aA(a) {
                            this._internalRoot = a
                        }
                        aA.prototype.unstable_scheduleHydration = function(a) {
                            if (a) {
                                var o = Ai();
                                a = {
                                    blockedOn: null,
                                    target: a,
                                    priority: o
                                };
                                for (var f = 0; f < Cu.length && o !== 0 && o < Cu[f].priority; f++)
                                    ;
                                Cu.splice(f, 0, a),
                                f === 0 && Kb(a)
                            }
                        }
                        ;
                        var eE = n.version;
                        if (eE !== "19.1.1")
                            throw Error(s(527, eE, "19.1.1"));
                        q.findDOMNode = function(a) {
                            var o = a._reactInternals;
                            if (o === void 0)
                                throw typeof a.render == "function" ? Error(s(188)) : (a = Object.keys(a).join(","),
                                Error(s(268, a)));
                            return a = p(o),
                            a = a !== null ? m(a) : null,
                            a = a === null ? null : a.stateNode,
                            a
                        }
                        ;
                        var z3 = {
                            bundleType: 0,
                            version: "19.1.1",
                            rendererPackageName: "react-dom",
                            currentDispatcherRef: V,
                            reconcilerVersion: "19.1.1"
                        };
                        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
                            var Ry = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                            if (!Ry.isDisabled && Ry.supportsFiber)
                                try {
                                    Qe = Ry.inject(z3),
                                    Be = Ry
                                } catch {}
                        }
                        e.createRoot = function(a, o) {
                            if (!r(a))
                                throw Error(s(299));
                            var f = !1
                              , g = ""
                              , S = Pd
                              , w = pg
                              , z = BS
                              , Y = null;
                            return o != null && (o.unstable_strictMode === !0 && (f = !0),
                            o.identifierPrefix !== void 0 && (g = o.identifierPrefix),
                            o.onUncaughtError !== void 0 && (S = o.onUncaughtError),
                            o.onCaughtError !== void 0 && (w = o.onCaughtError),
                            o.onRecoverableError !== void 0 && (z = o.onRecoverableError),
                            o.unstable_transitionCallbacks !== void 0 && (Y = o.unstable_transitionCallbacks)),
                            o = O3(a, 1, !1, null, null, f, g, S, w, z, Y, null),
                            a[Pr] = o.current,
                            Eb(a),
                            new sA(o)
                        }
                    }
                    )
                })
                  , tU = cn({
                    "node_modules/react-dom/client.js": ( (e, t) => {
                        function n() {
                            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                                try {
                                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                                } catch (i) {
                                    console.error(i)
                                }
                        }
                        n(),
                        t.exports = eU()
                    }
                    )
                })
                  , nU = cn({
                    "node_modules/react-reconciler/cjs/react-reconciler-constants.production.js": (e => {
                        e.ConcurrentRoot = 1,
                        e.ContinuousEventPriority = 8,
                        e.DefaultEventPriority = 32,
                        e.DiscreteEventPriority = 2
                    }
                    )
                })
                  , rE = cn({
                    "node_modules/react-reconciler/constants.js": ( (e, t) => {
                        t.exports = nU()
                    }
                    )
                })
                  , Dy = tr(rE())
                  , iU = tr(tU())
                  , Le = tr(Jd(), 1)
                  , oE = tr(aE());
                const xc = "180"
                  , Kh = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                }
                  , Jh = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                }
                  , lE = 0
                  , lA = 1
                  , cE = 2
                  , sU = 3
                  , uE = 0
                  , Oy = 1
                  , Og = 2
                  , Lo = 3
                  , Bl = 0
                  , ys = 1
                  , nr = 2
                  , oi = 0
                  , $h = 1
                  , Ny = 2
                  , cA = 3
                  , uA = 4
                  , hE = 5
                  , Du = 100
                  , fE = 101
                  , dE = 102
                  , pE = 103
                  , mE = 104
                  , gE = 200
                  , vE = 201
                  , yE = 202
                  , _E = 203
                  , Uy = 204
                  , By = 205
                  , xE = 206
                  , SE = 207
                  , AE = 208
                  , TE = 209
                  , ME = 210
                  , bE = 211
                  , EE = 212
                  , wE = 213
                  , CE = 214
                  , Ng = 0
                  , Ug = 1
                  , $d = 2
                  , Ou = 3
                  , ef = 4
                  , Bg = 5
                  , Pg = 6
                  , ep = 7
                  , Ig = 0
                  , RE = 1
                  , DE = 2
                  , zo = 0
                  , OE = 1
                  , NE = 2
                  , UE = 3
                  , hA = 4
                  , BE = 5
                  , PE = 6
                  , IE = 7
                  , fA = "attached"
                  , LE = "detached"
                  , Py = 300
                  , Sc = 301
                  , Nu = 302
                  , Lg = 303
                  , zg = 304
                  , tp = 306
                  , Uu = 1e3
                  , no = 1001
                  , Fg = 1002
                  , ti = 1003
                  , dA = 1004
                  , aU = 1004
                  , np = 1005
                  , rU = 1005
                  , mi = 1006
                  , Hg = 1007
                  , oU = 1007
                  , Pl = 1008
                  , lU = 1008
                  , ui = 1009
                  , pA = 1010
                  , mA = 1011
                  , ip = 1012
                  , Iy = 1013
                  , Il = 1014
                  , Xs = 1015
                  , tf = 1016
                  , Ly = 1017
                  , zy = 1018
                  , nf = 1020
                  , gA = 35902
                  , vA = 35899
                  , yA = 1021
                  , _A = 1022
                  , ss = 1023
                  , sp = 1026
                  , sf = 1027
                  , ap = 1028
                  , Vg = 1029
                  , Fy = 1030
                  , Hy = 1031
                  , cU = 1032
                  , Vy = 1033
                  , Gg = 33776
                  , kg = 33777
                  , Xg = 33778
                  , qg = 33779
                  , Gy = 35840
                  , ky = 35841
                  , Xy = 35842
                  , qy = 35843
                  , Yy = 36196
                  , Wy = 37492
                  , jy = 37496
                  , Qy = 37808
                  , Zy = 37809
                  , Ky = 37810
                  , Jy = 37811
                  , $y = 37812
                  , e_ = 37813
                  , t_ = 37814
                  , n_ = 37815
                  , i_ = 37816
                  , s_ = 37817
                  , a_ = 37818
                  , r_ = 37819
                  , o_ = 37820
                  , l_ = 37821
                  , c_ = 36492
                  , u_ = 36494
                  , h_ = 36495
                  , f_ = 36283
                  , d_ = 36284
                  , p_ = 36285
                  , m_ = 36286
                  , zE = 2200
                  , FE = 2201
                  , HE = 2202
                  , Yg = 2300
                  , g_ = 2301
                  , v_ = 2302
                  , af = 2400
                  , rf = 2401
                  , Wg = 2402
                  , y_ = 2500
                  , xA = 2501
                  , uU = 0
                  , hU = 1
                  , fU = 2
                  , ji = 3200
                  , Fo = 3201
                  , dU = 3202
                  , pU = 3203
                  , Bu = 0
                  , VE = 1
                  , Ho = ""
                  , $t = "srgb"
                  , Ll = "srgb-linear"
                  , jg = "linear"
                  , Wn = "srgb"
                  , mU = 0
                  , of = 7680
                  , gU = 7681
                  , vU = 7682
                  , yU = 7683
                  , _U = 34055
                  , xU = 34056
                  , SU = 5386
                  , AU = 512
                  , TU = 513
                  , MU = 514
                  , bU = 515
                  , EU = 516
                  , wU = 517
                  , CU = 518
                  , SA = 519
                  , GE = 512
                  , kE = 513
                  , XE = 514
                  , AA = 515
                  , qE = 516
                  , YE = 517
                  , WE = 518
                  , jE = 519
                  , Qg = 35044
                  , RU = 35048
                  , DU = 35040
                  , OU = 35045
                  , NU = 35049
                  , UU = 35041
                  , BU = 35046
                  , PU = 35050
                  , IU = 35042
                  , LU = "100"
                  , TA = "300 es"
                  , br = 2e3
                  , rp = 2001
                  , zU = {
                    COMPUTE: "compute",
                    RENDER: "render"
                }
                  , FU = {
                    PERSPECTIVE: "perspective",
                    LINEAR: "linear",
                    FLAT: "flat"
                }
                  , HU = {
                    NORMAL: "normal",
                    CENTROID: "centroid",
                    SAMPLE: "sample",
                    FIRST: "first",
                    EITHER: "either"
                };
                var Er = class {
                    addEventListener(e, t) {
                        this._listeners === void 0 && (this._listeners = {});
                        const n = this._listeners;
                        n[e] === void 0 && (n[e] = []),
                        n[e].indexOf(t) === -1 && n[e].push(t)
                    }
                    hasEventListener(e, t) {
                        const n = this._listeners;
                        return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
                    }
                    removeEventListener(e, t) {
                        const n = this._listeners;
                        if (n === void 0)
                            return;
                        const i = n[e];
                        if (i !== void 0) {
                            const s = i.indexOf(t);
                            s !== -1 && i.splice(s, 1)
                        }
                    }
                    dispatchEvent(e) {
                        const t = this._listeners;
                        if (t === void 0)
                            return;
                        const n = t[e.type];
                        if (n !== void 0) {
                            e.target = this;
                            const i = n.slice(0);
                            for (let s = 0, r = i.length; s < r; s++)
                                i[s].call(this, e);
                            e.target = null
                        }
                    }
                }
                ;
                const sa = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                let QE = 1234567;
                const lf = Math.PI / 180
                  , op = 180 / Math.PI;
                function wr() {
                    const e = Math.random() * 4294967295 | 0
                      , t = Math.random() * 4294967295 | 0
                      , n = Math.random() * 4294967295 | 0
                      , i = Math.random() * 4294967295 | 0;
                    return (sa[e & 255] + sa[e >> 8 & 255] + sa[e >> 16 & 255] + sa[e >> 24 & 255] + "-" + sa[t & 255] + sa[t >> 8 & 255] + "-" + sa[t >> 16 & 15 | 64] + sa[t >> 24 & 255] + "-" + sa[n & 63 | 128] + sa[n >> 8 & 255] + "-" + sa[n >> 16 & 255] + sa[n >> 24 & 255] + sa[i & 255] + sa[i >> 8 & 255] + sa[i >> 16 & 255] + sa[i >> 24 & 255]).toLowerCase()
                }
                function kt(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                }
                function MA(e, t) {
                    return (e % t + t) % t
                }
                function VU(e, t, n, i, s) {
                    return i + (e - t) * (s - i) / (n - t)
                }
                function GU(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                }
                function Zg(e, t, n) {
                    return (1 - n) * e + n * t
                }
                function kU(e, t, n, i) {
                    return Zg(e, t, 1 - Math.exp(-n * i))
                }
                function XU(e, t=1) {
                    return t - Math.abs(MA(e, t * 2) - t)
                }
                function qU(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t),
                    e * e * (3 - 2 * e))
                }
                function YU(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t),
                    e * e * e * (e * (e * 6 - 15) + 10))
                }
                function WU(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                }
                function jU(e, t) {
                    return e + Math.random() * (t - e)
                }
                function QU(e) {
                    return e * (.5 - Math.random())
                }
                function ZU(e) {
                    e !== void 0 && (QE = e);
                    let t = QE += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, t | 1),
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61),
                    ((t ^ t >>> 14) >>> 0) / 4294967296
                }
                function KU(e) {
                    return e * lf
                }
                function JU(e) {
                    return e * op
                }
                function $U(e) {
                    return (e & e - 1) === 0 && e !== 0
                }
                function eB(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                }
                function tB(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                }
                function nB(e, t, n, i, s) {
                    const r = Math.cos
                      , l = Math.sin
                      , h = r(n / 2)
                      , d = l(n / 2)
                      , p = r((t + i) / 2)
                      , m = l((t + i) / 2)
                      , v = r((t - i) / 2)
                      , _ = l((t - i) / 2)
                      , x = r((i - t) / 2)
                      , b = l((i - t) / 2);
                    switch (s) {
                    case "XYX":
                        e.set(h * m, d * v, d * _, h * p);
                        break;
                    case "YZY":
                        e.set(d * _, h * m, d * v, h * p);
                        break;
                    case "ZXZ":
                        e.set(d * v, d * _, h * m, h * p);
                        break;
                    case "XZX":
                        e.set(h * m, d * b, d * x, h * p);
                        break;
                    case "YXY":
                        e.set(d * x, h * m, d * b, h * p);
                        break;
                    case "ZYZ":
                        e.set(d * b, d * x, h * m, h * p);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s)
                    }
                }
                function Ua(e, t) {
                    switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return e / 4294967295;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int32Array:
                        return Math.max(e / 2147483647, -1);
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                function sn(e, t) {
                    switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return Math.round(e * 4294967295);
                    case Uint16Array:
                        return Math.round(e * 65535);
                    case Uint8Array:
                        return Math.round(e * 255);
                    case Int32Array:
                        return Math.round(e * 2147483647);
                    case Int16Array:
                        return Math.round(e * 32767);
                    case Int8Array:
                        return Math.round(e * 127);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                const iB = {
                    DEG2RAD: lf,
                    RAD2DEG: op,
                    generateUUID: wr,
                    clamp: kt,
                    euclideanModulo: MA,
                    mapLinear: VU,
                    inverseLerp: GU,
                    lerp: Zg,
                    damp: kU,
                    pingpong: XU,
                    smoothstep: qU,
                    smootherstep: YU,
                    randInt: WU,
                    randFloat: jU,
                    randFloatSpread: QU,
                    seededRandom: ZU,
                    degToRad: KU,
                    radToDeg: JU,
                    isPowerOfTwo: $U,
                    ceilPowerOfTwo: eB,
                    floorPowerOfTwo: tB,
                    setQuaternionFromProperEuler: nB,
                    normalize: sn,
                    denormalize: Ua
                };
                var ye = class xO {
                    constructor(t=0, n=0) {
                        xO.prototype.isVector2 = !0,
                        this.x = t,
                        this.y = n
                    }
                    get width() {
                        return this.x
                    }
                    set width(t) {
                        this.x = t
                    }
                    get height() {
                        return this.y
                    }
                    set height(t) {
                        this.y = t
                    }
                    set(t, n) {
                        return this.x = t,
                        this.y = n,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    applyMatrix3(t) {
                        const n = this.x
                          , i = this.y
                          , s = t.elements;
                        return this.x = s[0] * n + s[3] * i + s[6],
                        this.y = s[1] * n + s[4] * i + s[7],
                        this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this
                    }
                    clamp(t, n) {
                        return this.x = kt(this.x, t.x, n.x),
                        this.y = kt(this.y, t.y, n.y),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = kt(this.x, t, n),
                        this.y = kt(this.y, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(kt(i, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    angleTo(t) {
                        const n = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const i = this.dot(t) / n;
                        return Math.acos(kt(i, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const n = this.x - t.x
                          , i = this.y - t.y;
                        return n * n + i * i
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this
                    }
                    lerpVectors(t, n, i) {
                        return this.x = t.x + (n.x - t.x) * i,
                        this.y = t.y + (n.y - t.y) * i,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this
                    }
                    rotateAround(t, n) {
                        const i = Math.cos(n)
                          , s = Math.sin(n)
                          , r = this.x - t.x
                          , l = this.y - t.y;
                        return this.x = r * i - l * s + t.x,
                        this.y = r * s + l * i + t.y,
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y
                    }
                }
                  , _s = class {
                    constructor(e=0, t=0, n=0, i=1) {
                        this.isQuaternion = !0,
                        this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = i
                    }
                    static slerpFlat(e, t, n, i, s, r, l) {
                        let h = n[i + 0]
                          , d = n[i + 1]
                          , p = n[i + 2]
                          , m = n[i + 3];
                        const v = s[r + 0]
                          , _ = s[r + 1]
                          , x = s[r + 2]
                          , b = s[r + 3];
                        if (l === 0) {
                            e[t + 0] = h,
                            e[t + 1] = d,
                            e[t + 2] = p,
                            e[t + 3] = m;
                            return
                        }
                        if (l === 1) {
                            e[t + 0] = v,
                            e[t + 1] = _,
                            e[t + 2] = x,
                            e[t + 3] = b;
                            return
                        }
                        if (m !== b || h !== v || d !== _ || p !== x) {
                            let E = 1 - l;
                            const T = h * v + d * _ + p * x + m * b
                              , M = T >= 0 ? 1 : -1
                              , D = 1 - T * T;
                            if (D > Number.EPSILON) {
                                const O = Math.sqrt(D)
                                  , U = Math.atan2(O, T * M);
                                E = Math.sin(E * U) / O,
                                l = Math.sin(l * U) / O
                            }
                            const R = l * M;
                            if (h = h * E + v * R,
                            d = d * E + _ * R,
                            p = p * E + x * R,
                            m = m * E + b * R,
                            E === 1 - l) {
                                const O = 1 / Math.sqrt(h * h + d * d + p * p + m * m);
                                h *= O,
                                d *= O,
                                p *= O,
                                m *= O
                            }
                        }
                        e[t] = h,
                        e[t + 1] = d,
                        e[t + 2] = p,
                        e[t + 3] = m
                    }
                    static multiplyQuaternionsFlat(e, t, n, i, s, r) {
                        const l = n[i]
                          , h = n[i + 1]
                          , d = n[i + 2]
                          , p = n[i + 3]
                          , m = s[r]
                          , v = s[r + 1]
                          , _ = s[r + 2]
                          , x = s[r + 3];
                        return e[t] = l * x + p * m + h * _ - d * v,
                        e[t + 1] = h * x + p * v + d * m - l * _,
                        e[t + 2] = d * x + p * _ + l * v - h * m,
                        e[t + 3] = p * x - l * m - h * v - d * _,
                        e
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x = e,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y = e,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(e) {
                        this._z = e,
                        this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(e) {
                        this._w = e,
                        this._onChangeCallback()
                    }
                    set(e, t, n, i) {
                        return this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = i,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._w)
                    }
                    copy(e) {
                        return this._x = e.x,
                        this._y = e.y,
                        this._z = e.z,
                        this._w = e.w,
                        this._onChangeCallback(),
                        this
                    }
                    setFromEuler(e, t=!0) {
                        const n = e._x
                          , i = e._y
                          , s = e._z
                          , r = e._order
                          , l = Math.cos
                          , h = Math.sin
                          , d = l(n / 2)
                          , p = l(i / 2)
                          , m = l(s / 2)
                          , v = h(n / 2)
                          , _ = h(i / 2)
                          , x = h(s / 2);
                        switch (r) {
                        case "XYZ":
                            this._x = v * p * m + d * _ * x,
                            this._y = d * _ * m - v * p * x,
                            this._z = d * p * x + v * _ * m,
                            this._w = d * p * m - v * _ * x;
                            break;
                        case "YXZ":
                            this._x = v * p * m + d * _ * x,
                            this._y = d * _ * m - v * p * x,
                            this._z = d * p * x - v * _ * m,
                            this._w = d * p * m + v * _ * x;
                            break;
                        case "ZXY":
                            this._x = v * p * m - d * _ * x,
                            this._y = d * _ * m + v * p * x,
                            this._z = d * p * x + v * _ * m,
                            this._w = d * p * m - v * _ * x;
                            break;
                        case "ZYX":
                            this._x = v * p * m - d * _ * x,
                            this._y = d * _ * m + v * p * x,
                            this._z = d * p * x - v * _ * m,
                            this._w = d * p * m + v * _ * x;
                            break;
                        case "YZX":
                            this._x = v * p * m + d * _ * x,
                            this._y = d * _ * m + v * p * x,
                            this._z = d * p * x - v * _ * m,
                            this._w = d * p * m - v * _ * x;
                            break;
                        case "XZY":
                            this._x = v * p * m - d * _ * x,
                            this._y = d * _ * m - v * p * x,
                            this._z = d * p * x + v * _ * m,
                            this._w = d * p * m + v * _ * x;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r)
                        }
                        return t === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromAxisAngle(e, t) {
                        const n = t / 2
                          , i = Math.sin(n);
                        return this._x = e.x * i,
                        this._y = e.y * i,
                        this._z = e.z * i,
                        this._w = Math.cos(n),
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(e) {
                        const t = e.elements
                          , n = t[0]
                          , i = t[4]
                          , s = t[8]
                          , r = t[1]
                          , l = t[5]
                          , h = t[9]
                          , d = t[2]
                          , p = t[6]
                          , m = t[10]
                          , v = n + l + m;
                        if (v > 0) {
                            const _ = .5 / Math.sqrt(v + 1);
                            this._w = .25 / _,
                            this._x = (p - h) * _,
                            this._y = (s - d) * _,
                            this._z = (r - i) * _
                        } else if (n > l && n > m) {
                            const _ = 2 * Math.sqrt(1 + n - l - m);
                            this._w = (p - h) / _,
                            this._x = .25 * _,
                            this._y = (i + r) / _,
                            this._z = (s + d) / _
                        } else if (l > m) {
                            const _ = 2 * Math.sqrt(1 + l - n - m);
                            this._w = (s - d) / _,
                            this._x = (i + r) / _,
                            this._y = .25 * _,
                            this._z = (h + p) / _
                        } else {
                            const _ = 2 * Math.sqrt(1 + m - n - l);
                            this._w = (r - i) / _,
                            this._x = (s + d) / _,
                            this._y = (h + p) / _,
                            this._z = .25 * _
                        }
                        return this._onChangeCallback(),
                        this
                    }
                    setFromUnitVectors(e, t) {
                        let n = e.dot(t) + 1;
                        return n < 1e-8 ? (n = 0,
                        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                        this._y = e.x,
                        this._z = 0,
                        this._w = n) : (this._x = 0,
                        this._y = -e.z,
                        this._z = e.y,
                        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                        this._y = e.z * t.x - e.x * t.z,
                        this._z = e.x * t.y - e.y * t.x,
                        this._w = n),
                        this.normalize()
                    }
                    angleTo(e) {
                        return 2 * Math.acos(Math.abs(kt(this.dot(e), -1, 1)))
                    }
                    rotateTowards(e, t) {
                        const n = this.angleTo(e);
                        if (n === 0)
                            return this;
                        const i = Math.min(1, t / n);
                        return this.slerp(e, i),
                        this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this._onChangeCallback(),
                        this
                    }
                    dot(e) {
                        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let e = this.length();
                        return e === 0 ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (e = 1 / e,
                        this._x = this._x * e,
                        this._y = this._y * e,
                        this._z = this._z * e,
                        this._w = this._w * e),
                        this._onChangeCallback(),
                        this
                    }
                    multiply(e) {
                        return this.multiplyQuaternions(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyQuaternions(e, this)
                    }
                    multiplyQuaternions(e, t) {
                        const n = e._x
                          , i = e._y
                          , s = e._z
                          , r = e._w
                          , l = t._x
                          , h = t._y
                          , d = t._z
                          , p = t._w;
                        return this._x = n * p + r * l + i * d - s * h,
                        this._y = i * p + r * h + s * l - n * d,
                        this._z = s * p + r * d + n * h - i * l,
                        this._w = r * p - n * l - i * h - s * d,
                        this._onChangeCallback(),
                        this
                    }
                    slerp(e, t) {
                        if (t === 0)
                            return this;
                        if (t === 1)
                            return this.copy(e);
                        const n = this._x
                          , i = this._y
                          , s = this._z
                          , r = this._w;
                        let l = r * e._w + n * e._x + i * e._y + s * e._z;
                        if (l < 0 ? (this._w = -e._w,
                        this._x = -e._x,
                        this._y = -e._y,
                        this._z = -e._z,
                        l = -l) : this.copy(e),
                        l >= 1)
                            return this._w = r,
                            this._x = n,
                            this._y = i,
                            this._z = s,
                            this;
                        const h = 1 - l * l;
                        if (h <= Number.EPSILON) {
                            const _ = 1 - t;
                            return this._w = _ * r + t * this._w,
                            this._x = _ * n + t * this._x,
                            this._y = _ * i + t * this._y,
                            this._z = _ * s + t * this._z,
                            this.normalize(),
                            this
                        }
                        const d = Math.sqrt(h)
                          , p = Math.atan2(d, l)
                          , m = Math.sin((1 - t) * p) / d
                          , v = Math.sin(t * p) / d;
                        return this._w = r * m + this._w * v,
                        this._x = n * m + this._x * v,
                        this._y = i * m + this._y * v,
                        this._z = s * m + this._z * v,
                        this._onChangeCallback(),
                        this
                    }
                    slerpQuaternions(e, t, n) {
                        return this.copy(e).slerp(t, n)
                    }
                    random() {
                        const e = 2 * Math.PI * Math.random()
                          , t = 2 * Math.PI * Math.random()
                          , n = Math.random()
                          , i = Math.sqrt(1 - n)
                          , s = Math.sqrt(n);
                        return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
                    }
                    equals(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                    }
                    fromArray(e, t=0) {
                        return this._x = e[t],
                        this._y = e[t + 1],
                        this._z = e[t + 2],
                        this._w = e[t + 3],
                        this._onChangeCallback(),
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this._x,
                        e[t + 1] = this._y,
                        e[t + 2] = this._z,
                        e[t + 3] = this._w,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this._x = e.getX(t),
                        this._y = e.getY(t),
                        this._z = e.getZ(t),
                        this._w = e.getW(t),
                        this._onChangeCallback(),
                        this
                    }
                    toJSON() {
                        return this.toArray()
                    }
                    _onChange(e) {
                        return this._onChangeCallback = e,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._w
                    }
                }
                  , Q = class SO {
                    constructor(t=0, n=0, i=0) {
                        SO.prototype.isVector3 = !0,
                        this.x = t,
                        this.y = n,
                        this.z = i
                    }
                    set(t, n, i) {
                        return i === void 0 && (i = this.z),
                        this.x = t,
                        this.y = n,
                        this.z = i,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setZ(t) {
                        return this.z = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this.z = t.z + n.z,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this.z += t.z * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this.z = t.z - n.z,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this
                    }
                    multiplyVectors(t, n) {
                        return this.x = t.x * n.x,
                        this.y = t.y * n.y,
                        this.z = t.z * n.z,
                        this
                    }
                    applyEuler(t) {
                        return this.applyQuaternion(ZE.setFromEuler(t))
                    }
                    applyAxisAngle(t, n) {
                        return this.applyQuaternion(ZE.setFromAxisAngle(t, n))
                    }
                    applyMatrix3(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , r = t.elements;
                        return this.x = r[0] * n + r[3] * i + r[6] * s,
                        this.y = r[1] * n + r[4] * i + r[7] * s,
                        this.z = r[2] * n + r[5] * i + r[8] * s,
                        this
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                    applyMatrix4(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , r = t.elements
                          , l = 1 / (r[3] * n + r[7] * i + r[11] * s + r[15]);
                        return this.x = (r[0] * n + r[4] * i + r[8] * s + r[12]) * l,
                        this.y = (r[1] * n + r[5] * i + r[9] * s + r[13]) * l,
                        this.z = (r[2] * n + r[6] * i + r[10] * s + r[14]) * l,
                        this
                    }
                    applyQuaternion(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , r = t.x
                          , l = t.y
                          , h = t.z
                          , d = t.w
                          , p = 2 * (l * s - h * i)
                          , m = 2 * (h * n - r * s)
                          , v = 2 * (r * i - l * n);
                        return this.x = n + d * p + l * v - h * m,
                        this.y = i + d * m + h * p - r * v,
                        this.z = s + d * v + r * m - l * p,
                        this
                    }
                    project(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                    unproject(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                    transformDirection(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , r = t.elements;
                        return this.x = r[0] * n + r[4] * i + r[8] * s,
                        this.y = r[1] * n + r[5] * i + r[9] * s,
                        this.z = r[2] * n + r[6] * i + r[10] * s,
                        this.normalize()
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this
                    }
                    clamp(t, n) {
                        return this.x = kt(this.x, t.x, n.x),
                        this.y = kt(this.y, t.y, n.y),
                        this.z = kt(this.z, t.z, n.z),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = kt(this.x, t, n),
                        this.y = kt(this.y, t, n),
                        this.z = kt(this.z, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(kt(i, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this.z += (t.z - this.z) * n,
                        this
                    }
                    lerpVectors(t, n, i) {
                        return this.x = t.x + (n.x - t.x) * i,
                        this.y = t.y + (n.y - t.y) * i,
                        this.z = t.z + (n.z - t.z) * i,
                        this
                    }
                    cross(t) {
                        return this.crossVectors(this, t)
                    }
                    crossVectors(t, n) {
                        const i = t.x
                          , s = t.y
                          , r = t.z
                          , l = n.x
                          , h = n.y
                          , d = n.z;
                        return this.x = s * d - r * h,
                        this.y = r * l - i * d,
                        this.z = i * h - s * l,
                        this
                    }
                    projectOnVector(t) {
                        const n = t.lengthSq();
                        if (n === 0)
                            return this.set(0, 0, 0);
                        const i = t.dot(this) / n;
                        return this.copy(t).multiplyScalar(i)
                    }
                    projectOnPlane(t) {
                        return bA.copy(this).projectOnVector(t),
                        this.sub(bA)
                    }
                    reflect(t) {
                        return this.sub(bA.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                    angleTo(t) {
                        const n = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const i = this.dot(t) / n;
                        return Math.acos(kt(i, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const n = this.x - t.x
                          , i = this.y - t.y
                          , s = this.z - t.z;
                        return n * n + i * i + s * s
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                    setFromSphericalCoords(t, n, i) {
                        const s = Math.sin(n) * t;
                        return this.x = s * Math.sin(i),
                        this.y = Math.cos(n) * t,
                        this.z = s * Math.cos(i),
                        this
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                    setFromCylindricalCoords(t, n, i) {
                        return this.x = t * Math.sin(n),
                        this.y = i,
                        this.z = t * Math.cos(n),
                        this
                    }
                    setFromMatrixPosition(t) {
                        const n = t.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this
                    }
                    setFromMatrixScale(t) {
                        const n = this.setFromMatrixColumn(t, 0).length()
                          , i = this.setFromMatrixColumn(t, 1).length()
                          , s = this.setFromMatrixColumn(t, 2).length();
                        return this.x = n,
                        this.y = i,
                        this.z = s,
                        this
                    }
                    setFromMatrixColumn(t, n) {
                        return this.fromArray(t.elements, n * 4)
                    }
                    setFromMatrix3Column(t, n) {
                        return this.fromArray(t.elements, n * 3)
                    }
                    setFromEuler(t) {
                        return this.x = t._x,
                        this.y = t._y,
                        this.z = t._z,
                        this
                    }
                    setFromColor(t) {
                        return this.x = t.r,
                        this.y = t.g,
                        this.z = t.b,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this.z = t[n + 2],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t[n + 2] = this.z,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this.z = t.getZ(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this
                    }
                    randomDirection() {
                        const t = Math.random() * Math.PI * 2
                          , n = Math.random() * 2 - 1
                          , i = Math.sqrt(1 - n * n);
                        return this.x = i * Math.cos(t),
                        this.y = n,
                        this.z = i * Math.sin(t),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z
                    }
                }
                ;
                const bA = new Q
                  , ZE = new _s;
                var rn = class AO {
                    constructor(t, n, i, s, r, l, h, d, p) {
                        AO.prototype.isMatrix3 = !0,
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        t !== void 0 && this.set(t, n, i, s, r, l, h, d, p)
                    }
                    set(t, n, i, s, r, l, h, d, p) {
                        const m = this.elements;
                        return m[0] = t,
                        m[1] = s,
                        m[2] = h,
                        m[3] = n,
                        m[4] = r,
                        m[5] = d,
                        m[6] = i,
                        m[7] = l,
                        m[8] = p,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                    }
                    copy(t) {
                        const n = this.elements
                          , i = t.elements;
                        return n[0] = i[0],
                        n[1] = i[1],
                        n[2] = i[2],
                        n[3] = i[3],
                        n[4] = i[4],
                        n[5] = i[5],
                        n[6] = i[6],
                        n[7] = i[7],
                        n[8] = i[8],
                        this
                    }
                    extractBasis(t, n, i) {
                        return t.setFromMatrix3Column(this, 0),
                        n.setFromMatrix3Column(this, 1),
                        i.setFromMatrix3Column(this, 2),
                        this
                    }
                    setFromMatrix4(t) {
                        const n = t.elements;
                        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]),
                        this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, n) {
                        const i = t.elements
                          , s = n.elements
                          , r = this.elements
                          , l = i[0]
                          , h = i[3]
                          , d = i[6]
                          , p = i[1]
                          , m = i[4]
                          , v = i[7]
                          , _ = i[2]
                          , x = i[5]
                          , b = i[8]
                          , E = s[0]
                          , T = s[3]
                          , M = s[6]
                          , D = s[1]
                          , R = s[4]
                          , O = s[7]
                          , U = s[2]
                          , B = s[5]
                          , I = s[8];
                        return r[0] = l * E + h * D + d * U,
                        r[3] = l * T + h * R + d * B,
                        r[6] = l * M + h * O + d * I,
                        r[1] = p * E + m * D + v * U,
                        r[4] = p * T + m * R + v * B,
                        r[7] = p * M + m * O + v * I,
                        r[2] = _ * E + x * D + b * U,
                        r[5] = _ * T + x * R + b * B,
                        r[8] = _ * M + x * O + b * I,
                        this
                    }
                    multiplyScalar(t) {
                        const n = this.elements;
                        return n[0] *= t,
                        n[3] *= t,
                        n[6] *= t,
                        n[1] *= t,
                        n[4] *= t,
                        n[7] *= t,
                        n[2] *= t,
                        n[5] *= t,
                        n[8] *= t,
                        this
                    }
                    determinant() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[1]
                          , s = t[2]
                          , r = t[3]
                          , l = t[4]
                          , h = t[5]
                          , d = t[6]
                          , p = t[7]
                          , m = t[8];
                        return n * l * m - n * h * p - i * r * m + i * h * d + s * r * p - s * l * d
                    }
                    invert() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[1]
                          , s = t[2]
                          , r = t[3]
                          , l = t[4]
                          , h = t[5]
                          , d = t[6]
                          , p = t[7]
                          , m = t[8]
                          , v = m * l - h * p
                          , _ = h * d - m * r
                          , x = p * r - l * d
                          , b = n * v + i * _ + s * x;
                        if (b === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const E = 1 / b;
                        return t[0] = v * E,
                        t[1] = (s * p - m * i) * E,
                        t[2] = (h * i - s * l) * E,
                        t[3] = _ * E,
                        t[4] = (m * n - s * d) * E,
                        t[5] = (s * r - h * n) * E,
                        t[6] = x * E,
                        t[7] = (i * d - p * n) * E,
                        t[8] = (l * n - i * r) * E,
                        this
                    }
                    transpose() {
                        let t;
                        const n = this.elements;
                        return t = n[1],
                        n[1] = n[3],
                        n[3] = t,
                        t = n[2],
                        n[2] = n[6],
                        n[6] = t,
                        t = n[5],
                        n[5] = n[7],
                        n[7] = t,
                        this
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose()
                    }
                    transposeIntoArray(t) {
                        const n = this.elements;
                        return t[0] = n[0],
                        t[1] = n[3],
                        t[2] = n[6],
                        t[3] = n[1],
                        t[4] = n[4],
                        t[5] = n[7],
                        t[6] = n[2],
                        t[7] = n[5],
                        t[8] = n[8],
                        this
                    }
                    setUvTransform(t, n, i, s, r, l, h) {
                        const d = Math.cos(r)
                          , p = Math.sin(r);
                        return this.set(i * d, i * p, -i * (d * l + p * h) + l + t, -s * p, s * d, -s * (-p * l + d * h) + h + n, 0, 0, 1),
                        this
                    }
                    scale(t, n) {
                        return this.premultiply(EA.makeScale(t, n)),
                        this
                    }
                    rotate(t) {
                        return this.premultiply(EA.makeRotation(-t)),
                        this
                    }
                    translate(t, n) {
                        return this.premultiply(EA.makeTranslation(t, n)),
                        this
                    }
                    makeTranslation(t, n) {
                        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, n, 0, 0, 1),
                        this
                    }
                    makeRotation(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(n, -i, 0, i, n, 0, 0, 0, 1),
                        this
                    }
                    makeScale(t, n) {
                        return this.set(t, 0, 0, 0, n, 0, 0, 0, 1),
                        this
                    }
                    equals(t) {
                        const n = this.elements
                          , i = t.elements;
                        for (let s = 0; s < 9; s++)
                            if (n[s] !== i[s])
                                return !1;
                        return !0
                    }
                    fromArray(t, n=0) {
                        for (let i = 0; i < 9; i++)
                            this.elements[i] = t[i + n];
                        return this
                    }
                    toArray(t=[], n=0) {
                        const i = this.elements;
                        return t[n] = i[0],
                        t[n + 1] = i[1],
                        t[n + 2] = i[2],
                        t[n + 3] = i[3],
                        t[n + 4] = i[4],
                        t[n + 5] = i[5],
                        t[n + 6] = i[6],
                        t[n + 7] = i[7],
                        t[n + 8] = i[8],
                        t
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements)
                    }
                }
                ;
                const EA = new rn;
                function KE(e) {
                    for (let t = e.length - 1; t >= 0; --t)
                        if (e[t] >= 65535)
                            return !0;
                    return !1
                }
                const sB = {
                    Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                };
                function lp(e, t) {
                    return new sB[e](t)
                }
                function Kg(e) {
                    return document.createElementNS("http://www.w3.org/1999/xhtml", e)
                }
                function JE() {
                    const e = Kg("canvas");
                    return e.style.display = "block",
                    e
                }
                const $E = {};
                function Jg(e) {
                    e in $E || ($E[e] = !0,
                    console.warn(e))
                }
                function aB(e, t, n) {
                    return new Promise(function(i, s) {
                        function r() {
                            switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                            case e.WAIT_FAILED:
                                s();
                                break;
                            case e.TIMEOUT_EXPIRED:
                                setTimeout(r, n);
                                break;
                            default:
                                i()
                            }
                        }
                        setTimeout(r, n)
                    }
                    )
                }
                const ew = new rn().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
                  , tw = new rn().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
                function rB() {
                    const e = {
                        enabled: !0,
                        workingColorSpace: Ll,
                        spaces: {},
                        convert: function(s, r, l) {
                            return this.enabled === !1 || r === l || !r || !l || (this.spaces[r].transfer === Wn && (s.r = Ac(s.r),
                            s.g = Ac(s.g),
                            s.b = Ac(s.b)),
                            this.spaces[r].primaries !== this.spaces[l].primaries && (s.applyMatrix3(this.spaces[r].toXYZ),
                            s.applyMatrix3(this.spaces[l].fromXYZ)),
                            this.spaces[l].transfer === Wn && (s.r = cp(s.r),
                            s.g = cp(s.g),
                            s.b = cp(s.b))),
                            s
                        },
                        workingToColorSpace: function(s, r) {
                            return this.convert(s, this.workingColorSpace, r)
                        },
                        colorSpaceToWorking: function(s, r) {
                            return this.convert(s, r, this.workingColorSpace)
                        },
                        getPrimaries: function(s) {
                            return this.spaces[s].primaries
                        },
                        getTransfer: function(s) {
                            return s === Ho ? jg : this.spaces[s].transfer
                        },
                        getToneMappingMode: function(s) {
                            return this.spaces[s].outputColorSpaceConfig.toneMappingMode || "standard"
                        },
                        getLuminanceCoefficients: function(s, r=this.workingColorSpace) {
                            return s.fromArray(this.spaces[r].luminanceCoefficients)
                        },
                        define: function(s) {
                            Object.assign(this.spaces, s)
                        },
                        _getMatrix: function(s, r, l) {
                            return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[l].fromXYZ)
                        },
                        _getDrawingBufferColorSpace: function(s) {
                            return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace
                        },
                        _getUnpackColorSpace: function(s=this.workingColorSpace) {
                            return this.spaces[s].workingColorSpaceConfig.unpackColorSpace
                        },
                        fromWorkingColorSpace: function(s, r) {
                            return Jg("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
                            e.workingToColorSpace(s, r)
                        },
                        toWorkingColorSpace: function(s, r) {
                            return Jg("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
                            e.colorSpaceToWorking(s, r)
                        }
                    }
                      , t = [.64, .33, .3, .6, .15, .06]
                      , n = [.2126, .7152, .0722]
                      , i = [.3127, .329];
                    return e.define({
                        [Ll]: {
                            primaries: t,
                            whitePoint: i,
                            transfer: jg,
                            toXYZ: ew,
                            fromXYZ: tw,
                            luminanceCoefficients: n,
                            workingColorSpaceConfig: {
                                unpackColorSpace: $t
                            },
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: $t
                            }
                        },
                        [$t]: {
                            primaries: t,
                            whitePoint: i,
                            transfer: Wn,
                            toXYZ: ew,
                            fromXYZ: tw,
                            luminanceCoefficients: n,
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: $t
                            }
                        }
                    }),
                    e
                }
                const An = rB();
                function Ac(e) {
                    return e < .04045 ? e * .0773993808 : Math.pow(e * .9478672986 + .0521327014, 2.4)
                }
                function cp(e) {
                    return e < .0031308 ? e * 12.92 : 1.055 * Math.pow(e, .41666) - .055
                }
                let up;
                var nw = class {
                    static getDataURL(e, t="image/png") {
                        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                            return e.src;
                        let n;
                        if (e instanceof HTMLCanvasElement)
                            n = e;
                        else {
                            up === void 0 && (up = Kg("canvas")),
                            up.width = e.width,
                            up.height = e.height;
                            const i = up.getContext("2d");
                            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
                            n = up
                        }
                        return n.toDataURL(t)
                    }
                    static sRGBToLinear(e) {
                        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                            const t = Kg("canvas");
                            t.width = e.width,
                            t.height = e.height;
                            const n = t.getContext("2d");
                            n.drawImage(e, 0, 0, e.width, e.height);
                            const i = n.getImageData(0, 0, e.width, e.height)
                              , s = i.data;
                            for (let r = 0; r < s.length; r++)
                                s[r] = Ac(s[r] / 255) * 255;
                            return n.putImageData(i, 0, 0),
                            t
                        } else if (e.data) {
                            const t = e.data.slice(0);
                            for (let n = 0; n < t.length; n++)
                                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Ac(t[n] / 255) * 255) : t[n] = Ac(t[n]);
                            return {
                                data: t,
                                width: e.width,
                                height: e.height
                            }
                        } else
                            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                            e
                    }
                }
                ;
                let oB = 0;
                var Pu = class {
                    constructor(e=null) {
                        this.isSource = !0,
                        Object.defineProperty(this, "id", {
                            value: oB++
                        }),
                        this.uuid = wr(),
                        this.data = e,
                        this.dataReady = !0,
                        this.version = 0
                    }
                    getSize(e) {
                        const t = this.data;
                        return typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
                        e
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    toJSON(e) {
                        const t = e === void 0 || typeof e == "string";
                        if (!t && e.images[this.uuid] !== void 0)
                            return e.images[this.uuid];
                        const n = {
                            uuid: this.uuid,
                            url: ""
                        }
                          , i = this.data;
                        if (i !== null) {
                            let s;
                            if (Array.isArray(i)) {
                                s = [];
                                for (let r = 0, l = i.length; r < l; r++)
                                    i[r].isDataTexture ? s.push(wA(i[r].image)) : s.push(wA(i[r]))
                            } else
                                s = wA(i);
                            n.url = s
                        }
                        return t || (e.images[this.uuid] = n),
                        n
                    }
                }
                ;
                function wA(e) {
                    return typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap ? nw.getDataURL(e) : e.data ? {
                        data: Array.from(e.data),
                        width: e.width,
                        height: e.height,
                        type: e.data.constructor.name
                    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
                    {})
                }
                let lB = 0;
                const CA = new Q;
                var zi = class yS extends Er {
                    constructor(t=yS.DEFAULT_IMAGE, n=yS.DEFAULT_MAPPING, i=no, s=no, r=mi, l=Pl, h=ss, d=ui, p=yS.DEFAULT_ANISOTROPY, m=Ho) {
                        super(),
                        this.isTexture = !0,
                        Object.defineProperty(this, "id", {
                            value: lB++
                        }),
                        this.uuid = wr(),
                        this.name = "",
                        this.source = new Pu(t),
                        this.mipmaps = [],
                        this.mapping = n,
                        this.channel = 0,
                        this.wrapS = i,
                        this.wrapT = s,
                        this.magFilter = r,
                        this.minFilter = l,
                        this.anisotropy = p,
                        this.format = h,
                        this.internalFormat = null,
                        this.type = d,
                        this.offset = new ye(0,0),
                        this.repeat = new ye(1,1),
                        this.center = new ye(0,0),
                        this.rotation = 0,
                        this.matrixAutoUpdate = !0,
                        this.matrix = new rn,
                        this.generateMipmaps = !0,
                        this.premultiplyAlpha = !1,
                        this.flipY = !0,
                        this.unpackAlignment = 4,
                        this.colorSpace = m,
                        this.userData = {},
                        this.updateRanges = [],
                        this.version = 0,
                        this.onUpdate = null,
                        this.renderTarget = null,
                        this.isRenderTargetTexture = !1,
                        this.isArrayTexture = !!(t && t.depth && t.depth > 1),
                        this.pmremVersion = 0
                    }
                    get width() {
                        return this.source.getSize(CA).x
                    }
                    get height() {
                        return this.source.getSize(CA).y
                    }
                    get depth() {
                        return this.source.getSize(CA).z
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(t=null) {
                        this.source.data = t
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    addUpdateRange(t, n) {
                        this.updateRanges.push({
                            start: t,
                            count: n
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.name = t.name,
                        this.source = t.source,
                        this.mipmaps = t.mipmaps.slice(0),
                        this.mapping = t.mapping,
                        this.channel = t.channel,
                        this.wrapS = t.wrapS,
                        this.wrapT = t.wrapT,
                        this.magFilter = t.magFilter,
                        this.minFilter = t.minFilter,
                        this.anisotropy = t.anisotropy,
                        this.format = t.format,
                        this.internalFormat = t.internalFormat,
                        this.type = t.type,
                        this.offset.copy(t.offset),
                        this.repeat.copy(t.repeat),
                        this.center.copy(t.center),
                        this.rotation = t.rotation,
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrix.copy(t.matrix),
                        this.generateMipmaps = t.generateMipmaps,
                        this.premultiplyAlpha = t.premultiplyAlpha,
                        this.flipY = t.flipY,
                        this.unpackAlignment = t.unpackAlignment,
                        this.colorSpace = t.colorSpace,
                        this.renderTarget = t.renderTarget,
                        this.isRenderTargetTexture = t.isRenderTargetTexture,
                        this.isArrayTexture = t.isArrayTexture,
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        this.needsUpdate = !0,
                        this
                    }
                    setValues(t) {
                        for (const n in t) {
                            const i = t[n];
                            if (i === void 0) {
                                console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);
                                continue
                            }
                            const s = this[n];
                            if (s === void 0) {
                                console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);
                                continue
                            }
                            s && i && s.isVector2 && i.isVector2 || s && i && s.isVector3 && i.isVector3 || s && i && s.isMatrix3 && i.isMatrix3 ? s.copy(i) : this[n] = i
                        }
                    }
                    toJSON(t) {
                        const n = t === void 0 || typeof t == "string";
                        if (!n && t.textures[this.uuid] !== void 0)
                            return t.textures[this.uuid];
                        const i = {
                            metadata: {
                                version: 4.7,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(t).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                        n || (t.textures[this.uuid] = i),
                        i
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(t) {
                        if (this.mapping !== Py)
                            return t;
                        if (t.applyMatrix3(this.matrix),
                        t.x < 0 || t.x > 1)
                            switch (this.wrapS) {
                            case Uu:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case no:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case Fg:
                                Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                                break
                            }
                        if (t.y < 0 || t.y > 1)
                            switch (this.wrapT) {
                            case Uu:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case no:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case Fg:
                                Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                                break
                            }
                        return this.flipY && (t.y = 1 - t.y),
                        t
                    }
                    set needsUpdate(t) {
                        t === !0 && (this.version++,
                        this.source.needsUpdate = !0)
                    }
                    set needsPMREMUpdate(t) {
                        t === !0 && this.pmremVersion++
                    }
                }
                ;
                zi.DEFAULT_IMAGE = null,
                zi.DEFAULT_MAPPING = Py,
                zi.DEFAULT_ANISOTROPY = 1;
                var gn = class TO {
                    constructor(t=0, n=0, i=0, s=1) {
                        TO.prototype.isVector4 = !0,
                        this.x = t,
                        this.y = n,
                        this.z = i,
                        this.w = s
                    }
                    get width() {
                        return this.z
                    }
                    set width(t) {
                        this.z = t
                    }
                    get height() {
                        return this.w
                    }
                    set height(t) {
                        this.w = t
                    }
                    set(t, n, i, s) {
                        return this.x = t,
                        this.y = n,
                        this.z = i,
                        this.w = s,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this.w = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setZ(t) {
                        return this.z = t,
                        this
                    }
                    setW(t) {
                        return this.w = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        case 3:
                            this.w = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z,this.w)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this.w = t.w !== void 0 ? t.w : 1,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this.w += t.w,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this.w += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this.z = t.z + n.z,
                        this.w = t.w + n.w,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this.z += t.z * n,
                        this.w += t.w * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this.w -= t.w,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this.w -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this.z = t.z - n.z,
                        this.w = t.w - n.w,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this.w *= t.w,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this.w *= t,
                        this
                    }
                    applyMatrix4(t) {
                        const n = this.x
                          , i = this.y
                          , s = this.z
                          , r = this.w
                          , l = t.elements;
                        return this.x = l[0] * n + l[4] * i + l[8] * s + l[12] * r,
                        this.y = l[1] * n + l[5] * i + l[9] * s + l[13] * r,
                        this.z = l[2] * n + l[6] * i + l[10] * s + l[14] * r,
                        this.w = l[3] * n + l[7] * i + l[11] * s + l[15] * r,
                        this
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this.w /= t.w,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const n = Math.sqrt(1 - t.w * t.w);
                        return n < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = t.x / n,
                        this.y = t.y / n,
                        this.z = t.z / n),
                        this
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let n, i, s, r;
                        const d = t.elements
                          , p = d[0]
                          , m = d[4]
                          , v = d[8]
                          , _ = d[1]
                          , x = d[5]
                          , b = d[9]
                          , E = d[2]
                          , T = d[6]
                          , M = d[10];
                        if (Math.abs(m - _) < .01 && Math.abs(v - E) < .01 && Math.abs(b - T) < .01) {
                            if (Math.abs(m + _) < .1 && Math.abs(v + E) < .1 && Math.abs(b + T) < .1 && Math.abs(p + x + M - 3) < .1)
                                return this.set(1, 0, 0, 0),
                                this;
                            n = Math.PI;
                            const R = (p + 1) / 2
                              , O = (x + 1) / 2
                              , U = (M + 1) / 2
                              , B = (m + _) / 4
                              , I = (v + E) / 4
                              , F = (b + T) / 4;
                            return R > O && R > U ? R < .01 ? (i = 0,
                            s = .707106781,
                            r = .707106781) : (i = Math.sqrt(R),
                            s = B / i,
                            r = I / i) : O > U ? O < .01 ? (i = .707106781,
                            s = 0,
                            r = .707106781) : (s = Math.sqrt(O),
                            i = B / s,
                            r = F / s) : U < .01 ? (i = .707106781,
                            s = .707106781,
                            r = 0) : (r = Math.sqrt(U),
                            i = I / r,
                            s = F / r),
                            this.set(i, s, r, n),
                            this
                        }
                        let D = Math.sqrt((T - b) * (T - b) + (v - E) * (v - E) + (_ - m) * (_ - m));
                        return Math.abs(D) < .001 && (D = 1),
                        this.x = (T - b) / D,
                        this.y = (v - E) / D,
                        this.z = (_ - m) / D,
                        this.w = Math.acos((p + x + M - 1) / 2),
                        this
                    }
                    setFromMatrixPosition(t) {
                        const n = t.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this.w = n[15],
                        this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this.w = Math.min(this.w, t.w),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this.w = Math.max(this.w, t.w),
                        this
                    }
                    clamp(t, n) {
                        return this.x = kt(this.x, t.x, n.x),
                        this.y = kt(this.y, t.y, n.y),
                        this.z = kt(this.z, t.z, n.z),
                        this.w = kt(this.w, t.w, n.w),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = kt(this.x, t, n),
                        this.y = kt(this.y, t, n),
                        this.z = kt(this.z, t, n),
                        this.w = kt(this.w, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const i = this.length();
                        return this.divideScalar(i || 1).multiplyScalar(kt(i, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this.w = Math.trunc(this.w),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this.z += (t.z - this.z) * n,
                        this.w += (t.w - this.w) * n,
                        this
                    }
                    lerpVectors(t, n, i) {
                        return this.x = t.x + (n.x - t.x) * i,
                        this.y = t.y + (n.y - t.y) * i,
                        this.z = t.z + (n.z - t.z) * i,
                        this.w = t.w + (n.w - t.w) * i,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this.z = t[n + 2],
                        this.w = t[n + 3],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t[n + 2] = this.z,
                        t[n + 3] = this.w,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this.z = t.getZ(n),
                        this.w = t.getW(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this.w = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z,
                        yield this.w
                    }
                }
                  , RA = class extends Er {
                    constructor(e=1, t=1, n={}) {
                        super(),
                        n = Object.assign({
                            generateMipmaps: !1,
                            internalFormat: null,
                            minFilter: mi,
                            depthBuffer: !0,
                            stencilBuffer: !1,
                            resolveDepthBuffer: !0,
                            resolveStencilBuffer: !0,
                            depthTexture: null,
                            samples: 0,
                            count: 1,
                            depth: 1,
                            multiview: !1
                        }, n),
                        this.isRenderTarget = !0,
                        this.width = e,
                        this.height = t,
                        this.depth = n.depth,
                        this.scissor = new gn(0,0,e,t),
                        this.scissorTest = !1,
                        this.viewport = new gn(0,0,e,t);
                        const i = {
                            width: e,
                            height: t,
                            depth: n.depth
                        }
                          , s = new zi(i);
                        this.textures = [];
                        const r = n.count;
                        for (let l = 0; l < r; l++)
                            this.textures[l] = s.clone(),
                            this.textures[l].isRenderTargetTexture = !0,
                            this.textures[l].renderTarget = this;
                        this._setTextureOptions(n),
                        this.depthBuffer = n.depthBuffer,
                        this.stencilBuffer = n.stencilBuffer,
                        this.resolveDepthBuffer = n.resolveDepthBuffer,
                        this.resolveStencilBuffer = n.resolveStencilBuffer,
                        this._depthTexture = null,
                        this.depthTexture = n.depthTexture,
                        this.samples = n.samples,
                        this.multiview = n.multiview
                    }
                    _setTextureOptions(e={}) {
                        const t = {
                            minFilter: mi,
                            generateMipmaps: !1,
                            flipY: !1,
                            internalFormat: null
                        };
                        e.mapping !== void 0 && (t.mapping = e.mapping),
                        e.wrapS !== void 0 && (t.wrapS = e.wrapS),
                        e.wrapT !== void 0 && (t.wrapT = e.wrapT),
                        e.wrapR !== void 0 && (t.wrapR = e.wrapR),
                        e.magFilter !== void 0 && (t.magFilter = e.magFilter),
                        e.minFilter !== void 0 && (t.minFilter = e.minFilter),
                        e.format !== void 0 && (t.format = e.format),
                        e.type !== void 0 && (t.type = e.type),
                        e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
                        e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
                        e.flipY !== void 0 && (t.flipY = e.flipY),
                        e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
                        e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
                        for (let n = 0; n < this.textures.length; n++)
                            this.textures[n].setValues(t)
                    }
                    get texture() {
                        return this.textures[0]
                    }
                    set texture(e) {
                        this.textures[0] = e
                    }
                    set depthTexture(e) {
                        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
                        e !== null && (e.renderTarget = this),
                        this._depthTexture = e
                    }
                    get depthTexture() {
                        return this._depthTexture
                    }
                    setSize(e, t, n=1) {
                        if (this.width !== e || this.height !== t || this.depth !== n) {
                            this.width = e,
                            this.height = t,
                            this.depth = n;
                            for (let i = 0, s = this.textures.length; i < s; i++)
                                this.textures[i].image.width = e,
                                this.textures[i].image.height = t,
                                this.textures[i].image.depth = n,
                                this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
                            this.dispose()
                        }
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.width = e.width,
                        this.height = e.height,
                        this.depth = e.depth,
                        this.scissor.copy(e.scissor),
                        this.scissorTest = e.scissorTest,
                        this.viewport.copy(e.viewport),
                        this.textures.length = 0;
                        for (let t = 0, n = e.textures.length; t < n; t++) {
                            this.textures[t] = e.textures[t].clone(),
                            this.textures[t].isRenderTargetTexture = !0,
                            this.textures[t].renderTarget = this;
                            const i = Object.assign({}, e.textures[t].image);
                            this.textures[t].source = new Pu(i)
                        }
                        return this.depthBuffer = e.depthBuffer,
                        this.stencilBuffer = e.stencilBuffer,
                        this.resolveDepthBuffer = e.resolveDepthBuffer,
                        this.resolveStencilBuffer = e.resolveStencilBuffer,
                        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                        this.samples = e.samples,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                  , Un = class extends RA {
                    constructor(e=1, t=1, n={}) {
                        super(e, t, n),
                        this.isWebGLRenderTarget = !0
                    }
                }
                  , __ = class extends zi {
                    constructor(e=null, t=1, n=1, i=1) {
                        super(null),
                        this.isDataArrayTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n,
                            depth: i
                        },
                        this.magFilter = ti,
                        this.minFilter = ti,
                        this.wrapR = no,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(e) {
                        this.layerUpdates.add(e)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , cB = class extends Un {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isWebGLArrayRenderTarget = !0,
                        this.depth = n,
                        this.texture = new __(null,e,t,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , x_ = class extends zi {
                    constructor(e=null, t=1, n=1, i=1) {
                        super(null),
                        this.isData3DTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n,
                            depth: i
                        },
                        this.magFilter = ti,
                        this.minFilter = ti,
                        this.wrapR = no,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                  , uB = class extends Un {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isWebGL3DRenderTarget = !0,
                        this.depth = n,
                        this.texture = new x_(null,e,t,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , aa = class {
                    constructor(e=new Q(1 / 0,1 / 0,1 / 0), t=new Q(-1 / 0,-1 / 0,-1 / 0)) {
                        this.isBox3 = !0,
                        this.min = e,
                        this.max = t
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromArray(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t += 3)
                            this.expandByPoint(Vo.fromArray(e, t));
                        return this
                    }
                    setFromBufferAttribute(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.count; t < n; t++)
                            this.expandByPoint(Vo.fromBufferAttribute(e, t));
                        return this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = Vo.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    setFromObject(e, t=!1) {
                        return this.makeEmpty(),
                        this.expandByObject(e, t)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0,
                        this.max.x = this.max.y = this.max.z = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(e) {
                        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    expandByObject(e, t=!1) {
                        e.updateWorldMatrix(!1, !1);
                        const n = e.geometry;
                        if (n !== void 0) {
                            const s = n.getAttribute("position");
                            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                                for (let r = 0, l = s.count; r < l; r++)
                                    e.isMesh === !0 ? e.getVertexPosition(r, Vo) : Vo.fromBufferAttribute(s, r),
                                    Vo.applyMatrix4(e.matrixWorld),
                                    this.expandByPoint(Vo);
                            else
                                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                                S_.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                                S_.copy(n.boundingBox)),
                                S_.applyMatrix4(e.matrixWorld),
                                this.union(S_)
                        }
                        const i = e.children;
                        for (let s = 0, r = i.length; s < r; s++)
                            this.expandByObject(i[s], t);
                        return this
                    }
                    containsPoint(e) {
                        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                    }
                    getParameter(e, t) {
                        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(e) {
                        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                    }
                    intersectsSphere(e) {
                        return this.clampPoint(e.center, Vo),
                        Vo.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                    intersectsPlane(e) {
                        let t, n;
                        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                        n = e.normal.x * this.min.x),
                        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                        n += e.normal.y * this.min.y),
                        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                        n += e.normal.z * this.min.z),
                        t <= -e.constant && n >= -e.constant
                    }
                    intersectsTriangle(e) {
                        if (this.isEmpty())
                            return !1;
                        this.getCenter($g),
                        A_.subVectors(this.max, $g),
                        hp.subVectors(e.a, $g),
                        fp.subVectors(e.b, $g),
                        dp.subVectors(e.c, $g),
                        Iu.subVectors(fp, hp),
                        Lu.subVectors(dp, fp),
                        cf.subVectors(hp, dp);
                        let t = [0, -Iu.z, Iu.y, 0, -Lu.z, Lu.y, 0, -cf.z, cf.y, Iu.z, 0, -Iu.x, Lu.z, 0, -Lu.x, cf.z, 0, -cf.x, -Iu.y, Iu.x, 0, -Lu.y, Lu.x, 0, -cf.y, cf.x, 0];
                        return !DA(t, hp, fp, dp, A_) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        !DA(t, hp, fp, dp, A_)) ? !1 : (T_.crossVectors(Iu, Lu),
                        t = [T_.x, T_.y, T_.z],
                        DA(t, hp, fp, dp, A_))
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return this.clampPoint(e, Vo).distanceTo(e)
                    }
                    getBoundingSphere(e) {
                        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                        e.radius = this.getSize(Vo).length() * .5),
                        e
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    applyMatrix4(e) {
                        return this.isEmpty() ? this : (Tc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                        Tc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                        Tc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                        Tc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                        Tc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                        Tc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                        Tc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                        Tc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                        this.setFromPoints(Tc),
                        this)
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                    toJSON() {
                        return {
                            min: this.min.toArray(),
                            max: this.max.toArray()
                        }
                    }
                    fromJSON(e) {
                        return this.min.fromArray(e.min),
                        this.max.fromArray(e.max),
                        this
                    }
                }
                ;
                const Tc = [new Q, new Q, new Q, new Q, new Q, new Q, new Q, new Q]
                  , Vo = new Q
                  , S_ = new aa
                  , hp = new Q
                  , fp = new Q
                  , dp = new Q
                  , Iu = new Q
                  , Lu = new Q
                  , cf = new Q
                  , $g = new Q
                  , A_ = new Q
                  , T_ = new Q
                  , uf = new Q;
                function DA(e, t, n, i, s) {
                    for (let r = 0, l = e.length - 3; r <= l; r += 3) {
                        uf.fromArray(e, r);
                        const h = s.x * Math.abs(uf.x) + s.y * Math.abs(uf.y) + s.z * Math.abs(uf.z)
                          , d = t.dot(uf)
                          , p = n.dot(uf)
                          , m = i.dot(uf);
                        if (Math.max(-Math.max(d, p, m), Math.min(d, p, m)) > h)
                            return !1
                    }
                    return !0
                }
                const hB = new aa
                  , ev = new Q
                  , OA = new Q;
                var qs = class {
                    constructor(e=new Q, t=-1) {
                        this.isSphere = !0,
                        this.center = e,
                        this.radius = t
                    }
                    set(e, t) {
                        return this.center.copy(e),
                        this.radius = t,
                        this
                    }
                    setFromPoints(e, t) {
                        const n = this.center;
                        t !== void 0 ? n.copy(t) : hB.setFromPoints(e).getCenter(n);
                        let i = 0;
                        for (let s = 0, r = e.length; s < r; s++)
                            i = Math.max(i, n.distanceToSquared(e[s]));
                        return this.radius = Math.sqrt(i),
                        this
                    }
                    copy(e) {
                        return this.center.copy(e.center),
                        this.radius = e.radius,
                        this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0),
                        this.radius = -1,
                        this
                    }
                    containsPoint(e) {
                        return e.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(e) {
                        return e.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(e) {
                        const t = this.radius + e.radius;
                        return e.center.distanceToSquared(this.center) <= t * t
                    }
                    intersectsBox(e) {
                        return e.intersectsSphere(this)
                    }
                    intersectsPlane(e) {
                        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(e, t) {
                        const n = this.center.distanceToSquared(e);
                        return t.copy(e),
                        n > this.radius * this.radius && (t.sub(this.center).normalize(),
                        t.multiplyScalar(this.radius).add(this.center)),
                        t
                    }
                    getBoundingBox(e) {
                        return this.isEmpty() ? (e.makeEmpty(),
                        e) : (e.set(this.center, this.center),
                        e.expandByScalar(this.radius),
                        e)
                    }
                    applyMatrix4(e) {
                        return this.center.applyMatrix4(e),
                        this.radius = this.radius * e.getMaxScaleOnAxis(),
                        this
                    }
                    translate(e) {
                        return this.center.add(e),
                        this
                    }
                    expandByPoint(e) {
                        if (this.isEmpty())
                            return this.center.copy(e),
                            this.radius = 0,
                            this;
                        ev.subVectors(e, this.center);
                        const t = ev.lengthSq();
                        if (t > this.radius * this.radius) {
                            const n = Math.sqrt(t)
                              , i = (n - this.radius) * .5;
                            this.center.addScaledVector(ev, i / n),
                            this.radius += i
                        }
                        return this
                    }
                    union(e) {
                        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (OA.subVectors(e.center, this.center).setLength(e.radius),
                        this.expandByPoint(ev.copy(e.center).add(OA)),
                        this.expandByPoint(ev.copy(e.center).sub(OA))),
                        this)
                    }
                    equals(e) {
                        return e.center.equals(this.center) && e.radius === this.radius
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        return {
                            radius: this.radius,
                            center: this.center.toArray()
                        }
                    }
                    fromJSON(e) {
                        return this.radius = e.radius,
                        this.center.fromArray(e.center),
                        this
                    }
                }
                ;
                const Mc = new Q
                  , NA = new Q
                  , M_ = new Q
                  , zu = new Q
                  , UA = new Q
                  , b_ = new Q
                  , BA = new Q;
                var hf = class {
                    constructor(e=new Q, t=new Q(0,0,-1)) {
                        this.origin = e,
                        this.direction = t
                    }
                    set(e, t) {
                        return this.origin.copy(e),
                        this.direction.copy(t),
                        this
                    }
                    copy(e) {
                        return this.origin.copy(e.origin),
                        this.direction.copy(e.direction),
                        this
                    }
                    at(e, t) {
                        return t.copy(this.origin).addScaledVector(this.direction, e)
                    }
                    lookAt(e) {
                        return this.direction.copy(e).sub(this.origin).normalize(),
                        this
                    }
                    recast(e) {
                        return this.origin.copy(this.at(e, Mc)),
                        this
                    }
                    closestPointToPoint(e, t) {
                        t.subVectors(e, this.origin);
                        const n = t.dot(this.direction);
                        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                    }
                    distanceToPoint(e) {
                        return Math.sqrt(this.distanceSqToPoint(e))
                    }
                    distanceSqToPoint(e) {
                        const t = Mc.subVectors(e, this.origin).dot(this.direction);
                        return t < 0 ? this.origin.distanceToSquared(e) : (Mc.copy(this.origin).addScaledVector(this.direction, t),
                        Mc.distanceToSquared(e))
                    }
                    distanceSqToSegment(e, t, n, i) {
                        NA.copy(e).add(t).multiplyScalar(.5),
                        M_.copy(t).sub(e).normalize(),
                        zu.copy(this.origin).sub(NA);
                        const s = e.distanceTo(t) * .5
                          , r = -this.direction.dot(M_)
                          , l = zu.dot(this.direction)
                          , h = -zu.dot(M_)
                          , d = zu.lengthSq()
                          , p = Math.abs(1 - r * r);
                        let m, v, _, x;
                        if (p > 0)
                            if (m = r * h - l,
                            v = r * l - h,
                            x = s * p,
                            m >= 0)
                                if (v >= -x)
                                    if (v <= x) {
                                        const b = 1 / p;
                                        m *= b,
                                        v *= b,
                                        _ = m * (m + r * v + 2 * l) + v * (r * m + v + 2 * h) + d
                                    } else
                                        v = s,
                                        m = Math.max(0, -(r * v + l)),
                                        _ = -m * m + v * (v + 2 * h) + d;
                                else
                                    v = -s,
                                    m = Math.max(0, -(r * v + l)),
                                    _ = -m * m + v * (v + 2 * h) + d;
                            else
                                v <= -x ? (m = Math.max(0, -(-r * s + l)),
                                v = m > 0 ? -s : Math.min(Math.max(-s, -h), s),
                                _ = -m * m + v * (v + 2 * h) + d) : v <= x ? (m = 0,
                                v = Math.min(Math.max(-s, -h), s),
                                _ = v * (v + 2 * h) + d) : (m = Math.max(0, -(r * s + l)),
                                v = m > 0 ? s : Math.min(Math.max(-s, -h), s),
                                _ = -m * m + v * (v + 2 * h) + d);
                        else
                            v = r > 0 ? -s : s,
                            m = Math.max(0, -(r * v + l)),
                            _ = -m * m + v * (v + 2 * h) + d;
                        return n && n.copy(this.origin).addScaledVector(this.direction, m),
                        i && i.copy(NA).addScaledVector(M_, v),
                        _
                    }
                    intersectSphere(e, t) {
                        Mc.subVectors(e.center, this.origin);
                        const n = Mc.dot(this.direction)
                          , i = Mc.dot(Mc) - n * n
                          , s = e.radius * e.radius;
                        if (i > s)
                            return null;
                        const r = Math.sqrt(s - i)
                          , l = n - r
                          , h = n + r;
                        return h < 0 ? null : l < 0 ? this.at(h, t) : this.at(l, t)
                    }
                    intersectsSphere(e) {
                        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
                    }
                    distanceToPlane(e) {
                        const t = e.normal.dot(this.direction);
                        if (t === 0)
                            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                        const n = -(this.origin.dot(e.normal) + e.constant) / t;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(e, t) {
                        const n = this.distanceToPlane(e);
                        return n === null ? null : this.at(n, t)
                    }
                    intersectsPlane(e) {
                        const t = e.distanceToPoint(this.origin);
                        return t === 0 || e.normal.dot(this.direction) * t < 0
                    }
                    intersectBox(e, t) {
                        let n, i, s, r, l, h;
                        const d = 1 / this.direction.x
                          , p = 1 / this.direction.y
                          , m = 1 / this.direction.z
                          , v = this.origin;
                        return d >= 0 ? (n = (e.min.x - v.x) * d,
                        i = (e.max.x - v.x) * d) : (n = (e.max.x - v.x) * d,
                        i = (e.min.x - v.x) * d),
                        p >= 0 ? (s = (e.min.y - v.y) * p,
                        r = (e.max.y - v.y) * p) : (s = (e.max.y - v.y) * p,
                        r = (e.min.y - v.y) * p),
                        n > r || s > i || ((s > n || isNaN(n)) && (n = s),
                        (r < i || isNaN(i)) && (i = r),
                        m >= 0 ? (l = (e.min.z - v.z) * m,
                        h = (e.max.z - v.z) * m) : (l = (e.max.z - v.z) * m,
                        h = (e.min.z - v.z) * m),
                        n > h || l > i) || ((l > n || n !== n) && (n = l),
                        (h < i || i !== i) && (i = h),
                        i < 0) ? null : this.at(n >= 0 ? n : i, t)
                    }
                    intersectsBox(e) {
                        return this.intersectBox(e, Mc) !== null
                    }
                    intersectTriangle(e, t, n, i, s) {
                        UA.subVectors(t, e),
                        b_.subVectors(n, e),
                        BA.crossVectors(UA, b_);
                        let r = this.direction.dot(BA), l;
                        if (r > 0) {
                            if (i)
                                return null;
                            l = 1
                        } else if (r < 0)
                            l = -1,
                            r = -r;
                        else
                            return null;
                        zu.subVectors(this.origin, e);
                        const h = l * this.direction.dot(b_.crossVectors(zu, b_));
                        if (h < 0)
                            return null;
                        const d = l * this.direction.dot(UA.cross(zu));
                        if (d < 0 || h + d > r)
                            return null;
                        const p = -l * zu.dot(BA);
                        return p < 0 ? null : this.at(p / r, s)
                    }
                    applyMatrix4(e) {
                        return this.origin.applyMatrix4(e),
                        this.direction.transformDirection(e),
                        this
                    }
                    equals(e) {
                        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , Xt = class pb {
                    constructor(t, n, i, s, r, l, h, d, p, m, v, _, x, b, E, T) {
                        pb.prototype.isMatrix4 = !0,
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                        t !== void 0 && this.set(t, n, i, s, r, l, h, d, p, m, v, _, x, b, E, T)
                    }
                    set(t, n, i, s, r, l, h, d, p, m, v, _, x, b, E, T) {
                        const M = this.elements;
                        return M[0] = t,
                        M[4] = n,
                        M[8] = i,
                        M[12] = s,
                        M[1] = r,
                        M[5] = l,
                        M[9] = h,
                        M[13] = d,
                        M[2] = p,
                        M[6] = m,
                        M[10] = v,
                        M[14] = _,
                        M[3] = x,
                        M[7] = b,
                        M[11] = E,
                        M[15] = T,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    clone() {
                        return new pb().fromArray(this.elements)
                    }
                    copy(t) {
                        const n = this.elements
                          , i = t.elements;
                        return n[0] = i[0],
                        n[1] = i[1],
                        n[2] = i[2],
                        n[3] = i[3],
                        n[4] = i[4],
                        n[5] = i[5],
                        n[6] = i[6],
                        n[7] = i[7],
                        n[8] = i[8],
                        n[9] = i[9],
                        n[10] = i[10],
                        n[11] = i[11],
                        n[12] = i[12],
                        n[13] = i[13],
                        n[14] = i[14],
                        n[15] = i[15],
                        this
                    }
                    copyPosition(t) {
                        const n = this.elements
                          , i = t.elements;
                        return n[12] = i[12],
                        n[13] = i[13],
                        n[14] = i[14],
                        this
                    }
                    setFromMatrix3(t) {
                        const n = t.elements;
                        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1),
                        this
                    }
                    extractBasis(t, n, i) {
                        return t.setFromMatrixColumn(this, 0),
                        n.setFromMatrixColumn(this, 1),
                        i.setFromMatrixColumn(this, 2),
                        this
                    }
                    makeBasis(t, n, i) {
                        return this.set(t.x, n.x, i.x, 0, t.y, n.y, i.y, 0, t.z, n.z, i.z, 0, 0, 0, 0, 1),
                        this
                    }
                    extractRotation(t) {
                        const n = this.elements
                          , i = t.elements
                          , s = 1 / pp.setFromMatrixColumn(t, 0).length()
                          , r = 1 / pp.setFromMatrixColumn(t, 1).length()
                          , l = 1 / pp.setFromMatrixColumn(t, 2).length();
                        return n[0] = i[0] * s,
                        n[1] = i[1] * s,
                        n[2] = i[2] * s,
                        n[3] = 0,
                        n[4] = i[4] * r,
                        n[5] = i[5] * r,
                        n[6] = i[6] * r,
                        n[7] = 0,
                        n[8] = i[8] * l,
                        n[9] = i[9] * l,
                        n[10] = i[10] * l,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromEuler(t) {
                        const n = this.elements
                          , i = t.x
                          , s = t.y
                          , r = t.z
                          , l = Math.cos(i)
                          , h = Math.sin(i)
                          , d = Math.cos(s)
                          , p = Math.sin(s)
                          , m = Math.cos(r)
                          , v = Math.sin(r);
                        if (t.order === "XYZ") {
                            const _ = l * m
                              , x = l * v
                              , b = h * m
                              , E = h * v;
                            n[0] = d * m,
                            n[4] = -d * v,
                            n[8] = p,
                            n[1] = x + b * p,
                            n[5] = _ - E * p,
                            n[9] = -h * d,
                            n[2] = E - _ * p,
                            n[6] = b + x * p,
                            n[10] = l * d
                        } else if (t.order === "YXZ") {
                            const _ = d * m
                              , x = d * v
                              , b = p * m
                              , E = p * v;
                            n[0] = _ + E * h,
                            n[4] = b * h - x,
                            n[8] = l * p,
                            n[1] = l * v,
                            n[5] = l * m,
                            n[9] = -h,
                            n[2] = x * h - b,
                            n[6] = E + _ * h,
                            n[10] = l * d
                        } else if (t.order === "ZXY") {
                            const _ = d * m
                              , x = d * v
                              , b = p * m
                              , E = p * v;
                            n[0] = _ - E * h,
                            n[4] = -l * v,
                            n[8] = b + x * h,
                            n[1] = x + b * h,
                            n[5] = l * m,
                            n[9] = E - _ * h,
                            n[2] = -l * p,
                            n[6] = h,
                            n[10] = l * d
                        } else if (t.order === "ZYX") {
                            const _ = l * m
                              , x = l * v
                              , b = h * m
                              , E = h * v;
                            n[0] = d * m,
                            n[4] = b * p - x,
                            n[8] = _ * p + E,
                            n[1] = d * v,
                            n[5] = E * p + _,
                            n[9] = x * p - b,
                            n[2] = -p,
                            n[6] = h * d,
                            n[10] = l * d
                        } else if (t.order === "YZX") {
                            const _ = l * d
                              , x = l * p
                              , b = h * d
                              , E = h * p;
                            n[0] = d * m,
                            n[4] = E - _ * v,
                            n[8] = b * v + x,
                            n[1] = v,
                            n[5] = l * m,
                            n[9] = -h * m,
                            n[2] = -p * m,
                            n[6] = x * v + b,
                            n[10] = _ - E * v
                        } else if (t.order === "XZY") {
                            const _ = l * d
                              , x = l * p
                              , b = h * d
                              , E = h * p;
                            n[0] = d * m,
                            n[4] = -v,
                            n[8] = p * m,
                            n[1] = _ * v + E,
                            n[5] = l * m,
                            n[9] = x * v - b,
                            n[2] = b * v - x,
                            n[6] = h * m,
                            n[10] = E * v + _
                        }
                        return n[3] = 0,
                        n[7] = 0,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(fB, t, dB)
                    }
                    lookAt(t, n, i) {
                        const s = this.elements;
                        return Cr.subVectors(t, n),
                        Cr.lengthSq() === 0 && (Cr.z = 1),
                        Cr.normalize(),
                        Fu.crossVectors(i, Cr),
                        Fu.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Cr.x += 1e-4 : Cr.z += 1e-4,
                        Cr.normalize(),
                        Fu.crossVectors(i, Cr)),
                        Fu.normalize(),
                        E_.crossVectors(Cr, Fu),
                        s[0] = Fu.x,
                        s[4] = E_.x,
                        s[8] = Cr.x,
                        s[1] = Fu.y,
                        s[5] = E_.y,
                        s[9] = Cr.y,
                        s[2] = Fu.z,
                        s[6] = E_.z,
                        s[10] = Cr.z,
                        this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, n) {
                        const i = t.elements
                          , s = n.elements
                          , r = this.elements
                          , l = i[0]
                          , h = i[4]
                          , d = i[8]
                          , p = i[12]
                          , m = i[1]
                          , v = i[5]
                          , _ = i[9]
                          , x = i[13]
                          , b = i[2]
                          , E = i[6]
                          , T = i[10]
                          , M = i[14]
                          , D = i[3]
                          , R = i[7]
                          , O = i[11]
                          , U = i[15]
                          , B = s[0]
                          , I = s[4]
                          , F = s[8]
                          , P = s[12]
                          , L = s[1]
                          , H = s[5]
                          , Z = s[9]
                          , K = s[13]
                          , te = s[2]
                          , ce = s[6]
                          , G = s[10]
                          , V = s[14]
                          , q = s[3]
                          , ee = s[7]
                          , se = s[11]
                          , X = s[15];
                        return r[0] = l * B + h * L + d * te + p * q,
                        r[4] = l * I + h * H + d * ce + p * ee,
                        r[8] = l * F + h * Z + d * G + p * se,
                        r[12] = l * P + h * K + d * V + p * X,
                        r[1] = m * B + v * L + _ * te + x * q,
                        r[5] = m * I + v * H + _ * ce + x * ee,
                        r[9] = m * F + v * Z + _ * G + x * se,
                        r[13] = m * P + v * K + _ * V + x * X,
                        r[2] = b * B + E * L + T * te + M * q,
                        r[6] = b * I + E * H + T * ce + M * ee,
                        r[10] = b * F + E * Z + T * G + M * se,
                        r[14] = b * P + E * K + T * V + M * X,
                        r[3] = D * B + R * L + O * te + U * q,
                        r[7] = D * I + R * H + O * ce + U * ee,
                        r[11] = D * F + R * Z + O * G + U * se,
                        r[15] = D * P + R * K + O * V + U * X,
                        this
                    }
                    multiplyScalar(t) {
                        const n = this.elements;
                        return n[0] *= t,
                        n[4] *= t,
                        n[8] *= t,
                        n[12] *= t,
                        n[1] *= t,
                        n[5] *= t,
                        n[9] *= t,
                        n[13] *= t,
                        n[2] *= t,
                        n[6] *= t,
                        n[10] *= t,
                        n[14] *= t,
                        n[3] *= t,
                        n[7] *= t,
                        n[11] *= t,
                        n[15] *= t,
                        this
                    }
                    determinant() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[4]
                          , s = t[8]
                          , r = t[12]
                          , l = t[1]
                          , h = t[5]
                          , d = t[9]
                          , p = t[13]
                          , m = t[2]
                          , v = t[6]
                          , _ = t[10]
                          , x = t[14]
                          , b = t[3]
                          , E = t[7]
                          , T = t[11]
                          , M = t[15];
                        return b * (+r * d * v - s * p * v - r * h * _ + i * p * _ + s * h * x - i * d * x) + E * (+n * d * x - n * p * _ + r * l * _ - s * l * x + s * p * m - r * d * m) + T * (+n * p * v - n * h * x - r * l * v + i * l * x + r * h * m - i * p * m) + M * (-s * h * m - n * d * v + n * h * _ + s * l * v - i * l * _ + i * d * m)
                    }
                    transpose() {
                        const t = this.elements;
                        let n;
                        return n = t[1],
                        t[1] = t[4],
                        t[4] = n,
                        n = t[2],
                        t[2] = t[8],
                        t[8] = n,
                        n = t[6],
                        t[6] = t[9],
                        t[9] = n,
                        n = t[3],
                        t[3] = t[12],
                        t[12] = n,
                        n = t[7],
                        t[7] = t[13],
                        t[13] = n,
                        n = t[11],
                        t[11] = t[14],
                        t[14] = n,
                        this
                    }
                    setPosition(t, n, i) {
                        const s = this.elements;
                        return t.isVector3 ? (s[12] = t.x,
                        s[13] = t.y,
                        s[14] = t.z) : (s[12] = t,
                        s[13] = n,
                        s[14] = i),
                        this
                    }
                    invert() {
                        const t = this.elements
                          , n = t[0]
                          , i = t[1]
                          , s = t[2]
                          , r = t[3]
                          , l = t[4]
                          , h = t[5]
                          , d = t[6]
                          , p = t[7]
                          , m = t[8]
                          , v = t[9]
                          , _ = t[10]
                          , x = t[11]
                          , b = t[12]
                          , E = t[13]
                          , T = t[14]
                          , M = t[15]
                          , D = v * T * p - E * _ * p + E * d * x - h * T * x - v * d * M + h * _ * M
                          , R = b * _ * p - m * T * p - b * d * x + l * T * x + m * d * M - l * _ * M
                          , O = m * E * p - b * v * p + b * h * x - l * E * x - m * h * M + l * v * M
                          , U = b * v * d - m * E * d - b * h * _ + l * E * _ + m * h * T - l * v * T
                          , B = n * D + i * R + s * O + r * U;
                        if (B === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const I = 1 / B;
                        return t[0] = D * I,
                        t[1] = (E * _ * r - v * T * r - E * s * x + i * T * x + v * s * M - i * _ * M) * I,
                        t[2] = (h * T * r - E * d * r + E * s * p - i * T * p - h * s * M + i * d * M) * I,
                        t[3] = (v * d * r - h * _ * r - v * s * p + i * _ * p + h * s * x - i * d * x) * I,
                        t[4] = R * I,
                        t[5] = (m * T * r - b * _ * r + b * s * x - n * T * x - m * s * M + n * _ * M) * I,
                        t[6] = (b * d * r - l * T * r - b * s * p + n * T * p + l * s * M - n * d * M) * I,
                        t[7] = (l * _ * r - m * d * r + m * s * p - n * _ * p - l * s * x + n * d * x) * I,
                        t[8] = O * I,
                        t[9] = (b * v * r - m * E * r - b * i * x + n * E * x + m * i * M - n * v * M) * I,
                        t[10] = (l * E * r - b * h * r + b * i * p - n * E * p - l * i * M + n * h * M) * I,
                        t[11] = (m * h * r - l * v * r - m * i * p + n * v * p + l * i * x - n * h * x) * I,
                        t[12] = U * I,
                        t[13] = (m * E * s - b * v * s + b * i * _ - n * E * _ - m * i * T + n * v * T) * I,
                        t[14] = (b * h * s - l * E * s - b * i * d + n * E * d + l * i * T - n * h * T) * I,
                        t[15] = (l * v * s - m * h * s + m * i * d - n * v * d - l * i * _ + n * h * _) * I,
                        this
                    }
                    scale(t) {
                        const n = this.elements
                          , i = t.x
                          , s = t.y
                          , r = t.z;
                        return n[0] *= i,
                        n[4] *= s,
                        n[8] *= r,
                        n[1] *= i,
                        n[5] *= s,
                        n[9] *= r,
                        n[2] *= i,
                        n[6] *= s,
                        n[10] *= r,
                        n[3] *= i,
                        n[7] *= s,
                        n[11] *= r,
                        this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements
                          , n = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                          , i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                          , s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(n, i, s))
                    }
                    makeTranslation(t, n, i) {
                        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1),
                        this
                    }
                    makeRotationX(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationY(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationZ(t) {
                        const n = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationAxis(t, n) {
                        const i = Math.cos(n)
                          , s = Math.sin(n)
                          , r = 1 - i
                          , l = t.x
                          , h = t.y
                          , d = t.z
                          , p = r * l
                          , m = r * h;
                        return this.set(p * l + i, p * h - s * d, p * d + s * h, 0, p * h + s * d, m * h + i, m * d - s * l, 0, p * d - s * h, m * d + s * l, r * d * d + i, 0, 0, 0, 0, 1),
                        this
                    }
                    makeScale(t, n, i) {
                        return this.set(t, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
                        this
                    }
                    makeShear(t, n, i, s, r, l) {
                        return this.set(1, i, r, 0, t, 1, l, 0, n, s, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    compose(t, n, i) {
                        const s = this.elements
                          , r = n._x
                          , l = n._y
                          , h = n._z
                          , d = n._w
                          , p = r + r
                          , m = l + l
                          , v = h + h
                          , _ = r * p
                          , x = r * m
                          , b = r * v
                          , E = l * m
                          , T = l * v
                          , M = h * v
                          , D = d * p
                          , R = d * m
                          , O = d * v
                          , U = i.x
                          , B = i.y
                          , I = i.z;
                        return s[0] = (1 - (E + M)) * U,
                        s[1] = (x + O) * U,
                        s[2] = (b - R) * U,
                        s[3] = 0,
                        s[4] = (x - O) * B,
                        s[5] = (1 - (_ + M)) * B,
                        s[6] = (T + D) * B,
                        s[7] = 0,
                        s[8] = (b + R) * I,
                        s[9] = (T - D) * I,
                        s[10] = (1 - (_ + E)) * I,
                        s[11] = 0,
                        s[12] = t.x,
                        s[13] = t.y,
                        s[14] = t.z,
                        s[15] = 1,
                        this
                    }
                    decompose(t, n, i) {
                        const s = this.elements;
                        let r = pp.set(s[0], s[1], s[2]).length();
                        const l = pp.set(s[4], s[5], s[6]).length()
                          , h = pp.set(s[8], s[9], s[10]).length();
                        this.determinant() < 0 && (r = -r),
                        t.x = s[12],
                        t.y = s[13],
                        t.z = s[14],
                        Go.copy(this);
                        const d = 1 / r
                          , p = 1 / l
                          , m = 1 / h;
                        return Go.elements[0] *= d,
                        Go.elements[1] *= d,
                        Go.elements[2] *= d,
                        Go.elements[4] *= p,
                        Go.elements[5] *= p,
                        Go.elements[6] *= p,
                        Go.elements[8] *= m,
                        Go.elements[9] *= m,
                        Go.elements[10] *= m,
                        n.setFromRotationMatrix(Go),
                        i.x = r,
                        i.y = l,
                        i.z = h,
                        this
                    }
                    makePerspective(t, n, i, s, r, l, h=br, d=!1) {
                        const p = this.elements
                          , m = 2 * r / (n - t)
                          , v = 2 * r / (i - s)
                          , _ = (n + t) / (n - t)
                          , x = (i + s) / (i - s);
                        let b, E;
                        if (d)
                            b = r / (l - r),
                            E = l * r / (l - r);
                        else if (h === br)
                            b = -(l + r) / (l - r),
                            E = -2 * l * r / (l - r);
                        else if (h === rp)
                            b = -l / (l - r),
                            E = -l * r / (l - r);
                        else
                            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + h);
                        return p[0] = m,
                        p[4] = 0,
                        p[8] = _,
                        p[12] = 0,
                        p[1] = 0,
                        p[5] = v,
                        p[9] = x,
                        p[13] = 0,
                        p[2] = 0,
                        p[6] = 0,
                        p[10] = b,
                        p[14] = E,
                        p[3] = 0,
                        p[7] = 0,
                        p[11] = -1,
                        p[15] = 0,
                        this
                    }
                    makeOrthographic(t, n, i, s, r, l, h=br, d=!1) {
                        const p = this.elements
                          , m = 2 / (n - t)
                          , v = 2 / (i - s)
                          , _ = -(n + t) / (n - t)
                          , x = -(i + s) / (i - s);
                        let b, E;
                        if (d)
                            b = 1 / (l - r),
                            E = l / (l - r);
                        else if (h === br)
                            b = -2 / (l - r),
                            E = -(l + r) / (l - r);
                        else if (h === rp)
                            b = -1 / (l - r),
                            E = -r / (l - r);
                        else
                            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + h);
                        return p[0] = m,
                        p[4] = 0,
                        p[8] = 0,
                        p[12] = _,
                        p[1] = 0,
                        p[5] = v,
                        p[9] = 0,
                        p[13] = x,
                        p[2] = 0,
                        p[6] = 0,
                        p[10] = b,
                        p[14] = E,
                        p[3] = 0,
                        p[7] = 0,
                        p[11] = 0,
                        p[15] = 1,
                        this
                    }
                    equals(t) {
                        const n = this.elements
                          , i = t.elements;
                        for (let s = 0; s < 16; s++)
                            if (n[s] !== i[s])
                                return !1;
                        return !0
                    }
                    fromArray(t, n=0) {
                        for (let i = 0; i < 16; i++)
                            this.elements[i] = t[i + n];
                        return this
                    }
                    toArray(t=[], n=0) {
                        const i = this.elements;
                        return t[n] = i[0],
                        t[n + 1] = i[1],
                        t[n + 2] = i[2],
                        t[n + 3] = i[3],
                        t[n + 4] = i[4],
                        t[n + 5] = i[5],
                        t[n + 6] = i[6],
                        t[n + 7] = i[7],
                        t[n + 8] = i[8],
                        t[n + 9] = i[9],
                        t[n + 10] = i[10],
                        t[n + 11] = i[11],
                        t[n + 12] = i[12],
                        t[n + 13] = i[13],
                        t[n + 14] = i[14],
                        t[n + 15] = i[15],
                        t
                    }
                }
                ;
                const pp = new Q
                  , Go = new Xt
                  , fB = new Q(0,0,0)
                  , dB = new Q(1,1,1)
                  , Fu = new Q
                  , E_ = new Q
                  , Cr = new Q
                  , iw = new Xt
                  , sw = new _s;
                var io = class MO {
                    constructor(t=0, n=0, i=0, s=MO.DEFAULT_ORDER) {
                        this.isEuler = !0,
                        this._x = t,
                        this._y = n,
                        this._z = i,
                        this._order = s
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t,
                        this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(t) {
                        this._order = t,
                        this._onChangeCallback()
                    }
                    set(t, n, i, s=this._order) {
                        return this._x = t,
                        this._y = n,
                        this._z = i,
                        this._order = s,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._order)
                    }
                    copy(t) {
                        return this._x = t._x,
                        this._y = t._y,
                        this._z = t._z,
                        this._order = t._order,
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(t, n=this._order, i=!0) {
                        const s = t.elements
                          , r = s[0]
                          , l = s[4]
                          , h = s[8]
                          , d = s[1]
                          , p = s[5]
                          , m = s[9]
                          , v = s[2]
                          , _ = s[6]
                          , x = s[10];
                        switch (n) {
                        case "XYZ":
                            this._y = Math.asin(kt(h, -1, 1)),
                            Math.abs(h) < .9999999 ? (this._x = Math.atan2(-m, x),
                            this._z = Math.atan2(-l, r)) : (this._x = Math.atan2(_, p),
                            this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-kt(m, -1, 1)),
                            Math.abs(m) < .9999999 ? (this._y = Math.atan2(h, x),
                            this._z = Math.atan2(d, p)) : (this._y = Math.atan2(-v, r),
                            this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(kt(_, -1, 1)),
                            Math.abs(_) < .9999999 ? (this._y = Math.atan2(-v, x),
                            this._z = Math.atan2(-l, p)) : (this._y = 0,
                            this._z = Math.atan2(d, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-kt(v, -1, 1)),
                            Math.abs(v) < .9999999 ? (this._x = Math.atan2(_, x),
                            this._z = Math.atan2(d, r)) : (this._x = 0,
                            this._z = Math.atan2(-l, p));
                            break;
                        case "YZX":
                            this._z = Math.asin(kt(d, -1, 1)),
                            Math.abs(d) < .9999999 ? (this._x = Math.atan2(-m, p),
                            this._y = Math.atan2(-v, r)) : (this._x = 0,
                            this._y = Math.atan2(h, x));
                            break;
                        case "XZY":
                            this._z = Math.asin(-kt(l, -1, 1)),
                            Math.abs(l) < .9999999 ? (this._x = Math.atan2(_, p),
                            this._y = Math.atan2(h, r)) : (this._x = Math.atan2(-m, x),
                            this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
                        }
                        return this._order = n,
                        i === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromQuaternion(t, n, i) {
                        return iw.makeRotationFromQuaternion(t),
                        this.setFromRotationMatrix(iw, n, i)
                    }
                    setFromVector3(t, n=this._order) {
                        return this.set(t.x, t.y, t.z, n)
                    }
                    reorder(t) {
                        return sw.setFromEuler(this),
                        this.setFromQuaternion(sw, t)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                    fromArray(t) {
                        return this._x = t[0],
                        this._y = t[1],
                        this._z = t[2],
                        t[3] !== void 0 && (this._order = t[3]),
                        this._onChangeCallback(),
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this._x,
                        t[n + 1] = this._y,
                        t[n + 2] = this._z,
                        t[n + 3] = this._order,
                        t
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._order
                    }
                }
                ;
                io.DEFAULT_ORDER = "XYZ";
                var mp = class {
                    constructor() {
                        this.mask = 1
                    }
                    set(e) {
                        this.mask = (1 << e | 0) >>> 0
                    }
                    enable(e) {
                        this.mask |= 1 << e | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(e) {
                        this.mask ^= 1 << e | 0
                    }
                    disable(e) {
                        this.mask &= ~(1 << e | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(e) {
                        return (this.mask & e.mask) !== 0
                    }
                    isEnabled(e) {
                        return (this.mask & (1 << e | 0)) !== 0
                    }
                }
                ;
                let pB = 0;
                const aw = new Q
                  , gp = new _s
                  , bc = new Xt
                  , w_ = new Q
                  , tv = new Q
                  , mB = new Q
                  , gB = new _s
                  , rw = new Q(1,0,0)
                  , ow = new Q(0,1,0)
                  , lw = new Q(0,0,1)
                  , cw = {
                    type: "added"
                }
                  , vB = {
                    type: "removed"
                }
                  , vp = {
                    type: "childadded",
                    child: null
                }
                  , PA = {
                    type: "childremoved",
                    child: null
                };
                var jn = class _S extends Er {
                    constructor() {
                        super(),
                        this.isObject3D = !0,
                        Object.defineProperty(this, "id", {
                            value: pB++
                        }),
                        this.uuid = wr(),
                        this.name = "",
                        this.type = "Object3D",
                        this.parent = null,
                        this.children = [],
                        this.up = _S.DEFAULT_UP.clone();
                        const t = new Q
                          , n = new io
                          , i = new _s
                          , s = new Q(1,1,1);
                        function r() {
                            i.setFromEuler(n, !1)
                        }
                        function l() {
                            n.setFromQuaternion(i, void 0, !1)
                        }
                        n._onChange(r),
                        i._onChange(l),
                        Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: t
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: i
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: s
                            },
                            modelViewMatrix: {
                                value: new Xt
                            },
                            normalMatrix: {
                                value: new rn
                            }
                        }),
                        this.matrix = new Xt,
                        this.matrixWorld = new Xt,
                        this.matrixAutoUpdate = _S.DEFAULT_MATRIX_AUTO_UPDATE,
                        this.matrixWorldAutoUpdate = _S.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                        this.matrixWorldNeedsUpdate = !1,
                        this.layers = new mp,
                        this.visible = !0,
                        this.castShadow = !1,
                        this.receiveShadow = !1,
                        this.frustumCulled = !0,
                        this.renderOrder = 0,
                        this.animations = [],
                        this.customDepthMaterial = void 0,
                        this.customDistanceMaterial = void 0,
                        this.userData = {}
                    }
                    onBeforeShadow() {}
                    onAfterShadow() {}
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(t),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t),
                        this
                    }
                    setRotationFromAxisAngle(t, n) {
                        this.quaternion.setFromAxisAngle(t, n)
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0)
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t)
                    }
                    rotateOnAxis(t, n) {
                        return gp.setFromAxisAngle(t, n),
                        this.quaternion.multiply(gp),
                        this
                    }
                    rotateOnWorldAxis(t, n) {
                        return gp.setFromAxisAngle(t, n),
                        this.quaternion.premultiply(gp),
                        this
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(rw, t)
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(ow, t)
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(lw, t)
                    }
                    translateOnAxis(t, n) {
                        return aw.copy(t).applyQuaternion(this.quaternion),
                        this.position.add(aw.multiplyScalar(n)),
                        this
                    }
                    translateX(t) {
                        return this.translateOnAxis(rw, t)
                    }
                    translateY(t) {
                        return this.translateOnAxis(ow, t)
                    }
                    translateZ(t) {
                        return this.translateOnAxis(lw, t)
                    }
                    localToWorld(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.applyMatrix4(bc.copy(this.matrixWorld).invert())
                    }
                    lookAt(t, n, i) {
                        t.isVector3 ? w_.copy(t) : w_.set(t, n, i);
                        const s = this.parent;
                        this.updateWorldMatrix(!0, !1),
                        tv.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? bc.lookAt(tv, w_, this.up) : bc.lookAt(w_, tv, this.up),
                        this.quaternion.setFromRotationMatrix(bc),
                        s && (bc.extractRotation(s.matrixWorld),
                        gp.setFromRotationMatrix(bc),
                        this.quaternion.premultiply(gp.invert()))
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let n = 0; n < arguments.length; n++)
                                this.add(arguments[n]);
                            return this
                        }
                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                        this) : (t && t.isObject3D ? (t.removeFromParent(),
                        t.parent = this,
                        this.children.push(t),
                        t.dispatchEvent(cw),
                        vp.child = t,
                        this.dispatchEvent(vp),
                        vp.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                        this)
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let i = 0; i < arguments.length; i++)
                                this.remove(arguments[i]);
                            return this
                        }
                        const n = this.children.indexOf(t);
                        return n !== -1 && (t.parent = null,
                        this.children.splice(n, 1),
                        t.dispatchEvent(vB),
                        PA.child = t,
                        this.dispatchEvent(PA),
                        PA.child = null),
                        this
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return t !== null && t.remove(this),
                        this
                    }
                    clear() {
                        return this.remove(...this.children)
                    }
                    attach(t) {
                        return this.updateWorldMatrix(!0, !1),
                        bc.copy(this.matrixWorld).invert(),
                        t.parent !== null && (t.parent.updateWorldMatrix(!0, !1),
                        bc.multiply(t.parent.matrixWorld)),
                        t.applyMatrix4(bc),
                        t.removeFromParent(),
                        t.parent = this,
                        this.children.push(t),
                        t.updateWorldMatrix(!1, !0),
                        t.dispatchEvent(cw),
                        vp.child = t,
                        this.dispatchEvent(vp),
                        vp.child = null,
                        this
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t)
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t)
                    }
                    getObjectByProperty(t, n) {
                        if (this[t] === n)
                            return this;
                        for (let i = 0, s = this.children.length; i < s; i++) {
                            const r = this.children[i].getObjectByProperty(t, n);
                            if (r !== void 0)
                                return r
                        }
                    }
                    getObjectsByProperty(t, n, i=[]) {
                        this[t] === n && i.push(this);
                        const s = this.children;
                        for (let r = 0, l = s.length; r < l; r++)
                            s[r].getObjectsByProperty(t, n, i);
                        return i
                    }
                    getWorldPosition(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(t) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(tv, t, mB),
                        t
                    }
                    getWorldScale(t) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(tv, gB, t),
                        t
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const n = this.matrixWorld.elements;
                        return t.set(n[8], n[9], n[10]).normalize()
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const n = this.children;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].traverse(t)
                    }
                    traverseVisible(t) {
                        if (this.visible === !1)
                            return;
                        t(this);
                        const n = this.children;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const n = this.parent;
                        n !== null && (t(n),
                        n.traverseAncestors(t))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        this.matrixWorldNeedsUpdate = !1,
                        t = !0);
                        const n = this.children;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].updateMatrixWorld(t)
                    }
                    updateWorldMatrix(t, n) {
                        const i = this.parent;
                        if (t === !0 && i !== null && i.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        n === !0) {
                            const s = this.children;
                            for (let r = 0, l = s.length; r < l; r++)
                                s[r].updateWorldMatrix(!1, !0)
                        }
                    }
                    toJSON(t) {
                        const n = t === void 0 || typeof t == "string"
                          , i = {};
                        n && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                            nodes: {}
                        },
                        i.metadata = {
                            version: 4.7,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const s = {};
                        s.uuid = this.uuid,
                        s.type = this.type,
                        this.name !== "" && (s.name = this.name),
                        this.castShadow === !0 && (s.castShadow = !0),
                        this.receiveShadow === !0 && (s.receiveShadow = !0),
                        this.visible === !1 && (s.visible = !1),
                        this.frustumCulled === !1 && (s.frustumCulled = !1),
                        this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
                        Object.keys(this.userData).length > 0 && (s.userData = this.userData),
                        s.layers = this.layers.mask,
                        s.matrix = this.matrix.toArray(),
                        s.up = this.up.toArray(),
                        this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
                        this.isInstancedMesh && (s.type = "InstancedMesh",
                        s.count = this.count,
                        s.instanceMatrix = this.instanceMatrix.toJSON(),
                        this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())),
                        this.isBatchedMesh && (s.type = "BatchedMesh",
                        s.perObjectFrustumCulled = this.perObjectFrustumCulled,
                        s.sortObjects = this.sortObjects,
                        s.drawRanges = this._drawRanges,
                        s.reservedRanges = this._reservedRanges,
                        s.geometryInfo = this._geometryInfo.map(h => ({
                            ...h,
                            boundingBox: h.boundingBox ? h.boundingBox.toJSON() : void 0,
                            boundingSphere: h.boundingSphere ? h.boundingSphere.toJSON() : void 0
                        })),
                        s.instanceInfo = this._instanceInfo.map(h => ({
                            ...h
                        })),
                        s.availableInstanceIds = this._availableInstanceIds.slice(),
                        s.availableGeometryIds = this._availableGeometryIds.slice(),
                        s.nextIndexStart = this._nextIndexStart,
                        s.nextVertexStart = this._nextVertexStart,
                        s.geometryCount = this._geometryCount,
                        s.maxInstanceCount = this._maxInstanceCount,
                        s.maxVertexCount = this._maxVertexCount,
                        s.maxIndexCount = this._maxIndexCount,
                        s.geometryInitialized = this._geometryInitialized,
                        s.matricesTexture = this._matricesTexture.toJSON(t),
                        s.indirectTexture = this._indirectTexture.toJSON(t),
                        this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(t)),
                        this.boundingSphere !== null && (s.boundingSphere = this.boundingSphere.toJSON()),
                        this.boundingBox !== null && (s.boundingBox = this.boundingBox.toJSON()));
                        function r(h, d) {
                            return h[d.uuid] === void 0 && (h[d.uuid] = d.toJSON(t)),
                            d.uuid
                        }
                        if (this.isScene)
                            this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(t).uuid)),
                            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            s.geometry = r(t.geometries, this.geometry);
                            const h = this.geometry.parameters;
                            if (h !== void 0 && h.shapes !== void 0) {
                                const d = h.shapes;
                                if (Array.isArray(d))
                                    for (let p = 0, m = d.length; p < m; p++) {
                                        const v = d[p];
                                        r(t.shapes, v)
                                    }
                                else
                                    r(t.shapes, d)
                            }
                        }
                        if (this.isSkinnedMesh && (s.bindMode = this.bindMode,
                        s.bindMatrix = this.bindMatrix.toArray(),
                        this.skeleton !== void 0 && (r(t.skeletons, this.skeleton),
                        s.skeleton = this.skeleton.uuid)),
                        this.material !== void 0)
                            if (Array.isArray(this.material)) {
                                const h = [];
                                for (let d = 0, p = this.material.length; d < p; d++)
                                    h.push(r(t.materials, this.material[d]));
                                s.material = h
                            } else
                                s.material = r(t.materials, this.material);
                        if (this.children.length > 0) {
                            s.children = [];
                            for (let h = 0; h < this.children.length; h++)
                                s.children.push(this.children[h].toJSON(t).object)
                        }
                        if (this.animations.length > 0) {
                            s.animations = [];
                            for (let h = 0; h < this.animations.length; h++) {
                                const d = this.animations[h];
                                s.animations.push(r(t.animations, d))
                            }
                        }
                        if (n) {
                            const h = l(t.geometries)
                              , d = l(t.materials)
                              , p = l(t.textures)
                              , m = l(t.images)
                              , v = l(t.shapes)
                              , _ = l(t.skeletons)
                              , x = l(t.animations)
                              , b = l(t.nodes);
                            h.length > 0 && (i.geometries = h),
                            d.length > 0 && (i.materials = d),
                            p.length > 0 && (i.textures = p),
                            m.length > 0 && (i.images = m),
                            v.length > 0 && (i.shapes = v),
                            _.length > 0 && (i.skeletons = _),
                            x.length > 0 && (i.animations = x),
                            b.length > 0 && (i.nodes = b)
                        }
                        return i.object = s,
                        i;
                        function l(h) {
                            const d = [];
                            for (const p in h) {
                                const m = h[p];
                                delete m.metadata,
                                d.push(m)
                            }
                            return d
                        }
                    }
                    clone(t) {
                        return new this.constructor().copy(this, t)
                    }
                    copy(t, n=!0) {
                        if (this.name = t.name,
                        this.up.copy(t.up),
                        this.position.copy(t.position),
                        this.rotation.order = t.rotation.order,
                        this.quaternion.copy(t.quaternion),
                        this.scale.copy(t.scale),
                        this.matrix.copy(t.matrix),
                        this.matrixWorld.copy(t.matrixWorld),
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate,
                        this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                        this.layers.mask = t.layers.mask,
                        this.visible = t.visible,
                        this.castShadow = t.castShadow,
                        this.receiveShadow = t.receiveShadow,
                        this.frustumCulled = t.frustumCulled,
                        this.renderOrder = t.renderOrder,
                        this.animations = t.animations.slice(),
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        n === !0)
                            for (let i = 0; i < t.children.length; i++) {
                                const s = t.children[i];
                                this.add(s.clone())
                            }
                        return this
                    }
                }
                ;
                jn.DEFAULT_UP = new Q(0,1,0),
                jn.DEFAULT_MATRIX_AUTO_UPDATE = !0,
                jn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                const ko = new Q
                  , Ec = new Q
                  , IA = new Q
                  , wc = new Q
                  , yp = new Q
                  , _p = new Q
                  , uw = new Q
                  , LA = new Q
                  , zA = new Q
                  , FA = new Q
                  , HA = new gn
                  , VA = new gn
                  , GA = new gn;
                var Hu = class pm {
                    constructor(t=new Q, n=new Q, i=new Q) {
                        this.a = t,
                        this.b = n,
                        this.c = i
                    }
                    static getNormal(t, n, i, s) {
                        s.subVectors(i, n),
                        ko.subVectors(t, n),
                        s.cross(ko);
                        const r = s.lengthSq();
                        return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0)
                    }
                    static getBarycoord(t, n, i, s, r) {
                        ko.subVectors(s, n),
                        Ec.subVectors(i, n),
                        IA.subVectors(t, n);
                        const l = ko.dot(ko)
                          , h = ko.dot(Ec)
                          , d = ko.dot(IA)
                          , p = Ec.dot(Ec)
                          , m = Ec.dot(IA)
                          , v = l * p - h * h;
                        if (v === 0)
                            return r.set(0, 0, 0),
                            null;
                        const _ = 1 / v
                          , x = (p * d - h * m) * _
                          , b = (l * m - h * d) * _;
                        return r.set(1 - x - b, b, x)
                    }
                    static containsPoint(t, n, i, s) {
                        return this.getBarycoord(t, n, i, s, wc) === null ? !1 : wc.x >= 0 && wc.y >= 0 && wc.x + wc.y <= 1
                    }
                    static getInterpolation(t, n, i, s, r, l, h, d) {
                        return this.getBarycoord(t, n, i, s, wc) === null ? (d.x = 0,
                        d.y = 0,
                        "z"in d && (d.z = 0),
                        "w"in d && (d.w = 0),
                        null) : (d.setScalar(0),
                        d.addScaledVector(r, wc.x),
                        d.addScaledVector(l, wc.y),
                        d.addScaledVector(h, wc.z),
                        d)
                    }
                    static getInterpolatedAttribute(t, n, i, s, r, l) {
                        return HA.setScalar(0),
                        VA.setScalar(0),
                        GA.setScalar(0),
                        HA.fromBufferAttribute(t, n),
                        VA.fromBufferAttribute(t, i),
                        GA.fromBufferAttribute(t, s),
                        l.setScalar(0),
                        l.addScaledVector(HA, r.x),
                        l.addScaledVector(VA, r.y),
                        l.addScaledVector(GA, r.z),
                        l
                    }
                    static isFrontFacing(t, n, i, s) {
                        return ko.subVectors(i, n),
                        Ec.subVectors(t, n),
                        ko.cross(Ec).dot(s) < 0
                    }
                    set(t, n, i) {
                        return this.a.copy(t),
                        this.b.copy(n),
                        this.c.copy(i),
                        this
                    }
                    setFromPointsAndIndices(t, n, i, s) {
                        return this.a.copy(t[n]),
                        this.b.copy(t[i]),
                        this.c.copy(t[s]),
                        this
                    }
                    setFromAttributeAndIndices(t, n, i, s) {
                        return this.a.fromBufferAttribute(t, n),
                        this.b.fromBufferAttribute(t, i),
                        this.c.fromBufferAttribute(t, s),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.a.copy(t.a),
                        this.b.copy(t.b),
                        this.c.copy(t.c),
                        this
                    }
                    getArea() {
                        return ko.subVectors(this.c, this.b),
                        Ec.subVectors(this.a, this.b),
                        ko.cross(Ec).length() * .5
                    }
                    getMidpoint(t) {
                        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(t) {
                        return pm.getNormal(this.a, this.b, this.c, t)
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(t, n) {
                        return pm.getBarycoord(t, this.a, this.b, this.c, n)
                    }
                    getInterpolation(t, n, i, s, r) {
                        return pm.getInterpolation(t, this.a, this.b, this.c, n, i, s, r)
                    }
                    containsPoint(t) {
                        return pm.containsPoint(t, this.a, this.b, this.c)
                    }
                    isFrontFacing(t) {
                        return pm.isFrontFacing(this.a, this.b, this.c, t)
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this)
                    }
                    closestPointToPoint(t, n) {
                        const i = this.a
                          , s = this.b
                          , r = this.c;
                        let l, h;
                        yp.subVectors(s, i),
                        _p.subVectors(r, i),
                        LA.subVectors(t, i);
                        const d = yp.dot(LA)
                          , p = _p.dot(LA);
                        if (d <= 0 && p <= 0)
                            return n.copy(i);
                        zA.subVectors(t, s);
                        const m = yp.dot(zA)
                          , v = _p.dot(zA);
                        if (m >= 0 && v <= m)
                            return n.copy(s);
                        const _ = d * v - m * p;
                        if (_ <= 0 && d >= 0 && m <= 0)
                            return l = d / (d - m),
                            n.copy(i).addScaledVector(yp, l);
                        FA.subVectors(t, r);
                        const x = yp.dot(FA)
                          , b = _p.dot(FA);
                        if (b >= 0 && x <= b)
                            return n.copy(r);
                        const E = x * p - d * b;
                        if (E <= 0 && p >= 0 && b <= 0)
                            return h = p / (p - b),
                            n.copy(i).addScaledVector(_p, h);
                        const T = m * b - x * v;
                        if (T <= 0 && v - m >= 0 && x - b >= 0)
                            return uw.subVectors(r, s),
                            h = (v - m) / (v - m + (x - b)),
                            n.copy(s).addScaledVector(uw, h);
                        const M = 1 / (T + E + _);
                        return l = E * M,
                        h = _ * M,
                        n.copy(i).addScaledVector(yp, l).addScaledVector(_p, h)
                    }
                    equals(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }
                ;
                const hw = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                }
                  , Vu = {
                    h: 0,
                    s: 0,
                    l: 0
                }
                  , C_ = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                function kA(e, t, n) {
                    return n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e
                }
                var at = class {
                    constructor(e, t, n) {
                        return this.isColor = !0,
                        this.r = 1,
                        this.g = 1,
                        this.b = 1,
                        this.set(e, t, n)
                    }
                    set(e, t, n) {
                        if (t === void 0 && n === void 0) {
                            const i = e;
                            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
                        } else
                            this.setRGB(e, t, n);
                        return this
                    }
                    setScalar(e) {
                        return this.r = e,
                        this.g = e,
                        this.b = e,
                        this
                    }
                    setHex(e, t=$t) {
                        return e = Math.floor(e),
                        this.r = (e >> 16 & 255) / 255,
                        this.g = (e >> 8 & 255) / 255,
                        this.b = (e & 255) / 255,
                        An.colorSpaceToWorking(this, t),
                        this
                    }
                    setRGB(e, t, n, i=An.workingColorSpace) {
                        return this.r = e,
                        this.g = t,
                        this.b = n,
                        An.colorSpaceToWorking(this, i),
                        this
                    }
                    setHSL(e, t, n, i=An.workingColorSpace) {
                        if (e = MA(e, 1),
                        t = kt(t, 0, 1),
                        n = kt(n, 0, 1),
                        t === 0)
                            this.r = this.g = this.b = n;
                        else {
                            const s = n <= .5 ? n * (1 + t) : n + t - n * t
                              , r = 2 * n - s;
                            this.r = kA(r, s, e + 1 / 3),
                            this.g = kA(r, s, e),
                            this.b = kA(r, s, e - 1 / 3)
                        }
                        return An.colorSpaceToWorking(this, i),
                        this
                    }
                    setStyle(e, t=$t) {
                        function n(s) {
                            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                        }
                        let i;
                        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                            let s;
                            const r = i[1]
                              , l = i[2];
                            switch (r) {
                            case "rgb":
                            case "rgba":
                                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                                    return n(s[4]),
                                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                                    return n(s[4]),
                                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                                break;
                            case "hsl":
                            case "hsla":
                                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
                                    return n(s[4]),
                                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                                break;
                            default:
                                console.warn("THREE.Color: Unknown color model " + e)
                            }
                        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                            const s = i[1]
                              , r = s.length;
                            if (r === 3)
                                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
                            if (r === 6)
                                return this.setHex(parseInt(s, 16), t);
                            console.warn("THREE.Color: Invalid hex color " + e)
                        } else if (e && e.length > 0)
                            return this.setColorName(e, t);
                        return this
                    }
                    setColorName(e, t=$t) {
                        const n = hw[e.toLowerCase()];
                        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                        this
                    }
                    clone() {
                        return new this.constructor(this.r,this.g,this.b)
                    }
                    copy(e) {
                        return this.r = e.r,
                        this.g = e.g,
                        this.b = e.b,
                        this
                    }
                    copySRGBToLinear(e) {
                        return this.r = Ac(e.r),
                        this.g = Ac(e.g),
                        this.b = Ac(e.b),
                        this
                    }
                    copyLinearToSRGB(e) {
                        return this.r = cp(e.r),
                        this.g = cp(e.g),
                        this.b = cp(e.b),
                        this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this),
                        this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this),
                        this
                    }
                    getHex(e=$t) {
                        return An.workingToColorSpace(ra.copy(this), e),
                        Math.round(kt(ra.r * 255, 0, 255)) * 65536 + Math.round(kt(ra.g * 255, 0, 255)) * 256 + Math.round(kt(ra.b * 255, 0, 255))
                    }
                    getHexString(e=$t) {
                        return ("000000" + this.getHex(e).toString(16)).slice(-6)
                    }
                    getHSL(e, t=An.workingColorSpace) {
                        An.workingToColorSpace(ra.copy(this), t);
                        const n = ra.r
                          , i = ra.g
                          , s = ra.b
                          , r = Math.max(n, i, s)
                          , l = Math.min(n, i, s);
                        let h, d;
                        const p = (l + r) / 2;
                        if (l === r)
                            h = 0,
                            d = 0;
                        else {
                            const m = r - l;
                            switch (d = p <= .5 ? m / (r + l) : m / (2 - r - l),
                            r) {
                            case n:
                                h = (i - s) / m + (i < s ? 6 : 0);
                                break;
                            case i:
                                h = (s - n) / m + 2;
                                break;
                            case s:
                                h = (n - i) / m + 4;
                                break
                            }
                            h /= 6
                        }
                        return e.h = h,
                        e.s = d,
                        e.l = p,
                        e
                    }
                    getRGB(e, t=An.workingColorSpace) {
                        return An.workingToColorSpace(ra.copy(this), t),
                        e.r = ra.r,
                        e.g = ra.g,
                        e.b = ra.b,
                        e
                    }
                    getStyle(e=$t) {
                        An.workingToColorSpace(ra.copy(this), e);
                        const t = ra.r
                          , n = ra.g
                          , i = ra.b;
                        return e !== $t ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
                    }
                    offsetHSL(e, t, n) {
                        return this.getHSL(Vu),
                        this.setHSL(Vu.h + e, Vu.s + t, Vu.l + n)
                    }
                    add(e) {
                        return this.r += e.r,
                        this.g += e.g,
                        this.b += e.b,
                        this
                    }
                    addColors(e, t) {
                        return this.r = e.r + t.r,
                        this.g = e.g + t.g,
                        this.b = e.b + t.b,
                        this
                    }
                    addScalar(e) {
                        return this.r += e,
                        this.g += e,
                        this.b += e,
                        this
                    }
                    sub(e) {
                        return this.r = Math.max(0, this.r - e.r),
                        this.g = Math.max(0, this.g - e.g),
                        this.b = Math.max(0, this.b - e.b),
                        this
                    }
                    multiply(e) {
                        return this.r *= e.r,
                        this.g *= e.g,
                        this.b *= e.b,
                        this
                    }
                    multiplyScalar(e) {
                        return this.r *= e,
                        this.g *= e,
                        this.b *= e,
                        this
                    }
                    lerp(e, t) {
                        return this.r += (e.r - this.r) * t,
                        this.g += (e.g - this.g) * t,
                        this.b += (e.b - this.b) * t,
                        this
                    }
                    lerpColors(e, t, n) {
                        return this.r = e.r + (t.r - e.r) * n,
                        this.g = e.g + (t.g - e.g) * n,
                        this.b = e.b + (t.b - e.b) * n,
                        this
                    }
                    lerpHSL(e, t) {
                        this.getHSL(Vu),
                        e.getHSL(C_);
                        const n = Zg(Vu.h, C_.h, t)
                          , i = Zg(Vu.s, C_.s, t)
                          , s = Zg(Vu.l, C_.l, t);
                        return this.setHSL(n, i, s),
                        this
                    }
                    setFromVector3(e) {
                        return this.r = e.x,
                        this.g = e.y,
                        this.b = e.z,
                        this
                    }
                    applyMatrix3(e) {
                        const t = this.r
                          , n = this.g
                          , i = this.b
                          , s = e.elements;
                        return this.r = s[0] * t + s[3] * n + s[6] * i,
                        this.g = s[1] * t + s[4] * n + s[7] * i,
                        this.b = s[2] * t + s[5] * n + s[8] * i,
                        this
                    }
                    equals(e) {
                        return e.r === this.r && e.g === this.g && e.b === this.b
                    }
                    fromArray(e, t=0) {
                        return this.r = e[t],
                        this.g = e[t + 1],
                        this.b = e[t + 2],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.r,
                        e[t + 1] = this.g,
                        e[t + 2] = this.b,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this.r = e.getX(t),
                        this.g = e.getY(t),
                        this.b = e.getZ(t),
                        this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                    *[Symbol.iterator]() {
                        yield this.r,
                        yield this.g,
                        yield this.b
                    }
                }
                ;
                const ra = new at;
                at.NAMES = hw;
                let yB = 0;
                var Os = class extends Er {
                    constructor() {
                        super(),
                        this.isMaterial = !0,
                        Object.defineProperty(this, "id", {
                            value: yB++
                        }),
                        this.uuid = wr(),
                        this.name = "",
                        this.type = "Material",
                        this.blending = $h,
                        this.side = Bl,
                        this.vertexColors = !1,
                        this.opacity = 1,
                        this.transparent = !1,
                        this.alphaHash = !1,
                        this.blendSrc = Uy,
                        this.blendDst = By,
                        this.blendEquation = Du,
                        this.blendSrcAlpha = null,
                        this.blendDstAlpha = null,
                        this.blendEquationAlpha = null,
                        this.blendColor = new at(0,0,0),
                        this.blendAlpha = 0,
                        this.depthFunc = Ou,
                        this.depthTest = !0,
                        this.depthWrite = !0,
                        this.stencilWriteMask = 255,
                        this.stencilFunc = SA,
                        this.stencilRef = 0,
                        this.stencilFuncMask = 255,
                        this.stencilFail = of,
                        this.stencilZFail = of,
                        this.stencilZPass = of,
                        this.stencilWrite = !1,
                        this.clippingPlanes = null,
                        this.clipIntersection = !1,
                        this.clipShadows = !1,
                        this.shadowSide = null,
                        this.colorWrite = !0,
                        this.precision = null,
                        this.polygonOffset = !1,
                        this.polygonOffsetFactor = 0,
                        this.polygonOffsetUnits = 0,
                        this.dithering = !1,
                        this.alphaToCoverage = !1,
                        this.premultipliedAlpha = !1,
                        this.forceSinglePass = !1,
                        this.allowOverride = !0,
                        this.visible = !0,
                        this.toneMapped = !0,
                        this.userData = {},
                        this.version = 0,
                        this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(e) {
                        this._alphaTest > 0 != e > 0 && this.version++,
                        this._alphaTest = e
                    }
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(e) {
                        if (e !== void 0)
                            for (const t in e) {
                                const n = e[t];
                                if (n === void 0) {
                                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                                    continue
                                }
                                const i = this[t];
                                if (i === void 0) {
                                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                                    continue
                                }
                                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                            }
                    }
                    toJSON(e) {
                        const t = e === void 0 || typeof e == "string";
                        t && (e = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.7,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        n.uuid = this.uuid,
                        n.type = this.type,
                        this.name !== "" && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        this.roughness !== void 0 && (n.roughness = this.roughness),
                        this.metalness !== void 0 && (n.metalness = this.metalness),
                        this.sheen !== void 0 && (n.sheen = this.sheen),
                        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
                        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                        this.shininess !== void 0 && (n.shininess = this.shininess),
                        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
                        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                        this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
                        this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
                        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
                        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
                        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
                        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
                        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
                        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                        n.lightMapIntensity = this.lightMapIntensity),
                        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                        n.aoMapIntensity = this.aoMapIntensity),
                        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                        n.bumpScale = this.bumpScale),
                        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                        n.normalMapType = this.normalMapType,
                        n.normalScale = this.normalScale.toArray()),
                        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                        n.displacementScale = this.displacementScale,
                        n.displacementBias = this.displacementBias),
                        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                        this.combine !== void 0 && (n.combine = this.combine)),
                        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
                        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
                        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
                        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
                        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                        this.transmission !== void 0 && (n.transmission = this.transmission),
                        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                        this.thickness !== void 0 && (n.thickness = this.thickness),
                        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
                        this.size !== void 0 && (n.size = this.size),
                        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
                        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== $h && (n.blending = this.blending),
                        this.side !== Bl && (n.side = this.side),
                        this.vertexColors === !0 && (n.vertexColors = !0),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        this.transparent === !0 && (n.transparent = !0),
                        this.blendSrc !== Uy && (n.blendSrc = this.blendSrc),
                        this.blendDst !== By && (n.blendDst = this.blendDst),
                        this.blendEquation !== Du && (n.blendEquation = this.blendEquation),
                        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
                        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
                        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
                        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
                        this.depthFunc !== Ou && (n.depthFunc = this.depthFunc),
                        this.depthTest === !1 && (n.depthTest = this.depthTest),
                        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
                        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
                        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
                        this.stencilFunc !== SA && (n.stencilFunc = this.stencilFunc),
                        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
                        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
                        this.stencilFail !== of && (n.stencilFail = this.stencilFail),
                        this.stencilZFail !== of && (n.stencilZFail = this.stencilZFail),
                        this.stencilZPass !== of && (n.stencilZPass = this.stencilZPass),
                        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
                        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
                        this.polygonOffset === !0 && (n.polygonOffset = !0),
                        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
                        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
                        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
                        this.scale !== void 0 && (n.scale = this.scale),
                        this.dithering === !0 && (n.dithering = !0),
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        this.alphaHash === !0 && (n.alphaHash = !0),
                        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
                        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
                        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
                        this.wireframe === !0 && (n.wireframe = !0),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
                        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
                        this.flatShading === !0 && (n.flatShading = !0),
                        this.visible === !1 && (n.visible = !1),
                        this.toneMapped === !1 && (n.toneMapped = !1),
                        this.fog === !1 && (n.fog = !1),
                        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
                        function i(s) {
                            const r = [];
                            for (const l in s) {
                                const h = s[l];
                                delete h.metadata,
                                r.push(h)
                            }
                            return r
                        }
                        if (t) {
                            const s = i(e.textures)
                              , r = i(e.images);
                            s.length > 0 && (n.textures = s),
                            r.length > 0 && (n.images = r)
                        }
                        return n
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.name = e.name,
                        this.blending = e.blending,
                        this.side = e.side,
                        this.vertexColors = e.vertexColors,
                        this.opacity = e.opacity,
                        this.transparent = e.transparent,
                        this.blendSrc = e.blendSrc,
                        this.blendDst = e.blendDst,
                        this.blendEquation = e.blendEquation,
                        this.blendSrcAlpha = e.blendSrcAlpha,
                        this.blendDstAlpha = e.blendDstAlpha,
                        this.blendEquationAlpha = e.blendEquationAlpha,
                        this.blendColor.copy(e.blendColor),
                        this.blendAlpha = e.blendAlpha,
                        this.depthFunc = e.depthFunc,
                        this.depthTest = e.depthTest,
                        this.depthWrite = e.depthWrite,
                        this.stencilWriteMask = e.stencilWriteMask,
                        this.stencilFunc = e.stencilFunc,
                        this.stencilRef = e.stencilRef,
                        this.stencilFuncMask = e.stencilFuncMask,
                        this.stencilFail = e.stencilFail,
                        this.stencilZFail = e.stencilZFail,
                        this.stencilZPass = e.stencilZPass,
                        this.stencilWrite = e.stencilWrite;
                        const t = e.clippingPlanes;
                        let n = null;
                        if (t !== null) {
                            const i = t.length;
                            n = new Array(i);
                            for (let s = 0; s !== i; ++s)
                                n[s] = t[s].clone()
                        }
                        return this.clippingPlanes = n,
                        this.clipIntersection = e.clipIntersection,
                        this.clipShadows = e.clipShadows,
                        this.shadowSide = e.shadowSide,
                        this.colorWrite = e.colorWrite,
                        this.precision = e.precision,
                        this.polygonOffset = e.polygonOffset,
                        this.polygonOffsetFactor = e.polygonOffsetFactor,
                        this.polygonOffsetUnits = e.polygonOffsetUnits,
                        this.dithering = e.dithering,
                        this.alphaTest = e.alphaTest,
                        this.alphaHash = e.alphaHash,
                        this.alphaToCoverage = e.alphaToCoverage,
                        this.premultipliedAlpha = e.premultipliedAlpha,
                        this.forceSinglePass = e.forceSinglePass,
                        this.visible = e.visible,
                        this.toneMapped = e.toneMapped,
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                }
                  , Gu = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshBasicMaterial = !0,
                        this.type = "MeshBasicMaterial",
                        this.color = new at(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new io,
                        this.combine = Ig,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const Cc = _B();
                function _B() {
                    const e = new ArrayBuffer(4)
                      , t = new Float32Array(e)
                      , n = new Uint32Array(e)
                      , i = new Uint32Array(512)
                      , s = new Uint32Array(512);
                    for (let d = 0; d < 256; ++d) {
                        const p = d - 127;
                        p < -27 ? (i[d] = 0,
                        i[d | 256] = 32768,
                        s[d] = 24,
                        s[d | 256] = 24) : p < -14 ? (i[d] = 1024 >> -p - 14,
                        i[d | 256] = 1024 >> -p - 14 | 32768,
                        s[d] = -p - 1,
                        s[d | 256] = -p - 1) : p <= 15 ? (i[d] = p + 15 << 10,
                        i[d | 256] = p + 15 << 10 | 32768,
                        s[d] = 13,
                        s[d | 256] = 13) : p < 128 ? (i[d] = 31744,
                        i[d | 256] = 64512,
                        s[d] = 24,
                        s[d | 256] = 24) : (i[d] = 31744,
                        i[d | 256] = 64512,
                        s[d] = 13,
                        s[d | 256] = 13)
                    }
                    const r = new Uint32Array(2048)
                      , l = new Uint32Array(64)
                      , h = new Uint32Array(64);
                    for (let d = 1; d < 1024; ++d) {
                        let p = d << 13
                          , m = 0;
                        for (; (p & 8388608) === 0; )
                            p <<= 1,
                            m -= 8388608;
                        p &= -8388609,
                        m += 947912704,
                        r[d] = p | m
                    }
                    for (let d = 1024; d < 2048; ++d)
                        r[d] = 939524096 + (d - 1024 << 13);
                    for (let d = 1; d < 31; ++d)
                        l[d] = d << 23;
                    l[31] = 1199570944,
                    l[32] = 2147483648;
                    for (let d = 33; d < 63; ++d)
                        l[d] = 2147483648 + (d - 32 << 23);
                    l[63] = 3347054592;
                    for (let d = 1; d < 64; ++d)
                        d !== 32 && (h[d] = 1024);
                    return {
                        floatView: t,
                        uint32View: n,
                        baseTable: i,
                        shiftTable: s,
                        mantissaTable: r,
                        exponentTable: l,
                        offsetTable: h
                    }
                }
                function ir(e) {
                    Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
                    e = kt(e, -65504, 65504),
                    Cc.floatView[0] = e;
                    const t = Cc.uint32View[0]
                      , n = t >> 23 & 511;
                    return Cc.baseTable[n] + ((t & 8388607) >> Cc.shiftTable[n])
                }
                function nv(e) {
                    const t = e >> 10;
                    return Cc.uint32View[0] = Cc.mantissaTable[Cc.offsetTable[t] + (e & 1023)] + Cc.exponentTable[t],
                    Cc.floatView[0]
                }
                var xB = class {
                    static toHalfFloat(e) {
                        return ir(e)
                    }
                    static fromHalfFloat(e) {
                        return nv(e)
                    }
                }
                ;
                const as = new Q
                  , R_ = new ye;
                let SB = 0;
                var wn = class {
                    constructor(e, t, n=!1) {
                        if (Array.isArray(e))
                            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0,
                        Object.defineProperty(this, "id", {
                            value: SB++
                        }),
                        this.name = "",
                        this.array = e,
                        this.itemSize = t,
                        this.count = e !== void 0 ? e.length / t : 0,
                        this.normalized = n,
                        this.usage = Qg,
                        this.updateRanges = [],
                        this.gpuType = Xs,
                        this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    addUpdateRange(e, t) {
                        this.updateRanges.push({
                            start: e,
                            count: t
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(e) {
                        return this.name = e.name,
                        this.array = new e.array.constructor(e.array),
                        this.itemSize = e.itemSize,
                        this.count = e.count,
                        this.normalized = e.normalized,
                        this.usage = e.usage,
                        this.gpuType = e.gpuType,
                        this
                    }
                    copyAt(e, t, n) {
                        e *= this.itemSize,
                        n *= t.itemSize;
                        for (let i = 0, s = this.itemSize; i < s; i++)
                            this.array[e + i] = t.array[n + i];
                        return this
                    }
                    copyArray(e) {
                        return this.array.set(e),
                        this
                    }
                    applyMatrix3(e) {
                        if (this.itemSize === 2)
                            for (let t = 0, n = this.count; t < n; t++)
                                R_.fromBufferAttribute(this, t),
                                R_.applyMatrix3(e),
                                this.setXY(t, R_.x, R_.y);
                        else if (this.itemSize === 3)
                            for (let t = 0, n = this.count; t < n; t++)
                                as.fromBufferAttribute(this, t),
                                as.applyMatrix3(e),
                                this.setXYZ(t, as.x, as.y, as.z);
                        return this
                    }
                    applyMatrix4(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            as.fromBufferAttribute(this, t),
                            as.applyMatrix4(e),
                            this.setXYZ(t, as.x, as.y, as.z);
                        return this
                    }
                    applyNormalMatrix(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            as.fromBufferAttribute(this, t),
                            as.applyNormalMatrix(e),
                            this.setXYZ(t, as.x, as.y, as.z);
                        return this
                    }
                    transformDirection(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            as.fromBufferAttribute(this, t),
                            as.transformDirection(e),
                            this.setXYZ(t, as.x, as.y, as.z);
                        return this
                    }
                    set(e, t=0) {
                        return this.array.set(e, t),
                        this
                    }
                    getComponent(e, t) {
                        let n = this.array[e * this.itemSize + t];
                        return this.normalized && (n = Ua(n, this.array)),
                        n
                    }
                    setComponent(e, t, n) {
                        return this.normalized && (n = sn(n, this.array)),
                        this.array[e * this.itemSize + t] = n,
                        this
                    }
                    getX(e) {
                        let t = this.array[e * this.itemSize];
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setX(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize] = t,
                        this
                    }
                    getY(e) {
                        let t = this.array[e * this.itemSize + 1];
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setY(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize + 1] = t,
                        this
                    }
                    getZ(e) {
                        let t = this.array[e * this.itemSize + 2];
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setZ(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize + 2] = t,
                        this
                    }
                    getW(e) {
                        let t = this.array[e * this.itemSize + 3];
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setW(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize + 3] = t,
                        this
                    }
                    setXY(e, t, n) {
                        return e *= this.itemSize,
                        this.normalized && (t = sn(t, this.array),
                        n = sn(n, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this
                    }
                    setXYZ(e, t, n, i) {
                        return e *= this.itemSize,
                        this.normalized && (t = sn(t, this.array),
                        n = sn(n, this.array),
                        i = sn(i, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = i,
                        this
                    }
                    setXYZW(e, t, n, i, s) {
                        return e *= this.itemSize,
                        this.normalized && (t = sn(t, this.array),
                        n = sn(n, this.array),
                        i = sn(i, this.array),
                        s = sn(s, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = i,
                        this.array[e + 3] = s,
                        this
                    }
                    onUpload(e) {
                        return this.onUploadCallback = e,
                        this
                    }
                    clone() {
                        return new this.constructor(this.array,this.itemSize).copy(this)
                    }
                    toJSON() {
                        const e = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        return this.name !== "" && (e.name = this.name),
                        this.usage !== Qg && (e.usage = this.usage),
                        e
                    }
                }
                  , AB = class extends wn {
                    constructor(e, t, n) {
                        super(new Int8Array(e), t, n)
                    }
                }
                  , TB = class extends wn {
                    constructor(e, t, n) {
                        super(new Uint8Array(e), t, n)
                    }
                }
                  , MB = class extends wn {
                    constructor(e, t, n) {
                        super(new Uint8ClampedArray(e), t, n)
                    }
                }
                  , bB = class extends wn {
                    constructor(e, t, n) {
                        super(new Int16Array(e), t, n)
                    }
                }
                  , XA = class extends wn {
                    constructor(e, t, n) {
                        super(new Uint16Array(e), t, n)
                    }
                }
                  , EB = class extends wn {
                    constructor(e, t, n) {
                        super(new Int32Array(e), t, n)
                    }
                }
                  , qA = class extends wn {
                    constructor(e, t, n) {
                        super(new Uint32Array(e), t, n)
                    }
                }
                  , wB = class extends wn {
                    constructor(e, t, n) {
                        super(new Uint16Array(e), t, n),
                        this.isFloat16BufferAttribute = !0
                    }
                    getX(e) {
                        let t = nv(this.array[e * this.itemSize]);
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setX(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize] = ir(t),
                        this
                    }
                    getY(e) {
                        let t = nv(this.array[e * this.itemSize + 1]);
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setY(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize + 1] = ir(t),
                        this
                    }
                    getZ(e) {
                        let t = nv(this.array[e * this.itemSize + 2]);
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setZ(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize + 2] = ir(t),
                        this
                    }
                    getW(e) {
                        let t = nv(this.array[e * this.itemSize + 3]);
                        return this.normalized && (t = Ua(t, this.array)),
                        t
                    }
                    setW(e, t) {
                        return this.normalized && (t = sn(t, this.array)),
                        this.array[e * this.itemSize + 3] = ir(t),
                        this
                    }
                    setXY(e, t, n) {
                        return e *= this.itemSize,
                        this.normalized && (t = sn(t, this.array),
                        n = sn(n, this.array)),
                        this.array[e + 0] = ir(t),
                        this.array[e + 1] = ir(n),
                        this
                    }
                    setXYZ(e, t, n, i) {
                        return e *= this.itemSize,
                        this.normalized && (t = sn(t, this.array),
                        n = sn(n, this.array),
                        i = sn(i, this.array)),
                        this.array[e + 0] = ir(t),
                        this.array[e + 1] = ir(n),
                        this.array[e + 2] = ir(i),
                        this
                    }
                    setXYZW(e, t, n, i, s) {
                        return e *= this.itemSize,
                        this.normalized && (t = sn(t, this.array),
                        n = sn(n, this.array),
                        i = sn(i, this.array),
                        s = sn(s, this.array)),
                        this.array[e + 0] = ir(t),
                        this.array[e + 1] = ir(n),
                        this.array[e + 2] = ir(i),
                        this.array[e + 3] = ir(s),
                        this
                    }
                }
                  , At = class extends wn {
                    constructor(e, t, n) {
                        super(new Float32Array(e), t, n)
                    }
                }
                ;
                let CB = 0;
                const so = new Xt
                  , YA = new jn
                  , xp = new Q
                  , Rr = new aa
                  , iv = new aa
                  , Ns = new Q;
                var an = class bO extends Er {
                    constructor() {
                        super(),
                        this.isBufferGeometry = !0,
                        Object.defineProperty(this, "id", {
                            value: CB++
                        }),
                        this.uuid = wr(),
                        this.name = "",
                        this.type = "BufferGeometry",
                        this.index = null,
                        this.indirect = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.morphTargetsRelative = !1,
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        },
                        this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(t) {
                        return Array.isArray(t) ? this.index = new (KE(t) ? qA : XA)(t,1) : this.index = t,
                        this
                    }
                    setIndirect(t) {
                        return this.indirect = t,
                        this
                    }
                    getIndirect() {
                        return this.indirect
                    }
                    getAttribute(t) {
                        return this.attributes[t]
                    }
                    setAttribute(t, n) {
                        return this.attributes[t] = n,
                        this
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t],
                        this
                    }
                    hasAttribute(t) {
                        return this.attributes[t] !== void 0
                    }
                    addGroup(t, n, i=0) {
                        this.groups.push({
                            start: t,
                            count: n,
                            materialIndex: i
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(t, n) {
                        this.drawRange.start = t,
                        this.drawRange.count = n
                    }
                    applyMatrix4(t) {
                        const n = this.attributes.position;
                        n !== void 0 && (n.applyMatrix4(t),
                        n.needsUpdate = !0);
                        const i = this.attributes.normal;
                        if (i !== void 0) {
                            const r = new rn().getNormalMatrix(t);
                            i.applyNormalMatrix(r),
                            i.needsUpdate = !0
                        }
                        const s = this.attributes.tangent;
                        return s !== void 0 && (s.transformDirection(t),
                        s.needsUpdate = !0),
                        this.boundingBox !== null && this.computeBoundingBox(),
                        this.boundingSphere !== null && this.computeBoundingSphere(),
                        this
                    }
                    applyQuaternion(t) {
                        return so.makeRotationFromQuaternion(t),
                        this.applyMatrix4(so),
                        this
                    }
                    rotateX(t) {
                        return so.makeRotationX(t),
                        this.applyMatrix4(so),
                        this
                    }
                    rotateY(t) {
                        return so.makeRotationY(t),
                        this.applyMatrix4(so),
                        this
                    }
                    rotateZ(t) {
                        return so.makeRotationZ(t),
                        this.applyMatrix4(so),
                        this
                    }
                    translate(t, n, i) {
                        return so.makeTranslation(t, n, i),
                        this.applyMatrix4(so),
                        this
                    }
                    scale(t, n, i) {
                        return so.makeScale(t, n, i),
                        this.applyMatrix4(so),
                        this
                    }
                    lookAt(t) {
                        return YA.lookAt(t),
                        YA.updateMatrix(),
                        this.applyMatrix4(YA.matrix),
                        this
                    }
                    center() {
                        return this.computeBoundingBox(),
                        this.boundingBox.getCenter(xp).negate(),
                        this.translate(xp.x, xp.y, xp.z),
                        this
                    }
                    setFromPoints(t) {
                        const n = this.getAttribute("position");
                        if (n === void 0) {
                            const i = [];
                            for (let s = 0, r = t.length; s < r; s++) {
                                const l = t[s];
                                i.push(l.x, l.y, l.z || 0)
                            }
                            this.setAttribute("position", new At(i,3))
                        } else {
                            const i = Math.min(t.length, n.count);
                            for (let s = 0; s < i; s++) {
                                const r = t[s];
                                n.setXYZ(s, r.x, r.y, r.z || 0)
                            }
                            t.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                            n.needsUpdate = !0
                        }
                        return this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new aa);
                        const t = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) {
                            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                            this.boundingBox.set(new Q(-1 / 0,-1 / 0,-1 / 0), new Q(1 / 0,1 / 0,1 / 0));
                            return
                        }
                        if (t !== void 0) {
                            if (this.boundingBox.setFromBufferAttribute(t),
                            n)
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const r = n[i];
                                    Rr.setFromBufferAttribute(r),
                                    this.morphTargetsRelative ? (Ns.addVectors(this.boundingBox.min, Rr.min),
                                    this.boundingBox.expandByPoint(Ns),
                                    Ns.addVectors(this.boundingBox.max, Rr.max),
                                    this.boundingBox.expandByPoint(Ns)) : (this.boundingBox.expandByPoint(Rr.min),
                                    this.boundingBox.expandByPoint(Rr.max))
                                }
                        } else
                            this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new qs);
                        const t = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) {
                            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                            this.boundingSphere.set(new Q, 1 / 0);
                            return
                        }
                        if (t) {
                            const i = this.boundingSphere.center;
                            if (Rr.setFromBufferAttribute(t),
                            n)
                                for (let r = 0, l = n.length; r < l; r++) {
                                    const h = n[r];
                                    iv.setFromBufferAttribute(h),
                                    this.morphTargetsRelative ? (Ns.addVectors(Rr.min, iv.min),
                                    Rr.expandByPoint(Ns),
                                    Ns.addVectors(Rr.max, iv.max),
                                    Rr.expandByPoint(Ns)) : (Rr.expandByPoint(iv.min),
                                    Rr.expandByPoint(iv.max))
                                }
                            Rr.getCenter(i);
                            let s = 0;
                            for (let r = 0, l = t.count; r < l; r++)
                                Ns.fromBufferAttribute(t, r),
                                s = Math.max(s, i.distanceToSquared(Ns));
                            if (n)
                                for (let r = 0, l = n.length; r < l; r++) {
                                    const h = n[r]
                                      , d = this.morphTargetsRelative;
                                    for (let p = 0, m = h.count; p < m; p++)
                                        Ns.fromBufferAttribute(h, p),
                                        d && (xp.fromBufferAttribute(t, p),
                                        Ns.add(xp)),
                                        s = Math.max(s, i.distanceToSquared(Ns))
                                }
                            this.boundingSphere.radius = Math.sqrt(s),
                            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const t = this.index
                          , n = this.attributes;
                        if (t === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
                            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            return
                        }
                        const i = n.position
                          , s = n.normal
                          , r = n.uv;
                        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new wn(new Float32Array(4 * i.count),4));
                        const l = this.getAttribute("tangent")
                          , h = []
                          , d = [];
                        for (let F = 0; F < i.count; F++)
                            h[F] = new Q,
                            d[F] = new Q;
                        const p = new Q
                          , m = new Q
                          , v = new Q
                          , _ = new ye
                          , x = new ye
                          , b = new ye
                          , E = new Q
                          , T = new Q;
                        function M(F, P, L) {
                            p.fromBufferAttribute(i, F),
                            m.fromBufferAttribute(i, P),
                            v.fromBufferAttribute(i, L),
                            _.fromBufferAttribute(r, F),
                            x.fromBufferAttribute(r, P),
                            b.fromBufferAttribute(r, L),
                            m.sub(p),
                            v.sub(p),
                            x.sub(_),
                            b.sub(_);
                            const H = 1 / (x.x * b.y - b.x * x.y);
                            isFinite(H) && (E.copy(m).multiplyScalar(b.y).addScaledVector(v, -x.y).multiplyScalar(H),
                            T.copy(v).multiplyScalar(x.x).addScaledVector(m, -b.x).multiplyScalar(H),
                            h[F].add(E),
                            h[P].add(E),
                            h[L].add(E),
                            d[F].add(T),
                            d[P].add(T),
                            d[L].add(T))
                        }
                        let D = this.groups;
                        D.length === 0 && (D = [{
                            start: 0,
                            count: t.count
                        }]);
                        for (let F = 0, P = D.length; F < P; ++F) {
                            const L = D[F]
                              , H = L.start
                              , Z = L.count;
                            for (let K = H, te = H + Z; K < te; K += 3)
                                M(t.getX(K + 0), t.getX(K + 1), t.getX(K + 2))
                        }
                        const R = new Q
                          , O = new Q
                          , U = new Q
                          , B = new Q;
                        function I(F) {
                            U.fromBufferAttribute(s, F),
                            B.copy(U);
                            const P = h[F];
                            R.copy(P),
                            R.sub(U.multiplyScalar(U.dot(P))).normalize(),
                            O.crossVectors(B, P);
                            const L = O.dot(d[F]) < 0 ? -1 : 1;
                            l.setXYZW(F, R.x, R.y, R.z, L)
                        }
                        for (let F = 0, P = D.length; F < P; ++F) {
                            const L = D[F]
                              , H = L.start
                              , Z = L.count;
                            for (let K = H, te = H + Z; K < te; K += 3)
                                I(t.getX(K + 0)),
                                I(t.getX(K + 1)),
                                I(t.getX(K + 2))
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index
                          , n = this.getAttribute("position");
                        if (n !== void 0) {
                            let i = this.getAttribute("normal");
                            if (i === void 0)
                                i = new wn(new Float32Array(n.count * 3),3),
                                this.setAttribute("normal", i);
                            else
                                for (let _ = 0, x = i.count; _ < x; _++)
                                    i.setXYZ(_, 0, 0, 0);
                            const s = new Q
                              , r = new Q
                              , l = new Q
                              , h = new Q
                              , d = new Q
                              , p = new Q
                              , m = new Q
                              , v = new Q;
                            if (t)
                                for (let _ = 0, x = t.count; _ < x; _ += 3) {
                                    const b = t.getX(_ + 0)
                                      , E = t.getX(_ + 1)
                                      , T = t.getX(_ + 2);
                                    s.fromBufferAttribute(n, b),
                                    r.fromBufferAttribute(n, E),
                                    l.fromBufferAttribute(n, T),
                                    m.subVectors(l, r),
                                    v.subVectors(s, r),
                                    m.cross(v),
                                    h.fromBufferAttribute(i, b),
                                    d.fromBufferAttribute(i, E),
                                    p.fromBufferAttribute(i, T),
                                    h.add(m),
                                    d.add(m),
                                    p.add(m),
                                    i.setXYZ(b, h.x, h.y, h.z),
                                    i.setXYZ(E, d.x, d.y, d.z),
                                    i.setXYZ(T, p.x, p.y, p.z)
                                }
                            else
                                for (let _ = 0, x = n.count; _ < x; _ += 3)
                                    s.fromBufferAttribute(n, _ + 0),
                                    r.fromBufferAttribute(n, _ + 1),
                                    l.fromBufferAttribute(n, _ + 2),
                                    m.subVectors(l, r),
                                    v.subVectors(s, r),
                                    m.cross(v),
                                    i.setXYZ(_ + 0, m.x, m.y, m.z),
                                    i.setXYZ(_ + 1, m.x, m.y, m.z),
                                    i.setXYZ(_ + 2, m.x, m.y, m.z);
                            this.normalizeNormals(),
                            i.needsUpdate = !0
                        }
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let n = 0, i = t.count; n < i; n++)
                            Ns.fromBufferAttribute(t, n),
                            Ns.normalize(),
                            t.setXYZ(n, Ns.x, Ns.y, Ns.z)
                    }
                    toNonIndexed() {
                        function t(h, d) {
                            const p = h.array
                              , m = h.itemSize
                              , v = h.normalized
                              , _ = new p.constructor(d.length * m);
                            let x = 0
                              , b = 0;
                            for (let E = 0, T = d.length; E < T; E++) {
                                h.isInterleavedBufferAttribute ? x = d[E] * h.data.stride + h.offset : x = d[E] * m;
                                for (let M = 0; M < m; M++)
                                    _[b++] = p[x++]
                            }
                            return new wn(_,m,v)
                        }
                        if (this.index === null)
                            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                            this;
                        const n = new bO
                          , i = this.index.array
                          , s = this.attributes;
                        for (const h in s) {
                            const d = s[h]
                              , p = t(d, i);
                            n.setAttribute(h, p)
                        }
                        const r = this.morphAttributes;
                        for (const h in r) {
                            const d = []
                              , p = r[h];
                            for (let m = 0, v = p.length; m < v; m++) {
                                const _ = p[m]
                                  , x = t(_, i);
                                d.push(x)
                            }
                            n.morphAttributes[h] = d
                        }
                        n.morphTargetsRelative = this.morphTargetsRelative;
                        const l = this.groups;
                        for (let h = 0, d = l.length; h < d; h++) {
                            const p = l[h];
                            n.addGroup(p.start, p.count, p.materialIndex)
                        }
                        return n
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid,
                        t.type = this.type,
                        this.name !== "" && (t.name = this.name),
                        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                        this.parameters !== void 0) {
                            const d = this.parameters;
                            for (const p in d)
                                d[p] !== void 0 && (t[p] = d[p]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        const n = this.index;
                        n !== null && (t.data.index = {
                            type: n.array.constructor.name,
                            array: Array.prototype.slice.call(n.array)
                        });
                        const i = this.attributes;
                        for (const d in i) {
                            const p = i[d];
                            t.data.attributes[d] = p.toJSON(t.data)
                        }
                        const s = {};
                        let r = !1;
                        for (const d in this.morphAttributes) {
                            const p = this.morphAttributes[d]
                              , m = [];
                            for (let v = 0, _ = p.length; v < _; v++) {
                                const x = p[v];
                                m.push(x.toJSON(t.data))
                            }
                            m.length > 0 && (s[d] = m,
                            r = !0)
                        }
                        r && (t.data.morphAttributes = s,
                        t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const l = this.groups;
                        l.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(l)));
                        const h = this.boundingSphere;
                        return h !== null && (t.data.boundingSphere = h.toJSON()),
                        t
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        this.index = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        const n = {};
                        this.name = t.name;
                        const i = t.index;
                        i !== null && this.setIndex(i.clone());
                        const s = t.attributes;
                        for (const p in s) {
                            const m = s[p];
                            this.setAttribute(p, m.clone(n))
                        }
                        const r = t.morphAttributes;
                        for (const p in r) {
                            const m = []
                              , v = r[p];
                            for (let _ = 0, x = v.length; _ < x; _++)
                                m.push(v[_].clone(n));
                            this.morphAttributes[p] = m
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const l = t.groups;
                        for (let p = 0, m = l.length; p < m; p++) {
                            const v = l[p];
                            this.addGroup(v.start, v.count, v.materialIndex)
                        }
                        const h = t.boundingBox;
                        h !== null && (this.boundingBox = h.clone());
                        const d = t.boundingSphere;
                        return d !== null && (this.boundingSphere = d.clone()),
                        this.drawRange.start = t.drawRange.start,
                        this.drawRange.count = t.drawRange.count,
                        this.userData = t.userData,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                ;
                const fw = new Xt
                  , ff = new hf
                  , D_ = new qs
                  , dw = new Q
                  , O_ = new Q
                  , N_ = new Q
                  , U_ = new Q
                  , WA = new Q
                  , B_ = new Q
                  , pw = new Q
                  , P_ = new Q;
                var Fi = class extends jn {
                    constructor(e=new an, t=new Gu) {
                        super(),
                        this.isMesh = !0,
                        this.type = "Mesh",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.count = 1,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const r = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[r] = i
                                }
                            }
                        }
                    }
                    getVertexPosition(e, t) {
                        const n = this.geometry
                          , i = n.attributes.position
                          , s = n.morphAttributes.position
                          , r = n.morphTargetsRelative;
                        t.fromBufferAttribute(i, e);
                        const l = this.morphTargetInfluences;
                        if (s && l) {
                            B_.set(0, 0, 0);
                            for (let h = 0, d = s.length; h < d; h++) {
                                const p = l[h]
                                  , m = s[h];
                                p !== 0 && (WA.fromBufferAttribute(m, e),
                                r ? B_.addScaledVector(WA, p) : B_.addScaledVector(WA.sub(t), p))
                            }
                            t.add(B_)
                        }
                        return t
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , i = this.material
                          , s = this.matrixWorld;
                        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
                        D_.copy(n.boundingSphere),
                        D_.applyMatrix4(s),
                        ff.copy(e.ray).recast(e.near),
                        !(D_.containsPoint(ff.origin) === !1 && (ff.intersectSphere(D_, dw) === null || ff.origin.distanceToSquared(dw) > (e.far - e.near) ** 2)) && (fw.copy(s).invert(),
                        ff.copy(e.ray).applyMatrix4(fw),
                        !(n.boundingBox !== null && ff.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, ff)))
                    }
                    _computeIntersections(e, t, n) {
                        let i;
                        const s = this.geometry
                          , r = this.material
                          , l = s.index
                          , h = s.attributes.position
                          , d = s.attributes.uv
                          , p = s.attributes.uv1
                          , m = s.attributes.normal
                          , v = s.groups
                          , _ = s.drawRange;
                        if (l !== null)
                            if (Array.isArray(r))
                                for (let x = 0, b = v.length; x < b; x++) {
                                    const E = v[x]
                                      , T = r[E.materialIndex]
                                      , M = Math.max(E.start, _.start)
                                      , D = Math.min(l.count, Math.min(E.start + E.count, _.start + _.count));
                                    for (let R = M, O = D; R < O; R += 3) {
                                        const U = l.getX(R)
                                          , B = l.getX(R + 1)
                                          , I = l.getX(R + 2);
                                        i = I_(this, T, e, n, d, p, m, U, B, I),
                                        i && (i.faceIndex = Math.floor(R / 3),
                                        i.face.materialIndex = E.materialIndex,
                                        t.push(i))
                                    }
                                }
                            else {
                                const x = Math.max(0, _.start)
                                  , b = Math.min(l.count, _.start + _.count);
                                for (let E = x, T = b; E < T; E += 3) {
                                    const M = l.getX(E)
                                      , D = l.getX(E + 1)
                                      , R = l.getX(E + 2);
                                    i = I_(this, r, e, n, d, p, m, M, D, R),
                                    i && (i.faceIndex = Math.floor(E / 3),
                                    t.push(i))
                                }
                            }
                        else if (h !== void 0)
                            if (Array.isArray(r))
                                for (let x = 0, b = v.length; x < b; x++) {
                                    const E = v[x]
                                      , T = r[E.materialIndex]
                                      , M = Math.max(E.start, _.start)
                                      , D = Math.min(h.count, Math.min(E.start + E.count, _.start + _.count));
                                    for (let R = M, O = D; R < O; R += 3) {
                                        const U = R
                                          , B = R + 1
                                          , I = R + 2;
                                        i = I_(this, T, e, n, d, p, m, U, B, I),
                                        i && (i.faceIndex = Math.floor(R / 3),
                                        i.face.materialIndex = E.materialIndex,
                                        t.push(i))
                                    }
                                }
                            else {
                                const x = Math.max(0, _.start)
                                  , b = Math.min(h.count, _.start + _.count);
                                for (let E = x, T = b; E < T; E += 3) {
                                    const M = E
                                      , D = E + 1
                                      , R = E + 2;
                                    i = I_(this, r, e, n, d, p, m, M, D, R),
                                    i && (i.faceIndex = Math.floor(E / 3),
                                    t.push(i))
                                }
                            }
                    }
                }
                ;
                function RB(e, t, n, i, s, r, l, h) {
                    let d;
                    if (t.side === ys ? d = i.intersectTriangle(l, r, s, !0, h) : d = i.intersectTriangle(s, r, l, t.side === Bl, h),
                    d === null)
                        return null;
                    P_.copy(h),
                    P_.applyMatrix4(e.matrixWorld);
                    const p = n.ray.origin.distanceTo(P_);
                    return p < n.near || p > n.far ? null : {
                        distance: p,
                        point: P_.clone(),
                        object: e
                    }
                }
                function I_(e, t, n, i, s, r, l, h, d, p) {
                    e.getVertexPosition(h, O_),
                    e.getVertexPosition(d, N_),
                    e.getVertexPosition(p, U_);
                    const m = RB(e, t, n, i, O_, N_, U_, pw);
                    if (m) {
                        const v = new Q;
                        Hu.getBarycoord(pw, O_, N_, U_, v),
                        s && (m.uv = Hu.getInterpolatedAttribute(s, h, d, p, v, new ye)),
                        r && (m.uv1 = Hu.getInterpolatedAttribute(r, h, d, p, v, new ye)),
                        l && (m.normal = Hu.getInterpolatedAttribute(l, h, d, p, v, new Q),
                        m.normal.dot(i.direction) > 0 && m.normal.multiplyScalar(-1));
                        const _ = {
                            a: h,
                            b: d,
                            c: p,
                            normal: new Q,
                            materialIndex: 0
                        };
                        Hu.getNormal(O_, N_, U_, _.normal),
                        m.face = _,
                        m.barycoord = v
                    }
                    return m
                }
                var sv = class EO extends an {
                    constructor(t=1, n=1, i=1, s=1, r=1, l=1) {
                        super(),
                        this.type = "BoxGeometry",
                        this.parameters = {
                            width: t,
                            height: n,
                            depth: i,
                            widthSegments: s,
                            heightSegments: r,
                            depthSegments: l
                        };
                        const h = this;
                        s = Math.floor(s),
                        r = Math.floor(r),
                        l = Math.floor(l);
                        const d = []
                          , p = []
                          , m = []
                          , v = [];
                        let _ = 0
                          , x = 0;
                        b("z", "y", "x", -1, -1, i, n, t, l, r, 0),
                        b("z", "y", "x", 1, -1, i, n, -t, l, r, 1),
                        b("x", "z", "y", 1, 1, t, i, n, s, l, 2),
                        b("x", "z", "y", 1, -1, t, i, -n, s, l, 3),
                        b("x", "y", "z", 1, -1, t, n, i, s, r, 4),
                        b("x", "y", "z", -1, -1, t, n, -i, s, r, 5),
                        this.setIndex(d),
                        this.setAttribute("position", new At(p,3)),
                        this.setAttribute("normal", new At(m,3)),
                        this.setAttribute("uv", new At(v,2));
                        function b(E, T, M, D, R, O, U, B, I, F, P) {
                            const L = O / I
                              , H = U / F
                              , Z = O / 2
                              , K = U / 2
                              , te = B / 2
                              , ce = I + 1
                              , G = F + 1;
                            let V = 0
                              , q = 0;
                            const ee = new Q;
                            for (let se = 0; se < G; se++) {
                                const X = se * H - K;
                                for (let J = 0; J < ce; J++)
                                    ee[E] = (J * L - Z) * D,
                                    ee[T] = X * R,
                                    ee[M] = te,
                                    p.push(ee.x, ee.y, ee.z),
                                    ee[E] = 0,
                                    ee[T] = 0,
                                    ee[M] = B > 0 ? 1 : -1,
                                    m.push(ee.x, ee.y, ee.z),
                                    v.push(J / I),
                                    v.push(1 - se / F),
                                    V += 1
                            }
                            for (let se = 0; se < F; se++)
                                for (let X = 0; X < I; X++) {
                                    const J = _ + X + ce * se
                                      , ze = _ + X + ce * (se + 1)
                                      , xe = _ + (X + 1) + ce * (se + 1)
                                      , le = _ + (X + 1) + ce * se;
                                    d.push(J, ze, le),
                                    d.push(ze, xe, le),
                                    q += 6
                                }
                            h.addGroup(x, q, P),
                            x += q,
                            _ += V
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new EO(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
                    }
                }
                ;
                function Sp(e) {
                    const t = {};
                    for (const n in e) {
                        t[n] = {};
                        for (const i in e[n]) {
                            const s = e[n][i];
                            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                            t[n][i] = null) : t[n][i] = s.clone() : Array.isArray(s) ? t[n][i] = s.slice() : t[n][i] = s
                        }
                    }
                    return t
                }
                function Ba(e) {
                    const t = {};
                    for (let n = 0; n < e.length; n++) {
                        const i = Sp(e[n]);
                        for (const s in i)
                            t[s] = i[s]
                    }
                    return t
                }
                function DB(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }
                function mw(e) {
                    const t = e.getRenderTarget();
                    return t === null ? e.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : An.workingColorSpace
                }
                const gw = {
                    clone: Sp,
                    merge: Ba
                };
                var OB = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
                  , NB = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
                  , Fn = class extends Os {
                    constructor(e) {
                        super(),
                        this.isShaderMaterial = !0,
                        this.type = "ShaderMaterial",
                        this.defines = {},
                        this.uniforms = {},
                        this.uniformsGroups = [],
                        this.vertexShader = OB,
                        this.fragmentShader = NB,
                        this.linewidth = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.fog = !1,
                        this.lights = !1,
                        this.clipping = !1,
                        this.forceSinglePass = !0,
                        this.extensions = {
                            clipCullDistance: !1,
                            multiDraw: !1
                        },
                        this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv1: [0, 0]
                        },
                        this.index0AttributeName = void 0,
                        this.uniformsNeedUpdate = !1,
                        this.glslVersion = null,
                        e !== void 0 && this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.fragmentShader = e.fragmentShader,
                        this.vertexShader = e.vertexShader,
                        this.uniforms = Sp(e.uniforms),
                        this.uniformsGroups = DB(e.uniformsGroups),
                        this.defines = Object.assign({}, e.defines),
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.fog = e.fog,
                        this.lights = e.lights,
                        this.clipping = e.clipping,
                        this.extensions = Object.assign({}, e.extensions),
                        this.glslVersion = e.glslVersion,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        t.glslVersion = this.glslVersion,
                        t.uniforms = {};
                        for (const i in this.uniforms) {
                            const s = this.uniforms[i].value;
                            s && s.isTexture ? t.uniforms[i] = {
                                type: "t",
                                value: s.toJSON(e).uuid
                            } : s && s.isColor ? t.uniforms[i] = {
                                type: "c",
                                value: s.getHex()
                            } : s && s.isVector2 ? t.uniforms[i] = {
                                type: "v2",
                                value: s.toArray()
                            } : s && s.isVector3 ? t.uniforms[i] = {
                                type: "v3",
                                value: s.toArray()
                            } : s && s.isVector4 ? t.uniforms[i] = {
                                type: "v4",
                                value: s.toArray()
                            } : s && s.isMatrix3 ? t.uniforms[i] = {
                                type: "m3",
                                value: s.toArray()
                            } : s && s.isMatrix4 ? t.uniforms[i] = {
                                type: "m4",
                                value: s.toArray()
                            } : t.uniforms[i] = {
                                value: s
                            }
                        }
                        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                        t.vertexShader = this.vertexShader,
                        t.fragmentShader = this.fragmentShader,
                        t.lights = this.lights,
                        t.clipping = this.clipping;
                        const n = {};
                        for (const i in this.extensions)
                            this.extensions[i] === !0 && (n[i] = !0);
                        return Object.keys(n).length > 0 && (t.extensions = n),
                        t
                    }
                }
                  , av = class extends jn {
                    constructor() {
                        super(),
                        this.isCamera = !0,
                        this.type = "Camera",
                        this.matrixWorldInverse = new Xt,
                        this.projectionMatrix = new Xt,
                        this.projectionMatrixInverse = new Xt,
                        this.coordinateSystem = br,
                        this._reversedDepth = !1
                    }
                    get reversedDepth() {
                        return this._reversedDepth
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.matrixWorldInverse.copy(e.matrixWorldInverse),
                        this.projectionMatrix.copy(e.projectionMatrix),
                        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                        this.coordinateSystem = e.coordinateSystem,
                        this
                    }
                    getWorldDirection(e) {
                        return super.getWorldDirection(e).negate()
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(e, t) {
                        super.updateWorldMatrix(e, t),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const ku = new Q
                  , vw = new ye
                  , yw = new ye;
                var hi = class extends av {
                    constructor(e=50, t=1, n=.1, i=2e3) {
                        super(),
                        this.isPerspectiveCamera = !0,
                        this.type = "PerspectiveCamera",
                        this.fov = e,
                        this.zoom = 1,
                        this.near = n,
                        this.far = i,
                        this.focus = 10,
                        this.aspect = t,
                        this.view = null,
                        this.filmGauge = 35,
                        this.filmOffset = 0,
                        this.updateProjectionMatrix()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.fov = e.fov,
                        this.zoom = e.zoom,
                        this.near = e.near,
                        this.far = e.far,
                        this.focus = e.focus,
                        this.aspect = e.aspect,
                        this.view = e.view === null ? null : Object.assign({}, e.view),
                        this.filmGauge = e.filmGauge,
                        this.filmOffset = e.filmOffset,
                        this
                    }
                    setFocalLength(e) {
                        const t = .5 * this.getFilmHeight() / e;
                        this.fov = op * 2 * Math.atan(t),
                        this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const e = Math.tan(lf * .5 * this.fov);
                        return .5 * this.getFilmHeight() / e
                    }
                    getEffectiveFOV() {
                        return op * 2 * Math.atan(Math.tan(lf * .5 * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    getViewBounds(e, t, n) {
                        ku.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                        t.set(ku.x, ku.y).multiplyScalar(-e / ku.z),
                        ku.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                        n.set(ku.x, ku.y).multiplyScalar(-e / ku.z)
                    }
                    getViewSize(e, t) {
                        return this.getViewBounds(e, vw, yw),
                        t.subVectors(yw, vw)
                    }
                    setViewOffset(e, t, n, i, s, r) {
                        this.aspect = e / t,
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = s,
                        this.view.height = r,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const e = this.near;
                        let t = e * Math.tan(lf * .5 * this.fov) / this.zoom
                          , n = 2 * t
                          , i = this.aspect * n
                          , s = -.5 * i;
                        const r = this.view;
                        if (this.view !== null && this.view.enabled) {
                            const h = r.fullWidth
                              , d = r.fullHeight;
                            s += r.offsetX * i / h,
                            t -= r.offsetY * n / d,
                            i *= r.width / h,
                            n *= r.height / d
                        }
                        const l = this.filmOffset;
                        l !== 0 && (s += e * l / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.fov = this.fov,
                        t.object.zoom = this.zoom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        t.object.focus = this.focus,
                        t.object.aspect = this.aspect,
                        this.view !== null && (t.object.view = Object.assign({}, this.view)),
                        t.object.filmGauge = this.filmGauge,
                        t.object.filmOffset = this.filmOffset,
                        t
                    }
                }
                ;
                const Ap = -90
                  , Tp = 1;
                var _w = class extends jn {
                    constructor(e, t, n) {
                        super(),
                        this.type = "CubeCamera",
                        this.renderTarget = n,
                        this.coordinateSystem = null,
                        this.activeMipmapLevel = 0;
                        const i = new hi(Ap,Tp,e,t);
                        i.layers = this.layers,
                        this.add(i);
                        const s = new hi(Ap,Tp,e,t);
                        s.layers = this.layers,
                        this.add(s);
                        const r = new hi(Ap,Tp,e,t);
                        r.layers = this.layers,
                        this.add(r);
                        const l = new hi(Ap,Tp,e,t);
                        l.layers = this.layers,
                        this.add(l);
                        const h = new hi(Ap,Tp,e,t);
                        h.layers = this.layers,
                        this.add(h);
                        const d = new hi(Ap,Tp,e,t);
                        d.layers = this.layers,
                        this.add(d)
                    }
                    updateCoordinateSystem() {
                        const e = this.coordinateSystem
                          , t = this.children.concat()
                          , [n,i,s,r,l,h] = t;
                        for (const d of t)
                            this.remove(d);
                        if (e === br)
                            n.up.set(0, 1, 0),
                            n.lookAt(1, 0, 0),
                            i.up.set(0, 1, 0),
                            i.lookAt(-1, 0, 0),
                            s.up.set(0, 0, -1),
                            s.lookAt(0, 1, 0),
                            r.up.set(0, 0, 1),
                            r.lookAt(0, -1, 0),
                            l.up.set(0, 1, 0),
                            l.lookAt(0, 0, 1),
                            h.up.set(0, 1, 0),
                            h.lookAt(0, 0, -1);
                        else if (e === rp)
                            n.up.set(0, -1, 0),
                            n.lookAt(-1, 0, 0),
                            i.up.set(0, -1, 0),
                            i.lookAt(1, 0, 0),
                            s.up.set(0, 0, 1),
                            s.lookAt(0, 1, 0),
                            r.up.set(0, 0, -1),
                            r.lookAt(0, -1, 0),
                            l.up.set(0, -1, 0),
                            l.lookAt(0, 0, 1),
                            h.up.set(0, -1, 0),
                            h.lookAt(0, 0, -1);
                        else
                            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                        for (const d of t)
                            this.add(d),
                            d.updateMatrixWorld()
                    }
                    update(e, t) {
                        this.parent === null && this.updateMatrixWorld();
                        const {renderTarget: n, activeMipmapLevel: i} = this;
                        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                        this.updateCoordinateSystem());
                        const [s,r,l,h,d,p] = this.children
                          , m = e.getRenderTarget()
                          , v = e.getActiveCubeFace()
                          , _ = e.getActiveMipmapLevel()
                          , x = e.xr.enabled;
                        e.xr.enabled = !1;
                        const b = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1,
                        e.setRenderTarget(n, 0, i),
                        e.render(t, s),
                        e.setRenderTarget(n, 1, i),
                        e.render(t, r),
                        e.setRenderTarget(n, 2, i),
                        e.render(t, l),
                        e.setRenderTarget(n, 3, i),
                        e.render(t, h),
                        e.setRenderTarget(n, 4, i),
                        e.render(t, d),
                        n.texture.generateMipmaps = b,
                        e.setRenderTarget(n, 5, i),
                        e.render(t, p),
                        e.setRenderTarget(m, v, _),
                        e.xr.enabled = x,
                        n.texture.needsPMREMUpdate = !0
                    }
                }
                  , rv = class extends zi {
                    constructor(e=[], t=Sc, n, i, s, r, l, h, d, p) {
                        super(e, t, n, i, s, r, l, h, d, p),
                        this.isCubeTexture = !0,
                        this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(e) {
                        this.image = e
                    }
                }
                  , xw = class extends Un {
                    constructor(e=1, t={}) {
                        super(e, e, t),
                        this.isWebGLCubeRenderTarget = !0;
                        const n = {
                            width: e,
                            height: e,
                            depth: 1
                        };
                        this.texture = new rv([n, n, n, n, n, n]),
                        this._setTextureOptions(t),
                        this.texture.isRenderTargetTexture = !0
                    }
                    fromEquirectangularTexture(e, t) {
                        this.texture.type = t.type,
                        this.texture.colorSpace = t.colorSpace,
                        this.texture.generateMipmaps = t.generateMipmaps,
                        this.texture.minFilter = t.minFilter,
                        this.texture.magFilter = t.magFilter;
                        const n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        }
                          , i = new sv(5,5,5)
                          , s = new Fn({
                            name: "CubemapFromEquirect",
                            uniforms: Sp(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: ys,
                            blending: oi
                        });
                        s.uniforms.tEquirect.value = t;
                        const r = new Fi(i,s)
                          , l = t.minFilter;
                        return t.minFilter === Pl && (t.minFilter = mi),
                        new _w(1,10,this).update(e, r),
                        t.minFilter = l,
                        r.geometry.dispose(),
                        r.material.dispose(),
                        this
                    }
                    clear(e, t=!0, n=!0, i=!0) {
                        const s = e.getRenderTarget();
                        for (let r = 0; r < 6; r++)
                            e.setRenderTarget(this, r),
                            e.clear(t, n, i);
                        e.setRenderTarget(s)
                    }
                }
                  , Mp = class extends jn {
                    constructor() {
                        super(),
                        this.isGroup = !0,
                        this.type = "Group"
                    }
                }
                ;
                const UB = {
                    type: "move"
                };
                var L_ = class {
                    constructor() {
                        this._targetRay = null,
                        this._grip = null,
                        this._hand = null
                    }
                    getHandSpace() {
                        return this._hand === null && (this._hand = new Mp,
                        this._hand.matrixAutoUpdate = !1,
                        this._hand.visible = !1,
                        this._hand.joints = {},
                        this._hand.inputState = {
                            pinching: !1
                        }),
                        this._hand
                    }
                    getTargetRaySpace() {
                        return this._targetRay === null && (this._targetRay = new Mp,
                        this._targetRay.matrixAutoUpdate = !1,
                        this._targetRay.visible = !1,
                        this._targetRay.hasLinearVelocity = !1,
                        this._targetRay.linearVelocity = new Q,
                        this._targetRay.hasAngularVelocity = !1,
                        this._targetRay.angularVelocity = new Q),
                        this._targetRay
                    }
                    getGripSpace() {
                        return this._grip === null && (this._grip = new Mp,
                        this._grip.matrixAutoUpdate = !1,
                        this._grip.visible = !1,
                        this._grip.hasLinearVelocity = !1,
                        this._grip.linearVelocity = new Q,
                        this._grip.hasAngularVelocity = !1,
                        this._grip.angularVelocity = new Q),
                        this._grip
                    }
                    dispatchEvent(e) {
                        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
                        this._grip !== null && this._grip.dispatchEvent(e),
                        this._hand !== null && this._hand.dispatchEvent(e),
                        this
                    }
                    connect(e) {
                        if (e && e.hand) {
                            const t = this._hand;
                            if (t)
                                for (const n of e.hand.values())
                                    this._getHandJoint(t, n)
                        }
                        return this.dispatchEvent({
                            type: "connected",
                            data: e
                        }),
                        this
                    }
                    disconnect(e) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }),
                        this._targetRay !== null && (this._targetRay.visible = !1),
                        this._grip !== null && (this._grip.visible = !1),
                        this._hand !== null && (this._hand.visible = !1),
                        this
                    }
                    update(e, t, n) {
                        let i = null
                          , s = null
                          , r = null;
                        const l = this._targetRay
                          , h = this._grip
                          , d = this._hand;
                        if (e && t.session.visibilityState !== "visible-blurred") {
                            if (d && e.hand) {
                                r = !0;
                                for (const b of e.hand.values()) {
                                    const E = t.getJointPose(b, n)
                                      , T = this._getHandJoint(d, b);
                                    E !== null && (T.matrix.fromArray(E.transform.matrix),
                                    T.matrix.decompose(T.position, T.rotation, T.scale),
                                    T.matrixWorldNeedsUpdate = !0,
                                    T.jointRadius = E.radius),
                                    T.visible = E !== null
                                }
                                const p = d.joints["index-finger-tip"]
                                  , m = d.joints["thumb-tip"]
                                  , v = p.position.distanceTo(m.position)
                                  , _ = .02
                                  , x = .005;
                                d.inputState.pinching && v > _ + x ? (d.inputState.pinching = !1,
                                this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: e.handedness,
                                    target: this
                                })) : !d.inputState.pinching && v <= _ - x && (d.inputState.pinching = !0,
                                this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: e.handedness,
                                    target: this
                                }))
                            } else
                                h !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n),
                                s !== null && (h.matrix.fromArray(s.transform.matrix),
                                h.matrix.decompose(h.position, h.rotation, h.scale),
                                h.matrixWorldNeedsUpdate = !0,
                                s.linearVelocity ? (h.hasLinearVelocity = !0,
                                h.linearVelocity.copy(s.linearVelocity)) : h.hasLinearVelocity = !1,
                                s.angularVelocity ? (h.hasAngularVelocity = !0,
                                h.angularVelocity.copy(s.angularVelocity)) : h.hasAngularVelocity = !1));
                            l !== null && (i = t.getPose(e.targetRaySpace, n),
                            i === null && s !== null && (i = s),
                            i !== null && (l.matrix.fromArray(i.transform.matrix),
                            l.matrix.decompose(l.position, l.rotation, l.scale),
                            l.matrixWorldNeedsUpdate = !0,
                            i.linearVelocity ? (l.hasLinearVelocity = !0,
                            l.linearVelocity.copy(i.linearVelocity)) : l.hasLinearVelocity = !1,
                            i.angularVelocity ? (l.hasAngularVelocity = !0,
                            l.angularVelocity.copy(i.angularVelocity)) : l.hasAngularVelocity = !1,
                            this.dispatchEvent(UB)))
                        }
                        return l !== null && (l.visible = i !== null),
                        h !== null && (h.visible = s !== null),
                        d !== null && (d.visible = r !== null),
                        this
                    }
                    _getHandJoint(e, t) {
                        if (e.joints[t.jointName] === void 0) {
                            const n = new Mp;
                            n.matrixAutoUpdate = !1,
                            n.visible = !1,
                            e.joints[t.jointName] = n,
                            e.add(n)
                        }
                        return e.joints[t.jointName]
                    }
                }
                  , Sw = class wO {
                    constructor(t, n=25e-5) {
                        this.isFogExp2 = !0,
                        this.name = "",
                        this.color = new at(t),
                        this.density = n
                    }
                    clone() {
                        return new wO(this.color,this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            name: this.name,
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                  , Aw = class CO {
                    constructor(t, n=1, i=1e3) {
                        this.isFog = !0,
                        this.name = "",
                        this.color = new at(t),
                        this.near = n,
                        this.far = i
                    }
                    clone() {
                        return new CO(this.color,this.near,this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            name: this.name,
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                  , bp = class extends jn {
                    constructor() {
                        super(),
                        this.isScene = !0,
                        this.type = "Scene",
                        this.background = null,
                        this.environment = null,
                        this.fog = null,
                        this.backgroundBlurriness = 0,
                        this.backgroundIntensity = 1,
                        this.backgroundRotation = new io,
                        this.environmentIntensity = 1,
                        this.environmentRotation = new io,
                        this.overrideMaterial = null,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.background !== null && (this.background = e.background.clone()),
                        e.environment !== null && (this.environment = e.environment.clone()),
                        e.fog !== null && (this.fog = e.fog.clone()),
                        this.backgroundBlurriness = e.backgroundBlurriness,
                        this.backgroundIntensity = e.backgroundIntensity,
                        this.backgroundRotation.copy(e.backgroundRotation),
                        this.environmentIntensity = e.environmentIntensity,
                        this.environmentRotation.copy(e.environmentRotation),
                        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
                        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
                        t.object.backgroundRotation = this.backgroundRotation.toArray(),
                        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
                        t.object.environmentRotation = this.environmentRotation.toArray(),
                        t
                    }
                }
                  , z_ = class {
                    constructor(e, t) {
                        this.isInterleavedBuffer = !0,
                        this.array = e,
                        this.stride = t,
                        this.count = e !== void 0 ? e.length / t : 0,
                        this.usage = Qg,
                        this.updateRanges = [],
                        this.version = 0,
                        this.uuid = wr()
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    addUpdateRange(e, t) {
                        this.updateRanges.push({
                            start: e,
                            count: t
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(e) {
                        return this.array = new e.array.constructor(e.array),
                        this.count = e.count,
                        this.stride = e.stride,
                        this.usage = e.usage,
                        this
                    }
                    copyAt(e, t, n) {
                        e *= this.stride,
                        n *= t.stride;
                        for (let i = 0, s = this.stride; i < s; i++)
                            this.array[e + i] = t.array[n + i];
                        return this
                    }
                    set(e, t=0) {
                        return this.array.set(e, t),
                        this
                    }
                    clone(e) {
                        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = wr()),
                        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                          , n = new this.constructor(t,this.stride);
                        return n.setUsage(this.usage),
                        n
                    }
                    onUpload(e) {
                        return this.onUploadCallback = e,
                        this
                    }
                    toJSON(e) {
                        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = wr()),
                        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                ;
                const Pa = new Q;
                var ov = class RO {
                    constructor(t, n, i, s=!1) {
                        this.isInterleavedBufferAttribute = !0,
                        this.name = "",
                        this.data = t,
                        this.itemSize = n,
                        this.offset = i,
                        this.normalized = s
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(t) {
                        this.data.needsUpdate = t
                    }
                    applyMatrix4(t) {
                        for (let n = 0, i = this.data.count; n < i; n++)
                            Pa.fromBufferAttribute(this, n),
                            Pa.applyMatrix4(t),
                            this.setXYZ(n, Pa.x, Pa.y, Pa.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let n = 0, i = this.count; n < i; n++)
                            Pa.fromBufferAttribute(this, n),
                            Pa.applyNormalMatrix(t),
                            this.setXYZ(n, Pa.x, Pa.y, Pa.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let n = 0, i = this.count; n < i; n++)
                            Pa.fromBufferAttribute(this, n),
                            Pa.transformDirection(t),
                            this.setXYZ(n, Pa.x, Pa.y, Pa.z);
                        return this
                    }
                    getComponent(t, n) {
                        let i = this.array[t * this.data.stride + this.offset + n];
                        return this.normalized && (i = Ua(i, this.array)),
                        i
                    }
                    setComponent(t, n, i) {
                        return this.normalized && (i = sn(i, this.array)),
                        this.data.array[t * this.data.stride + this.offset + n] = i,
                        this
                    }
                    setX(t, n) {
                        return this.normalized && (n = sn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset] = n,
                        this
                    }
                    setY(t, n) {
                        return this.normalized && (n = sn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 1] = n,
                        this
                    }
                    setZ(t, n) {
                        return this.normalized && (n = sn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 2] = n,
                        this
                    }
                    setW(t, n) {
                        return this.normalized && (n = sn(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 3] = n,
                        this
                    }
                    getX(t) {
                        let n = this.data.array[t * this.data.stride + this.offset];
                        return this.normalized && (n = Ua(n, this.array)),
                        n
                    }
                    getY(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 1];
                        return this.normalized && (n = Ua(n, this.array)),
                        n
                    }
                    getZ(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 2];
                        return this.normalized && (n = Ua(n, this.array)),
                        n
                    }
                    getW(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 3];
                        return this.normalized && (n = Ua(n, this.array)),
                        n
                    }
                    setXY(t, n, i) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = sn(n, this.array),
                        i = sn(i, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = i,
                        this
                    }
                    setXYZ(t, n, i, s) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = sn(n, this.array),
                        i = sn(i, this.array),
                        s = sn(s, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = i,
                        this.data.array[t + 2] = s,
                        this
                    }
                    setXYZW(t, n, i, s, r) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = sn(n, this.array),
                        i = sn(i, this.array),
                        s = sn(s, this.array),
                        r = sn(r, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = i,
                        this.data.array[t + 2] = s,
                        this.data.array[t + 3] = r,
                        this
                    }
                    clone(t) {
                        if (t === void 0) {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let i = 0; i < this.count; i++) {
                                const s = i * this.data.stride + this.offset;
                                for (let r = 0; r < this.itemSize; r++)
                                    n.push(this.data.array[s + r])
                            }
                            return new wn(new this.array.constructor(n),this.itemSize,this.normalized)
                        } else
                            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
                            t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                            new RO(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                    }
                    toJSON(t) {
                        if (t === void 0) {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let i = 0; i < this.count; i++) {
                                const s = i * this.data.stride + this.offset;
                                for (let r = 0; r < this.itemSize; r++)
                                    n.push(this.data.array[s + r])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: n,
                                normalized: this.normalized
                            }
                        } else
                            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
                            t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                            {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                    }
                }
                  , jA = class extends Os {
                    constructor(e) {
                        super(),
                        this.isSpriteMaterial = !0,
                        this.type = "SpriteMaterial",
                        this.color = new at(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.rotation = 0,
                        this.sizeAttenuation = !0,
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.rotation = e.rotation,
                        this.sizeAttenuation = e.sizeAttenuation,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                let Ep;
                const lv = new Q
                  , wp = new Q
                  , Cp = new Q
                  , Rp = new ye
                  , cv = new ye
                  , Tw = new Xt
                  , F_ = new Q
                  , uv = new Q
                  , H_ = new Q
                  , Mw = new ye
                  , QA = new ye
                  , bw = new ye;
                var Ew = class extends jn {
                    constructor(e=new jA) {
                        if (super(),
                        this.isSprite = !0,
                        this.type = "Sprite",
                        Ep === void 0) {
                            Ep = new an;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                              , n = new z_(t,5);
                            Ep.setIndex([0, 1, 2, 0, 2, 3]),
                            Ep.setAttribute("position", new ov(n,3,0,!1)),
                            Ep.setAttribute("uv", new ov(n,2,3,!1))
                        }
                        this.geometry = Ep,
                        this.material = e,
                        this.center = new ye(.5,.5),
                        this.count = 1
                    }
                    raycast(e, t) {
                        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                        wp.setFromMatrixScale(this.matrixWorld),
                        Tw.copy(e.camera.matrixWorld),
                        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                        Cp.setFromMatrixPosition(this.modelViewMatrix),
                        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && wp.multiplyScalar(-Cp.z);
                        const n = this.material.rotation;
                        let i, s;
                        n !== 0 && (s = Math.cos(n),
                        i = Math.sin(n));
                        const r = this.center;
                        V_(F_.set(-.5, -.5, 0), Cp, r, wp, i, s),
                        V_(uv.set(.5, -.5, 0), Cp, r, wp, i, s),
                        V_(H_.set(.5, .5, 0), Cp, r, wp, i, s),
                        Mw.set(0, 0),
                        QA.set(1, 0),
                        bw.set(1, 1);
                        let l = e.ray.intersectTriangle(F_, uv, H_, !1, lv);
                        if (l === null && (V_(uv.set(-.5, .5, 0), Cp, r, wp, i, s),
                        QA.set(0, 1),
                        l = e.ray.intersectTriangle(F_, H_, uv, !1, lv),
                        l === null))
                            return;
                        const h = e.ray.origin.distanceTo(lv);
                        h < e.near || h > e.far || t.push({
                            distance: h,
                            point: lv.clone(),
                            uv: Hu.getInterpolation(lv, F_, uv, H_, Mw, QA, bw, new ye),
                            face: null,
                            object: this
                        })
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.center !== void 0 && this.center.copy(e.center),
                        this.material = e.material,
                        this
                    }
                }
                ;
                function V_(e, t, n, i, s, r) {
                    Rp.subVectors(e, n).addScalar(.5).multiply(i),
                    s !== void 0 ? (cv.x = r * Rp.x - s * Rp.y,
                    cv.y = s * Rp.x + r * Rp.y) : cv.copy(Rp),
                    e.copy(t),
                    e.x += cv.x,
                    e.y += cv.y,
                    e.applyMatrix4(Tw)
                }
                const G_ = new Q
                  , ww = new Q;
                var Cw = class extends jn {
                    constructor() {
                        super(),
                        this.isLOD = !0,
                        this._currentLevel = 0,
                        this.type = "LOD",
                        Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            }
                        }),
                        this.autoUpdate = !0
                    }
                    copy(e) {
                        super.copy(e, !1);
                        const t = e.levels;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const s = t[n];
                            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
                        }
                        return this.autoUpdate = e.autoUpdate,
                        this
                    }
                    addLevel(e, t=0, n=0) {
                        t = Math.abs(t);
                        const i = this.levels;
                        let s;
                        for (s = 0; s < i.length && !(t < i[s].distance); s++)
                            ;
                        return i.splice(s, 0, {
                            distance: t,
                            hysteresis: n,
                            object: e
                        }),
                        this.add(e),
                        this
                    }
                    removeLevel(e) {
                        const t = this.levels;
                        for (let n = 0; n < t.length; n++)
                            if (t[n].distance === e) {
                                const i = t.splice(n, 1);
                                return this.remove(i[0].object),
                                !0
                            }
                        return !1
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(e) {
                        const t = this.levels;
                        if (t.length > 0) {
                            let n, i;
                            for (n = 1,
                            i = t.length; n < i; n++) {
                                let s = t[n].distance;
                                if (t[n].object.visible && (s -= s * t[n].hysteresis),
                                e < s)
                                    break
                            }
                            return t[n - 1].object
                        }
                        return null
                    }
                    raycast(e, t) {
                        if (this.levels.length > 0) {
                            G_.setFromMatrixPosition(this.matrixWorld);
                            const n = e.ray.origin.distanceTo(G_);
                            this.getObjectForDistance(n).raycast(e, t)
                        }
                    }
                    update(e) {
                        const t = this.levels;
                        if (t.length > 1) {
                            G_.setFromMatrixPosition(e.matrixWorld),
                            ww.setFromMatrixPosition(this.matrixWorld);
                            const n = G_.distanceTo(ww) / e.zoom;
                            t[0].object.visible = !0;
                            let i, s;
                            for (i = 1,
                            s = t.length; i < s; i++) {
                                let r = t[i].distance;
                                if (t[i].object.visible && (r -= r * t[i].hysteresis),
                                n >= r)
                                    t[i - 1].object.visible = !1,
                                    t[i].object.visible = !0;
                                else
                                    break
                            }
                            for (this._currentLevel = i - 1; i < s; i++)
                                t[i].object.visible = !1
                        }
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
                        t.object.levels = [];
                        const n = this.levels;
                        for (let i = 0, s = n.length; i < s; i++) {
                            const r = n[i];
                            t.object.levels.push({
                                object: r.object.uuid,
                                distance: r.distance,
                                hysteresis: r.hysteresis
                            })
                        }
                        return t
                    }
                }
                ;
                const Rw = new Q
                  , Dw = new gn
                  , Ow = new gn
                  , BB = new Q
                  , Nw = new Xt
                  , k_ = new Q
                  , ZA = new qs
                  , Uw = new Xt
                  , KA = new hf;
                var Bw = class extends Fi {
                    constructor(e, t) {
                        super(e, t),
                        this.isSkinnedMesh = !0,
                        this.type = "SkinnedMesh",
                        this.bindMode = fA,
                        this.bindMatrix = new Xt,
                        this.bindMatrixInverse = new Xt,
                        this.boundingBox = null,
                        this.boundingSphere = null
                    }
                    computeBoundingBox() {
                        const e = this.geometry;
                        this.boundingBox === null && (this.boundingBox = new aa),
                        this.boundingBox.makeEmpty();
                        const t = e.getAttribute("position");
                        for (let n = 0; n < t.count; n++)
                            this.getVertexPosition(n, k_),
                            this.boundingBox.expandByPoint(k_)
                    }
                    computeBoundingSphere() {
                        const e = this.geometry;
                        this.boundingSphere === null && (this.boundingSphere = new qs),
                        this.boundingSphere.makeEmpty();
                        const t = e.getAttribute("position");
                        for (let n = 0; n < t.count; n++)
                            this.getVertexPosition(n, k_),
                            this.boundingSphere.expandByPoint(k_)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.bindMode = e.bindMode,
                        this.bindMatrix.copy(e.bindMatrix),
                        this.bindMatrixInverse.copy(e.bindMatrixInverse),
                        this.skeleton = e.skeleton,
                        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
                        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
                        this
                    }
                    raycast(e, t) {
                        const n = this.material
                          , i = this.matrixWorld;
                        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        ZA.copy(this.boundingSphere),
                        ZA.applyMatrix4(i),
                        e.ray.intersectsSphere(ZA) !== !1 && (Uw.copy(i).invert(),
                        KA.copy(e.ray).applyMatrix4(Uw),
                        !(this.boundingBox !== null && KA.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, KA)))
                    }
                    getVertexPosition(e, t) {
                        return super.getVertexPosition(e, t),
                        this.applyBoneTransform(e, t),
                        t
                    }
                    bind(e, t) {
                        this.skeleton = e,
                        t === void 0 && (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        t = this.matrixWorld),
                        this.bindMatrix.copy(t),
                        this.bindMatrixInverse.copy(t).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const e = new gn
                          , t = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = t.count; n < i; n++) {
                            e.fromBufferAttribute(t, n);
                            const s = 1 / e.manhattanLength();
                            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
                            t.setXYZW(n, e.x, e.y, e.z, e.w)
                        }
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                        this.bindMode === fA ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === LE ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    applyBoneTransform(e, t) {
                        const n = this.skeleton
                          , i = this.geometry;
                        Dw.fromBufferAttribute(i.attributes.skinIndex, e),
                        Ow.fromBufferAttribute(i.attributes.skinWeight, e),
                        Rw.copy(t).applyMatrix4(this.bindMatrix),
                        t.set(0, 0, 0);
                        for (let s = 0; s < 4; s++) {
                            const r = Ow.getComponent(s);
                            if (r !== 0) {
                                const l = Dw.getComponent(s);
                                Nw.multiplyMatrices(n.bones[l].matrixWorld, n.boneInverses[l]),
                                t.addScaledVector(BB.copy(Rw).applyMatrix4(Nw), r)
                            }
                        }
                        return t.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                  , JA = class extends jn {
                    constructor() {
                        super(),
                        this.isBone = !0,
                        this.type = "Bone"
                    }
                }
                  , Xo = class extends zi {
                    constructor(e=null, t=1, n=1, i, s, r, l, h, d=ti, p=ti, m, v) {
                        super(null, r, l, h, d, p, i, s, m, v),
                        this.isDataTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n
                        },
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                ;
                const Pw = new Xt
                  , PB = new Xt;
                var Iw = class DO {
                    constructor(t=[], n=[]) {
                        this.uuid = wr(),
                        this.bones = t.slice(0),
                        this.boneInverses = n,
                        this.boneMatrices = null,
                        this.boneTexture = null,
                        this.init()
                    }
                    init() {
                        const t = this.bones
                          , n = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(t.length * 16),
                        n.length === 0)
                            this.calculateInverses();
                        else if (t.length !== n.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                            this.boneInverses = [];
                            for (let i = 0, s = this.bones.length; i < s; i++)
                                this.boneInverses.push(new Xt)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const i = new Xt;
                            this.bones[t] && i.copy(this.bones[t].matrixWorld).invert(),
                            this.boneInverses.push(i)
                        }
                    }
                    pose() {
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const i = this.bones[t];
                            i && i.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const i = this.bones[t];
                            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
                            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
                            i.matrix.decompose(i.position, i.quaternion, i.scale))
                        }
                    }
                    update() {
                        const t = this.bones
                          , n = this.boneInverses
                          , i = this.boneMatrices
                          , s = this.boneTexture;
                        for (let r = 0, l = t.length; r < l; r++) {
                            const h = t[r] ? t[r].matrixWorld : PB;
                            Pw.multiplyMatrices(h, n[r]),
                            Pw.toArray(i, r * 16)
                        }
                        s !== null && (s.needsUpdate = !0)
                    }
                    clone() {
                        return new DO(this.bones,this.boneInverses)
                    }
                    computeBoneTexture() {
                        let t = Math.sqrt(this.bones.length * 4);
                        t = Math.ceil(t / 4) * 4,
                        t = Math.max(t, 4);
                        const n = new Float32Array(t * t * 4);
                        n.set(this.boneMatrices);
                        const i = new Xo(n,t,t,ss,Xs);
                        return i.needsUpdate = !0,
                        this.boneMatrices = n,
                        this.boneTexture = i,
                        this
                    }
                    getBoneByName(t) {
                        for (let n = 0, i = this.bones.length; n < i; n++) {
                            const s = this.bones[n];
                            if (s.name === t)
                                return s
                        }
                    }
                    dispose() {
                        this.boneTexture !== null && (this.boneTexture.dispose(),
                        this.boneTexture = null)
                    }
                    fromJSON(t, n) {
                        this.uuid = t.uuid;
                        for (let i = 0, s = t.bones.length; i < s; i++) {
                            const r = t.bones[i];
                            let l = n[r];
                            l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
                            l = new JA),
                            this.bones.push(l),
                            this.boneInverses.push(new Xt().fromArray(t.boneInverses[i]))
                        }
                        return this.init(),
                        this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        t.uuid = this.uuid;
                        const n = this.bones
                          , i = this.boneInverses;
                        for (let s = 0, r = n.length; s < r; s++) {
                            const l = n[s];
                            t.bones.push(l.uuid);
                            const h = i[s];
                            t.boneInverses.push(h.toArray())
                        }
                        return t
                    }
                }
                  , Dp = class extends wn {
                    constructor(e, t, n, i=1) {
                        super(e, t, n),
                        this.isInstancedBufferAttribute = !0,
                        this.meshPerAttribute = i
                    }
                    copy(e) {
                        return super.copy(e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.meshPerAttribute = this.meshPerAttribute,
                        e.isInstancedBufferAttribute = !0,
                        e
                    }
                }
                ;
                const Op = new Xt
                  , Lw = new Xt
                  , X_ = []
                  , zw = new aa
                  , IB = new Xt
                  , hv = new Fi
                  , fv = new qs;
                var Fw = class extends Fi {
                    constructor(e, t, n) {
                        super(e, t),
                        this.isInstancedMesh = !0,
                        this.instanceMatrix = new Dp(new Float32Array(n * 16),16),
                        this.instanceColor = null,
                        this.morphTexture = null,
                        this.count = n,
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        for (let i = 0; i < n; i++)
                            this.setMatrixAt(i, IB)
                    }
                    computeBoundingBox() {
                        const e = this.geometry
                          , t = this.count;
                        this.boundingBox === null && (this.boundingBox = new aa),
                        e.boundingBox === null && e.computeBoundingBox(),
                        this.boundingBox.makeEmpty();
                        for (let n = 0; n < t; n++)
                            this.getMatrixAt(n, Op),
                            zw.copy(e.boundingBox).applyMatrix4(Op),
                            this.boundingBox.union(zw)
                    }
                    computeBoundingSphere() {
                        const e = this.geometry
                          , t = this.count;
                        this.boundingSphere === null && (this.boundingSphere = new qs),
                        e.boundingSphere === null && e.computeBoundingSphere(),
                        this.boundingSphere.makeEmpty();
                        for (let n = 0; n < t; n++)
                            this.getMatrixAt(n, Op),
                            fv.copy(e.boundingSphere).applyMatrix4(Op),
                            this.boundingSphere.union(fv)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.instanceMatrix.copy(e.instanceMatrix),
                        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
                        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
                        this.count = e.count,
                        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
                        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
                        this
                    }
                    getColorAt(e, t) {
                        t.fromArray(this.instanceColor.array, e * 3)
                    }
                    getMatrixAt(e, t) {
                        t.fromArray(this.instanceMatrix.array, e * 16)
                    }
                    getMorphAt(e, t) {
                        const n = t.morphTargetInfluences
                          , i = this.morphTexture.source.data.data
                          , s = n.length + 1
                          , r = e * s + 1;
                        for (let l = 0; l < n.length; l++)
                            n[l] = i[r + l]
                    }
                    raycast(e, t) {
                        const n = this.matrixWorld
                          , i = this.count;
                        if (hv.geometry = this.geometry,
                        hv.material = this.material,
                        hv.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        fv.copy(this.boundingSphere),
                        fv.applyMatrix4(n),
                        e.ray.intersectsSphere(fv) !== !1))
                            for (let s = 0; s < i; s++) {
                                this.getMatrixAt(s, Op),
                                Lw.multiplyMatrices(n, Op),
                                hv.matrixWorld = Lw,
                                hv.raycast(e, X_);
                                for (let r = 0, l = X_.length; r < l; r++) {
                                    const h = X_[r];
                                    h.instanceId = s,
                                    h.object = this,
                                    t.push(h)
                                }
                                X_.length = 0
                            }
                    }
                    setColorAt(e, t) {
                        this.instanceColor === null && (this.instanceColor = new Dp(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
                        t.toArray(this.instanceColor.array, e * 3)
                    }
                    setMatrixAt(e, t) {
                        t.toArray(this.instanceMatrix.array, e * 16)
                    }
                    setMorphAt(e, t) {
                        const n = t.morphTargetInfluences
                          , i = n.length + 1;
                        this.morphTexture === null && (this.morphTexture = new Xo(new Float32Array(i * this.count),i,this.count,ap,Xs));
                        const s = this.morphTexture.source.data.data;
                        let r = 0;
                        for (let d = 0; d < n.length; d++)
                            r += n[d];
                        const l = this.geometry.morphTargetsRelative ? 1 : 1 - r
                          , h = i * e;
                        s[h] = l,
                        s.set(n, h + 1)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        }),
                        this.morphTexture !== null && (this.morphTexture.dispose(),
                        this.morphTexture = null)
                    }
                }
                ;
                const $A = new Q
                  , LB = new Q
                  , zB = new rn;
                var Rc = class {
                    constructor(e=new Q(1,0,0), t=0) {
                        this.isPlane = !0,
                        this.normal = e,
                        this.constant = t
                    }
                    set(e, t) {
                        return this.normal.copy(e),
                        this.constant = t,
                        this
                    }
                    setComponents(e, t, n, i) {
                        return this.normal.set(e, t, n),
                        this.constant = i,
                        this
                    }
                    setFromNormalAndCoplanarPoint(e, t) {
                        return this.normal.copy(e),
                        this.constant = -t.dot(this.normal),
                        this
                    }
                    setFromCoplanarPoints(e, t, n) {
                        const i = $A.subVectors(n, t).cross(LB.subVectors(e, t)).normalize();
                        return this.setFromNormalAndCoplanarPoint(i, e),
                        this
                    }
                    copy(e) {
                        return this.normal.copy(e.normal),
                        this.constant = e.constant,
                        this
                    }
                    normalize() {
                        const e = 1 / this.normal.length();
                        return this.normal.multiplyScalar(e),
                        this.constant *= e,
                        this
                    }
                    negate() {
                        return this.constant *= -1,
                        this.normal.negate(),
                        this
                    }
                    distanceToPoint(e) {
                        return this.normal.dot(e) + this.constant
                    }
                    distanceToSphere(e) {
                        return this.distanceToPoint(e.center) - e.radius
                    }
                    projectPoint(e, t) {
                        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                    }
                    intersectLine(e, t) {
                        const n = e.delta($A)
                          , i = this.normal.dot(n);
                        if (i === 0)
                            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
                        const s = -(e.start.dot(this.normal) + this.constant) / i;
                        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
                    }
                    intersectsLine(e) {
                        const t = this.distanceToPoint(e.start)
                          , n = this.distanceToPoint(e.end);
                        return t < 0 && n > 0 || n < 0 && t > 0
                    }
                    intersectsBox(e) {
                        return e.intersectsPlane(this)
                    }
                    intersectsSphere(e) {
                        return e.intersectsPlane(this)
                    }
                    coplanarPoint(e) {
                        return e.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(e, t) {
                        const n = t || zB.getNormalMatrix(e)
                          , i = this.coplanarPoint($A).applyMatrix4(e)
                          , s = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(s),
                        this
                    }
                    translate(e) {
                        return this.constant -= e.dot(this.normal),
                        this
                    }
                    equals(e) {
                        return e.normal.equals(this.normal) && e.constant === this.constant
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const df = new qs
                  , FB = new ye(.5,.5)
                  , q_ = new Q;
                var Np = class {
                    constructor(e=new Rc, t=new Rc, n=new Rc, i=new Rc, s=new Rc, r=new Rc) {
                        this.planes = [e, t, n, i, s, r]
                    }
                    set(e, t, n, i, s, r) {
                        const l = this.planes;
                        return l[0].copy(e),
                        l[1].copy(t),
                        l[2].copy(n),
                        l[3].copy(i),
                        l[4].copy(s),
                        l[5].copy(r),
                        this
                    }
                    copy(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            t[n].copy(e.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(e, t=br, n=!1) {
                        const i = this.planes
                          , s = e.elements
                          , r = s[0]
                          , l = s[1]
                          , h = s[2]
                          , d = s[3]
                          , p = s[4]
                          , m = s[5]
                          , v = s[6]
                          , _ = s[7]
                          , x = s[8]
                          , b = s[9]
                          , E = s[10]
                          , T = s[11]
                          , M = s[12]
                          , D = s[13]
                          , R = s[14]
                          , O = s[15];
                        if (i[0].setComponents(d - r, _ - p, T - x, O - M).normalize(),
                        i[1].setComponents(d + r, _ + p, T + x, O + M).normalize(),
                        i[2].setComponents(d + l, _ + m, T + b, O + D).normalize(),
                        i[3].setComponents(d - l, _ - m, T - b, O - D).normalize(),
                        n)
                            i[4].setComponents(h, v, E, R).normalize(),
                            i[5].setComponents(d - h, _ - v, T - E, O - R).normalize();
                        else if (i[4].setComponents(d - h, _ - v, T - E, O - R).normalize(),
                        t === br)
                            i[5].setComponents(d + h, _ + v, T + E, O + R).normalize();
                        else if (t === rp)
                            i[5].setComponents(h, v, E, R).normalize();
                        else
                            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                        return this
                    }
                    intersectsObject(e) {
                        if (e.boundingSphere !== void 0)
                            e.boundingSphere === null && e.computeBoundingSphere(),
                            df.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                        else {
                            const t = e.geometry;
                            t.boundingSphere === null && t.computeBoundingSphere(),
                            df.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                        }
                        return this.intersectsSphere(df)
                    }
                    intersectsSprite(e) {
                        return df.center.set(0, 0, 0),
                        df.radius = .7071067811865476 + FB.distanceTo(e.center),
                        df.applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(df)
                    }
                    intersectsSphere(e) {
                        const t = this.planes
                          , n = e.center
                          , i = -e.radius;
                        for (let s = 0; s < 6; s++)
                            if (t[s].distanceToPoint(n) < i)
                                return !1;
                        return !0
                    }
                    intersectsBox(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const i = t[n];
                            if (q_.x = i.normal.x > 0 ? e.max.x : e.min.x,
                            q_.y = i.normal.y > 0 ? e.max.y : e.min.y,
                            q_.z = i.normal.z > 0 ? e.max.z : e.min.z,
                            i.distanceToPoint(q_) < 0)
                                return !1
                        }
                        return !0
                    }
                    containsPoint(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (t[n].distanceToPoint(e) < 0)
                                return !1;
                        return !0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const zl = new Xt
                  , Fl = new Np;
                var Hw = class OO {
                    constructor() {
                        this.coordinateSystem = br
                    }
                    intersectsObject(t, n) {
                        if (!n.isArrayCamera || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (zl.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            Fl.setFromProjectionMatrix(zl, s.coordinateSystem, s.reversedDepth),
                            Fl.intersectsObject(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsSprite(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (zl.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            Fl.setFromProjectionMatrix(zl, s.coordinateSystem, s.reversedDepth),
                            Fl.intersectsSprite(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsSphere(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (zl.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            Fl.setFromProjectionMatrix(zl, s.coordinateSystem, s.reversedDepth),
                            Fl.intersectsSphere(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsBox(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (zl.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            Fl.setFromProjectionMatrix(zl, s.coordinateSystem, s.reversedDepth),
                            Fl.intersectsBox(t))
                                return !0
                        }
                        return !1
                    }
                    containsPoint(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let i = 0; i < n.cameras.length; i++) {
                            const s = n.cameras[i];
                            if (zl.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse),
                            Fl.setFromProjectionMatrix(zl, s.coordinateSystem, s.reversedDepth),
                            Fl.containsPoint(t))
                                return !0
                        }
                        return !1
                    }
                    clone() {
                        return new OO
                    }
                }
                ;
                function eT(e, t) {
                    return e - t
                }
                function HB(e, t) {
                    return e.z - t.z
                }
                function VB(e, t) {
                    return t.z - e.z
                }
                var GB = class {
                    constructor() {
                        this.index = 0,
                        this.pool = [],
                        this.list = []
                    }
                    push(e, t, n, i) {
                        const s = this.pool
                          , r = this.list;
                        this.index >= s.length && s.push({
                            start: -1,
                            count: -1,
                            z: -1,
                            index: -1
                        });
                        const l = s[this.index];
                        r.push(l),
                        this.index++,
                        l.start = e,
                        l.count = t,
                        l.z = n,
                        l.index = i
                    }
                    reset() {
                        this.list.length = 0,
                        this.index = 0
                    }
                }
                ;
                const sr = new Xt
                  , kB = new at(1,1,1)
                  , Vw = new Np
                  , XB = new Hw
                  , Y_ = new aa
                  , pf = new qs
                  , dv = new Q
                  , Gw = new Q
                  , qB = new Q
                  , tT = new GB
                  , oa = new Fi
                  , W_ = [];
                function YB(e, t, n=0) {
                    const i = t.itemSize;
                    if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                        const s = e.count;
                        for (let r = 0; r < s; r++)
                            for (let l = 0; l < i; l++)
                                t.setComponent(r + n, l, e.getComponent(r, l))
                    } else
                        t.array.set(e.array, n * i);
                    t.needsUpdate = !0
                }
                function mf(e, t) {
                    if (e.constructor !== t.constructor) {
                        const n = Math.min(e.length, t.length);
                        for (let i = 0; i < n; i++)
                            t[i] = e[i]
                    } else {
                        const n = Math.min(e.length, t.length);
                        t.set(new e.constructor(e.buffer,0,n))
                    }
                }
                var kw = class extends Fi {
                    constructor(e, t, n=t * 2, i) {
                        super(new an, i),
                        this.isBatchedMesh = !0,
                        this.perObjectFrustumCulled = !0,
                        this.sortObjects = !0,
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.customSort = null,
                        this._instanceInfo = [],
                        this._geometryInfo = [],
                        this._availableInstanceIds = [],
                        this._availableGeometryIds = [],
                        this._nextIndexStart = 0,
                        this._nextVertexStart = 0,
                        this._geometryCount = 0,
                        this._visibilityChanged = !0,
                        this._geometryInitialized = !1,
                        this._maxInstanceCount = e,
                        this._maxVertexCount = t,
                        this._maxIndexCount = n,
                        this._multiDrawCounts = new Int32Array(e),
                        this._multiDrawStarts = new Int32Array(e),
                        this._multiDrawCount = 0,
                        this._multiDrawInstances = null,
                        this._matricesTexture = null,
                        this._indirectTexture = null,
                        this._colorsTexture = null,
                        this._initMatricesTexture(),
                        this._initIndirectTexture()
                    }
                    get maxInstanceCount() {
                        return this._maxInstanceCount
                    }
                    get instanceCount() {
                        return this._instanceInfo.length - this._availableInstanceIds.length
                    }
                    get unusedVertexCount() {
                        return this._maxVertexCount - this._nextVertexStart
                    }
                    get unusedIndexCount() {
                        return this._maxIndexCount - this._nextIndexStart
                    }
                    _initMatricesTexture() {
                        let e = Math.sqrt(this._maxInstanceCount * 4);
                        e = Math.ceil(e / 4) * 4,
                        e = Math.max(e, 4);
                        const t = new Float32Array(e * e * 4);
                        this._matricesTexture = new Xo(t,e,e,ss,Xs)
                    }
                    _initIndirectTexture() {
                        let e = Math.sqrt(this._maxInstanceCount);
                        e = Math.ceil(e);
                        const t = new Uint32Array(e * e);
                        this._indirectTexture = new Xo(t,e,e,Vg,Il)
                    }
                    _initColorsTexture() {
                        let e = Math.sqrt(this._maxInstanceCount);
                        e = Math.ceil(e);
                        const t = new Float32Array(e * e * 4).fill(1)
                          , n = new Xo(t,e,e,ss,Xs);
                        n.colorSpace = An.workingColorSpace,
                        this._colorsTexture = n
                    }
                    _initializeGeometry(e) {
                        const t = this.geometry
                          , n = this._maxVertexCount
                          , i = this._maxIndexCount;
                        if (this._geometryInitialized === !1) {
                            for (const s in e.attributes) {
                                const {array: r, itemSize: l, normalized: h} = e.getAttribute(s)
                                  , d = new r.constructor(n * l)
                                  , p = new wn(d,l,h);
                                t.setAttribute(s, p)
                            }
                            if (e.getIndex() !== null) {
                                const s = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                                t.setIndex(new wn(s,1))
                            }
                            this._geometryInitialized = !0
                        }
                    }
                    _validateGeometry(e) {
                        const t = this.geometry;
                        if (!!e.getIndex() != !!t.getIndex())
                            throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
                        for (const n in t.attributes) {
                            if (!e.hasAttribute(n))
                                throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                            const i = e.getAttribute(n)
                              , s = t.getAttribute(n);
                            if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
                                throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                        }
                    }
                    validateInstanceId(e) {
                        const t = this._instanceInfo;
                        if (e < 0 || e >= t.length || t[e].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
                    }
                    validateGeometryId(e) {
                        const t = this._geometryInfo;
                        if (e < 0 || e >= t.length || t[e].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
                    }
                    setCustomSort(e) {
                        return this.customSort = e,
                        this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new aa);
                        const e = this.boundingBox
                          , t = this._instanceInfo;
                        e.makeEmpty();
                        for (let n = 0, i = t.length; n < i; n++) {
                            if (t[n].active === !1)
                                continue;
                            const s = t[n].geometryIndex;
                            this.getMatrixAt(n, sr),
                            this.getBoundingBoxAt(s, Y_).applyMatrix4(sr),
                            e.union(Y_)
                        }
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new qs);
                        const e = this.boundingSphere
                          , t = this._instanceInfo;
                        e.makeEmpty();
                        for (let n = 0, i = t.length; n < i; n++) {
                            if (t[n].active === !1)
                                continue;
                            const s = t[n].geometryIndex;
                            this.getMatrixAt(n, sr),
                            this.getBoundingSphereAt(s, pf).applyMatrix4(sr),
                            e.union(pf)
                        }
                    }
                    addInstance(e) {
                        if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
                            throw new Error("THREE.BatchedMesh: Maximum item count reached.");
                        const t = {
                            visible: !0,
                            active: !0,
                            geometryIndex: e
                        };
                        let n = null;
                        this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(eT),
                        n = this._availableInstanceIds.shift(),
                        this._instanceInfo[n] = t) : (n = this._instanceInfo.length,
                        this._instanceInfo.push(t));
                        const i = this._matricesTexture;
                        sr.identity().toArray(i.image.data, n * 16),
                        i.needsUpdate = !0;
                        const s = this._colorsTexture;
                        return s && (kB.toArray(s.image.data, n * 4),
                        s.needsUpdate = !0),
                        this._visibilityChanged = !0,
                        n
                    }
                    addGeometry(e, t=-1, n=-1) {
                        this._initializeGeometry(e),
                        this._validateGeometry(e);
                        const i = {
                            vertexStart: -1,
                            vertexCount: -1,
                            reservedVertexCount: -1,
                            indexStart: -1,
                            indexCount: -1,
                            reservedIndexCount: -1,
                            start: -1,
                            count: -1,
                            boundingBox: null,
                            boundingSphere: null,
                            active: !0
                        }
                          , s = this._geometryInfo;
                        i.vertexStart = this._nextVertexStart,
                        i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
                        const r = e.getIndex();
                        if (r !== null && (i.indexStart = this._nextIndexStart,
                        i.reservedIndexCount = n === -1 ? r.count : n),
                        i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                        let l;
                        return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(eT),
                        l = this._availableGeometryIds.shift(),
                        s[l] = i) : (l = this._geometryCount,
                        this._geometryCount++,
                        s.push(i)),
                        this.setGeometryAt(l, e),
                        this._nextIndexStart = i.indexStart + i.reservedIndexCount,
                        this._nextVertexStart = i.vertexStart + i.reservedVertexCount,
                        l
                    }
                    setGeometryAt(e, t) {
                        if (e >= this._geometryCount)
                            throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
                        this._validateGeometry(t);
                        const n = this.geometry
                          , i = n.getIndex() !== null
                          , s = n.getIndex()
                          , r = t.getIndex()
                          , l = this._geometryInfo[e];
                        if (i && r.count > l.reservedIndexCount || t.attributes.position.count > l.reservedVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
                        const h = l.vertexStart
                          , d = l.reservedVertexCount;
                        l.vertexCount = t.getAttribute("position").count;
                        for (const p in n.attributes) {
                            const m = t.getAttribute(p)
                              , v = n.getAttribute(p);
                            YB(m, v, h);
                            const _ = m.itemSize;
                            for (let x = m.count, b = d; x < b; x++) {
                                const E = h + x;
                                for (let T = 0; T < _; T++)
                                    v.setComponent(E, T, 0)
                            }
                            v.needsUpdate = !0,
                            v.addUpdateRange(h * _, d * _)
                        }
                        if (i) {
                            const p = l.indexStart
                              , m = l.reservedIndexCount;
                            l.indexCount = t.getIndex().count;
                            for (let v = 0; v < r.count; v++)
                                s.setX(p + v, h + r.getX(v));
                            for (let v = r.count, _ = m; v < _; v++)
                                s.setX(p + v, h);
                            s.needsUpdate = !0,
                            s.addUpdateRange(p, l.reservedIndexCount)
                        }
                        return l.start = i ? l.indexStart : l.vertexStart,
                        l.count = i ? l.indexCount : l.vertexCount,
                        l.boundingBox = null,
                        t.boundingBox !== null && (l.boundingBox = t.boundingBox.clone()),
                        l.boundingSphere = null,
                        t.boundingSphere !== null && (l.boundingSphere = t.boundingSphere.clone()),
                        this._visibilityChanged = !0,
                        e
                    }
                    deleteGeometry(e) {
                        const t = this._geometryInfo;
                        if (e >= t.length || t[e].active === !1)
                            return this;
                        const n = this._instanceInfo;
                        for (let i = 0, s = n.length; i < s; i++)
                            n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
                        return t[e].active = !1,
                        this._availableGeometryIds.push(e),
                        this._visibilityChanged = !0,
                        this
                    }
                    deleteInstance(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].active = !1,
                        this._availableInstanceIds.push(e),
                        this._visibilityChanged = !0,
                        this
                    }
                    optimize() {
                        let e = 0
                          , t = 0;
                        const n = this._geometryInfo
                          , i = n.map( (r, l) => l).sort( (r, l) => n[r].vertexStart - n[l].vertexStart)
                          , s = this.geometry;
                        for (let r = 0, l = n.length; r < l; r++) {
                            const h = i[r]
                              , d = n[h];
                            if (d.active !== !1) {
                                if (s.index !== null) {
                                    if (d.indexStart !== t) {
                                        const {indexStart: p, vertexStart: m, reservedIndexCount: v} = d
                                          , _ = s.index
                                          , x = _.array
                                          , b = e - m;
                                        for (let E = p; E < p + v; E++)
                                            x[E] = x[E] + b;
                                        _.array.copyWithin(t, p, p + v),
                                        _.addUpdateRange(t, v),
                                        d.indexStart = t
                                    }
                                    t += d.reservedIndexCount
                                }
                                if (d.vertexStart !== e) {
                                    const {vertexStart: p, reservedVertexCount: m} = d
                                      , v = s.attributes;
                                    for (const _ in v) {
                                        const x = v[_]
                                          , {array: b, itemSize: E} = x;
                                        b.copyWithin(e * E, p * E, (p + m) * E),
                                        x.addUpdateRange(e * E, m * E)
                                    }
                                    d.vertexStart = e
                                }
                                e += d.reservedVertexCount,
                                d.start = s.index ? d.indexStart : d.vertexStart,
                                this._nextIndexStart = s.index ? d.indexStart + d.reservedIndexCount : 0,
                                this._nextVertexStart = d.vertexStart + d.reservedVertexCount
                            }
                        }
                        return this
                    }
                    getBoundingBoxAt(e, t) {
                        if (e >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , i = this._geometryInfo[e];
                        if (i.boundingBox === null) {
                            const s = new aa
                              , r = n.index
                              , l = n.attributes.position;
                            for (let h = i.start, d = i.start + i.count; h < d; h++) {
                                let p = h;
                                r && (p = r.getX(p)),
                                s.expandByPoint(dv.fromBufferAttribute(l, p))
                            }
                            i.boundingBox = s
                        }
                        return t.copy(i.boundingBox),
                        t
                    }
                    getBoundingSphereAt(e, t) {
                        if (e >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , i = this._geometryInfo[e];
                        if (i.boundingSphere === null) {
                            const s = new qs;
                            this.getBoundingBoxAt(e, Y_),
                            Y_.getCenter(s.center);
                            const r = n.index
                              , l = n.attributes.position;
                            let h = 0;
                            for (let d = i.start, p = i.start + i.count; d < p; d++) {
                                let m = d;
                                r && (m = r.getX(m)),
                                dv.fromBufferAttribute(l, m),
                                h = Math.max(h, s.center.distanceToSquared(dv))
                            }
                            s.radius = Math.sqrt(h),
                            i.boundingSphere = s
                        }
                        return t.copy(i.boundingSphere),
                        t
                    }
                    setMatrixAt(e, t) {
                        this.validateInstanceId(e);
                        const n = this._matricesTexture
                          , i = this._matricesTexture.image.data;
                        return t.toArray(i, e * 16),
                        n.needsUpdate = !0,
                        this
                    }
                    getMatrixAt(e, t) {
                        return this.validateInstanceId(e),
                        t.fromArray(this._matricesTexture.image.data, e * 16)
                    }
                    setColorAt(e, t) {
                        return this.validateInstanceId(e),
                        this._colorsTexture === null && this._initColorsTexture(),
                        t.toArray(this._colorsTexture.image.data, e * 4),
                        this._colorsTexture.needsUpdate = !0,
                        this
                    }
                    getColorAt(e, t) {
                        return this.validateInstanceId(e),
                        t.fromArray(this._colorsTexture.image.data, e * 4)
                    }
                    setVisibleAt(e, t) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t,
                        this._visibilityChanged = !0,
                        this)
                    }
                    getVisibleAt(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].visible
                    }
                    setGeometryIdAt(e, t) {
                        return this.validateInstanceId(e),
                        this.validateGeometryId(t),
                        this._instanceInfo[e].geometryIndex = t,
                        this
                    }
                    getGeometryIdAt(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].geometryIndex
                    }
                    getGeometryRangeAt(e, t={}) {
                        this.validateGeometryId(e);
                        const n = this._geometryInfo[e];
                        return t.vertexStart = n.vertexStart,
                        t.vertexCount = n.vertexCount,
                        t.reservedVertexCount = n.reservedVertexCount,
                        t.indexStart = n.indexStart,
                        t.indexCount = n.indexCount,
                        t.reservedIndexCount = n.reservedIndexCount,
                        t.start = n.start,
                        t.count = n.count,
                        t
                    }
                    setInstanceCount(e) {
                        const t = this._availableInstanceIds
                          , n = this._instanceInfo;
                        for (t.sort(eT); t[t.length - 1] === n.length - 1; )
                            n.pop(),
                            t.pop();
                        if (e < n.length)
                            throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
                        const i = new Int32Array(e)
                          , s = new Int32Array(e);
                        mf(this._multiDrawCounts, i),
                        mf(this._multiDrawStarts, s),
                        this._multiDrawCounts = i,
                        this._multiDrawStarts = s,
                        this._maxInstanceCount = e;
                        const r = this._indirectTexture
                          , l = this._matricesTexture
                          , h = this._colorsTexture;
                        r.dispose(),
                        this._initIndirectTexture(),
                        mf(r.image.data, this._indirectTexture.image.data),
                        l.dispose(),
                        this._initMatricesTexture(),
                        mf(l.image.data, this._matricesTexture.image.data),
                        h && (h.dispose(),
                        this._initColorsTexture(),
                        mf(h.image.data, this._colorsTexture.image.data))
                    }
                    setGeometrySize(e, t) {
                        const n = [...this._geometryInfo].filter(r => r.active);
                        if (Math.max(...n.map(r => r.vertexStart + r.reservedVertexCount)) > e)
                            throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
                        if (this.geometry.index && Math.max(...n.map(r => r.indexStart + r.reservedIndexCount)) > t)
                            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
                        const i = this.geometry;
                        i.dispose(),
                        this._maxVertexCount = e,
                        this._maxIndexCount = t,
                        this._geometryInitialized && (this._geometryInitialized = !1,
                        this.geometry = new an,
                        this._initializeGeometry(i));
                        const s = this.geometry;
                        i.index && mf(i.index.array, s.index.array);
                        for (const r in i.attributes)
                            mf(i.attributes[r].array, s.attributes[r].array)
                    }
                    raycast(e, t) {
                        const n = this._instanceInfo
                          , i = this._geometryInfo
                          , s = this.matrixWorld
                          , r = this.geometry;
                        oa.material = this.material,
                        oa.geometry.index = r.index,
                        oa.geometry.attributes = r.attributes,
                        oa.geometry.boundingBox === null && (oa.geometry.boundingBox = new aa),
                        oa.geometry.boundingSphere === null && (oa.geometry.boundingSphere = new qs);
                        for (let l = 0, h = n.length; l < h; l++) {
                            if (!n[l].visible || !n[l].active)
                                continue;
                            const d = n[l].geometryIndex
                              , p = i[d];
                            oa.geometry.setDrawRange(p.start, p.count),
                            this.getMatrixAt(l, oa.matrixWorld).premultiply(s),
                            this.getBoundingBoxAt(d, oa.geometry.boundingBox),
                            this.getBoundingSphereAt(d, oa.geometry.boundingSphere),
                            oa.raycast(e, W_);
                            for (let m = 0, v = W_.length; m < v; m++) {
                                const _ = W_[m];
                                _.object = this,
                                _.batchId = l,
                                t.push(_)
                            }
                            W_.length = 0
                        }
                        oa.material = null,
                        oa.geometry.index = null,
                        oa.geometry.attributes = {},
                        oa.geometry.setDrawRange(0, 1 / 0)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.geometry = e.geometry.clone(),
                        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
                        this.sortObjects = e.sortObjects,
                        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
                        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
                        this._geometryInfo = e._geometryInfo.map(t => ({
                            ...t,
                            boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
                            boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
                        })),
                        this._instanceInfo = e._instanceInfo.map(t => ({
                            ...t
                        })),
                        this._availableInstanceIds = e._availableInstanceIds.slice(),
                        this._availableGeometryIds = e._availableGeometryIds.slice(),
                        this._nextIndexStart = e._nextIndexStart,
                        this._nextVertexStart = e._nextVertexStart,
                        this._geometryCount = e._geometryCount,
                        this._maxInstanceCount = e._maxInstanceCount,
                        this._maxVertexCount = e._maxVertexCount,
                        this._maxIndexCount = e._maxIndexCount,
                        this._geometryInitialized = e._geometryInitialized,
                        this._multiDrawCounts = e._multiDrawCounts.slice(),
                        this._multiDrawStarts = e._multiDrawStarts.slice(),
                        this._indirectTexture = e._indirectTexture.clone(),
                        this._indirectTexture.image.data = this._indirectTexture.image.data.slice(),
                        this._matricesTexture = e._matricesTexture.clone(),
                        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
                        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
                        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this._matricesTexture.dispose(),
                        this._matricesTexture = null,
                        this._indirectTexture.dispose(),
                        this._indirectTexture = null,
                        this._colorsTexture !== null && (this._colorsTexture.dispose(),
                        this._colorsTexture = null)
                    }
                    onBeforeRender(e, t, n, i, s) {
                        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                            return;
                        const r = i.getIndex()
                          , l = r === null ? 1 : r.array.BYTES_PER_ELEMENT
                          , h = this._instanceInfo
                          , d = this._multiDrawStarts
                          , p = this._multiDrawCounts
                          , m = this._geometryInfo
                          , v = this.perObjectFrustumCulled
                          , _ = this._indirectTexture
                          , x = _.image.data
                          , b = n.isArrayCamera ? XB : Vw;
                        v && !n.isArrayCamera && (sr.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
                        Vw.setFromProjectionMatrix(sr, n.coordinateSystem, n.reversedDepth));
                        let E = 0;
                        if (this.sortObjects) {
                            sr.copy(this.matrixWorld).invert(),
                            dv.setFromMatrixPosition(n.matrixWorld).applyMatrix4(sr),
                            Gw.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(sr);
                            for (let D = 0, R = h.length; D < R; D++)
                                if (h[D].visible && h[D].active) {
                                    const O = h[D].geometryIndex;
                                    this.getMatrixAt(D, sr),
                                    this.getBoundingSphereAt(O, pf).applyMatrix4(sr);
                                    let U = !1;
                                    if (v && (U = !b.intersectsSphere(pf, n)),
                                    !U) {
                                        const B = m[O]
                                          , I = qB.subVectors(pf.center, dv).dot(Gw);
                                        tT.push(B.start, B.count, I, D)
                                    }
                                }
                            const T = tT.list
                              , M = this.customSort;
                            M === null ? T.sort(s.transparent ? VB : HB) : M.call(this, T, n);
                            for (let D = 0, R = T.length; D < R; D++) {
                                const O = T[D];
                                d[E] = O.start * l,
                                p[E] = O.count,
                                x[E] = O.index,
                                E++
                            }
                            tT.reset()
                        } else
                            for (let T = 0, M = h.length; T < M; T++)
                                if (h[T].visible && h[T].active) {
                                    const D = h[T].geometryIndex;
                                    let R = !1;
                                    if (v && (this.getMatrixAt(T, sr),
                                    this.getBoundingSphereAt(D, pf).applyMatrix4(sr),
                                    R = !b.intersectsSphere(pf, n)),
                                    !R) {
                                        const O = m[D];
                                        d[E] = O.start * l,
                                        p[E] = O.count,
                                        x[E] = T,
                                        E++
                                    }
                                }
                        _.needsUpdate = !0,
                        this._multiDrawCount = E,
                        this._visibilityChanged = !1
                    }
                    onBeforeShadow(e, t, n, i, s, r) {
                        this.onBeforeRender(e, null, i, s, r)
                    }
                }
                  , Ia = class extends Os {
                    constructor(e) {
                        super(),
                        this.isLineBasicMaterial = !0,
                        this.type = "LineBasicMaterial",
                        this.color = new at(16777215),
                        this.map = null,
                        this.linewidth = 1,
                        this.linecap = "round",
                        this.linejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.linewidth = e.linewidth,
                        this.linecap = e.linecap,
                        this.linejoin = e.linejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const j_ = new Q
                  , Q_ = new Q
                  , Xw = new Xt
                  , pv = new hf
                  , Z_ = new qs
                  , nT = new Q
                  , qw = new Q;
                var Xu = class extends jn {
                    constructor(e=new an, t=new Ia) {
                        super(),
                        this.isLine = !0,
                        this.type = "Line",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.index === null) {
                            const t = e.attributes.position
                              , n = [0];
                            for (let i = 1, s = t.count; i < s; i++)
                                j_.fromBufferAttribute(t, i - 1),
                                Q_.fromBufferAttribute(t, i),
                                n[i] = n[i - 1],
                                n[i] += j_.distanceTo(Q_);
                            e.setAttribute("lineDistance", new At(n,1))
                        } else
                            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , i = this.matrixWorld
                          , s = e.params.Line.threshold
                          , r = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        Z_.copy(n.boundingSphere),
                        Z_.applyMatrix4(i),
                        Z_.radius += s,
                        e.ray.intersectsSphere(Z_) === !1)
                            return;
                        Xw.copy(i).invert(),
                        pv.copy(e.ray).applyMatrix4(Xw);
                        const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , h = l * l
                          , d = this.isLineSegments ? 2 : 1
                          , p = n.index
                          , m = n.attributes.position;
                        if (p !== null) {
                            const v = Math.max(0, r.start)
                              , _ = Math.min(p.count, r.start + r.count);
                            for (let x = v, b = _ - 1; x < b; x += d) {
                                const E = p.getX(x)
                                  , T = p.getX(x + 1)
                                  , M = K_(this, e, pv, h, E, T, x);
                                M && t.push(M)
                            }
                            if (this.isLineLoop) {
                                const x = p.getX(_ - 1)
                                  , b = p.getX(v)
                                  , E = K_(this, e, pv, h, x, b, _ - 1);
                                E && t.push(E)
                            }
                        } else {
                            const v = Math.max(0, r.start)
                              , _ = Math.min(m.count, r.start + r.count);
                            for (let x = v, b = _ - 1; x < b; x += d) {
                                const E = K_(this, e, pv, h, x, x + 1, x);
                                E && t.push(E)
                            }
                            if (this.isLineLoop) {
                                const x = K_(this, e, pv, h, _ - 1, v, _ - 1);
                                x && t.push(x)
                            }
                        }
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const r = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[r] = i
                                }
                            }
                        }
                    }
                }
                ;
                function K_(e, t, n, i, s, r, l) {
                    const h = e.geometry.attributes.position;
                    if (j_.fromBufferAttribute(h, s),
                    Q_.fromBufferAttribute(h, r),
                    n.distanceSqToSegment(j_, Q_, nT, qw) > i)
                        return;
                    nT.applyMatrix4(e.matrixWorld);
                    const d = t.ray.origin.distanceTo(nT);
                    if (!(d < t.near || d > t.far))
                        return {
                            distance: d,
                            point: qw.clone().applyMatrix4(e.matrixWorld),
                            index: l,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: e
                        }
                }
                const Yw = new Q
                  , Ww = new Q;
                var Hl = class extends Xu {
                    constructor(e, t) {
                        super(e, t),
                        this.isLineSegments = !0,
                        this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.index === null) {
                            const t = e.attributes.position
                              , n = [];
                            for (let i = 0, s = t.count; i < s; i += 2)
                                Yw.fromBufferAttribute(t, i),
                                Ww.fromBufferAttribute(t, i + 1),
                                n[i] = i === 0 ? 0 : n[i - 1],
                                n[i + 1] = n[i] + Yw.distanceTo(Ww);
                            e.setAttribute("lineDistance", new At(n,1))
                        } else
                            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                }
                  , jw = class extends Xu {
                    constructor(e, t) {
                        super(e, t),
                        this.isLineLoop = !0,
                        this.type = "LineLoop"
                    }
                }
                  , iT = class extends Os {
                    constructor(e) {
                        super(),
                        this.isPointsMaterial = !0,
                        this.type = "PointsMaterial",
                        this.color = new at(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.size = 1,
                        this.sizeAttenuation = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.size = e.size,
                        this.sizeAttenuation = e.sizeAttenuation,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const Qw = new Xt
                  , sT = new hf
                  , J_ = new qs
                  , $_ = new Q;
                var Zw = class extends jn {
                    constructor(e=new an, t=new iT) {
                        super(),
                        this.isPoints = !0,
                        this.type = "Points",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , i = this.matrixWorld
                          , s = e.params.Points.threshold
                          , r = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        J_.copy(n.boundingSphere),
                        J_.applyMatrix4(i),
                        J_.radius += s,
                        e.ray.intersectsSphere(J_) === !1)
                            return;
                        Qw.copy(i).invert(),
                        sT.copy(e.ray).applyMatrix4(Qw);
                        const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , h = l * l
                          , d = n.index
                          , p = n.attributes.position;
                        if (d !== null) {
                            const m = Math.max(0, r.start)
                              , v = Math.min(d.count, r.start + r.count);
                            for (let _ = m, x = v; _ < x; _++) {
                                const b = d.getX(_);
                                $_.fromBufferAttribute(p, b),
                                Kw($_, b, h, i, e, t, this)
                            }
                        } else {
                            const m = Math.max(0, r.start)
                              , v = Math.min(p.count, r.start + r.count);
                            for (let _ = m, x = v; _ < x; _++)
                                $_.fromBufferAttribute(p, _),
                                Kw($_, _, h, i, e, t, this)
                        }
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const r = n[i].name || String(i);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[r] = i
                                }
                            }
                        }
                    }
                }
                ;
                function Kw(e, t, n, i, s, r, l) {
                    const h = sT.distanceSqToPoint(e);
                    if (h < n) {
                        const d = new Q;
                        sT.closestPointToPoint(e, d),
                        d.applyMatrix4(i);
                        const p = s.ray.origin.distanceTo(d);
                        if (p < s.near || p > s.far)
                            return;
                        r.push({
                            distance: p,
                            distanceToRay: Math.sqrt(h),
                            point: d,
                            index: t,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: l
                        })
                    }
                }
                var Jw = class extends zi {
                    constructor(e, t, n, i, s=mi, r=mi, l, h, d) {
                        super(e, t, n, i, s, r, l, h, d),
                        this.isVideoTexture = !0,
                        this.generateMipmaps = !1,
                        this._requestVideoFrameCallbackId = 0;
                        const p = this;
                        function m() {
                            p.needsUpdate = !0,
                            p._requestVideoFrameCallbackId = e.requestVideoFrameCallback(m)
                        }
                        "requestVideoFrameCallback"in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(m))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const e = this.image;
                        !("requestVideoFrameCallback"in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                    dispose() {
                        this._requestVideoFrameCallbackId !== 0 && this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),
                        super.dispose()
                    }
                }
                  , WB = class extends Jw {
                    constructor(e, t, n, i, s, r, l, h) {
                        super({}, e, t, n, i, s, r, l, h),
                        this.isVideoFrameTexture = !0
                    }
                    update() {}
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    setFrame(e) {
                        this.image = e,
                        this.needsUpdate = !0
                    }
                }
                  , jB = class extends zi {
                    constructor(e, t) {
                        super({
                            width: e,
                            height: t
                        }),
                        this.isFramebufferTexture = !0,
                        this.magFilter = ti,
                        this.minFilter = ti,
                        this.generateMipmaps = !1,
                        this.needsUpdate = !0
                    }
                }
                  , ex = class extends zi {
                    constructor(e, t, n, i, s, r, l, h, d, p, m, v) {
                        super(null, r, l, h, d, p, i, s, m, v),
                        this.isCompressedTexture = !0,
                        this.image = {
                            width: t,
                            height: n
                        },
                        this.mipmaps = e,
                        this.flipY = !1,
                        this.generateMipmaps = !1
                    }
                }
                  , QB = class extends ex {
                    constructor(e, t, n, i, s, r) {
                        super(e, t, n, s, r),
                        this.isCompressedArrayTexture = !0,
                        this.image.depth = i,
                        this.wrapR = no,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(e) {
                        this.layerUpdates.add(e)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , ZB = class extends ex {
                    constructor(e, t, n) {
                        super(void 0, e[0].width, e[0].height, t, n, Sc),
                        this.isCompressedCubeTexture = !0,
                        this.isCubeTexture = !0,
                        this.image = e
                    }
                }
                  , KB = class extends zi {
                    constructor(e, t, n, i, s, r, l, h, d) {
                        super(e, t, n, i, s, r, l, h, d),
                        this.isCanvasTexture = !0,
                        this.needsUpdate = !0
                    }
                }
                  , mv = class extends zi {
                    constructor(e, t, n=Il, i, s, r, l=ti, h=ti, d, p=sp, m=1) {
                        if (p !== sp && p !== sf)
                            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        super({
                            width: e,
                            height: t,
                            depth: m
                        }, i, s, r, l, h, p, n, d),
                        this.isDepthTexture = !0,
                        this.flipY = !1,
                        this.generateMipmaps = !1,
                        this.compareFunction = null
                    }
                    copy(e) {
                        return super.copy(e),
                        this.source = new Pu(Object.assign({}, e.image)),
                        this.compareFunction = e.compareFunction,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
                        t
                    }
                }
                  , aT = class extends zi {
                    constructor(e=null) {
                        super(),
                        this.sourceTexture = e,
                        this.isExternalTexture = !0
                    }
                    copy(e) {
                        return super.copy(e),
                        this.sourceTexture = e.sourceTexture,
                        this
                    }
                }
                  , $w = class NO extends an {
                    constructor(t=1, n=1, i=4, s=8, r=1) {
                        super(),
                        this.type = "CapsuleGeometry",
                        this.parameters = {
                            radius: t,
                            height: n,
                            capSegments: i,
                            radialSegments: s,
                            heightSegments: r
                        },
                        n = Math.max(0, n),
                        i = Math.max(1, Math.floor(i)),
                        s = Math.max(3, Math.floor(s)),
                        r = Math.max(1, Math.floor(r));
                        const l = []
                          , h = []
                          , d = []
                          , p = []
                          , m = n / 2
                          , v = Math.PI / 2 * t
                          , _ = n
                          , x = 2 * v + _
                          , b = i * 2 + r
                          , E = s + 1
                          , T = new Q
                          , M = new Q;
                        for (let D = 0; D <= b; D++) {
                            let R = 0
                              , O = 0
                              , U = 0
                              , B = 0;
                            if (D <= i) {
                                const P = D / i
                                  , L = P * Math.PI / 2;
                                O = -m - t * Math.cos(L),
                                U = t * Math.sin(L),
                                B = -t * Math.cos(L),
                                R = P * v
                            } else if (D <= i + r) {
                                const P = (D - i) / r;
                                O = -m + P * n,
                                U = t,
                                B = 0,
                                R = v + P * _
                            } else {
                                const P = (D - i - r) / i
                                  , L = P * Math.PI / 2;
                                O = m + t * Math.sin(L),
                                U = t * Math.cos(L),
                                B = t * Math.sin(L),
                                R = v + _ + P * v
                            }
                            const I = Math.max(0, Math.min(1, R / x));
                            let F = 0;
                            D === 0 ? F = .5 / s : D === b && (F = -.5 / s);
                            for (let P = 0; P <= s; P++) {
                                const L = P / s
                                  , H = L * Math.PI * 2
                                  , Z = Math.sin(H)
                                  , K = Math.cos(H);
                                M.x = -U * K,
                                M.y = O,
                                M.z = U * Z,
                                h.push(M.x, M.y, M.z),
                                T.set(-U * K, B, U * Z),
                                T.normalize(),
                                d.push(T.x, T.y, T.z),
                                p.push(L + F, I)
                            }
                            if (D > 0) {
                                const P = (D - 1) * E;
                                for (let L = 0; L < s; L++) {
                                    const H = P + L
                                      , Z = P + L + 1
                                      , K = D * E + L
                                      , te = D * E + L + 1;
                                    l.push(H, Z, K),
                                    l.push(Z, te, K)
                                }
                            }
                        }
                        this.setIndex(l),
                        this.setAttribute("position", new At(h,3)),
                        this.setAttribute("normal", new At(d,3)),
                        this.setAttribute("uv", new At(p,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new NO(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)
                    }
                }
                  , eC = class UO extends an {
                    constructor(t=1, n=32, i=0, s=Math.PI * 2) {
                        super(),
                        this.type = "CircleGeometry",
                        this.parameters = {
                            radius: t,
                            segments: n,
                            thetaStart: i,
                            thetaLength: s
                        },
                        n = Math.max(3, n);
                        const r = []
                          , l = []
                          , h = []
                          , d = []
                          , p = new Q
                          , m = new ye;
                        l.push(0, 0, 0),
                        h.push(0, 0, 1),
                        d.push(.5, .5);
                        for (let v = 0, _ = 3; v <= n; v++,
                        _ += 3) {
                            const x = i + v / n * s;
                            p.x = t * Math.cos(x),
                            p.y = t * Math.sin(x),
                            l.push(p.x, p.y, p.z),
                            h.push(0, 0, 1),
                            m.x = (l[_] / t + 1) / 2,
                            m.y = (l[_ + 1] / t + 1) / 2,
                            d.push(m.x, m.y)
                        }
                        for (let v = 1; v <= n; v++)
                            r.push(v, v + 1, 0);
                        this.setIndex(r),
                        this.setAttribute("position", new At(l,3)),
                        this.setAttribute("normal", new At(h,3)),
                        this.setAttribute("uv", new At(d,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new UO(t.radius,t.segments,t.thetaStart,t.thetaLength)
                    }
                }
                  , rT = class BO extends an {
                    constructor(t=1, n=1, i=1, s=32, r=1, l=!1, h=0, d=Math.PI * 2) {
                        super(),
                        this.type = "CylinderGeometry",
                        this.parameters = {
                            radiusTop: t,
                            radiusBottom: n,
                            height: i,
                            radialSegments: s,
                            heightSegments: r,
                            openEnded: l,
                            thetaStart: h,
                            thetaLength: d
                        };
                        const p = this;
                        s = Math.floor(s),
                        r = Math.floor(r);
                        const m = []
                          , v = []
                          , _ = []
                          , x = [];
                        let b = 0;
                        const E = []
                          , T = i / 2;
                        let M = 0;
                        D(),
                        l === !1 && (t > 0 && R(!0),
                        n > 0 && R(!1)),
                        this.setIndex(m),
                        this.setAttribute("position", new At(v,3)),
                        this.setAttribute("normal", new At(_,3)),
                        this.setAttribute("uv", new At(x,2));
                        function D() {
                            const O = new Q
                              , U = new Q;
                            let B = 0;
                            const I = (n - t) / i;
                            for (let F = 0; F <= r; F++) {
                                const P = []
                                  , L = F / r
                                  , H = L * (n - t) + t;
                                for (let Z = 0; Z <= s; Z++) {
                                    const K = Z / s
                                      , te = K * d + h
                                      , ce = Math.sin(te)
                                      , G = Math.cos(te);
                                    U.x = H * ce,
                                    U.y = -L * i + T,
                                    U.z = H * G,
                                    v.push(U.x, U.y, U.z),
                                    O.set(ce, I, G).normalize(),
                                    _.push(O.x, O.y, O.z),
                                    x.push(K, 1 - L),
                                    P.push(b++)
                                }
                                E.push(P)
                            }
                            for (let F = 0; F < s; F++)
                                for (let P = 0; P < r; P++) {
                                    const L = E[P][F]
                                      , H = E[P + 1][F]
                                      , Z = E[P + 1][F + 1]
                                      , K = E[P][F + 1];
                                    (t > 0 || P !== 0) && (m.push(L, H, K),
                                    B += 3),
                                    (n > 0 || P !== r - 1) && (m.push(H, Z, K),
                                    B += 3)
                                }
                            p.addGroup(M, B, 0),
                            M += B
                        }
                        function R(O) {
                            const U = b
                              , B = new ye
                              , I = new Q;
                            let F = 0;
                            const P = O === !0 ? t : n
                              , L = O === !0 ? 1 : -1;
                            for (let Z = 1; Z <= s; Z++)
                                v.push(0, T * L, 0),
                                _.push(0, L, 0),
                                x.push(.5, .5),
                                b++;
                            const H = b;
                            for (let Z = 0; Z <= s; Z++) {
                                const K = Z / s * d + h
                                  , te = Math.cos(K)
                                  , ce = Math.sin(K);
                                I.x = P * ce,
                                I.y = T * L,
                                I.z = P * te,
                                v.push(I.x, I.y, I.z),
                                _.push(0, L, 0),
                                B.x = te * .5 + .5,
                                B.y = ce * .5 * L + .5,
                                x.push(B.x, B.y),
                                b++
                            }
                            for (let Z = 0; Z < s; Z++) {
                                const K = U + Z
                                  , te = H + Z;
                                O === !0 ? m.push(te, te + 1, K) : m.push(te + 1, te, K),
                                F += 3
                            }
                            p.addGroup(M, F, O === !0 ? 1 : 2),
                            M += F
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new BO(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)
                    }
                }
                  , oT = class PO extends rT {
                    constructor(t=1, n=1, i=32, s=1, r=!1, l=0, h=Math.PI * 2) {
                        super(0, t, n, i, s, r, l, h),
                        this.type = "ConeGeometry",
                        this.parameters = {
                            radius: t,
                            height: n,
                            radialSegments: i,
                            heightSegments: s,
                            openEnded: r,
                            thetaStart: l,
                            thetaLength: h
                        }
                    }
                    static fromJSON(t) {
                        return new PO(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)
                    }
                }
                  , Up = class IO extends an {
                    constructor(t=[], n=[], i=1, s=0) {
                        super(),
                        this.type = "PolyhedronGeometry",
                        this.parameters = {
                            vertices: t,
                            indices: n,
                            radius: i,
                            detail: s
                        };
                        const r = []
                          , l = [];
                        h(s),
                        p(i),
                        m(),
                        this.setAttribute("position", new At(r,3)),
                        this.setAttribute("normal", new At(r.slice(),3)),
                        this.setAttribute("uv", new At(l,2)),
                        s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
                        function h(D) {
                            const R = new Q
                              , O = new Q
                              , U = new Q;
                            for (let B = 0; B < n.length; B += 3)
                                x(n[B + 0], R),
                                x(n[B + 1], O),
                                x(n[B + 2], U),
                                d(R, O, U, D)
                        }
                        function d(D, R, O, U) {
                            const B = U + 1
                              , I = [];
                            for (let F = 0; F <= B; F++) {
                                I[F] = [];
                                const P = D.clone().lerp(O, F / B)
                                  , L = R.clone().lerp(O, F / B)
                                  , H = B - F;
                                for (let Z = 0; Z <= H; Z++)
                                    Z === 0 && F === B ? I[F][Z] = P : I[F][Z] = P.clone().lerp(L, Z / H)
                            }
                            for (let F = 0; F < B; F++)
                                for (let P = 0; P < 2 * (B - F) - 1; P++) {
                                    const L = Math.floor(P / 2);
                                    P % 2 === 0 ? (_(I[F][L + 1]),
                                    _(I[F + 1][L]),
                                    _(I[F][L])) : (_(I[F][L + 1]),
                                    _(I[F + 1][L + 1]),
                                    _(I[F + 1][L]))
                                }
                        }
                        function p(D) {
                            const R = new Q;
                            for (let O = 0; O < r.length; O += 3)
                                R.x = r[O + 0],
                                R.y = r[O + 1],
                                R.z = r[O + 2],
                                R.normalize().multiplyScalar(D),
                                r[O + 0] = R.x,
                                r[O + 1] = R.y,
                                r[O + 2] = R.z
                        }
                        function m() {
                            const D = new Q;
                            for (let R = 0; R < r.length; R += 3) {
                                D.x = r[R + 0],
                                D.y = r[R + 1],
                                D.z = r[R + 2];
                                const O = T(D) / 2 / Math.PI + .5
                                  , U = M(D) / Math.PI + .5;
                                l.push(O, 1 - U)
                            }
                            b(),
                            v()
                        }
                        function v() {
                            for (let D = 0; D < l.length; D += 6) {
                                const R = l[D + 0]
                                  , O = l[D + 2]
                                  , U = l[D + 4];
                                Math.max(R, O, U) > .9 && Math.min(R, O, U) < .1 && (R < .2 && (l[D + 0] += 1),
                                O < .2 && (l[D + 2] += 1),
                                U < .2 && (l[D + 4] += 1))
                            }
                        }
                        function _(D) {
                            r.push(D.x, D.y, D.z)
                        }
                        function x(D, R) {
                            const O = D * 3;
                            R.x = t[O + 0],
                            R.y = t[O + 1],
                            R.z = t[O + 2]
                        }
                        function b() {
                            const D = new Q
                              , R = new Q
                              , O = new Q
                              , U = new Q
                              , B = new ye
                              , I = new ye
                              , F = new ye;
                            for (let P = 0, L = 0; P < r.length; P += 9,
                            L += 6) {
                                D.set(r[P + 0], r[P + 1], r[P + 2]),
                                R.set(r[P + 3], r[P + 4], r[P + 5]),
                                O.set(r[P + 6], r[P + 7], r[P + 8]),
                                B.set(l[L + 0], l[L + 1]),
                                I.set(l[L + 2], l[L + 3]),
                                F.set(l[L + 4], l[L + 5]),
                                U.copy(D).add(R).add(O).divideScalar(3);
                                const H = T(U);
                                E(B, L + 0, D, H),
                                E(I, L + 2, R, H),
                                E(F, L + 4, O, H)
                            }
                        }
                        function E(D, R, O, U) {
                            U < 0 && D.x === 1 && (l[R] = D.x - 1),
                            O.x === 0 && O.z === 0 && (l[R] = U / 2 / Math.PI + .5)
                        }
                        function T(D) {
                            return Math.atan2(D.z, -D.x)
                        }
                        function M(D) {
                            return Math.atan2(-D.y, Math.sqrt(D.x * D.x + D.z * D.z))
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new IO(t.vertices,t.indices,t.radius,t.details)
                    }
                }
                  , tC = class LO extends Up {
                    constructor(t=1, n=0) {
                        const i = (1 + Math.sqrt(5)) / 2
                          , s = 1 / i
                          , r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, 0, -i, 0, -s, i, 0, -s, -i, 0, s, i, 0, s];
                        super(r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, n),
                        this.type = "DodecahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new LO(t.radius,t.detail)
                    }
                }
                ;
                const tx = new Q
                  , nx = new Q
                  , lT = new Q
                  , ix = new Hu;
                var nC = class extends an {
                    constructor(e=null, t=1) {
                        if (super(),
                        this.type = "EdgesGeometry",
                        this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        },
                        e !== null) {
                            const n = Math.pow(10, 4)
                              , i = Math.cos(lf * t)
                              , s = e.getIndex()
                              , r = e.getAttribute("position")
                              , l = s ? s.count : r.count
                              , h = [0, 0, 0]
                              , d = ["a", "b", "c"]
                              , p = new Array(3)
                              , m = {}
                              , v = [];
                            for (let _ = 0; _ < l; _ += 3) {
                                s ? (h[0] = s.getX(_),
                                h[1] = s.getX(_ + 1),
                                h[2] = s.getX(_ + 2)) : (h[0] = _,
                                h[1] = _ + 1,
                                h[2] = _ + 2);
                                const {a: x, b, c: E} = ix;
                                if (x.fromBufferAttribute(r, h[0]),
                                b.fromBufferAttribute(r, h[1]),
                                E.fromBufferAttribute(r, h[2]),
                                ix.getNormal(lT),
                                p[0] = `${Math.round(x.x * n)},${Math.round(x.y * n)},${Math.round(x.z * n)}`,
                                p[1] = `${Math.round(b.x * n)},${Math.round(b.y * n)},${Math.round(b.z * n)}`,
                                p[2] = `${Math.round(E.x * n)},${Math.round(E.y * n)},${Math.round(E.z * n)}`,
                                !(p[0] === p[1] || p[1] === p[2] || p[2] === p[0]))
                                    for (let T = 0; T < 3; T++) {
                                        const M = (T + 1) % 3
                                          , D = p[T]
                                          , R = p[M]
                                          , O = ix[d[T]]
                                          , U = ix[d[M]]
                                          , B = `${D}_${R}`
                                          , I = `${R}_${D}`;
                                        I in m && m[I] ? (lT.dot(m[I].normal) <= i && (v.push(O.x, O.y, O.z),
                                        v.push(U.x, U.y, U.z)),
                                        m[I] = null) : B in m || (m[B] = {
                                            index0: h[T],
                                            index1: h[M],
                                            normal: lT.clone()
                                        })
                                    }
                            }
                            for (const _ in m)
                                if (m[_]) {
                                    const {index0: x, index1: b} = m[_];
                                    tx.fromBufferAttribute(r, x),
                                    nx.fromBufferAttribute(r, b),
                                    v.push(tx.x, tx.y, tx.z),
                                    v.push(nx.x, nx.y, nx.z)
                                }
                            this.setAttribute("position", new At(v,3))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                }
                  , qo = class {
                    constructor() {
                        this.type = "Curve",
                        this.arcLengthDivisions = 200,
                        this.needsUpdate = !1,
                        this.cacheArcLengths = null
                    }
                    getPoint() {
                        console.warn("THREE.Curve: .getPoint() not implemented.")
                    }
                    getPointAt(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getPoint(n, t)
                    }
                    getPoints(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return t
                    }
                    getSpacedPoints(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPointAt(n / e));
                        return t
                    }
                    getLength() {
                        const e = this.getLengths();
                        return e[e.length - 1]
                    }
                    getLengths(e=this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const t = [];
                        let n, i = this.getPoint(0), s = 0;
                        t.push(0);
                        for (let r = 1; r <= e; r++)
                            n = this.getPoint(r / e),
                            s += n.distanceTo(i),
                            t.push(s),
                            i = n;
                        return this.cacheArcLengths = t,
                        t
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.getLengths()
                    }
                    getUtoTmapping(e, t=null) {
                        const n = this.getLengths();
                        let i = 0;
                        const s = n.length;
                        let r;
                        t ? r = t : r = e * n[s - 1];
                        let l = 0, h = s - 1, d;
                        for (; l <= h; )
                            if (i = Math.floor(l + (h - l) / 2),
                            d = n[i] - r,
                            d < 0)
                                l = i + 1;
                            else if (d > 0)
                                h = i - 1;
                            else {
                                h = i;
                                break
                            }
                        if (i = h,
                        n[i] === r)
                            return i / (s - 1);
                        const p = n[i]
                          , m = n[i + 1] - p
                          , v = (r - p) / m;
                        return (i + v) / (s - 1)
                    }
                    getTangent(e, t) {
                        let i = e - 1e-4
                          , s = e + 1e-4;
                        i < 0 && (i = 0),
                        s > 1 && (s = 1);
                        const r = this.getPoint(i)
                          , l = this.getPoint(s)
                          , h = t || (r.isVector2 ? new ye : new Q);
                        return h.copy(l).sub(r).normalize(),
                        h
                    }
                    getTangentAt(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getTangent(n, t)
                    }
                    computeFrenetFrames(e, t=!1) {
                        const n = new Q
                          , i = []
                          , s = []
                          , r = []
                          , l = new Q
                          , h = new Xt;
                        for (let _ = 0; _ <= e; _++) {
                            const x = _ / e;
                            i[_] = this.getTangentAt(x, new Q)
                        }
                        s[0] = new Q,
                        r[0] = new Q;
                        let d = Number.MAX_VALUE;
                        const p = Math.abs(i[0].x)
                          , m = Math.abs(i[0].y)
                          , v = Math.abs(i[0].z);
                        p <= d && (d = p,
                        n.set(1, 0, 0)),
                        m <= d && (d = m,
                        n.set(0, 1, 0)),
                        v <= d && n.set(0, 0, 1),
                        l.crossVectors(i[0], n).normalize(),
                        s[0].crossVectors(i[0], l),
                        r[0].crossVectors(i[0], s[0]);
                        for (let _ = 1; _ <= e; _++) {
                            if (s[_] = s[_ - 1].clone(),
                            r[_] = r[_ - 1].clone(),
                            l.crossVectors(i[_ - 1], i[_]),
                            l.length() > Number.EPSILON) {
                                l.normalize();
                                const x = Math.acos(kt(i[_ - 1].dot(i[_]), -1, 1));
                                s[_].applyMatrix4(h.makeRotationAxis(l, x))
                            }
                            r[_].crossVectors(i[_], s[_])
                        }
                        if (t === !0) {
                            let _ = Math.acos(kt(s[0].dot(s[e]), -1, 1));
                            _ /= e,
                            i[0].dot(l.crossVectors(s[0], s[e])) > 0 && (_ = -_);
                            for (let x = 1; x <= e; x++)
                                s[x].applyMatrix4(h.makeRotationAxis(i[x], _ * x)),
                                r[x].crossVectors(i[x], s[x])
                        }
                        return {
                            tangents: i,
                            normals: s,
                            binormals: r
                        }
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.7,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return e.arcLengthDivisions = this.arcLengthDivisions,
                        e.type = this.type,
                        e
                    }
                    fromJSON(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                }
                  , sx = class extends qo {
                    constructor(e=0, t=0, n=1, i=1, s=0, r=Math.PI * 2, l=!1, h=0) {
                        super(),
                        this.isEllipseCurve = !0,
                        this.type = "EllipseCurve",
                        this.aX = e,
                        this.aY = t,
                        this.xRadius = n,
                        this.yRadius = i,
                        this.aStartAngle = s,
                        this.aEndAngle = r,
                        this.aClockwise = l,
                        this.aRotation = h
                    }
                    getPoint(e, t=new ye) {
                        const n = t
                          , i = Math.PI * 2;
                        let s = this.aEndAngle - this.aStartAngle;
                        const r = Math.abs(s) < Number.EPSILON;
                        for (; s < 0; )
                            s += i;
                        for (; s > i; )
                            s -= i;
                        s < Number.EPSILON && (r ? s = 0 : s = i),
                        this.aClockwise === !0 && !r && (s === i ? s = -i : s = s - i);
                        const l = this.aStartAngle + e * s;
                        let h = this.aX + this.xRadius * Math.cos(l)
                          , d = this.aY + this.yRadius * Math.sin(l);
                        if (this.aRotation !== 0) {
                            const p = Math.cos(this.aRotation)
                              , m = Math.sin(this.aRotation)
                              , v = h - this.aX
                              , _ = d - this.aY;
                            h = v * p - _ * m + this.aX,
                            d = v * m + _ * p + this.aY
                        }
                        return n.set(h, d)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.aX = e.aX,
                        this.aY = e.aY,
                        this.xRadius = e.xRadius,
                        this.yRadius = e.yRadius,
                        this.aStartAngle = e.aStartAngle,
                        this.aEndAngle = e.aEndAngle,
                        this.aClockwise = e.aClockwise,
                        this.aRotation = e.aRotation,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.aX = this.aX,
                        e.aY = this.aY,
                        e.xRadius = this.xRadius,
                        e.yRadius = this.yRadius,
                        e.aStartAngle = this.aStartAngle,
                        e.aEndAngle = this.aEndAngle,
                        e.aClockwise = this.aClockwise,
                        e.aRotation = this.aRotation,
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.aX = e.aX,
                        this.aY = e.aY,
                        this.xRadius = e.xRadius,
                        this.yRadius = e.yRadius,
                        this.aStartAngle = e.aStartAngle,
                        this.aEndAngle = e.aEndAngle,
                        this.aClockwise = e.aClockwise,
                        this.aRotation = e.aRotation,
                        this
                    }
                }
                  , iC = class extends sx {
                    constructor(e, t, n, i, s, r) {
                        super(e, t, n, n, i, s, r),
                        this.isArcCurve = !0,
                        this.type = "ArcCurve"
                    }
                }
                ;
                function cT() {
                    let e = 0
                      , t = 0
                      , n = 0
                      , i = 0;
                    function s(r, l, h, d) {
                        e = r,
                        t = h,
                        n = -3 * r + 3 * l - 2 * h - d,
                        i = 2 * r - 2 * l + h + d
                    }
                    return {
                        initCatmullRom: function(r, l, h, d, p) {
                            s(l, h, p * (h - r), p * (d - l))
                        },
                        initNonuniformCatmullRom: function(r, l, h, d, p, m, v) {
                            let _ = (l - r) / p - (h - r) / (p + m) + (h - l) / m
                              , x = (h - l) / m - (d - l) / (m + v) + (d - h) / v;
                            _ *= m,
                            x *= m,
                            s(l, h, _, x)
                        },
                        calc: function(r) {
                            const l = r * r
                              , h = l * r;
                            return e + t * r + n * l + i * h
                        }
                    }
                }
                const ax = new Q
                  , uT = new cT
                  , hT = new cT
                  , fT = new cT;
                var sC = class extends qo {
                    constructor(e=[], t=!1, n="centripetal", i=.5) {
                        super(),
                        this.isCatmullRomCurve3 = !0,
                        this.type = "CatmullRomCurve3",
                        this.points = e,
                        this.closed = t,
                        this.curveType = n,
                        this.tension = i
                    }
                    getPoint(e, t=new Q) {
                        const n = t
                          , i = this.points
                          , s = i.length
                          , r = (s - (this.closed ? 0 : 1)) * e;
                        let l = Math.floor(r)
                          , h = r - l;
                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s : h === 0 && l === s - 1 && (l = s - 2,
                        h = 1);
                        let d, p;
                        this.closed || l > 0 ? d = i[(l - 1) % s] : (ax.subVectors(i[0], i[1]).add(i[0]),
                        d = ax);
                        const m = i[l % s]
                          , v = i[(l + 1) % s];
                        if (this.closed || l + 2 < s ? p = i[(l + 2) % s] : (ax.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]),
                        p = ax),
                        this.curveType === "centripetal" || this.curveType === "chordal") {
                            const _ = this.curveType === "chordal" ? .5 : .25;
                            let x = Math.pow(d.distanceToSquared(m), _)
                              , b = Math.pow(m.distanceToSquared(v), _)
                              , E = Math.pow(v.distanceToSquared(p), _);
                            b < 1e-4 && (b = 1),
                            x < 1e-4 && (x = b),
                            E < 1e-4 && (E = b),
                            uT.initNonuniformCatmullRom(d.x, m.x, v.x, p.x, x, b, E),
                            hT.initNonuniformCatmullRom(d.y, m.y, v.y, p.y, x, b, E),
                            fT.initNonuniformCatmullRom(d.z, m.z, v.z, p.z, x, b, E)
                        } else
                            this.curveType === "catmullrom" && (uT.initCatmullRom(d.x, m.x, v.x, p.x, this.tension),
                            hT.initCatmullRom(d.y, m.y, v.y, p.y, this.tension),
                            fT.initCatmullRom(d.z, m.z, v.z, p.z, this.tension));
                        return n.set(uT.calc(h), hT.calc(h), fT.calc(h)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(i.clone())
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const i = this.points[t];
                            e.points.push(i.toArray())
                        }
                        return e.closed = this.closed,
                        e.curveType = this.curveType,
                        e.tension = this.tension,
                        e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(new Q().fromArray(i))
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                }
                ;
                function aC(e, t, n, i, s) {
                    const r = (i - t) * .5
                      , l = (s - n) * .5
                      , h = e * e
                      , d = e * h;
                    return (2 * n - 2 * i + r + l) * d + (-3 * n + 3 * i - 2 * r - l) * h + r * e + n
                }
                function JB(e, t) {
                    const n = 1 - e;
                    return n * n * t
                }
                function $B(e, t) {
                    return 2 * (1 - e) * e * t
                }
                function eP(e, t) {
                    return e * e * t
                }
                function gv(e, t, n, i) {
                    return JB(e, t) + $B(e, n) + eP(e, i)
                }
                function tP(e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }
                function nP(e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }
                function iP(e, t) {
                    return 3 * (1 - e) * e * e * t
                }
                function sP(e, t) {
                    return e * e * e * t
                }
                function vv(e, t, n, i, s) {
                    return tP(e, t) + nP(e, n) + iP(e, i) + sP(e, s)
                }
                var dT = class extends qo {
                    constructor(e=new ye, t=new ye, n=new ye, i=new ye) {
                        super(),
                        this.isCubicBezierCurve = !0,
                        this.type = "CubicBezierCurve",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(e, t=new ye) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , r = this.v2
                          , l = this.v3;
                        return n.set(vv(e, i.x, s.x, r.x, l.x), vv(e, i.y, s.y, r.y, l.y)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                  , rC = class extends qo {
                    constructor(e=new Q, t=new Q, n=new Q, i=new Q) {
                        super(),
                        this.isCubicBezierCurve3 = !0,
                        this.type = "CubicBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(e, t=new Q) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , r = this.v2
                          , l = this.v3;
                        return n.set(vv(e, i.x, s.x, r.x, l.x), vv(e, i.y, s.y, r.y, l.y), vv(e, i.z, s.z, r.z, l.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                  , pT = class extends qo {
                    constructor(e=new ye, t=new ye) {
                        super(),
                        this.isLineCurve = !0,
                        this.type = "LineCurve",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new ye) {
                        const n = t;
                        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new ye) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , oC = class extends qo {
                    constructor(e=new Q, t=new Q) {
                        super(),
                        this.isLineCurve3 = !0,
                        this.type = "LineCurve3",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new Q) {
                        const n = t;
                        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new Q) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , mT = class extends qo {
                    constructor(e=new ye, t=new ye, n=new ye) {
                        super(),
                        this.isQuadraticBezierCurve = !0,
                        this.type = "QuadraticBezierCurve",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n
                    }
                    getPoint(e, t=new ye) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , r = this.v2;
                        return n.set(gv(e, i.x, s.x, r.x), gv(e, i.y, s.y, r.y)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , gT = class extends qo {
                    constructor(e=new Q, t=new Q, n=new Q) {
                        super(),
                        this.isQuadraticBezierCurve3 = !0,
                        this.type = "QuadraticBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n
                    }
                    getPoint(e, t=new Q) {
                        const n = t
                          , i = this.v0
                          , s = this.v1
                          , r = this.v2;
                        return n.set(gv(e, i.x, s.x, r.x), gv(e, i.y, s.y, r.y), gv(e, i.z, s.z, r.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , vT = class extends qo {
                    constructor(e=[]) {
                        super(),
                        this.isSplineCurve = !0,
                        this.type = "SplineCurve",
                        this.points = e
                    }
                    getPoint(e, t=new ye) {
                        const n = t
                          , i = this.points
                          , s = (i.length - 1) * e
                          , r = Math.floor(s)
                          , l = s - r
                          , h = i[r === 0 ? r : r - 1]
                          , d = i[r]
                          , p = i[r > i.length - 2 ? i.length - 1 : r + 1]
                          , m = i[r > i.length - 3 ? i.length - 1 : r + 2];
                        return n.set(aC(l, h.x, d.x, p.x, m.x), aC(l, h.y, d.y, p.y, m.y)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(i.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const i = this.points[t];
                            e.points.push(i.toArray())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const i = e.points[t];
                            this.points.push(new ye().fromArray(i))
                        }
                        return this
                    }
                }
                  , rx = Object.freeze({
                    __proto__: null,
                    ArcCurve: iC,
                    CatmullRomCurve3: sC,
                    CubicBezierCurve: dT,
                    CubicBezierCurve3: rC,
                    EllipseCurve: sx,
                    LineCurve: pT,
                    LineCurve3: oC,
                    QuadraticBezierCurve: mT,
                    QuadraticBezierCurve3: gT,
                    SplineCurve: vT
                })
                  , lC = class extends qo {
                    constructor() {
                        super(),
                        this.type = "CurvePath",
                        this.curves = [],
                        this.autoClose = !1
                    }
                    add(e) {
                        this.curves.push(e)
                    }
                    closePath() {
                        const e = this.curves[0].getPoint(0)
                          , t = this.curves[this.curves.length - 1].getPoint(1);
                        if (!e.equals(t)) {
                            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                            this.curves.push(new rx[n](t,e))
                        }
                        return this
                    }
                    getPoint(e, t) {
                        const n = e * this.getLength()
                          , i = this.getCurveLengths();
                        let s = 0;
                        for (; s < i.length; ) {
                            if (i[s] >= n) {
                                const r = i[s] - n
                                  , l = this.curves[s]
                                  , h = l.getLength()
                                  , d = h === 0 ? 0 : 1 - r / h;
                                return l.getPointAt(d, t)
                            }
                            s++
                        }
                        return null
                    }
                    getLength() {
                        const e = this.getCurveLengths();
                        return e[e.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.cacheLengths = null,
                        this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                            return this.cacheLengths;
                        const e = [];
                        let t = 0;
                        for (let n = 0, i = this.curves.length; n < i; n++)
                            t += this.curves[n].getLength(),
                            e.push(t);
                        return this.cacheLengths = e,
                        e
                    }
                    getSpacedPoints(e=40) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return this.autoClose && t.push(t[0]),
                        t
                    }
                    getPoints(e=12) {
                        const t = [];
                        let n;
                        for (let i = 0, s = this.curves; i < s.length; i++) {
                            const r = s[i]
                              , l = r.isEllipseCurve ? e * 2 : r.isLineCurve || r.isLineCurve3 ? 1 : r.isSplineCurve ? e * r.points.length : e
                              , h = r.getPoints(l);
                            for (let d = 0; d < h.length; d++) {
                                const p = h[d];
                                n && n.equals(p) || (t.push(p),
                                n = p)
                            }
                        }
                        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                        t
                    }
                    copy(e) {
                        super.copy(e),
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const i = e.curves[t];
                            this.curves.push(i.clone())
                        }
                        return this.autoClose = e.autoClose,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.autoClose = this.autoClose,
                        e.curves = [];
                        for (let t = 0, n = this.curves.length; t < n; t++) {
                            const i = this.curves[t];
                            e.curves.push(i.toJSON())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.autoClose = e.autoClose,
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const i = e.curves[t];
                            this.curves.push(new rx[i.type]().fromJSON(i))
                        }
                        return this
                    }
                }
                  , ox = class extends lC {
                    constructor(e) {
                        super(),
                        this.type = "Path",
                        this.currentPoint = new ye,
                        e && this.setFromPoints(e)
                    }
                    setFromPoints(e) {
                        this.moveTo(e[0].x, e[0].y);
                        for (let t = 1, n = e.length; t < n; t++)
                            this.lineTo(e[t].x, e[t].y);
                        return this
                    }
                    moveTo(e, t) {
                        return this.currentPoint.set(e, t),
                        this
                    }
                    lineTo(e, t) {
                        const n = new pT(this.currentPoint.clone(),new ye(e,t));
                        return this.curves.push(n),
                        this.currentPoint.set(e, t),
                        this
                    }
                    quadraticCurveTo(e, t, n, i) {
                        const s = new mT(this.currentPoint.clone(),new ye(e,t),new ye(n,i));
                        return this.curves.push(s),
                        this.currentPoint.set(n, i),
                        this
                    }
                    bezierCurveTo(e, t, n, i, s, r) {
                        const l = new dT(this.currentPoint.clone(),new ye(e,t),new ye(n,i),new ye(s,r));
                        return this.curves.push(l),
                        this.currentPoint.set(s, r),
                        this
                    }
                    splineThru(e) {
                        const t = [this.currentPoint.clone()].concat(e)
                          , n = new vT(t);
                        return this.curves.push(n),
                        this.currentPoint.copy(e[e.length - 1]),
                        this
                    }
                    arc(e, t, n, i, s, r) {
                        const l = this.currentPoint.x
                          , h = this.currentPoint.y;
                        return this.absarc(e + l, t + h, n, i, s, r),
                        this
                    }
                    absarc(e, t, n, i, s, r) {
                        return this.absellipse(e, t, n, n, i, s, r),
                        this
                    }
                    ellipse(e, t, n, i, s, r, l, h) {
                        const d = this.currentPoint.x
                          , p = this.currentPoint.y;
                        return this.absellipse(e + d, t + p, n, i, s, r, l, h),
                        this
                    }
                    absellipse(e, t, n, i, s, r, l, h) {
                        const d = new sx(e,t,n,i,s,r,l,h);
                        if (this.curves.length > 0) {
                            const m = d.getPoint(0);
                            m.equals(this.currentPoint) || this.lineTo(m.x, m.y)
                        }
                        this.curves.push(d);
                        const p = d.getPoint(1);
                        return this.currentPoint.copy(p),
                        this
                    }
                    copy(e) {
                        return super.copy(e),
                        this.currentPoint.copy(e.currentPoint),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.currentPoint = this.currentPoint.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.currentPoint.fromArray(e.currentPoint),
                        this
                    }
                }
                  , gf = class extends ox {
                    constructor(e) {
                        super(e),
                        this.uuid = wr(),
                        this.type = "Shape",
                        this.holes = []
                    }
                    getPointsHoles(e) {
                        const t = [];
                        for (let n = 0, i = this.holes.length; n < i; n++)
                            t[n] = this.holes[n].getPoints(e);
                        return t
                    }
                    extractPoints(e) {
                        return {
                            shape: this.getPoints(e),
                            holes: this.getPointsHoles(e)
                        }
                    }
                    copy(e) {
                        super.copy(e),
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const i = e.holes[t];
                            this.holes.push(i.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.uuid = this.uuid,
                        e.holes = [];
                        for (let t = 0, n = this.holes.length; t < n; t++) {
                            const i = this.holes[t];
                            e.holes.push(i.toJSON())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.uuid = e.uuid,
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const i = e.holes[t];
                            this.holes.push(new ox().fromJSON(i))
                        }
                        return this
                    }
                }
                ;
                function aP(e, t, n=2) {
                    const i = t && t.length
                      , s = i ? t[0] * n : e.length;
                    let r = cC(e, 0, s, n, !0);
                    const l = [];
                    if (!r || r.next === r.prev)
                        return l;
                    let h, d, p;
                    if (i && (r = uP(e, t, r, n)),
                    e.length > 80 * n) {
                        h = 1 / 0,
                        d = 1 / 0;
                        let m = -1 / 0
                          , v = -1 / 0;
                        for (let _ = n; _ < s; _ += n) {
                            const x = e[_]
                              , b = e[_ + 1];
                            x < h && (h = x),
                            b < d && (d = b),
                            x > m && (m = x),
                            b > v && (v = b)
                        }
                        p = Math.max(m - h, v - d),
                        p = p !== 0 ? 32767 / p : 0
                    }
                    return yv(r, l, n, h, d, p, 0),
                    l
                }
                function cC(e, t, n, i, s) {
                    let r;
                    if (s === SP(e, t, n, i) > 0)
                        for (let l = t; l < n; l += i)
                            r = dC(l / i | 0, e[l], e[l + 1], r);
                    else
                        for (let l = n - i; l >= t; l -= i)
                            r = dC(l / i | 0, e[l], e[l + 1], r);
                    return r && Bp(r, r.next) && (Sv(r),
                    r = r.next),
                    r
                }
                function vf(e, t) {
                    if (!e)
                        return e;
                    t || (t = e);
                    let n = e, i;
                    do
                        if (i = !1,
                        !n.steiner && (Bp(n, n.next) || Oi(n.prev, n, n.next) === 0)) {
                            if (Sv(n),
                            n = t = n.prev,
                            n === n.next)
                                break;
                            i = !0
                        } else
                            n = n.next;
                    while (i || n !== t);
                    return t
                }
                function yv(e, t, n, i, s, r, l) {
                    if (!e)
                        return;
                    !l && r && mP(e, i, s, r);
                    let h = e;
                    for (; e.prev !== e.next; ) {
                        const d = e.prev
                          , p = e.next;
                        if (r ? oP(e, i, s, r) : rP(e)) {
                            t.push(d.i, e.i, p.i),
                            Sv(e),
                            e = p.next,
                            h = p.next;
                            continue
                        }
                        if (e = p,
                        e === h) {
                            l ? l === 1 ? (e = lP(vf(e), t),
                            yv(e, t, n, i, s, r, 2)) : l === 2 && cP(e, t, n, i, s, r) : yv(vf(e), t, n, i, s, r, 1);
                            break
                        }
                    }
                }
                function rP(e) {
                    const t = e.prev
                      , n = e
                      , i = e.next;
                    if (Oi(t, n, i) >= 0)
                        return !1;
                    const s = t.x
                      , r = n.x
                      , l = i.x
                      , h = t.y
                      , d = n.y
                      , p = i.y
                      , m = Math.min(s, r, l)
                      , v = Math.min(h, d, p)
                      , _ = Math.max(s, r, l)
                      , x = Math.max(h, d, p);
                    let b = i.next;
                    for (; b !== t; ) {
                        if (b.x >= m && b.x <= _ && b.y >= v && b.y <= x && _v(s, h, r, d, l, p, b.x, b.y) && Oi(b.prev, b, b.next) >= 0)
                            return !1;
                        b = b.next
                    }
                    return !0
                }
                function oP(e, t, n, i) {
                    const s = e.prev
                      , r = e
                      , l = e.next;
                    if (Oi(s, r, l) >= 0)
                        return !1;
                    const h = s.x
                      , d = r.x
                      , p = l.x
                      , m = s.y
                      , v = r.y
                      , _ = l.y
                      , x = Math.min(h, d, p)
                      , b = Math.min(m, v, _)
                      , E = Math.max(h, d, p)
                      , T = Math.max(m, v, _)
                      , M = yT(x, b, t, n, i)
                      , D = yT(E, T, t, n, i);
                    let R = e.prevZ
                      , O = e.nextZ;
                    for (; R && R.z >= M && O && O.z <= D; ) {
                        if (R.x >= x && R.x <= E && R.y >= b && R.y <= T && R !== s && R !== l && _v(h, m, d, v, p, _, R.x, R.y) && Oi(R.prev, R, R.next) >= 0 || (R = R.prevZ,
                        O.x >= x && O.x <= E && O.y >= b && O.y <= T && O !== s && O !== l && _v(h, m, d, v, p, _, O.x, O.y) && Oi(O.prev, O, O.next) >= 0))
                            return !1;
                        O = O.nextZ
                    }
                    for (; R && R.z >= M; ) {
                        if (R.x >= x && R.x <= E && R.y >= b && R.y <= T && R !== s && R !== l && _v(h, m, d, v, p, _, R.x, R.y) && Oi(R.prev, R, R.next) >= 0)
                            return !1;
                        R = R.prevZ
                    }
                    for (; O && O.z <= D; ) {
                        if (O.x >= x && O.x <= E && O.y >= b && O.y <= T && O !== s && O !== l && _v(h, m, d, v, p, _, O.x, O.y) && Oi(O.prev, O, O.next) >= 0)
                            return !1;
                        O = O.nextZ
                    }
                    return !0
                }
                function lP(e, t) {
                    let n = e;
                    do {
                        const i = n.prev
                          , s = n.next.next;
                        !Bp(i, s) && hC(i, n, n.next, s) && xv(i, s) && xv(s, i) && (t.push(i.i, n.i, s.i),
                        Sv(n),
                        Sv(n.next),
                        n = e = s),
                        n = n.next
                    } while (n !== e);
                    return vf(n)
                }
                function cP(e, t, n, i, s, r) {
                    let l = e;
                    do {
                        let h = l.next.next;
                        for (; h !== l.prev; ) {
                            if (l.i !== h.i && yP(l, h)) {
                                let d = fC(l, h);
                                l = vf(l, l.next),
                                d = vf(d, d.next),
                                yv(l, t, n, i, s, r, 0),
                                yv(d, t, n, i, s, r, 0);
                                return
                            }
                            h = h.next
                        }
                        l = l.next
                    } while (l !== e)
                }
                function uP(e, t, n, i) {
                    const s = [];
                    for (let r = 0, l = t.length; r < l; r++) {
                        const h = t[r] * i
                          , d = r < l - 1 ? t[r + 1] * i : e.length
                          , p = cC(e, h, d, i, !1);
                        p === p.next && (p.steiner = !0),
                        s.push(vP(p))
                    }
                    s.sort(hP);
                    for (let r = 0; r < s.length; r++)
                        n = fP(s[r], n);
                    return n
                }
                function hP(e, t) {
                    let n = e.x - t.x;
                    if (n === 0 && (n = e.y - t.y,
                    n === 0)) {
                        const i = (e.next.y - e.y) / (e.next.x - e.x)
                          , s = (t.next.y - t.y) / (t.next.x - t.x);
                        n = i - s
                    }
                    return n
                }
                function fP(e, t) {
                    const n = dP(e, t);
                    if (!n)
                        return t;
                    const i = fC(n, e);
                    return vf(i, i.next),
                    vf(n, n.next)
                }
                function dP(e, t) {
                    let n = t;
                    const i = e.x
                      , s = e.y;
                    let r = -1 / 0, l;
                    if (Bp(e, n))
                        return n;
                    do {
                        if (Bp(e, n.next))
                            return n.next;
                        if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                            const v = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (v <= i && v > r && (r = v,
                            l = n.x < n.next.x ? n : n.next,
                            v === i))
                                return l
                        }
                        n = n.next
                    } while (n !== t);
                    if (!l)
                        return null;
                    const h = l
                      , d = l.x
                      , p = l.y;
                    let m = 1 / 0;
                    n = l;
                    do {
                        if (i >= n.x && n.x >= d && i !== n.x && uC(s < p ? i : r, s, d, p, s < p ? r : i, s, n.x, n.y)) {
                            const v = Math.abs(s - n.y) / (i - n.x);
                            xv(n, e) && (v < m || v === m && (n.x > l.x || n.x === l.x && pP(l, n))) && (l = n,
                            m = v)
                        }
                        n = n.next
                    } while (n !== h);
                    return l
                }
                function pP(e, t) {
                    return Oi(e.prev, e, t.prev) < 0 && Oi(t.next, e, e.next) < 0
                }
                function mP(e, t, n, i) {
                    let s = e;
                    do
                        s.z === 0 && (s.z = yT(s.x, s.y, t, n, i)),
                        s.prevZ = s.prev,
                        s.nextZ = s.next,
                        s = s.next;
                    while (s !== e);
                    s.prevZ.nextZ = null,
                    s.prevZ = null,
                    gP(s)
                }
                function gP(e) {
                    let t, n = 1;
                    do {
                        let i = e, s;
                        e = null;
                        let r = null;
                        for (t = 0; i; ) {
                            t++;
                            let l = i
                              , h = 0;
                            for (let p = 0; p < n && (h++,
                            l = l.nextZ,
                            !!l); p++)
                                ;
                            let d = n;
                            for (; h > 0 || d > 0 && l; )
                                h !== 0 && (d === 0 || !l || i.z <= l.z) ? (s = i,
                                i = i.nextZ,
                                h--) : (s = l,
                                l = l.nextZ,
                                d--),
                                r ? r.nextZ = s : e = s,
                                s.prevZ = r,
                                r = s;
                            i = l
                        }
                        r.nextZ = null,
                        n *= 2
                    } while (t > 1);
                    return e
                }
                function yT(e, t, n, i, s) {
                    return e = (e - n) * s | 0,
                    t = (t - i) * s | 0,
                    e = (e | e << 8) & 16711935,
                    e = (e | e << 4) & 252645135,
                    e = (e | e << 2) & 858993459,
                    e = (e | e << 1) & 1431655765,
                    t = (t | t << 8) & 16711935,
                    t = (t | t << 4) & 252645135,
                    t = (t | t << 2) & 858993459,
                    t = (t | t << 1) & 1431655765,
                    e | t << 1
                }
                function vP(e) {
                    let t = e
                      , n = e;
                    do
                        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                        t = t.next;
                    while (t !== e);
                    return n
                }
                function uC(e, t, n, i, s, r, l, h) {
                    return (s - l) * (t - h) >= (e - l) * (r - h) && (e - l) * (i - h) >= (n - l) * (t - h) && (n - l) * (r - h) >= (s - l) * (i - h)
                }
                function _v(e, t, n, i, s, r, l, h) {
                    return !(e === l && t === h) && uC(e, t, n, i, s, r, l, h)
                }
                function yP(e, t) {
                    return e.next.i !== t.i && e.prev.i !== t.i && !_P(e, t) && (xv(e, t) && xv(t, e) && xP(e, t) && (Oi(e.prev, e, t.prev) || Oi(e, t.prev, t)) || Bp(e, t) && Oi(e.prev, e, e.next) > 0 && Oi(t.prev, t, t.next) > 0)
                }
                function Oi(e, t, n) {
                    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
                }
                function Bp(e, t) {
                    return e.x === t.x && e.y === t.y
                }
                function hC(e, t, n, i) {
                    const s = cx(Oi(e, t, n))
                      , r = cx(Oi(e, t, i))
                      , l = cx(Oi(n, i, e))
                      , h = cx(Oi(n, i, t));
                    return !!(s !== r && l !== h || s === 0 && lx(e, n, t) || r === 0 && lx(e, i, t) || l === 0 && lx(n, e, i) || h === 0 && lx(n, t, i))
                }
                function lx(e, t, n) {
                    return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
                }
                function cx(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0
                }
                function _P(e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && hC(n, n.next, e, t))
                            return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }
                function xv(e, t) {
                    return Oi(e.prev, e, e.next) < 0 ? Oi(e, t, e.next) >= 0 && Oi(e, e.prev, t) >= 0 : Oi(e, t, e.prev) < 0 || Oi(e, e.next, t) < 0
                }
                function xP(e, t) {
                    let n = e
                      , i = !1;
                    const s = (e.x + t.x) / 2
                      , r = (e.y + t.y) / 2;
                    do
                        n.y > r != n.next.y > r && n.next.y !== n.y && s < (n.next.x - n.x) * (r - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                        n = n.next;
                    while (n !== e);
                    return i
                }
                function fC(e, t) {
                    const n = _T(e.i, e.x, e.y)
                      , i = _T(t.i, t.x, t.y)
                      , s = e.next
                      , r = t.prev;
                    return e.next = t,
                    t.prev = e,
                    n.next = s,
                    s.prev = n,
                    i.next = n,
                    n.prev = i,
                    r.next = i,
                    i.prev = r,
                    i
                }
                function dC(e, t, n, i) {
                    const s = _T(e, t, n);
                    return i ? (s.next = i.next,
                    s.prev = i,
                    i.next.prev = s,
                    i.next = s) : (s.prev = s,
                    s.next = s),
                    s
                }
                function Sv(e) {
                    e.next.prev = e.prev,
                    e.prev.next = e.next,
                    e.prevZ && (e.prevZ.nextZ = e.nextZ),
                    e.nextZ && (e.nextZ.prevZ = e.prevZ)
                }
                function _T(e, t, n) {
                    return {
                        i: e,
                        x: t,
                        y: n,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                function SP(e, t, n, i) {
                    let s = 0;
                    for (let r = t, l = n - i; r < n; r += i)
                        s += (e[l] - e[r]) * (e[r + 1] + e[l + 1]),
                        l = r;
                    return s
                }
                var AP = class {
                    static triangulate(e, t, n=2) {
                        return aP(e, t, n)
                    }
                }
                  , Dc = class zO {
                    static area(t) {
                        const n = t.length;
                        let i = 0;
                        for (let s = n - 1, r = 0; r < n; s = r++)
                            i += t[s].x * t[r].y - t[r].x * t[s].y;
                        return i * .5
                    }
                    static isClockWise(t) {
                        return zO.area(t) < 0
                    }
                    static triangulateShape(t, n) {
                        const i = []
                          , s = []
                          , r = [];
                        pC(t),
                        mC(i, t);
                        let l = t.length;
                        n.forEach(pC);
                        for (let d = 0; d < n.length; d++)
                            s.push(l),
                            l += n[d].length,
                            mC(i, n[d]);
                        const h = AP.triangulate(i, s);
                        for (let d = 0; d < h.length; d += 3)
                            r.push(h.slice(d, d + 3));
                        return r
                    }
                }
                ;
                function pC(e) {
                    const t = e.length;
                    t > 2 && e[t - 1].equals(e[0]) && e.pop()
                }
                function mC(e, t) {
                    for (let n = 0; n < t.length; n++)
                        e.push(t[n].x),
                        e.push(t[n].y)
                }
                var gC = class FO extends an {
                    constructor(t=new gf([new ye(.5,.5), new ye(-.5,.5), new ye(-.5,-.5), new ye(.5,-.5)]), n={}) {
                        super(),
                        this.type = "ExtrudeGeometry",
                        this.parameters = {
                            shapes: t,
                            options: n
                        },
                        t = Array.isArray(t) ? t : [t];
                        const i = this
                          , s = []
                          , r = [];
                        for (let h = 0, d = t.length; h < d; h++) {
                            const p = t[h];
                            l(p)
                        }
                        this.setAttribute("position", new At(s,3)),
                        this.setAttribute("uv", new At(r,2)),
                        this.computeVertexNormals();
                        function l(h) {
                            const d = []
                              , p = n.curveSegments !== void 0 ? n.curveSegments : 12
                              , m = n.steps !== void 0 ? n.steps : 1
                              , v = n.depth !== void 0 ? n.depth : 1;
                            let _ = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0
                              , x = n.bevelThickness !== void 0 ? n.bevelThickness : .2
                              , b = n.bevelSize !== void 0 ? n.bevelSize : x - .1
                              , E = n.bevelOffset !== void 0 ? n.bevelOffset : 0
                              , T = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
                            const M = n.extrudePath
                              , D = n.UVGenerator !== void 0 ? n.UVGenerator : TP;
                            let R, O = !1, U, B, I, F;
                            M && (R = M.getSpacedPoints(m),
                            O = !0,
                            _ = !1,
                            U = M.computeFrenetFrames(m, !1),
                            B = new Q,
                            I = new Q,
                            F = new Q),
                            _ || (T = 0,
                            x = 0,
                            b = 0,
                            E = 0);
                            const P = h.extractPoints(p);
                            let L = P.shape;
                            const H = P.holes;
                            if (!Dc.isClockWise(L)) {
                                L = L.reverse();
                                for (let Ve = 0, de = H.length; Ve < de; Ve++) {
                                    const Te = H[Ve];
                                    Dc.isClockWise(Te) && (H[Ve] = Te.reverse())
                                }
                            }
                            function Z(Ve) {
                                const Te = 10000000000000001e-36;
                                let Pe = Ve[0];
                                for (let Ye = 1; Ye <= Ve.length; Ye++) {
                                    const Ie = Ye % Ve.length
                                      , Fe = Ve[Ie]
                                      , xt = Fe.x - Pe.x
                                      , yt = Fe.y - Pe.y
                                      , wt = xt * xt + yt * yt
                                      , $ = Math.max(Math.abs(Fe.x), Math.abs(Fe.y), Math.abs(Pe.x), Math.abs(Pe.y))
                                      , k = Te * $ * $;
                                    if (wt <= k) {
                                        Ve.splice(Ie, 1),
                                        Ye--;
                                        continue
                                    }
                                    Pe = Fe
                                }
                            }
                            Z(L),
                            H.forEach(Z);
                            const K = H.length
                              , te = L;
                            for (let Ve = 0; Ve < K; Ve++) {
                                const de = H[Ve];
                                L = L.concat(de)
                            }
                            function ce(Ve, de, Te) {
                                return de || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                                Ve.clone().addScaledVector(de, Te)
                            }
                            const G = L.length;
                            function V(Ve, de, Te) {
                                let Pe, Ye, Ie;
                                const Fe = Ve.x - de.x
                                  , xt = Ve.y - de.y
                                  , yt = Te.x - Ve.x
                                  , wt = Te.y - Ve.y
                                  , $ = Fe * Fe + xt * xt
                                  , k = Fe * wt - xt * yt;
                                if (Math.abs(k) > Number.EPSILON) {
                                    const pe = Math.sqrt($)
                                      , Ge = Math.sqrt(yt * yt + wt * wt)
                                      , Qe = de.x - xt / pe
                                      , Be = de.y + Fe / pe
                                      , ct = Te.x - wt / Ge
                                      , Ke = Te.y + yt / Ge
                                      , _t = ((ct - Qe) * wt - (Ke - Be) * yt) / (Fe * wt - xt * yt);
                                    Pe = Qe + Fe * _t - Ve.x,
                                    Ye = Be + xt * _t - Ve.y;
                                    const Ct = Pe * Pe + Ye * Ye;
                                    if (Ct <= 2)
                                        return new ye(Pe,Ye);
                                    Ie = Math.sqrt(Ct / 2)
                                } else {
                                    let pe = !1;
                                    Fe > Number.EPSILON ? yt > Number.EPSILON && (pe = !0) : Fe < -Number.EPSILON ? yt < -Number.EPSILON && (pe = !0) : Math.sign(xt) === Math.sign(wt) && (pe = !0),
                                    pe ? (Pe = -xt,
                                    Ye = Fe,
                                    Ie = Math.sqrt($)) : (Pe = Fe,
                                    Ye = xt,
                                    Ie = Math.sqrt($ / 2))
                                }
                                return new ye(Pe / Ie,Ye / Ie)
                            }
                            const q = [];
                            for (let Ve = 0, de = te.length, Te = de - 1, Pe = Ve + 1; Ve < de; Ve++,
                            Te++,
                            Pe++)
                                Te === de && (Te = 0),
                                Pe === de && (Pe = 0),
                                q[Ve] = V(te[Ve], te[Te], te[Pe]);
                            const ee = [];
                            let se, X = q.concat();
                            for (let Ve = 0, de = K; Ve < de; Ve++) {
                                const Te = H[Ve];
                                se = [];
                                for (let Pe = 0, Ye = Te.length, Ie = Ye - 1, Fe = Pe + 1; Pe < Ye; Pe++,
                                Ie++,
                                Fe++)
                                    Ie === Ye && (Ie = 0),
                                    Fe === Ye && (Fe = 0),
                                    se[Pe] = V(Te[Pe], Te[Ie], Te[Fe]);
                                ee.push(se),
                                X = X.concat(se)
                            }
                            let J;
                            if (T === 0)
                                J = Dc.triangulateShape(te, H);
                            else {
                                const Ve = []
                                  , de = [];
                                for (let Te = 0; Te < T; Te++) {
                                    const Pe = Te / T
                                      , Ye = x * Math.cos(Pe * Math.PI / 2)
                                      , Ie = b * Math.sin(Pe * Math.PI / 2) + E;
                                    for (let Fe = 0, xt = te.length; Fe < xt; Fe++) {
                                        const yt = ce(te[Fe], q[Fe], Ie);
                                        Ue(yt.x, yt.y, -Ye),
                                        Pe === 0 && Ve.push(yt)
                                    }
                                    for (let Fe = 0, xt = K; Fe < xt; Fe++) {
                                        const yt = H[Fe];
                                        se = ee[Fe];
                                        const wt = [];
                                        for (let $ = 0, k = yt.length; $ < k; $++) {
                                            const pe = ce(yt[$], se[$], Ie);
                                            Ue(pe.x, pe.y, -Ye),
                                            Pe === 0 && wt.push(pe)
                                        }
                                        Pe === 0 && de.push(wt)
                                    }
                                }
                                J = Dc.triangulateShape(Ve, de)
                            }
                            const ze = J.length
                              , xe = b + E;
                            for (let Ve = 0; Ve < G; Ve++) {
                                const de = _ ? ce(L[Ve], X[Ve], xe) : L[Ve];
                                O ? (I.copy(U.normals[0]).multiplyScalar(de.x),
                                B.copy(U.binormals[0]).multiplyScalar(de.y),
                                F.copy(R[0]).add(I).add(B),
                                Ue(F.x, F.y, F.z)) : Ue(de.x, de.y, 0)
                            }
                            for (let Ve = 1; Ve <= m; Ve++)
                                for (let de = 0; de < G; de++) {
                                    const Te = _ ? ce(L[de], X[de], xe) : L[de];
                                    O ? (I.copy(U.normals[Ve]).multiplyScalar(Te.x),
                                    B.copy(U.binormals[Ve]).multiplyScalar(Te.y),
                                    F.copy(R[Ve]).add(I).add(B),
                                    Ue(F.x, F.y, F.z)) : Ue(Te.x, Te.y, v / m * Ve)
                                }
                            for (let Ve = T - 1; Ve >= 0; Ve--) {
                                const de = Ve / T
                                  , Te = x * Math.cos(de * Math.PI / 2)
                                  , Pe = b * Math.sin(de * Math.PI / 2) + E;
                                for (let Ye = 0, Ie = te.length; Ye < Ie; Ye++) {
                                    const Fe = ce(te[Ye], q[Ye], Pe);
                                    Ue(Fe.x, Fe.y, v + Te)
                                }
                                for (let Ye = 0, Ie = H.length; Ye < Ie; Ye++) {
                                    const Fe = H[Ye];
                                    se = ee[Ye];
                                    for (let xt = 0, yt = Fe.length; xt < yt; xt++) {
                                        const wt = ce(Fe[xt], se[xt], Pe);
                                        O ? Ue(wt.x, wt.y + R[m - 1].y, R[m - 1].x + Te) : Ue(wt.x, wt.y, v + Te)
                                    }
                                }
                            }
                            le(),
                            Ne();
                            function le() {
                                const Ve = s.length / 3;
                                if (_) {
                                    let de = 0
                                      , Te = G * de;
                                    for (let Pe = 0; Pe < ze; Pe++) {
                                        const Ye = J[Pe];
                                        $e(Ye[2] + Te, Ye[1] + Te, Ye[0] + Te)
                                    }
                                    de = m + T * 2,
                                    Te = G * de;
                                    for (let Pe = 0; Pe < ze; Pe++) {
                                        const Ye = J[Pe];
                                        $e(Ye[0] + Te, Ye[1] + Te, Ye[2] + Te)
                                    }
                                } else {
                                    for (let de = 0; de < ze; de++) {
                                        const Te = J[de];
                                        $e(Te[2], Te[1], Te[0])
                                    }
                                    for (let de = 0; de < ze; de++) {
                                        const Te = J[de];
                                        $e(Te[0] + G * m, Te[1] + G * m, Te[2] + G * m)
                                    }
                                }
                                i.addGroup(Ve, s.length / 3 - Ve, 0)
                            }
                            function Ne() {
                                const Ve = s.length / 3;
                                let de = 0;
                                be(te, de),
                                de += te.length;
                                for (let Te = 0, Pe = H.length; Te < Pe; Te++) {
                                    const Ye = H[Te];
                                    be(Ye, de),
                                    de += Ye.length
                                }
                                i.addGroup(Ve, s.length / 3 - Ve, 1)
                            }
                            function be(Ve, de) {
                                let Te = Ve.length;
                                for (; --Te >= 0; ) {
                                    const Pe = Te;
                                    let Ye = Te - 1;
                                    Ye < 0 && (Ye = Ve.length - 1);
                                    for (let Ie = 0, Fe = m + T * 2; Ie < Fe; Ie++) {
                                        const xt = G * Ie
                                          , yt = G * (Ie + 1)
                                          , wt = de + Pe + xt
                                          , $ = de + Ye + xt
                                          , k = de + Ye + yt
                                          , pe = de + Pe + yt;
                                        rt(wt, $, k, pe)
                                    }
                                }
                            }
                            function Ue(Ve, de, Te) {
                                d.push(Ve),
                                d.push(de),
                                d.push(Te)
                            }
                            function $e(Ve, de, Te) {
                                Et(Ve),
                                Et(de),
                                Et(Te);
                                const Pe = s.length / 3
                                  , Ye = D.generateTopUV(i, s, Pe - 3, Pe - 2, Pe - 1);
                                ne(Ye[0]),
                                ne(Ye[1]),
                                ne(Ye[2])
                            }
                            function rt(Ve, de, Te, Pe) {
                                Et(Ve),
                                Et(de),
                                Et(Pe),
                                Et(de),
                                Et(Te),
                                Et(Pe);
                                const Ye = s.length / 3
                                  , Ie = D.generateSideWallUV(i, s, Ye - 6, Ye - 3, Ye - 2, Ye - 1);
                                ne(Ie[0]),
                                ne(Ie[1]),
                                ne(Ie[3]),
                                ne(Ie[1]),
                                ne(Ie[2]),
                                ne(Ie[3])
                            }
                            function Et(Ve) {
                                s.push(d[Ve * 3 + 0]),
                                s.push(d[Ve * 3 + 1]),
                                s.push(d[Ve * 3 + 2])
                            }
                            function ne(Ve) {
                                r.push(Ve.x),
                                r.push(Ve.y)
                            }
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON()
                          , n = this.parameters.shapes
                          , i = this.parameters.options;
                        return MP(n, i, t)
                    }
                    static fromJSON(t, n) {
                        const i = [];
                        for (let r = 0, l = t.shapes.length; r < l; r++) {
                            const h = n[t.shapes[r]];
                            i.push(h)
                        }
                        const s = t.options.extrudePath;
                        return s !== void 0 && (t.options.extrudePath = new rx[s.type]().fromJSON(s)),
                        new FO(i,t.options)
                    }
                }
                ;
                const TP = {
                    generateTopUV: function(e, t, n, i, s) {
                        const r = t[n * 3]
                          , l = t[n * 3 + 1]
                          , h = t[i * 3]
                          , d = t[i * 3 + 1]
                          , p = t[s * 3]
                          , m = t[s * 3 + 1];
                        return [new ye(r,l), new ye(h,d), new ye(p,m)]
                    },
                    generateSideWallUV: function(e, t, n, i, s, r) {
                        const l = t[n * 3]
                          , h = t[n * 3 + 1]
                          , d = t[n * 3 + 2]
                          , p = t[i * 3]
                          , m = t[i * 3 + 1]
                          , v = t[i * 3 + 2]
                          , _ = t[s * 3]
                          , x = t[s * 3 + 1]
                          , b = t[s * 3 + 2]
                          , E = t[r * 3]
                          , T = t[r * 3 + 1]
                          , M = t[r * 3 + 2];
                        return Math.abs(h - m) < Math.abs(l - p) ? [new ye(l,1 - d), new ye(p,1 - v), new ye(_,1 - b), new ye(E,1 - M)] : [new ye(h,1 - d), new ye(m,1 - v), new ye(x,1 - b), new ye(T,1 - M)]
                    }
                };
                function MP(e, t, n) {
                    if (n.shapes = [],
                    Array.isArray(e))
                        for (let i = 0, s = e.length; i < s; i++) {
                            const r = e[i];
                            n.shapes.push(r.uuid)
                        }
                    else
                        n.shapes.push(e.uuid);
                    return n.options = Object.assign({}, t),
                    t.extrudePath !== void 0 && (n.options.extrudePath = t.extrudePath.toJSON()),
                    n
                }
                var vC = class HO extends Up {
                    constructor(t=1, n=0) {
                        const i = (1 + Math.sqrt(5)) / 2
                          , s = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
                        super(s, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, n),
                        this.type = "IcosahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new HO(t.radius,t.detail)
                    }
                }
                  , yC = class VO extends an {
                    constructor(t=[new ye(0,-.5), new ye(.5,0), new ye(0,.5)], n=12, i=0, s=Math.PI * 2) {
                        super(),
                        this.type = "LatheGeometry",
                        this.parameters = {
                            points: t,
                            segments: n,
                            phiStart: i,
                            phiLength: s
                        },
                        n = Math.floor(n),
                        s = kt(s, 0, Math.PI * 2);
                        const r = []
                          , l = []
                          , h = []
                          , d = []
                          , p = []
                          , m = 1 / n
                          , v = new Q
                          , _ = new ye
                          , x = new Q
                          , b = new Q
                          , E = new Q;
                        let T = 0
                          , M = 0;
                        for (let D = 0; D <= t.length - 1; D++)
                            switch (D) {
                            case 0:
                                T = t[D + 1].x - t[D].x,
                                M = t[D + 1].y - t[D].y,
                                x.x = M * 1,
                                x.y = -T,
                                x.z = M * 0,
                                E.copy(x),
                                x.normalize(),
                                d.push(x.x, x.y, x.z);
                                break;
                            case t.length - 1:
                                d.push(E.x, E.y, E.z);
                                break;
                            default:
                                T = t[D + 1].x - t[D].x,
                                M = t[D + 1].y - t[D].y,
                                x.x = M * 1,
                                x.y = -T,
                                x.z = M * 0,
                                b.copy(x),
                                x.x += E.x,
                                x.y += E.y,
                                x.z += E.z,
                                x.normalize(),
                                d.push(x.x, x.y, x.z),
                                E.copy(b)
                            }
                        for (let D = 0; D <= n; D++) {
                            const R = i + D * m * s
                              , O = Math.sin(R)
                              , U = Math.cos(R);
                            for (let B = 0; B <= t.length - 1; B++) {
                                v.x = t[B].x * O,
                                v.y = t[B].y,
                                v.z = t[B].x * U,
                                l.push(v.x, v.y, v.z),
                                _.x = D / n,
                                _.y = B / (t.length - 1),
                                h.push(_.x, _.y);
                                const I = d[3 * B + 0] * O
                                  , F = d[3 * B + 1]
                                  , P = d[3 * B + 0] * U;
                                p.push(I, F, P)
                            }
                        }
                        for (let D = 0; D < n; D++)
                            for (let R = 0; R < t.length - 1; R++) {
                                const O = R + D * t.length
                                  , U = O
                                  , B = O + t.length
                                  , I = O + t.length + 1
                                  , F = O + 1;
                                r.push(U, B, F),
                                r.push(I, F, B)
                            }
                        this.setIndex(r),
                        this.setAttribute("position", new At(l,3)),
                        this.setAttribute("uv", new At(h,2)),
                        this.setAttribute("normal", new At(p,3))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new VO(t.points,t.segments,t.phiStart,t.phiLength)
                    }
                }
                  , xT = class GO extends Up {
                    constructor(t=1, n=0) {
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, n),
                        this.type = "OctahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new GO(t.radius,t.detail)
                    }
                }
                  , ux = class kO extends an {
                    constructor(t=1, n=1, i=1, s=1) {
                        super(),
                        this.type = "PlaneGeometry",
                        this.parameters = {
                            width: t,
                            height: n,
                            widthSegments: i,
                            heightSegments: s
                        };
                        const r = t / 2
                          , l = n / 2
                          , h = Math.floor(i)
                          , d = Math.floor(s)
                          , p = h + 1
                          , m = d + 1
                          , v = t / h
                          , _ = n / d
                          , x = []
                          , b = []
                          , E = []
                          , T = [];
                        for (let M = 0; M < m; M++) {
                            const D = M * _ - l;
                            for (let R = 0; R < p; R++) {
                                const O = R * v - r;
                                b.push(O, -D, 0),
                                E.push(0, 0, 1),
                                T.push(R / h),
                                T.push(1 - M / d)
                            }
                        }
                        for (let M = 0; M < d; M++)
                            for (let D = 0; D < h; D++) {
                                const R = D + p * M
                                  , O = D + p * (M + 1)
                                  , U = D + 1 + p * (M + 1)
                                  , B = D + 1 + p * M;
                                x.push(R, O, B),
                                x.push(O, U, B)
                            }
                        this.setIndex(x),
                        this.setAttribute("position", new At(b,3)),
                        this.setAttribute("normal", new At(E,3)),
                        this.setAttribute("uv", new At(T,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new kO(t.width,t.height,t.widthSegments,t.heightSegments)
                    }
                }
                  , _C = class XO extends an {
                    constructor(t=.5, n=1, i=32, s=1, r=0, l=Math.PI * 2) {
                        super(),
                        this.type = "RingGeometry",
                        this.parameters = {
                            innerRadius: t,
                            outerRadius: n,
                            thetaSegments: i,
                            phiSegments: s,
                            thetaStart: r,
                            thetaLength: l
                        },
                        i = Math.max(3, i),
                        s = Math.max(1, s);
                        const h = []
                          , d = []
                          , p = []
                          , m = [];
                        let v = t;
                        const _ = (n - t) / s
                          , x = new Q
                          , b = new ye;
                        for (let E = 0; E <= s; E++) {
                            for (let T = 0; T <= i; T++) {
                                const M = r + T / i * l;
                                x.x = v * Math.cos(M),
                                x.y = v * Math.sin(M),
                                d.push(x.x, x.y, x.z),
                                p.push(0, 0, 1),
                                b.x = (x.x / n + 1) / 2,
                                b.y = (x.y / n + 1) / 2,
                                m.push(b.x, b.y)
                            }
                            v += _
                        }
                        for (let E = 0; E < s; E++) {
                            const T = E * (i + 1);
                            for (let M = 0; M < i; M++) {
                                const D = M + T
                                  , R = D
                                  , O = D + i + 1
                                  , U = D + i + 2
                                  , B = D + 1;
                                h.push(R, O, B),
                                h.push(O, U, B)
                            }
                        }
                        this.setIndex(h),
                        this.setAttribute("position", new At(d,3)),
                        this.setAttribute("normal", new At(p,3)),
                        this.setAttribute("uv", new At(m,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new XO(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)
                    }
                }
                  , xC = class qO extends an {
                    constructor(t=new gf([new ye(0,.5), new ye(-.5,-.5), new ye(.5,-.5)]), n=12) {
                        super(),
                        this.type = "ShapeGeometry",
                        this.parameters = {
                            shapes: t,
                            curveSegments: n
                        };
                        const i = []
                          , s = []
                          , r = []
                          , l = [];
                        let h = 0
                          , d = 0;
                        if (Array.isArray(t) === !1)
                            p(t);
                        else
                            for (let m = 0; m < t.length; m++)
                                p(t[m]),
                                this.addGroup(h, d, m),
                                h += d,
                                d = 0;
                        this.setIndex(i),
                        this.setAttribute("position", new At(s,3)),
                        this.setAttribute("normal", new At(r,3)),
                        this.setAttribute("uv", new At(l,2));
                        function p(m) {
                            const v = s.length / 3
                              , _ = m.extractPoints(n);
                            let x = _.shape;
                            const b = _.holes;
                            Dc.isClockWise(x) === !1 && (x = x.reverse());
                            for (let T = 0, M = b.length; T < M; T++) {
                                const D = b[T];
                                Dc.isClockWise(D) === !0 && (b[T] = D.reverse())
                            }
                            const E = Dc.triangulateShape(x, b);
                            for (let T = 0, M = b.length; T < M; T++) {
                                const D = b[T];
                                x = x.concat(D)
                            }
                            for (let T = 0, M = x.length; T < M; T++) {
                                const D = x[T];
                                s.push(D.x, D.y, 0),
                                r.push(0, 0, 1),
                                l.push(D.x, D.y)
                            }
                            for (let T = 0, M = E.length; T < M; T++) {
                                const D = E[T]
                                  , R = D[0] + v
                                  , O = D[1] + v
                                  , U = D[2] + v;
                                i.push(R, O, U),
                                d += 3
                            }
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON()
                          , n = this.parameters.shapes;
                        return bP(n, t)
                    }
                    static fromJSON(t, n) {
                        const i = [];
                        for (let s = 0, r = t.shapes.length; s < r; s++) {
                            const l = n[t.shapes[s]];
                            i.push(l)
                        }
                        return new qO(i,t.curveSegments)
                    }
                }
                ;
                function bP(e, t) {
                    if (t.shapes = [],
                    Array.isArray(e))
                        for (let n = 0, i = e.length; n < i; n++) {
                            const s = e[n];
                            t.shapes.push(s.uuid)
                        }
                    else
                        t.shapes.push(e.uuid);
                    return t
                }
                var ST = class YO extends an {
                    constructor(t=1, n=32, i=16, s=0, r=Math.PI * 2, l=0, h=Math.PI) {
                        super(),
                        this.type = "SphereGeometry",
                        this.parameters = {
                            radius: t,
                            widthSegments: n,
                            heightSegments: i,
                            phiStart: s,
                            phiLength: r,
                            thetaStart: l,
                            thetaLength: h
                        },
                        n = Math.max(3, Math.floor(n)),
                        i = Math.max(2, Math.floor(i));
                        const d = Math.min(l + h, Math.PI);
                        let p = 0;
                        const m = []
                          , v = new Q
                          , _ = new Q
                          , x = []
                          , b = []
                          , E = []
                          , T = [];
                        for (let M = 0; M <= i; M++) {
                            const D = []
                              , R = M / i;
                            let O = 0;
                            M === 0 && l === 0 ? O = .5 / n : M === i && d === Math.PI && (O = -.5 / n);
                            for (let U = 0; U <= n; U++) {
                                const B = U / n;
                                v.x = -t * Math.cos(s + B * r) * Math.sin(l + R * h),
                                v.y = t * Math.cos(l + R * h),
                                v.z = t * Math.sin(s + B * r) * Math.sin(l + R * h),
                                b.push(v.x, v.y, v.z),
                                _.copy(v).normalize(),
                                E.push(_.x, _.y, _.z),
                                T.push(B + O, 1 - R),
                                D.push(p++)
                            }
                            m.push(D)
                        }
                        for (let M = 0; M < i; M++)
                            for (let D = 0; D < n; D++) {
                                const R = m[M][D + 1]
                                  , O = m[M][D]
                                  , U = m[M + 1][D]
                                  , B = m[M + 1][D + 1];
                                (M !== 0 || l > 0) && x.push(R, O, B),
                                (M !== i - 1 || d < Math.PI) && x.push(O, U, B)
                            }
                        this.setIndex(x),
                        this.setAttribute("position", new At(b,3)),
                        this.setAttribute("normal", new At(E,3)),
                        this.setAttribute("uv", new At(T,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new YO(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)
                    }
                }
                  , SC = class WO extends Up {
                    constructor(t=1, n=0) {
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, n),
                        this.type = "TetrahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new WO(t.radius,t.detail)
                    }
                }
                  , AC = class jO extends an {
                    constructor(t=1, n=.4, i=12, s=48, r=Math.PI * 2) {
                        super(),
                        this.type = "TorusGeometry",
                        this.parameters = {
                            radius: t,
                            tube: n,
                            radialSegments: i,
                            tubularSegments: s,
                            arc: r
                        },
                        i = Math.floor(i),
                        s = Math.floor(s);
                        const l = []
                          , h = []
                          , d = []
                          , p = []
                          , m = new Q
                          , v = new Q
                          , _ = new Q;
                        for (let x = 0; x <= i; x++)
                            for (let b = 0; b <= s; b++) {
                                const E = b / s * r
                                  , T = x / i * Math.PI * 2;
                                v.x = (t + n * Math.cos(T)) * Math.cos(E),
                                v.y = (t + n * Math.cos(T)) * Math.sin(E),
                                v.z = n * Math.sin(T),
                                h.push(v.x, v.y, v.z),
                                m.x = t * Math.cos(E),
                                m.y = t * Math.sin(E),
                                _.subVectors(v, m).normalize(),
                                d.push(_.x, _.y, _.z),
                                p.push(b / s),
                                p.push(x / i)
                            }
                        for (let x = 1; x <= i; x++)
                            for (let b = 1; b <= s; b++) {
                                const E = (s + 1) * x + b - 1
                                  , T = (s + 1) * (x - 1) + b - 1
                                  , M = (s + 1) * (x - 1) + b
                                  , D = (s + 1) * x + b;
                                l.push(E, T, D),
                                l.push(T, M, D)
                            }
                        this.setIndex(l),
                        this.setAttribute("position", new At(h,3)),
                        this.setAttribute("normal", new At(d,3)),
                        this.setAttribute("uv", new At(p,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new jO(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)
                    }
                }
                  , TC = class QO extends an {
                    constructor(t=1, n=.4, i=64, s=8, r=2, l=3) {
                        super(),
                        this.type = "TorusKnotGeometry",
                        this.parameters = {
                            radius: t,
                            tube: n,
                            tubularSegments: i,
                            radialSegments: s,
                            p: r,
                            q: l
                        },
                        i = Math.floor(i),
                        s = Math.floor(s);
                        const h = []
                          , d = []
                          , p = []
                          , m = []
                          , v = new Q
                          , _ = new Q
                          , x = new Q
                          , b = new Q
                          , E = new Q
                          , T = new Q
                          , M = new Q;
                        for (let R = 0; R <= i; ++R) {
                            const O = R / i * r * Math.PI * 2;
                            D(O, r, l, t, x),
                            D(O + .01, r, l, t, b),
                            T.subVectors(b, x),
                            M.addVectors(b, x),
                            E.crossVectors(T, M),
                            M.crossVectors(E, T),
                            E.normalize(),
                            M.normalize();
                            for (let U = 0; U <= s; ++U) {
                                const B = U / s * Math.PI * 2
                                  , I = -n * Math.cos(B)
                                  , F = n * Math.sin(B);
                                v.x = x.x + (I * M.x + F * E.x),
                                v.y = x.y + (I * M.y + F * E.y),
                                v.z = x.z + (I * M.z + F * E.z),
                                d.push(v.x, v.y, v.z),
                                _.subVectors(v, x).normalize(),
                                p.push(_.x, _.y, _.z),
                                m.push(R / i),
                                m.push(U / s)
                            }
                        }
                        for (let R = 1; R <= i; R++)
                            for (let O = 1; O <= s; O++) {
                                const U = (s + 1) * (R - 1) + (O - 1)
                                  , B = (s + 1) * R + (O - 1)
                                  , I = (s + 1) * R + O
                                  , F = (s + 1) * (R - 1) + O;
                                h.push(U, B, F),
                                h.push(B, I, F)
                            }
                        this.setIndex(h),
                        this.setAttribute("position", new At(d,3)),
                        this.setAttribute("normal", new At(p,3)),
                        this.setAttribute("uv", new At(m,2));
                        function D(R, O, U, B, I) {
                            const F = Math.cos(R)
                              , P = Math.sin(R)
                              , L = U / O * R
                              , H = Math.cos(L);
                            I.x = B * (2 + H) * .5 * F,
                            I.y = B * (2 + H) * P * .5,
                            I.z = B * Math.sin(L) * .5
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new QO(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)
                    }
                }
                  , MC = class ZO extends an {
                    constructor(t=new gT(new Q(-1,-1,0),new Q(-1,1,0),new Q(1,1,0)), n=64, i=1, s=8, r=!1) {
                        super(),
                        this.type = "TubeGeometry",
                        this.parameters = {
                            path: t,
                            tubularSegments: n,
                            radius: i,
                            radialSegments: s,
                            closed: r
                        };
                        const l = t.computeFrenetFrames(n, r);
                        this.tangents = l.tangents,
                        this.normals = l.normals,
                        this.binormals = l.binormals;
                        const h = new Q
                          , d = new Q
                          , p = new ye;
                        let m = new Q;
                        const v = []
                          , _ = []
                          , x = []
                          , b = [];
                        E(),
                        this.setIndex(b),
                        this.setAttribute("position", new At(v,3)),
                        this.setAttribute("normal", new At(_,3)),
                        this.setAttribute("uv", new At(x,2));
                        function E() {
                            for (let R = 0; R < n; R++)
                                T(R);
                            T(r === !1 ? n : 0),
                            D(),
                            M()
                        }
                        function T(R) {
                            m = t.getPointAt(R / n, m);
                            const O = l.normals[R]
                              , U = l.binormals[R];
                            for (let B = 0; B <= s; B++) {
                                const I = B / s * Math.PI * 2
                                  , F = Math.sin(I)
                                  , P = -Math.cos(I);
                                d.x = P * O.x + F * U.x,
                                d.y = P * O.y + F * U.y,
                                d.z = P * O.z + F * U.z,
                                d.normalize(),
                                _.push(d.x, d.y, d.z),
                                h.x = m.x + i * d.x,
                                h.y = m.y + i * d.y,
                                h.z = m.z + i * d.z,
                                v.push(h.x, h.y, h.z)
                            }
                        }
                        function M() {
                            for (let R = 1; R <= n; R++)
                                for (let O = 1; O <= s; O++) {
                                    const U = (s + 1) * (R - 1) + (O - 1)
                                      , B = (s + 1) * R + (O - 1)
                                      , I = (s + 1) * R + O
                                      , F = (s + 1) * (R - 1) + O;
                                    b.push(U, B, F),
                                    b.push(B, I, F)
                                }
                        }
                        function D() {
                            for (let R = 0; R <= n; R++)
                                for (let O = 0; O <= s; O++)
                                    p.x = R / n,
                                    p.y = O / s,
                                    x.push(p.x, p.y)
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.path = this.parameters.path.toJSON(),
                        t
                    }
                    static fromJSON(t) {
                        return new ZO(new rx[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)
                    }
                }
                  , bC = class extends an {
                    constructor(e=null) {
                        if (super(),
                        this.type = "WireframeGeometry",
                        this.parameters = {
                            geometry: e
                        },
                        e !== null) {
                            const t = []
                              , n = new Set
                              , i = new Q
                              , s = new Q;
                            if (e.index !== null) {
                                const r = e.attributes.position
                                  , l = e.index;
                                let h = e.groups;
                                h.length === 0 && (h = [{
                                    start: 0,
                                    count: l.count,
                                    materialIndex: 0
                                }]);
                                for (let d = 0, p = h.length; d < p; ++d) {
                                    const m = h[d]
                                      , v = m.start
                                      , _ = m.count;
                                    for (let x = v, b = v + _; x < b; x += 3)
                                        for (let E = 0; E < 3; E++) {
                                            const T = l.getX(x + E)
                                              , M = l.getX(x + (E + 1) % 3);
                                            i.fromBufferAttribute(r, T),
                                            s.fromBufferAttribute(r, M),
                                            EC(i, s, n) === !0 && (t.push(i.x, i.y, i.z),
                                            t.push(s.x, s.y, s.z))
                                        }
                                }
                            } else {
                                const r = e.attributes.position;
                                for (let l = 0, h = r.count / 3; l < h; l++)
                                    for (let d = 0; d < 3; d++) {
                                        const p = 3 * l + d
                                          , m = 3 * l + (d + 1) % 3;
                                        i.fromBufferAttribute(r, p),
                                        s.fromBufferAttribute(r, m),
                                        EC(i, s, n) === !0 && (t.push(i.x, i.y, i.z),
                                        t.push(s.x, s.y, s.z))
                                    }
                            }
                            this.setAttribute("position", new At(t,3))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                }
                ;
                function EC(e, t, n) {
                    const i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`
                      , s = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                    return n.has(i) === !0 || n.has(s) === !0 ? !1 : (n.add(i),
                    n.add(s),
                    !0)
                }
                var wC = Object.freeze({
                    __proto__: null,
                    BoxGeometry: sv,
                    CapsuleGeometry: $w,
                    CircleGeometry: eC,
                    ConeGeometry: oT,
                    CylinderGeometry: rT,
                    DodecahedronGeometry: tC,
                    EdgesGeometry: nC,
                    ExtrudeGeometry: gC,
                    IcosahedronGeometry: vC,
                    LatheGeometry: yC,
                    OctahedronGeometry: xT,
                    PlaneGeometry: ux,
                    PolyhedronGeometry: Up,
                    RingGeometry: _C,
                    ShapeGeometry: xC,
                    SphereGeometry: ST,
                    TetrahedronGeometry: SC,
                    TorusGeometry: AC,
                    TorusKnotGeometry: TC,
                    TubeGeometry: MC,
                    WireframeGeometry: bC
                })
                  , CC = class extends Os {
                    constructor(e) {
                        super(),
                        this.isShadowMaterial = !0,
                        this.type = "ShadowMaterial",
                        this.color = new at(0),
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.fog = e.fog,
                        this
                    }
                }
                  , RC = class extends Fn {
                    constructor(e) {
                        super(e),
                        this.isRawShaderMaterial = !0,
                        this.type = "RawShaderMaterial"
                    }
                }
                  , AT = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshStandardMaterial = !0,
                        this.type = "MeshStandardMaterial",
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color = new at(16777215),
                        this.roughness = 1,
                        this.metalness = 0,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new at(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = Bu,
                        this.normalScale = new ye(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.roughnessMap = null,
                        this.metalnessMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new io,
                        this.envMapIntensity = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color.copy(e.color),
                        this.roughness = e.roughness,
                        this.metalness = e.metalness,
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.roughnessMap = e.roughnessMap,
                        this.metalnessMap = e.metalnessMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.envMapIntensity = e.envMapIntensity,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , DC = class extends AT {
                    constructor(e) {
                        super(),
                        this.isMeshPhysicalMaterial = !0,
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.type = "MeshPhysicalMaterial",
                        this.anisotropyRotation = 0,
                        this.anisotropyMap = null,
                        this.clearcoatMap = null,
                        this.clearcoatRoughness = 0,
                        this.clearcoatRoughnessMap = null,
                        this.clearcoatNormalScale = new ye(1,1),
                        this.clearcoatNormalMap = null,
                        this.ior = 1.5,
                        Object.defineProperty(this, "reflectivity", {
                            get: function() {
                                return kt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function(t) {
                                this.ior = (1 + .4 * t) / (1 - .4 * t)
                            }
                        }),
                        this.iridescenceMap = null,
                        this.iridescenceIOR = 1.3,
                        this.iridescenceThicknessRange = [100, 400],
                        this.iridescenceThicknessMap = null,
                        this.sheenColor = new at(0),
                        this.sheenColorMap = null,
                        this.sheenRoughness = 1,
                        this.sheenRoughnessMap = null,
                        this.transmissionMap = null,
                        this.thickness = 0,
                        this.thicknessMap = null,
                        this.attenuationDistance = 1 / 0,
                        this.attenuationColor = new at(1,1,1),
                        this.specularIntensity = 1,
                        this.specularIntensityMap = null,
                        this.specularColor = new at(1,1,1),
                        this.specularColorMap = null,
                        this._anisotropy = 0,
                        this._clearcoat = 0,
                        this._dispersion = 0,
                        this._iridescence = 0,
                        this._sheen = 0,
                        this._transmission = 0,
                        this.setValues(e)
                    }
                    get anisotropy() {
                        return this._anisotropy
                    }
                    set anisotropy(e) {
                        this._anisotropy > 0 != e > 0 && this.version++,
                        this._anisotropy = e
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(e) {
                        this._clearcoat > 0 != e > 0 && this.version++,
                        this._clearcoat = e
                    }
                    get iridescence() {
                        return this._iridescence
                    }
                    set iridescence(e) {
                        this._iridescence > 0 != e > 0 && this.version++,
                        this._iridescence = e
                    }
                    get dispersion() {
                        return this._dispersion
                    }
                    set dispersion(e) {
                        this._dispersion > 0 != e > 0 && this.version++,
                        this._dispersion = e
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(e) {
                        this._sheen > 0 != e > 0 && this.version++,
                        this._sheen = e
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(e) {
                        this._transmission > 0 != e > 0 && this.version++,
                        this._transmission = e
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.anisotropy = e.anisotropy,
                        this.anisotropyRotation = e.anisotropyRotation,
                        this.anisotropyMap = e.anisotropyMap,
                        this.clearcoat = e.clearcoat,
                        this.clearcoatMap = e.clearcoatMap,
                        this.clearcoatRoughness = e.clearcoatRoughness,
                        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                        this.clearcoatNormalMap = e.clearcoatNormalMap,
                        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                        this.dispersion = e.dispersion,
                        this.ior = e.ior,
                        this.iridescence = e.iridescence,
                        this.iridescenceMap = e.iridescenceMap,
                        this.iridescenceIOR = e.iridescenceIOR,
                        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                        this.sheen = e.sheen,
                        this.sheenColor.copy(e.sheenColor),
                        this.sheenColorMap = e.sheenColorMap,
                        this.sheenRoughness = e.sheenRoughness,
                        this.sheenRoughnessMap = e.sheenRoughnessMap,
                        this.transmission = e.transmission,
                        this.transmissionMap = e.transmissionMap,
                        this.thickness = e.thickness,
                        this.thicknessMap = e.thicknessMap,
                        this.attenuationDistance = e.attenuationDistance,
                        this.attenuationColor.copy(e.attenuationColor),
                        this.specularIntensity = e.specularIntensity,
                        this.specularIntensityMap = e.specularIntensityMap,
                        this.specularColor.copy(e.specularColor),
                        this.specularColorMap = e.specularColorMap,
                        this
                    }
                }
                  , OC = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshPhongMaterial = !0,
                        this.type = "MeshPhongMaterial",
                        this.color = new at(16777215),
                        this.specular = new at(1118481),
                        this.shininess = 30,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new at(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = Bu,
                        this.normalScale = new ye(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new io,
                        this.combine = Ig,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.specular.copy(e.specular),
                        this.shininess = e.shininess,
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , NC = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshToonMaterial = !0,
                        this.defines = {
                            TOON: ""
                        },
                        this.type = "MeshToonMaterial",
                        this.color = new at(16777215),
                        this.map = null,
                        this.gradientMap = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new at(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = Bu,
                        this.normalScale = new ye(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.gradientMap = e.gradientMap,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.alphaMap = e.alphaMap,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                  , TT = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshNormalMaterial = !0,
                        this.type = "MeshNormalMaterial",
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = Bu,
                        this.normalScale = new ye(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.flatShading = !1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.flatShading = e.flatShading,
                        this
                    }
                }
                  , UC = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshLambertMaterial = !0,
                        this.type = "MeshLambertMaterial",
                        this.color = new at(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new at(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = Bu,
                        this.normalScale = new ye(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new io,
                        this.combine = Ig,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , hx = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshDepthMaterial = !0,
                        this.type = "MeshDepthMaterial",
                        this.depthPacking = ji,
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.depthPacking = e.depthPacking,
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this
                    }
                }
                  , MT = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshDistanceMaterial = !0,
                        this.type = "MeshDistanceMaterial",
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this
                    }
                }
                  , BC = class extends Os {
                    constructor(e) {
                        super(),
                        this.isMeshMatcapMaterial = !0,
                        this.defines = {
                            MATCAP: ""
                        },
                        this.type = "MeshMatcapMaterial",
                        this.color = new at(16777215),
                        this.matcap = null,
                        this.map = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = Bu,
                        this.normalScale = new ye(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            MATCAP: ""
                        },
                        this.color.copy(e.color),
                        this.matcap = e.matcap,
                        this.map = e.map,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.alphaMap = e.alphaMap,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , PC = class extends Ia {
                    constructor(e) {
                        super(),
                        this.isLineDashedMaterial = !0,
                        this.type = "LineDashedMaterial",
                        this.scale = 1,
                        this.dashSize = 3,
                        this.gapSize = 1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.scale = e.scale,
                        this.dashSize = e.dashSize,
                        this.gapSize = e.gapSize,
                        this
                    }
                }
                ;
                function yf(e, t) {
                    return !e || e.constructor === t ? e : typeof t.BYTES_PER_ELEMENT == "number" ? new t(e) : Array.prototype.slice.call(e)
                }
                function IC(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                }
                function LC(e) {
                    function t(s, r) {
                        return e[s] - e[r]
                    }
                    const n = e.length
                      , i = new Array(n);
                    for (let s = 0; s !== n; ++s)
                        i[s] = s;
                    return i.sort(t),
                    i
                }
                function bT(e, t, n) {
                    const i = e.length
                      , s = new e.constructor(i);
                    for (let r = 0, l = 0; l !== i; ++r) {
                        const h = n[r] * t;
                        for (let d = 0; d !== t; ++d)
                            s[l++] = e[h + d]
                    }
                    return s
                }
                function ET(e, t, n, i) {
                    let s = 1
                      , r = e[0];
                    for (; r !== void 0 && r[i] === void 0; )
                        r = e[s++];
                    if (r === void 0)
                        return;
                    let l = r[i];
                    if (l !== void 0)
                        if (Array.isArray(l))
                            do
                                l = r[i],
                                l !== void 0 && (t.push(r.time),
                                n.push(...l)),
                                r = e[s++];
                            while (r !== void 0);
                        else if (l.toArray !== void 0)
                            do
                                l = r[i],
                                l !== void 0 && (t.push(r.time),
                                l.toArray(n, n.length)),
                                r = e[s++];
                            while (r !== void 0);
                        else
                            do
                                l = r[i],
                                l !== void 0 && (t.push(r.time),
                                n.push(l)),
                                r = e[s++];
                            while (r !== void 0)
                }
                function EP(e, t, n, i, s=30) {
                    const r = e.clone();
                    r.name = t;
                    const l = [];
                    for (let d = 0; d < r.tracks.length; ++d) {
                        const p = r.tracks[d]
                          , m = p.getValueSize()
                          , v = []
                          , _ = [];
                        for (let x = 0; x < p.times.length; ++x) {
                            const b = p.times[x] * s;
                            if (!(b < n || b >= i)) {
                                v.push(p.times[x]);
                                for (let E = 0; E < m; ++E)
                                    _.push(p.values[x * m + E])
                            }
                        }
                        v.length !== 0 && (p.times = yf(v, p.times.constructor),
                        p.values = yf(_, p.values.constructor),
                        l.push(p))
                    }
                    r.tracks = l;
                    let h = 1 / 0;
                    for (let d = 0; d < r.tracks.length; ++d)
                        h > r.tracks[d].times[0] && (h = r.tracks[d].times[0]);
                    for (let d = 0; d < r.tracks.length; ++d)
                        r.tracks[d].shift(-1 * h);
                    return r.resetDuration(),
                    r
                }
                function wP(e, t=0, n=e, i=30) {
                    i <= 0 && (i = 30);
                    const s = n.tracks.length
                      , r = t / i;
                    for (let l = 0; l < s; ++l) {
                        const h = n.tracks[l]
                          , d = h.ValueTypeName;
                        if (d === "bool" || d === "string")
                            continue;
                        const p = e.tracks.find(function(M) {
                            return M.name === h.name && M.ValueTypeName === d
                        });
                        if (p === void 0)
                            continue;
                        let m = 0;
                        const v = h.getValueSize();
                        h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = v / 3);
                        let _ = 0;
                        const x = p.getValueSize();
                        p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (_ = x / 3);
                        const b = h.times.length - 1;
                        let E;
                        if (r <= h.times[0]) {
                            const M = m
                              , D = v - m;
                            E = h.values.slice(M, D)
                        } else if (r >= h.times[b]) {
                            const M = b * v + m
                              , D = M + v - m;
                            E = h.values.slice(M, D)
                        } else {
                            const M = h.createInterpolant()
                              , D = m
                              , R = v - m;
                            M.evaluate(r),
                            E = M.resultBuffer.slice(D, R)
                        }
                        d === "quaternion" && new _s().fromArray(E).normalize().conjugate().toArray(E);
                        const T = p.times.length;
                        for (let M = 0; M < T; ++M) {
                            const D = M * x + _;
                            if (d === "quaternion")
                                _s.multiplyQuaternionsFlat(p.values, D, E, 0, p.values, D);
                            else {
                                const R = x - _ * 2;
                                for (let O = 0; O < R; ++O)
                                    p.values[D + O] -= E[O]
                            }
                        }
                    }
                    return e.blendMode = xA,
                    e
                }
                var CP = class {
                    static convertArray(e, t) {
                        return yf(e, t)
                    }
                    static isTypedArray(e) {
                        return IC(e)
                    }
                    static getKeyframeOrder(e) {
                        return LC(e)
                    }
                    static sortedArray(e, t, n) {
                        return bT(e, t, n)
                    }
                    static flattenJSON(e, t, n, i) {
                        ET(e, t, n, i)
                    }
                    static subclip(e, t, n, i, s=30) {
                        return EP(e, t, n, i, s)
                    }
                    static makeClipAdditive(e, t=0, n=e, i=30) {
                        return wP(e, t, n, i)
                    }
                }
                  , Av = class {
                    constructor(e, t, n, i) {
                        this.parameterPositions = e,
                        this._cachedIndex = 0,
                        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
                        this.sampleValues = t,
                        this.valueSize = n,
                        this.settings = null,
                        this.DefaultSettings_ = {}
                    }
                    evaluate(e) {
                        const t = this.parameterPositions;
                        let n = this._cachedIndex
                          , i = t[n]
                          , s = t[n - 1];
                        e: {
                            t: {
                                let r;
                                n: {
                                    i: if (!(e < i)) {
                                        for (let l = n + 2; ; ) {
                                            if (i === void 0) {
                                                if (e < s)
                                                    break i;
                                                return n = t.length,
                                                this._cachedIndex = n,
                                                this.copySampleValue_(n - 1)
                                            }
                                            if (n === l)
                                                break;
                                            if (s = i,
                                            i = t[++n],
                                            e < i)
                                                break t
                                        }
                                        r = t.length;
                                        break n
                                    }
                                    if (!(e >= s)) {
                                        const l = t[1];
                                        e < l && (n = 2,
                                        s = l);
                                        for (let h = n - 2; ; ) {
                                            if (s === void 0)
                                                return this._cachedIndex = 0,
                                                this.copySampleValue_(0);
                                            if (n === h)
                                                break;
                                            if (i = s,
                                            s = t[--n - 1],
                                            e >= s)
                                                break t
                                        }
                                        r = n,
                                        n = 0;
                                        break n
                                    }
                                    break e
                                }
                                for (; n < r; ) {
                                    const l = n + r >>> 1;
                                    e < t[l] ? r = l : n = l + 1
                                }
                                if (i = t[n],
                                s = t[n - 1],
                                s === void 0)
                                    return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                if (i === void 0)
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.copySampleValue_(n - 1)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, s, i)
                        }
                        return this.interpolate_(n, s, e, i)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(e) {
                        const t = this.resultBuffer
                          , n = this.sampleValues
                          , i = this.valueSize
                          , s = e * i;
                        for (let r = 0; r !== i; ++r)
                            t[r] = n[s + r];
                        return t
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                  , zC = class extends Av {
                    constructor(e, t, n, i) {
                        super(e, t, n, i),
                        this._weightPrev = -0,
                        this._offsetPrev = -0,
                        this._weightNext = -0,
                        this._offsetNext = -0,
                        this.DefaultSettings_ = {
                            endingStart: af,
                            endingEnd: af
                        }
                    }
                    intervalChanged_(e, t, n) {
                        const i = this.parameterPositions;
                        let s = e - 2
                          , r = e + 1
                          , l = i[s]
                          , h = i[r];
                        if (l === void 0)
                            switch (this.getSettings_().endingStart) {
                            case rf:
                                s = e,
                                l = 2 * t - n;
                                break;
                            case Wg:
                                s = i.length - 2,
                                l = t + i[s] - i[s + 1];
                                break;
                            default:
                                s = e,
                                l = n
                            }
                        if (h === void 0)
                            switch (this.getSettings_().endingEnd) {
                            case rf:
                                r = e,
                                h = 2 * n - t;
                                break;
                            case Wg:
                                r = 1,
                                h = n + i[1] - i[0];
                                break;
                            default:
                                r = e - 1,
                                h = t
                            }
                        const d = (n - t) * .5
                          , p = this.valueSize;
                        this._weightPrev = d / (t - l),
                        this._weightNext = d / (h - n),
                        this._offsetPrev = s * p,
                        this._offsetNext = r * p
                    }
                    interpolate_(e, t, n, i) {
                        const s = this.resultBuffer
                          , r = this.sampleValues
                          , l = this.valueSize
                          , h = e * l
                          , d = h - l
                          , p = this._offsetPrev
                          , m = this._offsetNext
                          , v = this._weightPrev
                          , _ = this._weightNext
                          , x = (n - t) / (i - t)
                          , b = x * x
                          , E = b * x
                          , T = -v * E + 2 * v * b - v * x
                          , M = (1 + v) * E + (-1.5 - 2 * v) * b + (-.5 + v) * x + 1
                          , D = (-1 - _) * E + (1.5 + _) * b + .5 * x
                          , R = _ * E - _ * b;
                        for (let O = 0; O !== l; ++O)
                            s[O] = T * r[p + O] + M * r[d + O] + D * r[h + O] + R * r[m + O];
                        return s
                    }
                }
                  , wT = class extends Av {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    interpolate_(e, t, n, i) {
                        const s = this.resultBuffer
                          , r = this.sampleValues
                          , l = this.valueSize
                          , h = e * l
                          , d = h - l
                          , p = (n - t) / (i - t)
                          , m = 1 - p;
                        for (let v = 0; v !== l; ++v)
                            s[v] = r[d + v] * m + r[h + v] * p;
                        return s
                    }
                }
                  , FC = class extends Av {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    interpolate_(e) {
                        return this.copySampleValue_(e - 1)
                    }
                }
                  , ao = class {
                    constructor(e, t, n, i) {
                        if (e === void 0)
                            throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (t === void 0 || t.length === 0)
                            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                        this.name = e,
                        this.times = yf(t, this.TimeBufferType),
                        this.values = yf(n, this.ValueBufferType),
                        this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(e) {
                        const t = e.constructor;
                        let n;
                        if (t.toJSON !== this.toJSON)
                            n = t.toJSON(e);
                        else {
                            n = {
                                name: e.name,
                                times: yf(e.times, Array),
                                values: yf(e.values, Array)
                            };
                            const i = e.getInterpolation();
                            i !== e.DefaultInterpolation && (n.interpolation = i)
                        }
                        return n.type = e.ValueTypeName,
                        n
                    }
                    InterpolantFactoryMethodDiscrete(e) {
                        return new FC(this.times,this.values,this.getValueSize(),e)
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new wT(this.times,this.values,this.getValueSize(),e)
                    }
                    InterpolantFactoryMethodSmooth(e) {
                        return new zC(this.times,this.values,this.getValueSize(),e)
                    }
                    setInterpolation(e) {
                        let t;
                        switch (e) {
                        case Yg:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case g_:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case v_:
                            t = this.InterpolantFactoryMethodSmooth;
                            break
                        }
                        if (t === void 0) {
                            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (this.createInterpolant === void 0)
                                if (e !== this.DefaultInterpolation)
                                    this.setInterpolation(this.DefaultInterpolation);
                                else
                                    throw new Error(n);
                            return console.warn("THREE.KeyframeTrack:", n),
                            this
                        }
                        return this.createInterpolant = t,
                        this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Yg;
                        case this.InterpolantFactoryMethodLinear:
                            return g_;
                        case this.InterpolantFactoryMethodSmooth:
                            return v_
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(e) {
                        if (e !== 0) {
                            const t = this.times;
                            for (let n = 0, i = t.length; n !== i; ++n)
                                t[n] += e
                        }
                        return this
                    }
                    scale(e) {
                        if (e !== 1) {
                            const t = this.times;
                            for (let n = 0, i = t.length; n !== i; ++n)
                                t[n] *= e
                        }
                        return this
                    }
                    trim(e, t) {
                        const n = this.times
                          , i = n.length;
                        let s = 0
                          , r = i - 1;
                        for (; s !== i && n[s] < e; )
                            ++s;
                        for (; r !== -1 && n[r] > t; )
                            --r;
                        if (++r,
                        s !== 0 || r !== i) {
                            s >= r && (r = Math.max(r, 1),
                            s = r - 1);
                            const l = this.getValueSize();
                            this.times = n.slice(s, r),
                            this.values = this.values.slice(s * l, r * l)
                        }
                        return this
                    }
                    validate() {
                        let e = !0;
                        const t = this.getValueSize();
                        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                        e = !1);
                        const n = this.times
                          , i = this.values
                          , s = n.length;
                        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                        e = !1);
                        let r = null;
                        for (let l = 0; l !== s; l++) {
                            const h = n[l];
                            if (typeof h == "number" && isNaN(h)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, l, h),
                                e = !1;
                                break
                            }
                            if (r !== null && r > h) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, l, h, r),
                                e = !1;
                                break
                            }
                            r = h
                        }
                        if (i !== void 0 && IC(i))
                            for (let l = 0, h = i.length; l !== h; ++l) {
                                const d = i[l];
                                if (isNaN(d)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, d),
                                    e = !1;
                                    break
                                }
                            }
                        return e
                    }
                    optimize() {
                        const e = this.times.slice()
                          , t = this.values.slice()
                          , n = this.getValueSize()
                          , i = this.getInterpolation() === v_
                          , s = e.length - 1;
                        let r = 1;
                        for (let l = 1; l < s; ++l) {
                            let h = !1;
                            const d = e[l]
                              , p = e[l + 1];
                            if (d !== p && (l !== 1 || d !== e[0]))
                                if (i)
                                    h = !0;
                                else {
                                    const m = l * n
                                      , v = m - n
                                      , _ = m + n;
                                    for (let x = 0; x !== n; ++x) {
                                        const b = t[m + x];
                                        if (b !== t[v + x] || b !== t[_ + x]) {
                                            h = !0;
                                            break
                                        }
                                    }
                                }
                            if (h) {
                                if (l !== r) {
                                    e[r] = e[l];
                                    const m = l * n
                                      , v = r * n;
                                    for (let _ = 0; _ !== n; ++_)
                                        t[v + _] = t[m + _]
                                }
                                ++r
                            }
                        }
                        if (s > 0) {
                            e[r] = e[s];
                            for (let l = s * n, h = r * n, d = 0; d !== n; ++d)
                                t[h + d] = t[l + d];
                            ++r
                        }
                        return r !== e.length ? (this.times = e.slice(0, r),
                        this.values = t.slice(0, r * n)) : (this.times = e,
                        this.values = t),
                        this
                    }
                    clone() {
                        const e = this.times.slice()
                          , t = this.values.slice()
                          , n = this.constructor
                          , i = new n(this.name,e,t);
                        return i.createInterpolant = this.createInterpolant,
                        i
                    }
                }
                ;
                ao.prototype.ValueTypeName = "",
                ao.prototype.TimeBufferType = Float32Array,
                ao.prototype.ValueBufferType = Float32Array,
                ao.prototype.DefaultInterpolation = g_;
                var _f = class extends ao {
                    constructor(e, t, n) {
                        super(e, t, n)
                    }
                }
                ;
                _f.prototype.ValueTypeName = "bool",
                _f.prototype.ValueBufferType = Array,
                _f.prototype.DefaultInterpolation = Yg,
                _f.prototype.InterpolantFactoryMethodLinear = void 0,
                _f.prototype.InterpolantFactoryMethodSmooth = void 0;
                var CT = class extends ao {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                }
                ;
                CT.prototype.ValueTypeName = "color";
                var Tv = class extends ao {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                }
                ;
                Tv.prototype.ValueTypeName = "number";
                var HC = class extends Av {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    interpolate_(e, t, n, i) {
                        const s = this.resultBuffer
                          , r = this.sampleValues
                          , l = this.valueSize
                          , h = (n - t) / (i - t);
                        let d = e * l;
                        for (let p = d + l; d !== p; d += 4)
                            _s.slerpFlat(s, 0, r, d - l, r, d, h);
                        return s
                    }
                }
                  , Mv = class extends ao {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new HC(this.times,this.values,this.getValueSize(),e)
                    }
                }
                ;
                Mv.prototype.ValueTypeName = "quaternion",
                Mv.prototype.InterpolantFactoryMethodSmooth = void 0;
                var xf = class extends ao {
                    constructor(e, t, n) {
                        super(e, t, n)
                    }
                }
                ;
                xf.prototype.ValueTypeName = "string",
                xf.prototype.ValueBufferType = Array,
                xf.prototype.DefaultInterpolation = Yg,
                xf.prototype.InterpolantFactoryMethodLinear = void 0,
                xf.prototype.InterpolantFactoryMethodSmooth = void 0;
                var bv = class extends ao {
                    constructor(e, t, n, i) {
                        super(e, t, n, i)
                    }
                }
                ;
                bv.prototype.ValueTypeName = "vector";
                var Ev = class {
                    constructor(e="", t=-1, n=[], i=y_) {
                        this.name = e,
                        this.tracks = n,
                        this.duration = t,
                        this.blendMode = i,
                        this.uuid = wr(),
                        this.userData = {},
                        this.duration < 0 && this.resetDuration()
                    }
                    static parse(e) {
                        const t = []
                          , n = e.tracks
                          , i = 1 / (e.fps || 1);
                        for (let r = 0, l = n.length; r !== l; ++r)
                            t.push(DP(n[r]).scale(i));
                        const s = new this(e.name,e.duration,t,e.blendMode);
                        return s.uuid = e.uuid,
                        s.userData = JSON.parse(e.userData || "{}"),
                        s
                    }
                    static toJSON(e) {
                        const t = []
                          , n = e.tracks
                          , i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode,
                            userData: JSON.stringify(e.userData)
                        };
                        for (let s = 0, r = n.length; s !== r; ++s)
                            t.push(ao.toJSON(n[s]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(e, t, n, i) {
                        const s = t.length
                          , r = [];
                        for (let l = 0; l < s; l++) {
                            let h = []
                              , d = [];
                            h.push((l + s - 1) % s, l, (l + 1) % s),
                            d.push(0, 1, 0);
                            const p = LC(h);
                            h = bT(h, 1, p),
                            d = bT(d, 1, p),
                            !i && h[0] === 0 && (h.push(s),
                            d.push(d[0])),
                            r.push(new Tv(".morphTargetInfluences[" + t[l].name + "]",h,d).scale(1 / n))
                        }
                        return new this(e,-1,r)
                    }
                    static findByName(e, t) {
                        let n = e;
                        if (!Array.isArray(e)) {
                            const i = e;
                            n = i.geometry && i.geometry.animations || i.animations
                        }
                        for (let i = 0; i < n.length; i++)
                            if (n[i].name === t)
                                return n[i];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(e, t, n) {
                        const i = {}
                          , s = /^([\w-]*?)([\d]+)$/;
                        for (let l = 0, h = e.length; l < h; l++) {
                            const d = e[l]
                              , p = d.name.match(s);
                            if (p && p.length > 1) {
                                const m = p[1];
                                let v = i[m];
                                v || (i[m] = v = []),
                                v.push(d)
                            }
                        }
                        const r = [];
                        for (const l in i)
                            r.push(this.CreateFromMorphTargetSequence(l, i[l], t, n));
                        return r
                    }
                    static parseAnimation(e, t) {
                        if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
                        !e)
                            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                            null;
                        const n = function(p, m, v, _, x) {
                            if (v.length !== 0) {
                                const b = []
                                  , E = [];
                                ET(v, b, E, _),
                                b.length !== 0 && x.push(new p(m,b,E))
                            }
                        }
                          , i = []
                          , s = e.name || "default"
                          , r = e.fps || 30
                          , l = e.blendMode;
                        let h = e.length || -1;
                        const d = e.hierarchy || [];
                        for (let p = 0; p < d.length; p++) {
                            const m = d[p].keys;
                            if (!(!m || m.length === 0))
                                if (m[0].morphTargets) {
                                    const v = {};
                                    let _;
                                    for (_ = 0; _ < m.length; _++)
                                        if (m[_].morphTargets)
                                            for (let x = 0; x < m[_].morphTargets.length; x++)
                                                v[m[_].morphTargets[x]] = -1;
                                    for (const x in v) {
                                        const b = []
                                          , E = [];
                                        for (let T = 0; T !== m[_].morphTargets.length; ++T) {
                                            const M = m[_];
                                            b.push(M.time),
                                            E.push(M.morphTarget === x ? 1 : 0)
                                        }
                                        i.push(new Tv(".morphTargetInfluence[" + x + "]",b,E))
                                    }
                                    h = v.length * r
                                } else {
                                    const v = ".bones[" + t[p].name + "]";
                                    n(bv, v + ".position", m, "pos", i),
                                    n(Mv, v + ".quaternion", m, "rot", i),
                                    n(bv, v + ".scale", m, "scl", i)
                                }
                        }
                        return i.length === 0 ? null : new this(s,h,i,l)
                    }
                    resetDuration() {
                        const e = this.tracks;
                        let t = 0;
                        for (let n = 0, i = e.length; n !== i; ++n) {
                            const s = this.tracks[n];
                            t = Math.max(t, s.times[s.times.length - 1])
                        }
                        return this.duration = t,
                        this
                    }
                    trim() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let e = !0;
                        for (let t = 0; t < this.tracks.length; t++)
                            e = e && this.tracks[t].validate();
                        return e
                    }
                    optimize() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].optimize();
                        return this
                    }
                    clone() {
                        const e = [];
                        for (let n = 0; n < this.tracks.length; n++)
                            e.push(this.tracks[n].clone());
                        const t = new this.constructor(this.name,this.duration,e,this.blendMode);
                        return t.userData = JSON.parse(JSON.stringify(this.userData)),
                        t
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }
                ;
                function RP(e) {
                    switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Tv;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return bv;
                    case "color":
                        return CT;
                    case "quaternion":
                        return Mv;
                    case "bool":
                    case "boolean":
                        return _f;
                    case "string":
                        return xf
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }
                function DP(e) {
                    if (e.type === void 0)
                        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const t = RP(e.type);
                    if (e.times === void 0) {
                        const n = []
                          , i = [];
                        ET(e.keys, n, i, "value"),
                        e.times = n,
                        e.values = i
                    }
                    return t.parse !== void 0 ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
                }
                const Vl = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        this.enabled !== !1 && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (this.enabled !== !1)
                            return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                var fx = class {
                    constructor(e, t, n) {
                        const i = this;
                        let s = !1, r = 0, l = 0, h;
                        const d = [];
                        this.onStart = void 0,
                        this.onLoad = e,
                        this.onProgress = t,
                        this.onError = n,
                        this.abortController = new AbortController,
                        this.itemStart = function(p) {
                            l++,
                            s === !1 && i.onStart !== void 0 && i.onStart(p, r, l),
                            s = !0
                        }
                        ,
                        this.itemEnd = function(p) {
                            r++,
                            i.onProgress !== void 0 && i.onProgress(p, r, l),
                            r === l && (s = !1,
                            i.onLoad !== void 0 && i.onLoad())
                        }
                        ,
                        this.itemError = function(p) {
                            i.onError !== void 0 && i.onError(p)
                        }
                        ,
                        this.resolveURL = function(p) {
                            return h ? h(p) : p
                        }
                        ,
                        this.setURLModifier = function(p) {
                            return h = p,
                            this
                        }
                        ,
                        this.addHandler = function(p, m) {
                            return d.push(p, m),
                            this
                        }
                        ,
                        this.removeHandler = function(p) {
                            const m = d.indexOf(p);
                            return m !== -1 && d.splice(m, 2),
                            this
                        }
                        ,
                        this.getHandler = function(p) {
                            for (let m = 0, v = d.length; m < v; m += 2) {
                                const _ = d[m]
                                  , x = d[m + 1];
                                if (_.global && (_.lastIndex = 0),
                                _.test(p))
                                    return x
                            }
                            return null
                        }
                        ,
                        this.abort = function() {
                            return this.abortController.abort(),
                            this.abortController = new AbortController,
                            this
                        }
                    }
                }
                ;
                const VC = new fx;
                var ar = class {
                    constructor(e) {
                        this.manager = e !== void 0 ? e : VC,
                        this.crossOrigin = "anonymous",
                        this.withCredentials = !1,
                        this.path = "",
                        this.resourcePath = "",
                        this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(e, t) {
                        const n = this;
                        return new Promise(function(i, s) {
                            n.load(e, i, t, s)
                        }
                        )
                    }
                    parse() {}
                    setCrossOrigin(e) {
                        return this.crossOrigin = e,
                        this
                    }
                    setWithCredentials(e) {
                        return this.withCredentials = e,
                        this
                    }
                    setPath(e) {
                        return this.path = e,
                        this
                    }
                    setResourcePath(e) {
                        return this.resourcePath = e,
                        this
                    }
                    setRequestHeader(e) {
                        return this.requestHeader = e,
                        this
                    }
                    abort() {
                        return this
                    }
                }
                ;
                ar.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                const Oc = {};
                var OP = class extends Error {
                    constructor(e, t) {
                        super(e),
                        this.response = t
                    }
                }
                  , Nc = class extends ar {
                    constructor(e) {
                        super(e),
                        this.mimeType = "",
                        this.responseType = "",
                        this._abortController = new AbortController
                    }
                    load(e, t, n, i) {
                        e === void 0 && (e = ""),
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const s = Vl.get(`file:${e}`);
                        if (s !== void 0)
                            return this.manager.itemStart(e),
                            setTimeout( () => {
                                t && t(s),
                                this.manager.itemEnd(e)
                            }
                            , 0),
                            s;
                        if (Oc[e] !== void 0) {
                            Oc[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: i
                            });
                            return
                        }
                        Oc[e] = [],
                        Oc[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        });
                        const r = new Request(e,{
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin",
                            signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
                        })
                          , l = this.mimeType
                          , h = this.responseType;
                        fetch(r).then(d => {
                            if (d.status === 200 || d.status === 0) {
                                if (d.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                                typeof ReadableStream > "u" || d.body === void 0 || d.body.getReader === void 0)
                                    return d;
                                const p = Oc[e]
                                  , m = d.body.getReader()
                                  , v = d.headers.get("X-File-Size") || d.headers.get("Content-Length")
                                  , _ = v ? parseInt(v) : 0
                                  , x = _ !== 0;
                                let b = 0;
                                const E = new ReadableStream({
                                    start(T) {
                                        M();
                                        function M() {
                                            m.read().then( ({done: D, value: R}) => {
                                                if (D)
                                                    T.close();
                                                else {
                                                    b += R.byteLength;
                                                    const O = new ProgressEvent("progress",{
                                                        lengthComputable: x,
                                                        loaded: b,
                                                        total: _
                                                    });
                                                    for (let U = 0, B = p.length; U < B; U++) {
                                                        const I = p[U];
                                                        I.onProgress && I.onProgress(O)
                                                    }
                                                    T.enqueue(R),
                                                    M()
                                                }
                                            }
                                            , D => {
                                                T.error(D)
                                            }
                                            )
                                        }
                                    }
                                });
                                return new Response(E)
                            } else
                                throw new OP(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,d)
                        }
                        ).then(d => {
                            switch (h) {
                            case "arraybuffer":
                                return d.arrayBuffer();
                            case "blob":
                                return d.blob();
                            case "document":
                                return d.text().then(p => new DOMParser().parseFromString(p, l));
                            case "json":
                                return d.json();
                            default:
                                if (l === "")
                                    return d.text();
                                {
                                    const p = /charset="?([^;"\s]*)"?/i.exec(l)
                                      , m = p && p[1] ? p[1].toLowerCase() : void 0
                                      , v = new TextDecoder(m);
                                    return d.arrayBuffer().then(_ => v.decode(_))
                                }
                            }
                        }
                        ).then(d => {
                            Vl.add(`file:${e}`, d);
                            const p = Oc[e];
                            delete Oc[e];
                            for (let m = 0, v = p.length; m < v; m++) {
                                const _ = p[m];
                                _.onLoad && _.onLoad(d)
                            }
                        }
                        ).catch(d => {
                            const p = Oc[e];
                            if (p === void 0)
                                throw this.manager.itemError(e),
                                d;
                            delete Oc[e];
                            for (let m = 0, v = p.length; m < v; m++) {
                                const _ = p[m];
                                _.onError && _.onError(d)
                            }
                            this.manager.itemError(e)
                        }
                        ).finally( () => {
                            this.manager.itemEnd(e)
                        }
                        ),
                        this.manager.itemStart(e)
                    }
                    setResponseType(e) {
                        return this.responseType = e,
                        this
                    }
                    setMimeType(e) {
                        return this.mimeType = e,
                        this
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                  , NP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , r = new Nc(this.manager);
                        r.setPath(this.path),
                        r.setRequestHeader(this.requestHeader),
                        r.setWithCredentials(this.withCredentials),
                        r.load(e, function(l) {
                            try {
                                t(s.parse(JSON.parse(l)))
                            } catch (h) {
                                i ? i(h) : console.error(h),
                                s.manager.itemError(e)
                            }
                        }, n, i)
                    }
                    parse(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const i = Ev.parse(e[n]);
                            t.push(i)
                        }
                        return t
                    }
                }
                  , UP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , r = []
                          , l = new ex
                          , h = new Nc(this.manager);
                        h.setPath(this.path),
                        h.setResponseType("arraybuffer"),
                        h.setRequestHeader(this.requestHeader),
                        h.setWithCredentials(s.withCredentials);
                        let d = 0;
                        function p(m) {
                            h.load(e[m], function(v) {
                                const _ = s.parse(v, !0);
                                r[m] = {
                                    width: _.width,
                                    height: _.height,
                                    format: _.format,
                                    mipmaps: _.mipmaps
                                },
                                d += 1,
                                d === 6 && (_.mipmapCount === 1 && (l.minFilter = mi),
                                l.image = r,
                                l.format = _.format,
                                l.needsUpdate = !0,
                                t && t(l))
                            }, n, i)
                        }
                        if (Array.isArray(e))
                            for (let m = 0, v = e.length; m < v; ++m)
                                p(m);
                        else
                            h.load(e, function(m) {
                                const v = s.parse(m, !0);
                                if (v.isCubemap) {
                                    const _ = v.mipmaps.length / v.mipmapCount;
                                    for (let x = 0; x < _; x++) {
                                        r[x] = {
                                            mipmaps: []
                                        };
                                        for (let b = 0; b < v.mipmapCount; b++)
                                            r[x].mipmaps.push(v.mipmaps[x * v.mipmapCount + b]),
                                            r[x].format = v.format,
                                            r[x].width = v.width,
                                            r[x].height = v.height
                                    }
                                    l.image = r
                                } else
                                    l.image.width = v.width,
                                    l.image.height = v.height,
                                    l.mipmaps = v.mipmaps;
                                v.mipmapCount === 1 && (l.minFilter = mi),
                                l.format = v.format,
                                l.needsUpdate = !0,
                                t && t(l)
                            }, n, i);
                        return l
                    }
                }
                ;
                const Pp = new WeakMap;
                var wv = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const s = this
                          , r = Vl.get(`image:${e}`);
                        if (r !== void 0) {
                            if (r.complete === !0)
                                s.manager.itemStart(e),
                                setTimeout(function() {
                                    t && t(r),
                                    s.manager.itemEnd(e)
                                }, 0);
                            else {
                                let m = Pp.get(r);
                                m === void 0 && (m = [],
                                Pp.set(r, m)),
                                m.push({
                                    onLoad: t,
                                    onError: i
                                })
                            }
                            return r
                        }
                        const l = Kg("img");
                        function h() {
                            p(),
                            t && t(this);
                            const m = Pp.get(this) || [];
                            for (let v = 0; v < m.length; v++) {
                                const _ = m[v];
                                _.onLoad && _.onLoad(this)
                            }
                            Pp.delete(this),
                            s.manager.itemEnd(e)
                        }
                        function d(m) {
                            p(),
                            i && i(m),
                            Vl.remove(`image:${e}`);
                            const v = Pp.get(this) || [];
                            for (let _ = 0; _ < v.length; _++) {
                                const x = v[_];
                                x.onError && x.onError(m)
                            }
                            Pp.delete(this),
                            s.manager.itemError(e),
                            s.manager.itemEnd(e)
                        }
                        function p() {
                            l.removeEventListener("load", h, !1),
                            l.removeEventListener("error", d, !1)
                        }
                        return l.addEventListener("load", h, !1),
                        l.addEventListener("error", d, !1),
                        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin),
                        Vl.add(`image:${e}`, l),
                        s.manager.itemStart(e),
                        l.src = e,
                        l
                    }
                }
                  , BP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = new rv;
                        s.colorSpace = $t;
                        const r = new wv(this.manager);
                        r.setCrossOrigin(this.crossOrigin),
                        r.setPath(this.path);
                        let l = 0;
                        function h(d) {
                            r.load(e[d], function(p) {
                                s.images[d] = p,
                                l++,
                                l === 6 && (s.needsUpdate = !0,
                                t && t(s))
                            }, void 0, i)
                        }
                        for (let d = 0; d < e.length; ++d)
                            h(d);
                        return s
                    }
                }
                  , PP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , r = new Xo
                          , l = new Nc(this.manager);
                        return l.setResponseType("arraybuffer"),
                        l.setRequestHeader(this.requestHeader),
                        l.setPath(this.path),
                        l.setWithCredentials(s.withCredentials),
                        l.load(e, function(h) {
                            let d;
                            try {
                                d = s.parse(h)
                            } catch (p) {
                                if (i !== void 0)
                                    i(p);
                                else {
                                    console.error(p);
                                    return
                                }
                            }
                            d.image !== void 0 ? r.image = d.image : d.data !== void 0 && (r.image.width = d.width,
                            r.image.height = d.height,
                            r.image.data = d.data),
                            r.wrapS = d.wrapS !== void 0 ? d.wrapS : no,
                            r.wrapT = d.wrapT !== void 0 ? d.wrapT : no,
                            r.magFilter = d.magFilter !== void 0 ? d.magFilter : mi,
                            r.minFilter = d.minFilter !== void 0 ? d.minFilter : mi,
                            r.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1,
                            d.colorSpace !== void 0 && (r.colorSpace = d.colorSpace),
                            d.flipY !== void 0 && (r.flipY = d.flipY),
                            d.format !== void 0 && (r.format = d.format),
                            d.type !== void 0 && (r.type = d.type),
                            d.mipmaps !== void 0 && (r.mipmaps = d.mipmaps,
                            r.minFilter = Pl),
                            d.mipmapCount === 1 && (r.minFilter = mi),
                            d.generateMipmaps !== void 0 && (r.generateMipmaps = d.generateMipmaps),
                            r.needsUpdate = !0,
                            t && t(r, d)
                        }, n, i),
                        r
                    }
                }
                  , IP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = new zi
                          , r = new wv(this.manager);
                        return r.setCrossOrigin(this.crossOrigin),
                        r.setPath(this.path),
                        r.load(e, function(l) {
                            s.image = l,
                            s.needsUpdate = !0,
                            t !== void 0 && t(s)
                        }, n, i),
                        s
                    }
                }
                  , qu = class extends jn {
                    constructor(e, t=1) {
                        super(),
                        this.isLight = !0,
                        this.type = "Light",
                        this.color = new at(e),
                        this.intensity = t
                    }
                    dispose() {}
                    copy(e, t) {
                        return super.copy(e, t),
                        this.color.copy(e.color),
                        this.intensity = e.intensity,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.color = this.color.getHex(),
                        t.object.intensity = this.intensity,
                        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
                        this.distance !== void 0 && (t.object.distance = this.distance),
                        this.angle !== void 0 && (t.object.angle = this.angle),
                        this.decay !== void 0 && (t.object.decay = this.decay),
                        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
                        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
                        this.target !== void 0 && (t.object.target = this.target.uuid),
                        t
                    }
                }
                  , GC = class extends qu {
                    constructor(e, t, n) {
                        super(e, n),
                        this.isHemisphereLight = !0,
                        this.type = "HemisphereLight",
                        this.position.copy(jn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.groundColor = new at(t)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.groundColor.copy(e.groundColor),
                        this
                    }
                }
                ;
                const RT = new Xt
                  , kC = new Q
                  , XC = new Q;
                var DT = class {
                    constructor(e) {
                        this.camera = e,
                        this.intensity = 1,
                        this.bias = 0,
                        this.normalBias = 0,
                        this.radius = 1,
                        this.blurSamples = 8,
                        this.mapSize = new ye(512,512),
                        this.mapType = ui,
                        this.map = null,
                        this.mapPass = null,
                        this.matrix = new Xt,
                        this.autoUpdate = !0,
                        this.needsUpdate = !1,
                        this._frustum = new Np,
                        this._frameExtents = new ye(1,1),
                        this._viewportCount = 1,
                        this._viewports = [new gn(0,0,1,1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(e) {
                        const t = this.camera
                          , n = this.matrix;
                        kC.setFromMatrixPosition(e.matrixWorld),
                        t.position.copy(kC),
                        XC.setFromMatrixPosition(e.target.matrixWorld),
                        t.lookAt(XC),
                        t.updateMatrixWorld(),
                        RT.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(RT, t.coordinateSystem, t.reversedDepth),
                        t.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        n.multiply(RT)
                    }
                    getViewport(e) {
                        return this._viewports[e]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(),
                        this.mapPass && this.mapPass.dispose()
                    }
                    copy(e) {
                        return this.camera = e.camera.clone(),
                        this.intensity = e.intensity,
                        this.bias = e.bias,
                        this.radius = e.radius,
                        this.autoUpdate = e.autoUpdate,
                        this.needsUpdate = e.needsUpdate,
                        this.normalBias = e.normalBias,
                        this.blurSamples = e.blurSamples,
                        this.mapSize.copy(e.mapSize),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        const e = {};
                        return this.intensity !== 1 && (e.intensity = this.intensity),
                        this.bias !== 0 && (e.bias = this.bias),
                        this.normalBias !== 0 && (e.normalBias = this.normalBias),
                        this.radius !== 1 && (e.radius = this.radius),
                        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
                        e.camera = this.camera.toJSON(!1).object,
                        delete e.camera.matrix,
                        e
                    }
                }
                  , LP = class extends DT {
                    constructor() {
                        super(new hi(50,1,.5,500)),
                        this.isSpotLightShadow = !0,
                        this.focus = 1,
                        this.aspect = 1
                    }
                    updateMatrices(e) {
                        const t = this.camera
                          , n = op * 2 * e.angle * this.focus
                          , i = this.mapSize.width / this.mapSize.height * this.aspect
                          , s = e.distance || t.far;
                        (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n,
                        t.aspect = i,
                        t.far = s,
                        t.updateProjectionMatrix()),
                        super.updateMatrices(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.focus = e.focus,
                        this
                    }
                }
                  , qC = class extends qu {
                    constructor(e, t, n=0, i=Math.PI / 3, s=0, r=2) {
                        super(e, t),
                        this.isSpotLight = !0,
                        this.type = "SpotLight",
                        this.position.copy(jn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new jn,
                        this.distance = n,
                        this.angle = i,
                        this.penumbra = s,
                        this.decay = r,
                        this.map = null,
                        this.shadow = new LP
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.distance = e.distance,
                        this.angle = e.angle,
                        this.penumbra = e.penumbra,
                        this.decay = e.decay,
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }
                ;
                const YC = new Xt
                  , Cv = new Q
                  , OT = new Q;
                var zP = class extends DT {
                    constructor() {
                        super(new hi(90,1,.5,500)),
                        this.isPointLightShadow = !0,
                        this._frameExtents = new ye(4,2),
                        this._viewportCount = 6,
                        this._viewports = [new gn(2,1,1,1), new gn(0,1,1,1), new gn(3,1,1,1), new gn(1,1,1,1), new gn(3,0,1,1), new gn(1,0,1,1)],
                        this._cubeDirections = [new Q(1,0,0), new Q(-1,0,0), new Q(0,0,1), new Q(0,0,-1), new Q(0,1,0), new Q(0,-1,0)],
                        this._cubeUps = [new Q(0,1,0), new Q(0,1,0), new Q(0,1,0), new Q(0,1,0), new Q(0,0,1), new Q(0,0,-1)]
                    }
                    updateMatrices(e, t=0) {
                        const n = this.camera
                          , i = this.matrix
                          , s = e.distance || n.far;
                        s !== n.far && (n.far = s,
                        n.updateProjectionMatrix()),
                        Cv.setFromMatrixPosition(e.matrixWorld),
                        n.position.copy(Cv),
                        OT.copy(n.position),
                        OT.add(this._cubeDirections[t]),
                        n.up.copy(this._cubeUps[t]),
                        n.lookAt(OT),
                        n.updateMatrixWorld(),
                        i.makeTranslation(-Cv.x, -Cv.y, -Cv.z),
                        YC.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(YC, n.coordinateSystem, n.reversedDepth)
                    }
                }
                  , WC = class extends qu {
                    constructor(e, t, n=0, i=2) {
                        super(e, t),
                        this.isPointLight = !0,
                        this.type = "PointLight",
                        this.distance = n,
                        this.decay = i,
                        this.shadow = new zP
                    }
                    get power() {
                        return this.intensity * 4 * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.distance = e.distance,
                        this.decay = e.decay,
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }
                  , Yu = class extends av {
                    constructor(e=-1, t=1, n=1, i=-1, s=.1, r=2e3) {
                        super(),
                        this.isOrthographicCamera = !0,
                        this.type = "OrthographicCamera",
                        this.zoom = 1,
                        this.view = null,
                        this.left = e,
                        this.right = t,
                        this.top = n,
                        this.bottom = i,
                        this.near = s,
                        this.far = r,
                        this.updateProjectionMatrix()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.left = e.left,
                        this.right = e.right,
                        this.top = e.top,
                        this.bottom = e.bottom,
                        this.near = e.near,
                        this.far = e.far,
                        this.zoom = e.zoom,
                        this.view = e.view === null ? null : Object.assign({}, e.view),
                        this
                    }
                    setViewOffset(e, t, n, i, s, r) {
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = s,
                        this.view.height = r,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const e = (this.right - this.left) / (2 * this.zoom)
                          , t = (this.top - this.bottom) / (2 * this.zoom)
                          , n = (this.right + this.left) / 2
                          , i = (this.top + this.bottom) / 2;
                        let s = n - e
                          , r = n + e
                          , l = i + t
                          , h = i - t;
                        if (this.view !== null && this.view.enabled) {
                            const d = (this.right - this.left) / this.view.fullWidth / this.zoom
                              , p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            s += d * this.view.offsetX,
                            r = s + d * this.view.width,
                            l -= p * this.view.offsetY,
                            h = l - p * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(s, r, l, h, this.near, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.zoom = this.zoom,
                        t.object.left = this.left,
                        t.object.right = this.right,
                        t.object.top = this.top,
                        t.object.bottom = this.bottom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        this.view !== null && (t.object.view = Object.assign({}, this.view)),
                        t
                    }
                }
                  , FP = class extends DT {
                    constructor() {
                        super(new Yu(-5,5,5,-5,.5,500)),
                        this.isDirectionalLightShadow = !0
                    }
                }
                  , jC = class extends qu {
                    constructor(e, t) {
                        super(e, t),
                        this.isDirectionalLight = !0,
                        this.type = "DirectionalLight",
                        this.position.copy(jn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new jn,
                        this.shadow = new FP
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(e) {
                        return super.copy(e),
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }
                  , QC = class extends qu {
                    constructor(e, t) {
                        super(e, t),
                        this.isAmbientLight = !0,
                        this.type = "AmbientLight"
                    }
                }
                  , ZC = class extends qu {
                    constructor(e, t, n=10, i=10) {
                        super(e, t),
                        this.isRectAreaLight = !0,
                        this.type = "RectAreaLight",
                        this.width = n,
                        this.height = i
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / (this.width * this.height * Math.PI)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.width = e.width,
                        this.height = e.height,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.width = this.width,
                        t.object.height = this.height,
                        t
                    }
                }
                  , KC = class {
                    constructor() {
                        this.isSphericalHarmonics3 = !0,
                        this.coefficients = [];
                        for (let e = 0; e < 9; e++)
                            this.coefficients.push(new Q)
                    }
                    set(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].copy(e[t]);
                        return this
                    }
                    zero() {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].set(0, 0, 0);
                        return this
                    }
                    getAt(e, t) {
                        const n = e.x
                          , i = e.y
                          , s = e.z
                          , r = this.coefficients;
                        return t.copy(r[0]).multiplyScalar(.282095),
                        t.addScaledVector(r[1], .488603 * i),
                        t.addScaledVector(r[2], .488603 * s),
                        t.addScaledVector(r[3], .488603 * n),
                        t.addScaledVector(r[4], 1.092548 * (n * i)),
                        t.addScaledVector(r[5], 1.092548 * (i * s)),
                        t.addScaledVector(r[6], .315392 * (3 * s * s - 1)),
                        t.addScaledVector(r[7], 1.092548 * (n * s)),
                        t.addScaledVector(r[8], .546274 * (n * n - i * i)),
                        t
                    }
                    getIrradianceAt(e, t) {
                        const n = e.x
                          , i = e.y
                          , s = e.z
                          , r = this.coefficients;
                        return t.copy(r[0]).multiplyScalar(.886227),
                        t.addScaledVector(r[1], 2 * .511664 * i),
                        t.addScaledVector(r[2], 2 * .511664 * s),
                        t.addScaledVector(r[3], 2 * .511664 * n),
                        t.addScaledVector(r[4], 2 * .429043 * n * i),
                        t.addScaledVector(r[5], 2 * .429043 * i * s),
                        t.addScaledVector(r[6], .743125 * s * s - .247708),
                        t.addScaledVector(r[7], 2 * .429043 * n * s),
                        t.addScaledVector(r[8], .429043 * (n * n - i * i)),
                        t
                    }
                    add(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].add(e.coefficients[t]);
                        return this
                    }
                    addScaledSH(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].addScaledVector(e.coefficients[n], t);
                        return this
                    }
                    scale(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].multiplyScalar(e);
                        return this
                    }
                    lerp(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].lerp(e.coefficients[n], t);
                        return this
                    }
                    equals(e) {
                        for (let t = 0; t < 9; t++)
                            if (!this.coefficients[t].equals(e.coefficients[t]))
                                return !1;
                        return !0
                    }
                    copy(e) {
                        return this.set(e.coefficients)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    fromArray(e, t=0) {
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++)
                            n[i].fromArray(e, t + i * 3);
                        return this
                    }
                    toArray(e=[], t=0) {
                        const n = this.coefficients;
                        for (let i = 0; i < 9; i++)
                            n[i].toArray(e, t + i * 3);
                        return e
                    }
                    static getBasisAt(e, t) {
                        const n = e.x
                          , i = e.y
                          , s = e.z;
                        t[0] = .282095,
                        t[1] = .488603 * i,
                        t[2] = .488603 * s,
                        t[3] = .488603 * n,
                        t[4] = 1.092548 * n * i,
                        t[5] = 1.092548 * i * s,
                        t[6] = .315392 * (3 * s * s - 1),
                        t[7] = 1.092548 * n * s,
                        t[8] = .546274 * (n * n - i * i)
                    }
                }
                  , JC = class extends qu {
                    constructor(e=new KC, t=1) {
                        super(void 0, t),
                        this.isLightProbe = !0,
                        this.sh = e
                    }
                    copy(e) {
                        return super.copy(e),
                        this.sh.copy(e.sh),
                        this
                    }
                    fromJSON(e) {
                        return this.intensity = e.intensity,
                        this.sh.fromArray(e.sh),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.sh = this.sh.toArray(),
                        t
                    }
                }
                  , $C = class KO extends ar {
                    constructor(t) {
                        super(t),
                        this.textures = {}
                    }
                    load(t, n, i, s) {
                        const r = this
                          , l = new Nc(r.manager);
                        l.setPath(r.path),
                        l.setRequestHeader(r.requestHeader),
                        l.setWithCredentials(r.withCredentials),
                        l.load(t, function(h) {
                            try {
                                n(r.parse(JSON.parse(h)))
                            } catch (d) {
                                s ? s(d) : console.error(d),
                                r.manager.itemError(t)
                            }
                        }, i, s)
                    }
                    parse(t) {
                        const n = this.textures;
                        function i(r) {
                            return n[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r),
                            n[r]
                        }
                        const s = this.createMaterialFromType(t.type);
                        if (t.uuid !== void 0 && (s.uuid = t.uuid),
                        t.name !== void 0 && (s.name = t.name),
                        t.color !== void 0 && s.color !== void 0 && s.color.setHex(t.color),
                        t.roughness !== void 0 && (s.roughness = t.roughness),
                        t.metalness !== void 0 && (s.metalness = t.metalness),
                        t.sheen !== void 0 && (s.sheen = t.sheen),
                        t.sheenColor !== void 0 && (s.sheenColor = new at().setHex(t.sheenColor)),
                        t.sheenRoughness !== void 0 && (s.sheenRoughness = t.sheenRoughness),
                        t.emissive !== void 0 && s.emissive !== void 0 && s.emissive.setHex(t.emissive),
                        t.specular !== void 0 && s.specular !== void 0 && s.specular.setHex(t.specular),
                        t.specularIntensity !== void 0 && (s.specularIntensity = t.specularIntensity),
                        t.specularColor !== void 0 && s.specularColor !== void 0 && s.specularColor.setHex(t.specularColor),
                        t.shininess !== void 0 && (s.shininess = t.shininess),
                        t.clearcoat !== void 0 && (s.clearcoat = t.clearcoat),
                        t.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = t.clearcoatRoughness),
                        t.dispersion !== void 0 && (s.dispersion = t.dispersion),
                        t.iridescence !== void 0 && (s.iridescence = t.iridescence),
                        t.iridescenceIOR !== void 0 && (s.iridescenceIOR = t.iridescenceIOR),
                        t.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = t.iridescenceThicknessRange),
                        t.transmission !== void 0 && (s.transmission = t.transmission),
                        t.thickness !== void 0 && (s.thickness = t.thickness),
                        t.attenuationDistance !== void 0 && (s.attenuationDistance = t.attenuationDistance),
                        t.attenuationColor !== void 0 && s.attenuationColor !== void 0 && s.attenuationColor.setHex(t.attenuationColor),
                        t.anisotropy !== void 0 && (s.anisotropy = t.anisotropy),
                        t.anisotropyRotation !== void 0 && (s.anisotropyRotation = t.anisotropyRotation),
                        t.fog !== void 0 && (s.fog = t.fog),
                        t.flatShading !== void 0 && (s.flatShading = t.flatShading),
                        t.blending !== void 0 && (s.blending = t.blending),
                        t.combine !== void 0 && (s.combine = t.combine),
                        t.side !== void 0 && (s.side = t.side),
                        t.shadowSide !== void 0 && (s.shadowSide = t.shadowSide),
                        t.opacity !== void 0 && (s.opacity = t.opacity),
                        t.transparent !== void 0 && (s.transparent = t.transparent),
                        t.alphaTest !== void 0 && (s.alphaTest = t.alphaTest),
                        t.alphaHash !== void 0 && (s.alphaHash = t.alphaHash),
                        t.depthFunc !== void 0 && (s.depthFunc = t.depthFunc),
                        t.depthTest !== void 0 && (s.depthTest = t.depthTest),
                        t.depthWrite !== void 0 && (s.depthWrite = t.depthWrite),
                        t.colorWrite !== void 0 && (s.colorWrite = t.colorWrite),
                        t.blendSrc !== void 0 && (s.blendSrc = t.blendSrc),
                        t.blendDst !== void 0 && (s.blendDst = t.blendDst),
                        t.blendEquation !== void 0 && (s.blendEquation = t.blendEquation),
                        t.blendSrcAlpha !== void 0 && (s.blendSrcAlpha = t.blendSrcAlpha),
                        t.blendDstAlpha !== void 0 && (s.blendDstAlpha = t.blendDstAlpha),
                        t.blendEquationAlpha !== void 0 && (s.blendEquationAlpha = t.blendEquationAlpha),
                        t.blendColor !== void 0 && s.blendColor !== void 0 && s.blendColor.setHex(t.blendColor),
                        t.blendAlpha !== void 0 && (s.blendAlpha = t.blendAlpha),
                        t.stencilWriteMask !== void 0 && (s.stencilWriteMask = t.stencilWriteMask),
                        t.stencilFunc !== void 0 && (s.stencilFunc = t.stencilFunc),
                        t.stencilRef !== void 0 && (s.stencilRef = t.stencilRef),
                        t.stencilFuncMask !== void 0 && (s.stencilFuncMask = t.stencilFuncMask),
                        t.stencilFail !== void 0 && (s.stencilFail = t.stencilFail),
                        t.stencilZFail !== void 0 && (s.stencilZFail = t.stencilZFail),
                        t.stencilZPass !== void 0 && (s.stencilZPass = t.stencilZPass),
                        t.stencilWrite !== void 0 && (s.stencilWrite = t.stencilWrite),
                        t.wireframe !== void 0 && (s.wireframe = t.wireframe),
                        t.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = t.wireframeLinewidth),
                        t.wireframeLinecap !== void 0 && (s.wireframeLinecap = t.wireframeLinecap),
                        t.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = t.wireframeLinejoin),
                        t.rotation !== void 0 && (s.rotation = t.rotation),
                        t.linewidth !== void 0 && (s.linewidth = t.linewidth),
                        t.dashSize !== void 0 && (s.dashSize = t.dashSize),
                        t.gapSize !== void 0 && (s.gapSize = t.gapSize),
                        t.scale !== void 0 && (s.scale = t.scale),
                        t.polygonOffset !== void 0 && (s.polygonOffset = t.polygonOffset),
                        t.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = t.polygonOffsetFactor),
                        t.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = t.polygonOffsetUnits),
                        t.dithering !== void 0 && (s.dithering = t.dithering),
                        t.alphaToCoverage !== void 0 && (s.alphaToCoverage = t.alphaToCoverage),
                        t.premultipliedAlpha !== void 0 && (s.premultipliedAlpha = t.premultipliedAlpha),
                        t.forceSinglePass !== void 0 && (s.forceSinglePass = t.forceSinglePass),
                        t.visible !== void 0 && (s.visible = t.visible),
                        t.toneMapped !== void 0 && (s.toneMapped = t.toneMapped),
                        t.userData !== void 0 && (s.userData = t.userData),
                        t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? s.vertexColors = t.vertexColors > 0 : s.vertexColors = t.vertexColors),
                        t.uniforms !== void 0)
                            for (const r in t.uniforms) {
                                const l = t.uniforms[r];
                                switch (s.uniforms[r] = {},
                                l.type) {
                                case "t":
                                    s.uniforms[r].value = i(l.value);
                                    break;
                                case "c":
                                    s.uniforms[r].value = new at().setHex(l.value);
                                    break;
                                case "v2":
                                    s.uniforms[r].value = new ye().fromArray(l.value);
                                    break;
                                case "v3":
                                    s.uniforms[r].value = new Q().fromArray(l.value);
                                    break;
                                case "v4":
                                    s.uniforms[r].value = new gn().fromArray(l.value);
                                    break;
                                case "m3":
                                    s.uniforms[r].value = new rn().fromArray(l.value);
                                    break;
                                case "m4":
                                    s.uniforms[r].value = new Xt().fromArray(l.value);
                                    break;
                                default:
                                    s.uniforms[r].value = l.value
                                }
                            }
                        if (t.defines !== void 0 && (s.defines = t.defines),
                        t.vertexShader !== void 0 && (s.vertexShader = t.vertexShader),
                        t.fragmentShader !== void 0 && (s.fragmentShader = t.fragmentShader),
                        t.glslVersion !== void 0 && (s.glslVersion = t.glslVersion),
                        t.extensions !== void 0)
                            for (const r in t.extensions)
                                s.extensions[r] = t.extensions[r];
                        if (t.lights !== void 0 && (s.lights = t.lights),
                        t.clipping !== void 0 && (s.clipping = t.clipping),
                        t.size !== void 0 && (s.size = t.size),
                        t.sizeAttenuation !== void 0 && (s.sizeAttenuation = t.sizeAttenuation),
                        t.map !== void 0 && (s.map = i(t.map)),
                        t.matcap !== void 0 && (s.matcap = i(t.matcap)),
                        t.alphaMap !== void 0 && (s.alphaMap = i(t.alphaMap)),
                        t.bumpMap !== void 0 && (s.bumpMap = i(t.bumpMap)),
                        t.bumpScale !== void 0 && (s.bumpScale = t.bumpScale),
                        t.normalMap !== void 0 && (s.normalMap = i(t.normalMap)),
                        t.normalMapType !== void 0 && (s.normalMapType = t.normalMapType),
                        t.normalScale !== void 0) {
                            let r = t.normalScale;
                            Array.isArray(r) === !1 && (r = [r, r]),
                            s.normalScale = new ye().fromArray(r)
                        }
                        return t.displacementMap !== void 0 && (s.displacementMap = i(t.displacementMap)),
                        t.displacementScale !== void 0 && (s.displacementScale = t.displacementScale),
                        t.displacementBias !== void 0 && (s.displacementBias = t.displacementBias),
                        t.roughnessMap !== void 0 && (s.roughnessMap = i(t.roughnessMap)),
                        t.metalnessMap !== void 0 && (s.metalnessMap = i(t.metalnessMap)),
                        t.emissiveMap !== void 0 && (s.emissiveMap = i(t.emissiveMap)),
                        t.emissiveIntensity !== void 0 && (s.emissiveIntensity = t.emissiveIntensity),
                        t.specularMap !== void 0 && (s.specularMap = i(t.specularMap)),
                        t.specularIntensityMap !== void 0 && (s.specularIntensityMap = i(t.specularIntensityMap)),
                        t.specularColorMap !== void 0 && (s.specularColorMap = i(t.specularColorMap)),
                        t.envMap !== void 0 && (s.envMap = i(t.envMap)),
                        t.envMapRotation !== void 0 && s.envMapRotation.fromArray(t.envMapRotation),
                        t.envMapIntensity !== void 0 && (s.envMapIntensity = t.envMapIntensity),
                        t.reflectivity !== void 0 && (s.reflectivity = t.reflectivity),
                        t.refractionRatio !== void 0 && (s.refractionRatio = t.refractionRatio),
                        t.lightMap !== void 0 && (s.lightMap = i(t.lightMap)),
                        t.lightMapIntensity !== void 0 && (s.lightMapIntensity = t.lightMapIntensity),
                        t.aoMap !== void 0 && (s.aoMap = i(t.aoMap)),
                        t.aoMapIntensity !== void 0 && (s.aoMapIntensity = t.aoMapIntensity),
                        t.gradientMap !== void 0 && (s.gradientMap = i(t.gradientMap)),
                        t.clearcoatMap !== void 0 && (s.clearcoatMap = i(t.clearcoatMap)),
                        t.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)),
                        t.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = i(t.clearcoatNormalMap)),
                        t.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new ye().fromArray(t.clearcoatNormalScale)),
                        t.iridescenceMap !== void 0 && (s.iridescenceMap = i(t.iridescenceMap)),
                        t.iridescenceThicknessMap !== void 0 && (s.iridescenceThicknessMap = i(t.iridescenceThicknessMap)),
                        t.transmissionMap !== void 0 && (s.transmissionMap = i(t.transmissionMap)),
                        t.thicknessMap !== void 0 && (s.thicknessMap = i(t.thicknessMap)),
                        t.anisotropyMap !== void 0 && (s.anisotropyMap = i(t.anisotropyMap)),
                        t.sheenColorMap !== void 0 && (s.sheenColorMap = i(t.sheenColorMap)),
                        t.sheenRoughnessMap !== void 0 && (s.sheenRoughnessMap = i(t.sheenRoughnessMap)),
                        s
                    }
                    setTextures(t) {
                        return this.textures = t,
                        this
                    }
                    createMaterialFromType(t) {
                        return KO.createMaterialFromType(t)
                    }
                    static createMaterialFromType(t) {
                        return new {
                            ShadowMaterial: CC,
                            SpriteMaterial: jA,
                            RawShaderMaterial: RC,
                            ShaderMaterial: Fn,
                            PointsMaterial: iT,
                            MeshPhysicalMaterial: DC,
                            MeshStandardMaterial: AT,
                            MeshPhongMaterial: OC,
                            MeshToonMaterial: NC,
                            MeshNormalMaterial: TT,
                            MeshLambertMaterial: UC,
                            MeshDepthMaterial: hx,
                            MeshDistanceMaterial: MT,
                            MeshBasicMaterial: Gu,
                            MeshMatcapMaterial: BC,
                            LineDashedMaterial: PC,
                            LineBasicMaterial: Ia,
                            Material: Os
                        }[t]
                    }
                }
                  , NT = class {
                    static extractUrlBase(e) {
                        const t = e.lastIndexOf("/");
                        return t === -1 ? "./" : e.slice(0, t + 1)
                    }
                    static resolveURL(e, t) {
                        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                    }
                }
                  , e1 = class extends an {
                    constructor() {
                        super(),
                        this.isInstancedBufferGeometry = !0,
                        this.type = "InstancedBufferGeometry",
                        this.instanceCount = 1 / 0
                    }
                    copy(e) {
                        return super.copy(e),
                        this.instanceCount = e.instanceCount,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.instanceCount = this.instanceCount,
                        e.isInstancedBufferGeometry = !0,
                        e
                    }
                }
                  , t1 = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , r = new Nc(s.manager);
                        r.setPath(s.path),
                        r.setRequestHeader(s.requestHeader),
                        r.setWithCredentials(s.withCredentials),
                        r.load(e, function(l) {
                            try {
                                t(s.parse(JSON.parse(l)))
                            } catch (h) {
                                i ? i(h) : console.error(h),
                                s.manager.itemError(e)
                            }
                        }, n, i)
                    }
                    parse(e) {
                        const t = {}
                          , n = {};
                        function i(v, _) {
                            if (t[_] !== void 0)
                                return t[_];
                            const x = v.interleavedBuffers[_]
                              , b = s(v, x.buffer)
                              , E = lp(x.type, b)
                              , T = new z_(E,x.stride);
                            return T.uuid = x.uuid,
                            t[_] = T,
                            T
                        }
                        function s(v, _) {
                            if (n[_] !== void 0)
                                return n[_];
                            const x = v.arrayBuffers[_]
                              , b = new Uint32Array(x).buffer;
                            return n[_] = b,
                            b
                        }
                        const r = e.isInstancedBufferGeometry ? new e1 : new an
                          , l = e.data.index;
                        if (l !== void 0) {
                            const v = lp(l.type, l.array);
                            r.setIndex(new wn(v,1))
                        }
                        const h = e.data.attributes;
                        for (const v in h) {
                            const _ = h[v];
                            let x;
                            if (_.isInterleavedBufferAttribute) {
                                const b = i(e.data, _.data);
                                x = new ov(b,_.itemSize,_.offset,_.normalized)
                            } else {
                                const b = lp(_.type, _.array);
                                x = new (_.isInstancedBufferAttribute ? Dp : wn)(b,_.itemSize,_.normalized)
                            }
                            _.name !== void 0 && (x.name = _.name),
                            _.usage !== void 0 && x.setUsage(_.usage),
                            r.setAttribute(v, x)
                        }
                        const d = e.data.morphAttributes;
                        if (d)
                            for (const v in d) {
                                const _ = d[v]
                                  , x = [];
                                for (let b = 0, E = _.length; b < E; b++) {
                                    const T = _[b];
                                    let M;
                                    if (T.isInterleavedBufferAttribute) {
                                        const D = i(e.data, T.data);
                                        M = new ov(D,T.itemSize,T.offset,T.normalized)
                                    } else {
                                        const D = lp(T.type, T.array);
                                        M = new wn(D,T.itemSize,T.normalized)
                                    }
                                    T.name !== void 0 && (M.name = T.name),
                                    x.push(M)
                                }
                                r.morphAttributes[v] = x
                            }
                        e.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                        const p = e.data.groups || e.data.drawcalls || e.data.offsets;
                        if (p !== void 0)
                            for (let v = 0, _ = p.length; v !== _; ++v) {
                                const x = p[v];
                                r.addGroup(x.start, x.count, x.materialIndex)
                            }
                        const m = e.data.boundingSphere;
                        return m !== void 0 && (r.boundingSphere = new qs().fromJSON(m)),
                        e.name && (r.name = e.name),
                        e.userData && (r.userData = e.userData),
                        r
                    }
                }
                  , HP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , r = this.path === "" ? NT.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || r;
                        const l = new Nc(this.manager);
                        l.setPath(this.path),
                        l.setRequestHeader(this.requestHeader),
                        l.setWithCredentials(this.withCredentials),
                        l.load(e, function(h) {
                            let d = null;
                            try {
                                d = JSON.parse(h)
                            } catch (m) {
                                i !== void 0 && i(m),
                                console.error("THREE:ObjectLoader: Can't parse " + e + ".", m.message);
                                return
                            }
                            const p = d.metadata;
                            if (p === void 0 || p.type === void 0 || p.type.toLowerCase() === "geometry") {
                                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
                                console.error("THREE.ObjectLoader: Can't load " + e);
                                return
                            }
                            s.parse(d, t)
                        }, n, i)
                    }
                    async loadAsync(e, t) {
                        const n = this
                          , i = this.path === "" ? NT.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || i;
                        const s = new Nc(this.manager);
                        s.setPath(this.path),
                        s.setRequestHeader(this.requestHeader),
                        s.setWithCredentials(this.withCredentials);
                        const r = await s.loadAsync(e, t)
                          , l = JSON.parse(r)
                          , h = l.metadata;
                        if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry")
                            throw new Error("THREE.ObjectLoader: Can't load " + e);
                        return await n.parseAsync(l)
                    }
                    parse(e, t) {
                        const n = this.parseAnimations(e.animations)
                          , i = this.parseShapes(e.shapes)
                          , s = this.parseGeometries(e.geometries, i)
                          , r = this.parseImages(e.images, function() {
                            t !== void 0 && t(d)
                        })
                          , l = this.parseTextures(e.textures, r)
                          , h = this.parseMaterials(e.materials, l)
                          , d = this.parseObject(e.object, s, h, l, n)
                          , p = this.parseSkeletons(e.skeletons, d);
                        if (this.bindSkeletons(d, p),
                        this.bindLightTargets(d),
                        t !== void 0) {
                            let m = !1;
                            for (const v in r)
                                if (r[v].data instanceof HTMLImageElement) {
                                    m = !0;
                                    break
                                }
                            m === !1 && t(d)
                        }
                        return d
                    }
                    async parseAsync(e) {
                        const t = this.parseAnimations(e.animations)
                          , n = this.parseShapes(e.shapes)
                          , i = this.parseGeometries(e.geometries, n)
                          , s = await this.parseImagesAsync(e.images)
                          , r = this.parseTextures(e.textures, s)
                          , l = this.parseMaterials(e.materials, r)
                          , h = this.parseObject(e.object, i, l, r, t)
                          , d = this.parseSkeletons(e.skeletons, h);
                        return this.bindSkeletons(h, d),
                        this.bindLightTargets(h),
                        h
                    }
                    parseShapes(e) {
                        const t = {};
                        if (e !== void 0)
                            for (let n = 0, i = e.length; n < i; n++) {
                                const s = new gf().fromJSON(e[n]);
                                t[s.uuid] = s
                            }
                        return t
                    }
                    parseSkeletons(e, t) {
                        const n = {}
                          , i = {};
                        if (t.traverse(function(s) {
                            s.isBone && (i[s.uuid] = s)
                        }),
                        e !== void 0)
                            for (let s = 0, r = e.length; s < r; s++) {
                                const l = new Iw().fromJSON(e[s], i);
                                n[l.uuid] = l
                            }
                        return n
                    }
                    parseGeometries(e, t) {
                        const n = {};
                        if (e !== void 0) {
                            const i = new t1;
                            for (let s = 0, r = e.length; s < r; s++) {
                                let l;
                                const h = e[s];
                                switch (h.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    l = i.parse(h);
                                    break;
                                default:
                                    h.type in wC ? l = wC[h.type].fromJSON(h, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${h.type}"`)
                                }
                                l.uuid = h.uuid,
                                h.name !== void 0 && (l.name = h.name),
                                h.userData !== void 0 && (l.userData = h.userData),
                                n[h.uuid] = l
                            }
                        }
                        return n
                    }
                    parseMaterials(e, t) {
                        const n = {}
                          , i = {};
                        if (e !== void 0) {
                            const s = new $C;
                            s.setTextures(t);
                            for (let r = 0, l = e.length; r < l; r++) {
                                const h = e[r];
                                n[h.uuid] === void 0 && (n[h.uuid] = s.parse(h)),
                                i[h.uuid] = n[h.uuid]
                            }
                        }
                        return i
                    }
                    parseAnimations(e) {
                        const t = {};
                        if (e !== void 0)
                            for (let n = 0; n < e.length; n++) {
                                const i = e[n]
                                  , s = Ev.parse(i);
                                t[s.uuid] = s
                            }
                        return t
                    }
                    parseImages(e, t) {
                        const n = this
                          , i = {};
                        let s;
                        function r(h) {
                            return n.manager.itemStart(h),
                            s.load(h, function() {
                                n.manager.itemEnd(h)
                            }, void 0, function() {
                                n.manager.itemError(h),
                                n.manager.itemEnd(h)
                            })
                        }
                        function l(h) {
                            if (typeof h == "string") {
                                const d = h
                                  , p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                                return r(p)
                            } else
                                return h.data ? {
                                    data: lp(h.type, h.data),
                                    width: h.width,
                                    height: h.height
                                } : null
                        }
                        if (e !== void 0 && e.length > 0) {
                            const h = new fx(t);
                            s = new wv(h),
                            s.setCrossOrigin(this.crossOrigin);
                            for (let d = 0, p = e.length; d < p; d++) {
                                const m = e[d]
                                  , v = m.url;
                                if (Array.isArray(v)) {
                                    const _ = [];
                                    for (let x = 0, b = v.length; x < b; x++) {
                                        const E = v[x]
                                          , T = l(E);
                                        T !== null && (T instanceof HTMLImageElement ? _.push(T) : _.push(new Xo(T.data,T.width,T.height)))
                                    }
                                    i[m.uuid] = new Pu(_)
                                } else {
                                    const _ = l(m.url);
                                    i[m.uuid] = new Pu(_)
                                }
                            }
                        }
                        return i
                    }
                    async parseImagesAsync(e) {
                        const t = this
                          , n = {};
                        let i;
                        async function s(r) {
                            if (typeof r == "string") {
                                const l = r
                                  , h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
                                return await i.loadAsync(h)
                            } else
                                return r.data ? {
                                    data: lp(r.type, r.data),
                                    width: r.width,
                                    height: r.height
                                } : null
                        }
                        if (e !== void 0 && e.length > 0) {
                            i = new wv(this.manager),
                            i.setCrossOrigin(this.crossOrigin);
                            for (let r = 0, l = e.length; r < l; r++) {
                                const h = e[r]
                                  , d = h.url;
                                if (Array.isArray(d)) {
                                    const p = [];
                                    for (let m = 0, v = d.length; m < v; m++) {
                                        const _ = d[m]
                                          , x = await s(_);
                                        x !== null && (x instanceof HTMLImageElement ? p.push(x) : p.push(new Xo(x.data,x.width,x.height)))
                                    }
                                    n[h.uuid] = new Pu(p)
                                } else {
                                    const p = await s(h.url);
                                    n[h.uuid] = new Pu(p)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(e, t) {
                        function n(s, r) {
                            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
                            r[s])
                        }
                        const i = {};
                        if (e !== void 0)
                            for (let s = 0, r = e.length; s < r; s++) {
                                const l = e[s];
                                l.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
                                t[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
                                const h = t[l.image]
                                  , d = h.data;
                                let p;
                                Array.isArray(d) ? (p = new rv,
                                d.length === 6 && (p.needsUpdate = !0)) : (d && d.data ? p = new Xo : p = new zi,
                                d && (p.needsUpdate = !0)),
                                p.source = h,
                                p.uuid = l.uuid,
                                l.name !== void 0 && (p.name = l.name),
                                l.mapping !== void 0 && (p.mapping = n(l.mapping, VP)),
                                l.channel !== void 0 && (p.channel = l.channel),
                                l.offset !== void 0 && p.offset.fromArray(l.offset),
                                l.repeat !== void 0 && p.repeat.fromArray(l.repeat),
                                l.center !== void 0 && p.center.fromArray(l.center),
                                l.rotation !== void 0 && (p.rotation = l.rotation),
                                l.wrap !== void 0 && (p.wrapS = n(l.wrap[0], n1),
                                p.wrapT = n(l.wrap[1], n1)),
                                l.format !== void 0 && (p.format = l.format),
                                l.internalFormat !== void 0 && (p.internalFormat = l.internalFormat),
                                l.type !== void 0 && (p.type = l.type),
                                l.colorSpace !== void 0 && (p.colorSpace = l.colorSpace),
                                l.minFilter !== void 0 && (p.minFilter = n(l.minFilter, i1)),
                                l.magFilter !== void 0 && (p.magFilter = n(l.magFilter, i1)),
                                l.anisotropy !== void 0 && (p.anisotropy = l.anisotropy),
                                l.flipY !== void 0 && (p.flipY = l.flipY),
                                l.generateMipmaps !== void 0 && (p.generateMipmaps = l.generateMipmaps),
                                l.premultiplyAlpha !== void 0 && (p.premultiplyAlpha = l.premultiplyAlpha),
                                l.unpackAlignment !== void 0 && (p.unpackAlignment = l.unpackAlignment),
                                l.compareFunction !== void 0 && (p.compareFunction = l.compareFunction),
                                l.userData !== void 0 && (p.userData = l.userData),
                                i[l.uuid] = p
                            }
                        return i
                    }
                    parseObject(e, t, n, i, s) {
                        let r;
                        function l(v) {
                            return t[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", v),
                            t[v]
                        }
                        function h(v) {
                            if (v !== void 0) {
                                if (Array.isArray(v)) {
                                    const _ = [];
                                    for (let x = 0, b = v.length; x < b; x++) {
                                        const E = v[x];
                                        n[E] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", E),
                                        _.push(n[E])
                                    }
                                    return _
                                }
                                return n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v),
                                n[v]
                            }
                        }
                        function d(v) {
                            return i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", v),
                            i[v]
                        }
                        let p, m;
                        switch (e.type) {
                        case "Scene":
                            r = new bp,
                            e.background !== void 0 && (Number.isInteger(e.background) ? r.background = new at(e.background) : r.background = d(e.background)),
                            e.environment !== void 0 && (r.environment = d(e.environment)),
                            e.fog !== void 0 && (e.fog.type === "Fog" ? r.fog = new Aw(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (r.fog = new Sw(e.fog.color,e.fog.density)),
                            e.fog.name !== "" && (r.fog.name = e.fog.name)),
                            e.backgroundBlurriness !== void 0 && (r.backgroundBlurriness = e.backgroundBlurriness),
                            e.backgroundIntensity !== void 0 && (r.backgroundIntensity = e.backgroundIntensity),
                            e.backgroundRotation !== void 0 && r.backgroundRotation.fromArray(e.backgroundRotation),
                            e.environmentIntensity !== void 0 && (r.environmentIntensity = e.environmentIntensity),
                            e.environmentRotation !== void 0 && r.environmentRotation.fromArray(e.environmentRotation);
                            break;
                        case "PerspectiveCamera":
                            r = new hi(e.fov,e.aspect,e.near,e.far),
                            e.focus !== void 0 && (r.focus = e.focus),
                            e.zoom !== void 0 && (r.zoom = e.zoom),
                            e.filmGauge !== void 0 && (r.filmGauge = e.filmGauge),
                            e.filmOffset !== void 0 && (r.filmOffset = e.filmOffset),
                            e.view !== void 0 && (r.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            r = new Yu(e.left,e.right,e.top,e.bottom,e.near,e.far),
                            e.zoom !== void 0 && (r.zoom = e.zoom),
                            e.view !== void 0 && (r.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            r = new QC(e.color,e.intensity);
                            break;
                        case "DirectionalLight":
                            r = new jC(e.color,e.intensity),
                            r.target = e.target || "";
                            break;
                        case "PointLight":
                            r = new WC(e.color,e.intensity,e.distance,e.decay);
                            break;
                        case "RectAreaLight":
                            r = new ZC(e.color,e.intensity,e.width,e.height);
                            break;
                        case "SpotLight":
                            r = new qC(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
                            r.target = e.target || "";
                            break;
                        case "HemisphereLight":
                            r = new GC(e.color,e.groundColor,e.intensity);
                            break;
                        case "LightProbe":
                            r = new JC().fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            p = l(e.geometry),
                            m = h(e.material),
                            r = new Bw(p,m),
                            e.bindMode !== void 0 && (r.bindMode = e.bindMode),
                            e.bindMatrix !== void 0 && r.bindMatrix.fromArray(e.bindMatrix),
                            e.skeleton !== void 0 && (r.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            p = l(e.geometry),
                            m = h(e.material),
                            r = new Fi(p,m);
                            break;
                        case "InstancedMesh":
                            p = l(e.geometry),
                            m = h(e.material);
                            const v = e.count
                              , _ = e.instanceMatrix
                              , x = e.instanceColor;
                            r = new Fw(p,m,v),
                            r.instanceMatrix = new Dp(new Float32Array(_.array),16),
                            x !== void 0 && (r.instanceColor = new Dp(new Float32Array(x.array),x.itemSize));
                            break;
                        case "BatchedMesh":
                            p = l(e.geometry),
                            m = h(e.material),
                            r = new kw(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,m),
                            r.geometry = p,
                            r.perObjectFrustumCulled = e.perObjectFrustumCulled,
                            r.sortObjects = e.sortObjects,
                            r._drawRanges = e.drawRanges,
                            r._reservedRanges = e.reservedRanges,
                            r._geometryInfo = e.geometryInfo.map(b => {
                                let E = null
                                  , T = null;
                                return b.boundingBox !== void 0 && (E = new aa().fromJSON(b.boundingBox)),
                                b.boundingSphere !== void 0 && (T = new qs().fromJSON(b.boundingSphere)),
                                {
                                    ...b,
                                    boundingBox: E,
                                    boundingSphere: T
                                }
                            }
                            ),
                            r._instanceInfo = e.instanceInfo,
                            r._availableInstanceIds = e._availableInstanceIds,
                            r._availableGeometryIds = e._availableGeometryIds,
                            r._nextIndexStart = e.nextIndexStart,
                            r._nextVertexStart = e.nextVertexStart,
                            r._geometryCount = e.geometryCount,
                            r._maxInstanceCount = e.maxInstanceCount,
                            r._maxVertexCount = e.maxVertexCount,
                            r._maxIndexCount = e.maxIndexCount,
                            r._geometryInitialized = e.geometryInitialized,
                            r._matricesTexture = d(e.matricesTexture.uuid),
                            r._indirectTexture = d(e.indirectTexture.uuid),
                            e.colorsTexture !== void 0 && (r._colorsTexture = d(e.colorsTexture.uuid)),
                            e.boundingSphere !== void 0 && (r.boundingSphere = new qs().fromJSON(e.boundingSphere)),
                            e.boundingBox !== void 0 && (r.boundingBox = new aa().fromJSON(e.boundingBox));
                            break;
                        case "LOD":
                            r = new Cw;
                            break;
                        case "Line":
                            r = new Xu(l(e.geometry),h(e.material));
                            break;
                        case "LineLoop":
                            r = new jw(l(e.geometry),h(e.material));
                            break;
                        case "LineSegments":
                            r = new Hl(l(e.geometry),h(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            r = new Zw(l(e.geometry),h(e.material));
                            break;
                        case "Sprite":
                            r = new Ew(h(e.material));
                            break;
                        case "Group":
                            r = new Mp;
                            break;
                        case "Bone":
                            r = new JA;
                            break;
                        default:
                            r = new jn
                        }
                        if (r.uuid = e.uuid,
                        e.name !== void 0 && (r.name = e.name),
                        e.matrix !== void 0 ? (r.matrix.fromArray(e.matrix),
                        e.matrixAutoUpdate !== void 0 && (r.matrixAutoUpdate = e.matrixAutoUpdate),
                        r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (e.position !== void 0 && r.position.fromArray(e.position),
                        e.rotation !== void 0 && r.rotation.fromArray(e.rotation),
                        e.quaternion !== void 0 && r.quaternion.fromArray(e.quaternion),
                        e.scale !== void 0 && r.scale.fromArray(e.scale)),
                        e.up !== void 0 && r.up.fromArray(e.up),
                        e.castShadow !== void 0 && (r.castShadow = e.castShadow),
                        e.receiveShadow !== void 0 && (r.receiveShadow = e.receiveShadow),
                        e.shadow && (e.shadow.intensity !== void 0 && (r.shadow.intensity = e.shadow.intensity),
                        e.shadow.bias !== void 0 && (r.shadow.bias = e.shadow.bias),
                        e.shadow.normalBias !== void 0 && (r.shadow.normalBias = e.shadow.normalBias),
                        e.shadow.radius !== void 0 && (r.shadow.radius = e.shadow.radius),
                        e.shadow.mapSize !== void 0 && r.shadow.mapSize.fromArray(e.shadow.mapSize),
                        e.shadow.camera !== void 0 && (r.shadow.camera = this.parseObject(e.shadow.camera))),
                        e.visible !== void 0 && (r.visible = e.visible),
                        e.frustumCulled !== void 0 && (r.frustumCulled = e.frustumCulled),
                        e.renderOrder !== void 0 && (r.renderOrder = e.renderOrder),
                        e.userData !== void 0 && (r.userData = e.userData),
                        e.layers !== void 0 && (r.layers.mask = e.layers),
                        e.children !== void 0) {
                            const v = e.children;
                            for (let _ = 0; _ < v.length; _++)
                                r.add(this.parseObject(v[_], t, n, i, s))
                        }
                        if (e.animations !== void 0) {
                            const v = e.animations;
                            for (let _ = 0; _ < v.length; _++) {
                                const x = v[_];
                                r.animations.push(s[x])
                            }
                        }
                        if (e.type === "LOD") {
                            e.autoUpdate !== void 0 && (r.autoUpdate = e.autoUpdate);
                            const v = e.levels;
                            for (let _ = 0; _ < v.length; _++) {
                                const x = v[_]
                                  , b = r.getObjectByProperty("uuid", x.object);
                                b !== void 0 && r.addLevel(b, x.distance, x.hysteresis)
                            }
                        }
                        return r
                    }
                    bindSkeletons(e, t) {
                        Object.keys(t).length !== 0 && e.traverse(function(n) {
                            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                                const i = t[n.skeleton];
                                i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix)
                            }
                        })
                    }
                    bindLightTargets(e) {
                        e.traverse(function(t) {
                            if (t.isDirectionalLight || t.isSpotLight) {
                                const n = t.target
                                  , i = e.getObjectByProperty("uuid", n);
                                i !== void 0 ? t.target = i : t.target = new jn
                            }
                        })
                    }
                }
                ;
                const VP = {
                    UVMapping: Py,
                    CubeReflectionMapping: Sc,
                    CubeRefractionMapping: Nu,
                    EquirectangularReflectionMapping: Lg,
                    EquirectangularRefractionMapping: zg,
                    CubeUVReflectionMapping: tp
                }
                  , n1 = {
                    RepeatWrapping: Uu,
                    ClampToEdgeWrapping: no,
                    MirroredRepeatWrapping: Fg
                }
                  , i1 = {
                    NearestFilter: ti,
                    NearestMipmapNearestFilter: dA,
                    NearestMipmapLinearFilter: np,
                    LinearFilter: mi,
                    LinearMipmapNearestFilter: Hg,
                    LinearMipmapLinearFilter: Pl
                }
                  , UT = new WeakMap;
                var GP = class extends ar {
                    constructor(e) {
                        super(e),
                        this.isImageBitmapLoader = !0,
                        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                        this.options = {
                            premultiplyAlpha: "none"
                        },
                        this._abortController = new AbortController
                    }
                    setOptions(e) {
                        return this.options = e,
                        this
                    }
                    load(e, t, n, i) {
                        e === void 0 && (e = ""),
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const s = this
                          , r = Vl.get(`image-bitmap:${e}`);
                        if (r !== void 0) {
                            if (s.manager.itemStart(e),
                            r.then) {
                                r.then(d => {
                                    if (UT.has(r) === !0)
                                        i && i(UT.get(r)),
                                        s.manager.itemError(e),
                                        s.manager.itemEnd(e);
                                    else
                                        return t && t(d),
                                        s.manager.itemEnd(e),
                                        d
                                }
                                );
                                return
                            }
                            return setTimeout(function() {
                                t && t(r),
                                s.manager.itemEnd(e)
                            }, 0),
                            r
                        }
                        const l = {};
                        l.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                        l.headers = this.requestHeader,
                        l.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
                        const h = fetch(e, l).then(function(d) {
                            return d.blob()
                        }).then(function(d) {
                            return createImageBitmap(d, Object.assign(s.options, {
                                colorSpaceConversion: "none"
                            }))
                        }).then(function(d) {
                            return Vl.add(`image-bitmap:${e}`, d),
                            t && t(d),
                            s.manager.itemEnd(e),
                            d
                        }).catch(function(d) {
                            i && i(d),
                            UT.set(h, d),
                            Vl.remove(`image-bitmap:${e}`),
                            s.manager.itemError(e),
                            s.manager.itemEnd(e)
                        });
                        Vl.add(`image-bitmap:${e}`, h),
                        s.manager.itemStart(e)
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                ;
                let dx;
                var BT = class {
                    static getContext() {
                        return dx === void 0 && (dx = new (window.AudioContext || window.webkitAudioContext)),
                        dx
                    }
                    static setContext(e) {
                        dx = e
                    }
                }
                  , kP = class extends ar {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, i) {
                        const s = this
                          , r = new Nc(this.manager);
                        r.setResponseType("arraybuffer"),
                        r.setPath(this.path),
                        r.setRequestHeader(this.requestHeader),
                        r.setWithCredentials(this.withCredentials),
                        r.load(e, function(h) {
                            try {
                                const d = h.slice(0);
                                BT.getContext().decodeAudioData(d, function(p) {
                                    t(p)
                                }).catch(l)
                            } catch (d) {
                                l(d)
                            }
                        }, n, i);
                        function l(h) {
                            i ? i(h) : console.error(h),
                            s.manager.itemError(e)
                        }
                    }
                }
                ;
                const s1 = new Xt
                  , a1 = new Xt
                  , Sf = new Xt;
                var XP = class {
                    constructor() {
                        this.type = "StereoCamera",
                        this.aspect = 1,
                        this.eyeSep = .064,
                        this.cameraL = new hi,
                        this.cameraL.layers.enable(1),
                        this.cameraL.matrixAutoUpdate = !1,
                        this.cameraR = new hi,
                        this.cameraR.layers.enable(2),
                        this.cameraR.matrixAutoUpdate = !1,
                        this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(e) {
                        const t = this._cache;
                        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                            t.focus = e.focus,
                            t.fov = e.fov,
                            t.aspect = e.aspect * this.aspect,
                            t.near = e.near,
                            t.far = e.far,
                            t.zoom = e.zoom,
                            t.eyeSep = this.eyeSep,
                            Sf.copy(e.projectionMatrix);
                            const n = t.eyeSep / 2
                              , i = n * t.near / t.focus
                              , s = t.near * Math.tan(lf * t.fov * .5) / t.zoom;
                            let r, l;
                            a1.elements[12] = -n,
                            s1.elements[12] = n,
                            r = -s * t.aspect + i,
                            l = s * t.aspect + i,
                            Sf.elements[0] = 2 * t.near / (l - r),
                            Sf.elements[8] = (l + r) / (l - r),
                            this.cameraL.projectionMatrix.copy(Sf),
                            r = -s * t.aspect - i,
                            l = s * t.aspect - i,
                            Sf.elements[0] = 2 * t.near / (l - r),
                            Sf.elements[8] = (l + r) / (l - r),
                            this.cameraR.projectionMatrix.copy(Sf)
                        }
                        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(a1),
                        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(s1)
                    }
                }
                  , r1 = class extends hi {
                    constructor(e=[]) {
                        super(),
                        this.isArrayCamera = !0,
                        this.isMultiViewCamera = !1,
                        this.cameras = e
                    }
                }
                  , PT = class {
                    constructor(e=!0) {
                        this.autoStart = e,
                        this.startTime = 0,
                        this.oldTime = 0,
                        this.elapsedTime = 0,
                        this.running = !1
                    }
                    start() {
                        this.startTime = performance.now(),
                        this.oldTime = this.startTime,
                        this.elapsedTime = 0,
                        this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(),
                        this.running = !1,
                        this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(),
                        this.elapsedTime
                    }
                    getDelta() {
                        let e = 0;
                        if (this.autoStart && !this.running)
                            return this.start(),
                            0;
                        if (this.running) {
                            const t = performance.now();
                            e = (t - this.oldTime) / 1e3,
                            this.oldTime = t,
                            this.elapsedTime += e
                        }
                        return e
                    }
                }
                ;
                const Af = new Q
                  , IT = new _s
                  , qP = new Q
                  , Tf = new Q
                  , Mf = new Q;
                var YP = class extends jn {
                    constructor() {
                        super(),
                        this.type = "AudioListener",
                        this.context = BT.getContext(),
                        this.gain = this.context.createGain(),
                        this.gain.connect(this.context.destination),
                        this.filter = null,
                        this.timeDelta = 0,
                        this._clock = new PT
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return this.filter !== null && (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination),
                        this.gain.connect(this.context.destination),
                        this.filter = null),
                        this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(e) {
                        return this.filter !== null ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                        this.filter = e,
                        this.gain.connect(this.filter),
                        this.filter.connect(this.context.destination),
                        this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e);
                        const t = this.context.listener;
                        if (this.timeDelta = this._clock.getDelta(),
                        this.matrixWorld.decompose(Af, IT, qP),
                        Tf.set(0, 0, -1).applyQuaternion(IT),
                        Mf.set(0, 1, 0).applyQuaternion(IT),
                        t.positionX) {
                            const n = this.context.currentTime + this.timeDelta;
                            t.positionX.linearRampToValueAtTime(Af.x, n),
                            t.positionY.linearRampToValueAtTime(Af.y, n),
                            t.positionZ.linearRampToValueAtTime(Af.z, n),
                            t.forwardX.linearRampToValueAtTime(Tf.x, n),
                            t.forwardY.linearRampToValueAtTime(Tf.y, n),
                            t.forwardZ.linearRampToValueAtTime(Tf.z, n),
                            t.upX.linearRampToValueAtTime(Mf.x, n),
                            t.upY.linearRampToValueAtTime(Mf.y, n),
                            t.upZ.linearRampToValueAtTime(Mf.z, n)
                        } else
                            t.setPosition(Af.x, Af.y, Af.z),
                            t.setOrientation(Tf.x, Tf.y, Tf.z, Mf.x, Mf.y, Mf.z)
                    }
                }
                  , o1 = class extends jn {
                    constructor(e) {
                        super(),
                        this.type = "Audio",
                        this.listener = e,
                        this.context = e.context,
                        this.gain = this.context.createGain(),
                        this.gain.connect(e.getInput()),
                        this.autoplay = !1,
                        this.buffer = null,
                        this.detune = 0,
                        this.loop = !1,
                        this.loopStart = 0,
                        this.loopEnd = 0,
                        this.offset = 0,
                        this.duration = void 0,
                        this.playbackRate = 1,
                        this.isPlaying = !1,
                        this.hasPlaybackControl = !0,
                        this.source = null,
                        this.sourceType = "empty",
                        this._startedAt = 0,
                        this._progress = 0,
                        this._connected = !1,
                        this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "audioNode",
                        this.source = e,
                        this.connect(),
                        this
                    }
                    setMediaElementSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaNode",
                        this.source = this.context.createMediaElementSource(e),
                        this.connect(),
                        this
                    }
                    setMediaStreamSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaStreamNode",
                        this.source = this.context.createMediaStreamSource(e),
                        this.connect(),
                        this
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this.sourceType = "buffer",
                        this.autoplay && this.play(),
                        this
                    }
                    play(e=0) {
                        if (this.isPlaying === !0) {
                            console.warn("THREE.Audio: Audio is already playing.");
                            return
                        }
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        this._startedAt = this.context.currentTime + e;
                        const t = this.context.createBufferSource();
                        return t.buffer = this.buffer,
                        t.loop = this.loop,
                        t.loopStart = this.loopStart,
                        t.loopEnd = this.loopEnd,
                        t.onended = this.onEnded.bind(this),
                        t.start(this._startedAt, this._progress + this.offset, this.duration),
                        this.isPlaying = !0,
                        this.source = t,
                        this.setDetune(this.detune),
                        this.setPlaybackRate(this.playbackRate),
                        this.connect()
                    }
                    pause() {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                        this.source.stop(),
                        this.source.onended = null,
                        this.isPlaying = !1),
                        this
                    }
                    stop(e=0) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this._progress = 0,
                        this.source !== null && (this.source.stop(this.context.currentTime + e),
                        this.source.onended = null),
                        this.isPlaying = !1,
                        this
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let e = 1, t = this.filters.length; e < t; e++)
                                this.filters[e - 1].connect(this.filters[e]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else
                            this.source.connect(this.getOutput());
                        return this._connected = !0,
                        this
                    }
                    disconnect() {
                        if (this._connected !== !1) {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (let e = 1, t = this.filters.length; e < t; e++)
                                    this.filters[e - 1].disconnect(this.filters[e]);
                                this.filters[this.filters.length - 1].disconnect(this.getOutput())
                            } else
                                this.source.disconnect(this.getOutput());
                            return this._connected = !1,
                            this
                        }
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(e) {
                        return e || (e = []),
                        this._connected === !0 ? (this.disconnect(),
                        this.filters = e.slice(),
                        this.connect()) : this.filters = e.slice(),
                        this
                    }
                    setDetune(e) {
                        return this.detune = e,
                        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                        this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(e) {
                        return this.setFilters(e ? [e] : [])
                    }
                    setPlaybackRate(e) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this.playbackRate = e,
                        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                        this
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1,
                        this._progress = 0
                    }
                    getLoop() {
                        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                        !1) : this.loop
                    }
                    setLoop(e) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn("THREE.Audio: this Audio has no playback control.");
                            return
                        }
                        return this.loop = e,
                        this.isPlaying === !0 && (this.source.loop = this.loop),
                        this
                    }
                    setLoopStart(e) {
                        return this.loopStart = e,
                        this
                    }
                    setLoopEnd(e) {
                        return this.loopEnd = e,
                        this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
                        this) : (this.autoplay = e.autoplay,
                        this.buffer = e.buffer,
                        this.detune = e.detune,
                        this.loop = e.loop,
                        this.loopStart = e.loopStart,
                        this.loopEnd = e.loopEnd,
                        this.offset = e.offset,
                        this.duration = e.duration,
                        this.playbackRate = e.playbackRate,
                        this.hasPlaybackControl = e.hasPlaybackControl,
                        this.sourceType = e.sourceType,
                        this.filters = e.filters.slice(),
                        this)
                    }
                    clone(e) {
                        return new this.constructor(this.listener).copy(this, e)
                    }
                }
                ;
                const bf = new Q
                  , l1 = new _s
                  , WP = new Q
                  , Ef = new Q;
                var jP = class extends o1 {
                    constructor(e) {
                        super(e),
                        this.panner = this.context.createPanner(),
                        this.panner.panningModel = "HRTF",
                        this.panner.connect(this.gain)
                    }
                    connect() {
                        return super.connect(),
                        this.panner.connect(this.gain),
                        this
                    }
                    disconnect() {
                        return super.disconnect(),
                        this.panner.disconnect(this.gain),
                        this
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(e) {
                        return this.panner.refDistance = e,
                        this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(e) {
                        return this.panner.rolloffFactor = e,
                        this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(e) {
                        return this.panner.distanceModel = e,
                        this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(e) {
                        return this.panner.maxDistance = e,
                        this
                    }
                    setDirectionalCone(e, t, n) {
                        return this.panner.coneInnerAngle = e,
                        this.panner.coneOuterAngle = t,
                        this.panner.coneOuterGain = n,
                        this
                    }
                    updateMatrixWorld(e) {
                        if (super.updateMatrixWorld(e),
                        this.hasPlaybackControl === !0 && this.isPlaying === !1)
                            return;
                        this.matrixWorld.decompose(bf, l1, WP),
                        Ef.set(0, 0, 1).applyQuaternion(l1);
                        const t = this.panner;
                        if (t.positionX) {
                            const n = this.context.currentTime + this.listener.timeDelta;
                            t.positionX.linearRampToValueAtTime(bf.x, n),
                            t.positionY.linearRampToValueAtTime(bf.y, n),
                            t.positionZ.linearRampToValueAtTime(bf.z, n),
                            t.orientationX.linearRampToValueAtTime(Ef.x, n),
                            t.orientationY.linearRampToValueAtTime(Ef.y, n),
                            t.orientationZ.linearRampToValueAtTime(Ef.z, n)
                        } else
                            t.setPosition(bf.x, bf.y, bf.z),
                            t.setOrientation(Ef.x, Ef.y, Ef.z)
                    }
                }
                  , QP = class {
                    constructor(e, t=2048) {
                        this.analyser = e.context.createAnalyser(),
                        this.analyser.fftSize = t,
                        this.data = new Uint8Array(this.analyser.frequencyBinCount),
                        e.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data),
                        this.data
                    }
                    getAverageFrequency() {
                        let e = 0;
                        const t = this.getFrequencyData();
                        for (let n = 0; n < t.length; n++)
                            e += t[n];
                        return e / t.length
                    }
                }
                  , c1 = class {
                    constructor(e, t, n) {
                        this.binding = e,
                        this.valueSize = n;
                        let i, s, r;
                        switch (t) {
                        case "quaternion":
                            i = this._slerp,
                            s = this._slerpAdditive,
                            r = this._setAdditiveIdentityQuaternion,
                            this.buffer = new Float64Array(n * 6),
                            this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            i = this._select,
                            s = this._select,
                            r = this._setAdditiveIdentityOther,
                            this.buffer = new Array(n * 5);
                            break;
                        default:
                            i = this._lerp,
                            s = this._lerpAdditive,
                            r = this._setAdditiveIdentityNumeric,
                            this.buffer = new Float64Array(n * 5)
                        }
                        this._mixBufferRegion = i,
                        this._mixBufferRegionAdditive = s,
                        this._setIdentity = r,
                        this._origIndex = 3,
                        this._addIndex = 4,
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        this.useCount = 0,
                        this.referenceCount = 0
                    }
                    accumulate(e, t) {
                        const n = this.buffer
                          , i = this.valueSize
                          , s = e * i + i;
                        let r = this.cumulativeWeight;
                        if (r === 0) {
                            for (let l = 0; l !== i; ++l)
                                n[s + l] = n[l];
                            r = t
                        } else {
                            r += t;
                            const l = t / r;
                            this._mixBufferRegion(n, s, 0, l, i)
                        }
                        this.cumulativeWeight = r
                    }
                    accumulateAdditive(e) {
                        const t = this.buffer
                          , n = this.valueSize
                          , i = n * this._addIndex;
                        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                        this._mixBufferRegionAdditive(t, i, 0, e, n),
                        this.cumulativeWeightAdditive += e
                    }
                    apply(e) {
                        const t = this.valueSize
                          , n = this.buffer
                          , i = e * t + t
                          , s = this.cumulativeWeight
                          , r = this.cumulativeWeightAdditive
                          , l = this.binding;
                        if (this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        s < 1) {
                            const h = t * this._origIndex;
                            this._mixBufferRegion(n, i, h, 1 - s, t)
                        }
                        r > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                        for (let h = t, d = t + t; h !== d; ++h)
                            if (n[h] !== n[h + t]) {
                                l.setValue(n, i);
                                break
                            }
                    }
                    saveOriginalState() {
                        const e = this.binding
                          , t = this.buffer
                          , n = this.valueSize
                          , i = n * this._origIndex;
                        e.getValue(t, i);
                        for (let s = n, r = i; s !== r; ++s)
                            t[s] = t[i + s % n];
                        this._setIdentity(),
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const e = this.valueSize * 3;
                        this.binding.setValue(this.buffer, e)
                    }
                    _setAdditiveIdentityNumeric() {
                        const e = this._addIndex * this.valueSize
                          , t = e + this.valueSize;
                        for (let n = e; n < t; n++)
                            this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(),
                        this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const e = this._origIndex * this.valueSize
                          , t = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++)
                            this.buffer[t + n] = this.buffer[e + n]
                    }
                    _select(e, t, n, i, s) {
                        if (i >= .5)
                            for (let r = 0; r !== s; ++r)
                                e[t + r] = e[n + r]
                    }
                    _slerp(e, t, n, i) {
                        _s.slerpFlat(e, t, e, t, e, n, i)
                    }
                    _slerpAdditive(e, t, n, i, s) {
                        const r = this._workIndex * s;
                        _s.multiplyQuaternionsFlat(e, r, e, t, e, n),
                        _s.slerpFlat(e, t, e, t, e, r, i)
                    }
                    _lerp(e, t, n, i, s) {
                        const r = 1 - i;
                        for (let l = 0; l !== s; ++l) {
                            const h = t + l;
                            e[h] = e[h] * r + e[n + l] * i
                        }
                    }
                    _lerpAdditive(e, t, n, i, s) {
                        for (let r = 0; r !== s; ++r) {
                            const l = t + r;
                            e[l] = e[l] + e[n + r] * i
                        }
                    }
                }
                ;
                const LT = "\\[\\]\\.:\\/"
                  , ZP = new RegExp("[" + LT + "]","g")
                  , zT = "[^" + LT + "]"
                  , KP = "[^" + LT.replace("\\.", "") + "]"
                  , JP = /((?:WC+[\/:])*)/.source.replace("WC", zT)
                  , $P = /(WCOD+)?/.source.replace("WCOD", KP)
                  , eI = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", zT)
                  , tI = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", zT)
                  , nI = new RegExp("^" + JP + $P + eI + tI + "$")
                  , iI = ["material", "materials", "bones", "map"];
                var sI = class {
                    constructor(e, t, n) {
                        const i = n || li.parseTrackName(t);
                        this._targetGroup = e,
                        this._bindings = e.subscribe_(t, i)
                    }
                    getValue(e, t) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_
                          , i = this._bindings[n];
                        i !== void 0 && i.getValue(e, t)
                    }
                    setValue(e, t) {
                        const n = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
                            n[i].setValue(e, t)
                    }
                    bind() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].bind()
                    }
                    unbind() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].unbind()
                    }
                }
                  , li = class mm {
                    constructor(t, n, i) {
                        this.path = n,
                        this.parsedPath = i || mm.parseTrackName(n),
                        this.node = mm.findNode(t, this.parsedPath.nodeName),
                        this.rootNode = t,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                    static create(t, n, i) {
                        return t && t.isAnimationObjectGroup ? new mm.Composite(t,n,i) : new mm(t,n,i)
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(ZP, "")
                    }
                    static parseTrackName(t) {
                        const n = nI.exec(t);
                        if (n === null)
                            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const i = {
                            nodeName: n[2],
                            objectName: n[3],
                            objectIndex: n[4],
                            propertyName: n[5],
                            propertyIndex: n[6]
                        }
                          , s = i.nodeName && i.nodeName.lastIndexOf(".");
                        if (s !== void 0 && s !== -1) {
                            const r = i.nodeName.substring(s + 1);
                            iI.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, s),
                            i.objectName = r)
                        }
                        if (i.propertyName === null || i.propertyName.length === 0)
                            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return i
                    }
                    static findNode(t, n) {
                        if (n === void 0 || n === "" || n === "." || n === -1 || n === t.name || n === t.uuid)
                            return t;
                        if (t.skeleton) {
                            const i = t.skeleton.getBoneByName(n);
                            if (i !== void 0)
                                return i
                        }
                        if (t.children) {
                            const i = function(r) {
                                for (let l = 0; l < r.length; l++) {
                                    const h = r[l];
                                    if (h.name === n || h.uuid === n)
                                        return h;
                                    const d = i(h.children);
                                    if (d)
                                        return d
                                }
                                return null
                            }
                              , s = i(t.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, n) {
                        t[n] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, r = i.length; s !== r; ++s)
                            t[n++] = i[s]
                    }
                    _getValue_arrayElement(t, n) {
                        t[n] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(t, n) {
                        this.resolvedProperty.toArray(t, n)
                    }
                    _setValue_direct(t, n) {
                        this.targetObject[this.propertyName] = t[n]
                    }
                    _setValue_direct_setNeedsUpdate(t, n) {
                        this.targetObject[this.propertyName] = t[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, n) {
                        this.targetObject[this.propertyName] = t[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, r = i.length; s !== r; ++s)
                            i[s] = t[n++]
                    }
                    _setValue_array_setNeedsUpdate(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, r = i.length; s !== r; ++s)
                            i[s] = t[n++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, n) {
                        const i = this.resolvedProperty;
                        for (let s = 0, r = i.length; s !== r; ++s)
                            i[s] = t[n++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n]
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(t, n) {
                        this.resolvedProperty.fromArray(t, n)
                    }
                    _setValue_fromArray_setNeedsUpdate(t, n) {
                        this.resolvedProperty.fromArray(t, n),
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, n) {
                        this.resolvedProperty.fromArray(t, n),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(t, n) {
                        this.bind(),
                        this.getValue(t, n)
                    }
                    _setValue_unbound(t, n) {
                        this.bind(),
                        this.setValue(t, n)
                    }
                    bind() {
                        let t = this.node;
                        const n = this.parsedPath
                          , i = n.objectName
                          , s = n.propertyName;
                        let r = n.propertyIndex;
                        if (t || (t = mm.findNode(this.rootNode, n.nodeName),
                        this.node = t),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !t) {
                            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                            return
                        }
                        if (i) {
                            let p = n.objectIndex;
                            switch (i) {
                            case "materials":
                                if (!t.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.materials) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) {
                                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                t = t.skeleton.bones;
                                for (let m = 0; m < t.length; m++)
                                    if (t[m].name === p) {
                                        p = m;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map"in t) {
                                    t = t.map;
                                    break
                                }
                                if (!t.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.map) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                t = t.material.map;
                                break;
                            default:
                                if (t[i] === void 0) {
                                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                t = t[i]
                            }
                            if (p !== void 0) {
                                if (t[p] === void 0) {
                                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    return
                                }
                                t = t[p]
                            }
                        }
                        const l = t[s];
                        if (l === void 0) {
                            const p = n.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + p + "." + s + " but it wasn't found.", t);
                            return
                        }
                        let h = this.Versioning.None;
                        this.targetObject = t,
                        t.isMaterial === !0 ? h = this.Versioning.NeedsUpdate : t.isObject3D === !0 && (h = this.Versioning.MatrixWorldNeedsUpdate);
                        let d = this.BindingType.Direct;
                        if (r !== void 0) {
                            if (s === "morphTargetInfluences") {
                                if (!t.geometry) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    return
                                }
                                if (!t.geometry.morphAttributes) {
                                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                t.morphTargetDictionary[r] !== void 0 && (r = t.morphTargetDictionary[r])
                            }
                            d = this.BindingType.ArrayElement,
                            this.resolvedProperty = l,
                            this.propertyIndex = r
                        } else
                            l.fromArray !== void 0 && l.toArray !== void 0 ? (d = this.BindingType.HasFromToArray,
                            this.resolvedProperty = l) : Array.isArray(l) ? (d = this.BindingType.EntireArray,
                            this.resolvedProperty = l) : this.propertyName = s;
                        this.getValue = this.GetterByBindingType[d],
                        this.setValue = this.SetterByBindingTypeAndVersioning[d][h]
                    }
                    unbind() {
                        this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                }
                ;
                li.Composite = sI,
                li.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                li.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                li.prototype.GetterByBindingType = [li.prototype._getValue_direct, li.prototype._getValue_array, li.prototype._getValue_arrayElement, li.prototype._getValue_toArray],
                li.prototype.SetterByBindingTypeAndVersioning = [[li.prototype._setValue_direct, li.prototype._setValue_direct_setNeedsUpdate, li.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [li.prototype._setValue_array, li.prototype._setValue_array_setNeedsUpdate, li.prototype._setValue_array_setMatrixWorldNeedsUpdate], [li.prototype._setValue_arrayElement, li.prototype._setValue_arrayElement_setNeedsUpdate, li.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [li.prototype._setValue_fromArray, li.prototype._setValue_fromArray_setNeedsUpdate, li.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
                var aI = class {
                    constructor() {
                        this.isAnimationObjectGroup = !0,
                        this.uuid = wr(),
                        this._objects = Array.prototype.slice.call(arguments),
                        this.nCachedObjects_ = 0;
                        const e = {};
                        this._indicesByUUID = e;
                        for (let n = 0, i = arguments.length; n !== i; ++n)
                            e[arguments[n].uuid] = n;
                        this._paths = [],
                        this._parsedPaths = [],
                        this._bindings = [],
                        this._bindingsIndicesByPath = {};
                        const t = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return t._objects.length
                                },
                                get inUse() {
                                    return this.total - t.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return t._bindings.length
                            }
                        }
                    }
                    add() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._paths
                          , i = this._parsedPaths
                          , s = this._bindings
                          , r = s.length;
                        let l, h = e.length, d = this.nCachedObjects_;
                        for (let p = 0, m = arguments.length; p !== m; ++p) {
                            const v = arguments[p]
                              , _ = v.uuid;
                            let x = t[_];
                            if (x === void 0) {
                                x = h++,
                                t[_] = x,
                                e.push(v);
                                for (let b = 0, E = r; b !== E; ++b)
                                    s[b].push(new li(v,n[b],i[b]))
                            } else if (x < d) {
                                l = e[x];
                                const b = --d
                                  , E = e[b];
                                t[E.uuid] = x,
                                e[x] = E,
                                t[_] = b,
                                e[b] = v;
                                for (let T = 0, M = r; T !== M; ++T) {
                                    const D = s[T]
                                      , R = D[b];
                                    let O = D[x];
                                    D[x] = R,
                                    O === void 0 && (O = new li(v,n[T],i[T])),
                                    D[b] = O
                                }
                            } else
                                e[x] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = d
                    }
                    remove() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , i = n.length;
                        let s = this.nCachedObjects_;
                        for (let r = 0, l = arguments.length; r !== l; ++r) {
                            const h = arguments[r]
                              , d = h.uuid
                              , p = t[d];
                            if (p !== void 0 && p >= s) {
                                const m = s++
                                  , v = e[m];
                                t[v.uuid] = p,
                                e[p] = v,
                                t[d] = m,
                                e[m] = h;
                                for (let _ = 0, x = i; _ !== x; ++_) {
                                    const b = n[_]
                                      , E = b[m]
                                      , T = b[p];
                                    b[p] = E,
                                    b[m] = T
                                }
                            }
                        }
                        this.nCachedObjects_ = s
                    }
                    uncache() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , i = n.length;
                        let s = this.nCachedObjects_
                          , r = e.length;
                        for (let l = 0, h = arguments.length; l !== h; ++l) {
                            const d = arguments[l]
                              , p = d.uuid
                              , m = t[p];
                            if (m !== void 0)
                                if (delete t[p],
                                m < s) {
                                    const v = --s
                                      , _ = e[v]
                                      , x = --r
                                      , b = e[x];
                                    t[_.uuid] = m,
                                    e[m] = _,
                                    t[b.uuid] = v,
                                    e[v] = b,
                                    e.pop();
                                    for (let E = 0, T = i; E !== T; ++E) {
                                        const M = n[E]
                                          , D = M[v]
                                          , R = M[x];
                                        M[m] = D,
                                        M[v] = R,
                                        M.pop()
                                    }
                                } else {
                                    const v = --r
                                      , _ = e[v];
                                    v > 0 && (t[_.uuid] = m),
                                    e[m] = _,
                                    e.pop();
                                    for (let x = 0, b = i; x !== b; ++x) {
                                        const E = n[x];
                                        E[m] = E[v],
                                        E.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = s
                    }
                    subscribe_(e, t) {
                        const n = this._bindingsIndicesByPath;
                        let i = n[e];
                        const s = this._bindings;
                        if (i !== void 0)
                            return s[i];
                        const r = this._paths
                          , l = this._parsedPaths
                          , h = this._objects
                          , d = h.length
                          , p = this.nCachedObjects_
                          , m = new Array(d);
                        i = s.length,
                        n[e] = i,
                        r.push(e),
                        l.push(t),
                        s.push(m);
                        for (let v = p, _ = h.length; v !== _; ++v) {
                            const x = h[v];
                            m[v] = new li(x,e,t)
                        }
                        return m
                    }
                    unsubscribe_(e) {
                        const t = this._bindingsIndicesByPath
                          , n = t[e];
                        if (n !== void 0) {
                            const i = this._paths
                              , s = this._parsedPaths
                              , r = this._bindings
                              , l = r.length - 1
                              , h = r[l]
                              , d = e[l];
                            t[d] = n,
                            r[n] = h,
                            r.pop(),
                            s[n] = s[l],
                            s.pop(),
                            i[n] = i[l],
                            i.pop()
                        }
                    }
                }
                  , u1 = class {
                    constructor(e, t, n=null, i=t.blendMode) {
                        this._mixer = e,
                        this._clip = t,
                        this._localRoot = n,
                        this.blendMode = i;
                        const s = t.tracks
                          , r = s.length
                          , l = new Array(r)
                          , h = {
                            endingStart: af,
                            endingEnd: af
                        };
                        for (let d = 0; d !== r; ++d) {
                            const p = s[d].createInterpolant(null);
                            l[d] = p,
                            p.settings = h
                        }
                        this._interpolantSettings = h,
                        this._interpolants = l,
                        this._propertyBindings = new Array(r),
                        this._cacheIndex = null,
                        this._byClipCacheIndex = null,
                        this._timeScaleInterpolant = null,
                        this._weightInterpolant = null,
                        this.loop = FE,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.time = 0,
                        this.timeScale = 1,
                        this._effectiveTimeScale = 1,
                        this.weight = 1,
                        this._effectiveWeight = 1,
                        this.repetitions = 1 / 0,
                        this.paused = !1,
                        this.enabled = !0,
                        this.clampWhenFinished = !1,
                        this.zeroSlopeAtStart = !0,
                        this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this),
                        this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this),
                        this.reset()
                    }
                    reset() {
                        return this.paused = !1,
                        this.enabled = !0,
                        this.time = 0,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(e) {
                        return this._startTime = e,
                        this
                    }
                    setLoop(e, t) {
                        return this.loop = e,
                        this.repetitions = t,
                        this
                    }
                    setEffectiveWeight(e) {
                        return this.weight = e,
                        this._effectiveWeight = this.enabled ? e : 0,
                        this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(e) {
                        return this._scheduleFading(e, 0, 1)
                    }
                    fadeOut(e) {
                        return this._scheduleFading(e, 1, 0)
                    }
                    crossFadeFrom(e, t, n=!1) {
                        if (e.fadeOut(t),
                        this.fadeIn(t),
                        n === !0) {
                            const i = this._clip.duration
                              , s = e._clip.duration
                              , r = s / i
                              , l = i / s;
                            e.warp(1, r, t),
                            this.warp(l, 1, t)
                        }
                        return this
                    }
                    crossFadeTo(e, t, n=!1) {
                        return e.crossFadeFrom(this, t, n)
                    }
                    stopFading() {
                        const e = this._weightInterpolant;
                        return e !== null && (this._weightInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    setEffectiveTimeScale(e) {
                        return this.timeScale = e,
                        this._effectiveTimeScale = this.paused ? 0 : e,
                        this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(e) {
                        return this.timeScale = this._clip.duration / e,
                        this.stopWarping()
                    }
                    syncWith(e) {
                        return this.time = e.time,
                        this.timeScale = e.timeScale,
                        this.stopWarping()
                    }
                    halt(e) {
                        return this.warp(this._effectiveTimeScale, 0, e)
                    }
                    warp(e, t, n) {
                        const i = this._mixer
                          , s = i.time
                          , r = this.timeScale;
                        let l = this._timeScaleInterpolant;
                        l === null && (l = i._lendControlInterpolant(),
                        this._timeScaleInterpolant = l);
                        const h = l.parameterPositions
                          , d = l.sampleValues;
                        return h[0] = s,
                        h[1] = s + n,
                        d[0] = e / r,
                        d[1] = t / r,
                        this
                    }
                    stopWarping() {
                        const e = this._timeScaleInterpolant;
                        return e !== null && (this._timeScaleInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(e, t, n, i) {
                        if (!this.enabled) {
                            this._updateWeight(e);
                            return
                        }
                        const s = this._startTime;
                        if (s !== null) {
                            const h = (e - s) * n;
                            h < 0 || n === 0 ? t = 0 : (this._startTime = null,
                            t = n * h)
                        }
                        t *= this._updateTimeScale(e);
                        const r = this._updateTime(t)
                          , l = this._updateWeight(e);
                        if (l > 0) {
                            const h = this._interpolants
                              , d = this._propertyBindings;
                            switch (this.blendMode) {
                            case xA:
                                for (let p = 0, m = h.length; p !== m; ++p)
                                    h[p].evaluate(r),
                                    d[p].accumulateAdditive(l);
                                break;
                            case y_:
                            default:
                                for (let p = 0, m = h.length; p !== m; ++p)
                                    h[p].evaluate(r),
                                    d[p].accumulate(i, l)
                            }
                        }
                    }
                    _updateWeight(e) {
                        let t = 0;
                        if (this.enabled) {
                            t = this.weight;
                            const n = this._weightInterpolant;
                            if (n !== null) {
                                const i = n.evaluate(e)[0];
                                t *= i,
                                e > n.parameterPositions[1] && (this.stopFading(),
                                i === 0 && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = t,
                        t
                    }
                    _updateTimeScale(e) {
                        let t = 0;
                        if (!this.paused) {
                            t = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            if (n !== null) {
                                const i = n.evaluate(e)[0];
                                t *= i,
                                e > n.parameterPositions[1] && (this.stopWarping(),
                                t === 0 ? this.paused = !0 : this.timeScale = t)
                            }
                        }
                        return this._effectiveTimeScale = t,
                        t
                    }
                    _updateTime(e) {
                        const t = this._clip.duration
                          , n = this.loop;
                        let i = this.time + e
                          , s = this._loopCount;
                        const r = n === HE;
                        if (e === 0)
                            return s === -1 ? i : r && (s & 1) === 1 ? t - i : i;
                        if (n === zE) {
                            s === -1 && (this._loopCount = 0,
                            this._setEndings(!0, !0, !1));
                            e: {
                                if (i >= t)
                                    i = t;
                                else if (i < 0)
                                    i = 0;
                                else {
                                    this.time = i;
                                    break e
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: e < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (s === -1 && (e >= 0 ? (s = 0,
                            this._setEndings(!0, this.repetitions === 0, r)) : this._setEndings(this.repetitions === 0, !0, r)),
                            i >= t || i < 0) {
                                const l = Math.floor(i / t);
                                i -= t * l,
                                s += Math.abs(l);
                                const h = this.repetitions - s;
                                if (h <= 0)
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    i = e > 0 ? t : 0,
                                    this.time = i,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    });
                                else {
                                    if (h === 1) {
                                        const d = e < 0;
                                        this._setEndings(d, !d, r)
                                    } else
                                        this._setEndings(!1, !1, r);
                                    this._loopCount = s,
                                    this.time = i,
                                    this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: l
                                    })
                                }
                            } else
                                this.time = i;
                            if (r && (s & 1) === 1)
                                return t - i
                        }
                        return i
                    }
                    _setEndings(e, t, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = rf,
                        i.endingEnd = rf) : (e ? i.endingStart = this.zeroSlopeAtStart ? rf : af : i.endingStart = Wg,
                        t ? i.endingEnd = this.zeroSlopeAtEnd ? rf : af : i.endingEnd = Wg)
                    }
                    _scheduleFading(e, t, n) {
                        const i = this._mixer
                          , s = i.time;
                        let r = this._weightInterpolant;
                        r === null && (r = i._lendControlInterpolant(),
                        this._weightInterpolant = r);
                        const l = r.parameterPositions
                          , h = r.sampleValues;
                        return l[0] = s,
                        h[0] = t,
                        l[1] = s + e,
                        h[1] = n,
                        this
                    }
                }
                ;
                const rI = new Float32Array(1);
                var oI = class extends Er {
                    constructor(e) {
                        super(),
                        this._root = e,
                        this._initMemoryManager(),
                        this._accuIndex = 0,
                        this.time = 0,
                        this.timeScale = 1
                    }
                    _bindAction(e, t) {
                        const n = e._localRoot || this._root
                          , i = e._clip.tracks
                          , s = i.length
                          , r = e._propertyBindings
                          , l = e._interpolants
                          , h = n.uuid
                          , d = this._bindingsByRootAndName;
                        let p = d[h];
                        p === void 0 && (p = {},
                        d[h] = p);
                        for (let m = 0; m !== s; ++m) {
                            const v = i[m]
                              , _ = v.name;
                            let x = p[_];
                            if (x !== void 0)
                                ++x.referenceCount,
                                r[m] = x;
                            else {
                                if (x = r[m],
                                x !== void 0) {
                                    x._cacheIndex === null && (++x.referenceCount,
                                    this._addInactiveBinding(x, h, _));
                                    continue
                                }
                                const b = t && t._propertyBindings[m].binding.parsedPath;
                                x = new c1(li.create(n, _, b),v.ValueTypeName,v.getValueSize()),
                                ++x.referenceCount,
                                this._addInactiveBinding(x, h, _),
                                r[m] = x
                            }
                            l[m].resultBuffer = x.buffer
                        }
                    }
                    _activateAction(e) {
                        if (!this._isActiveAction(e)) {
                            if (e._cacheIndex === null) {
                                const n = (e._localRoot || this._root).uuid
                                  , i = e._clip.uuid
                                  , s = this._actionsByClip[i];
                                this._bindAction(e, s && s.knownActions[0]),
                                this._addInactiveAction(e, i, n)
                            }
                            const t = e._propertyBindings;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const s = t[n];
                                s.useCount++ === 0 && (this._lendBinding(s),
                                s.saveOriginalState())
                            }
                            this._lendAction(e)
                        }
                    }
                    _deactivateAction(e) {
                        if (this._isActiveAction(e)) {
                            const t = e._propertyBindings;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const s = t[n];
                                --s.useCount === 0 && (s.restoreOriginalState(),
                                this._takeBackBinding(s))
                            }
                            this._takeBackAction(e)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [],
                        this._nActiveActions = 0,
                        this._actionsByClip = {},
                        this._bindings = [],
                        this._nActiveBindings = 0,
                        this._bindingsByRootAndName = {},
                        this._controlInterpolants = [],
                        this._nActiveControlInterpolants = 0;
                        const e = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return e._actions.length
                                },
                                get inUse() {
                                    return e._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return e._bindings.length
                                },
                                get inUse() {
                                    return e._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return e._controlInterpolants.length
                                },
                                get inUse() {
                                    return e._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(e) {
                        const t = e._cacheIndex;
                        return t !== null && t < this._nActiveActions
                    }
                    _addInactiveAction(e, t, n) {
                        const i = this._actions
                          , s = this._actionsByClip;
                        let r = s[t];
                        if (r === void 0)
                            r = {
                                knownActions: [e],
                                actionByRoot: {}
                            },
                            e._byClipCacheIndex = 0,
                            s[t] = r;
                        else {
                            const l = r.knownActions;
                            e._byClipCacheIndex = l.length,
                            l.push(e)
                        }
                        e._cacheIndex = i.length,
                        i.push(e),
                        r.actionByRoot[n] = e
                    }
                    _removeInactiveAction(e) {
                        const t = this._actions
                          , n = t[t.length - 1]
                          , i = e._cacheIndex;
                        n._cacheIndex = i,
                        t[i] = n,
                        t.pop(),
                        e._cacheIndex = null;
                        const s = e._clip.uuid
                          , r = this._actionsByClip
                          , l = r[s]
                          , h = l.knownActions
                          , d = h[h.length - 1]
                          , p = e._byClipCacheIndex;
                        d._byClipCacheIndex = p,
                        h[p] = d,
                        h.pop(),
                        e._byClipCacheIndex = null;
                        const m = l.actionByRoot
                          , v = (e._localRoot || this._root).uuid;
                        delete m[v],
                        h.length === 0 && delete r[s],
                        this._removeInactiveBindingsForAction(e)
                    }
                    _removeInactiveBindingsForAction(e) {
                        const t = e._propertyBindings;
                        for (let n = 0, i = t.length; n !== i; ++n) {
                            const s = t[n];
                            --s.referenceCount === 0 && this._removeInactiveBinding(s)
                        }
                    }
                    _lendAction(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , i = this._nActiveActions++
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _takeBackAction(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , i = --this._nActiveActions
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _addInactiveBinding(e, t, n) {
                        const i = this._bindingsByRootAndName
                          , s = this._bindings;
                        let r = i[t];
                        r === void 0 && (r = {},
                        i[t] = r),
                        r[n] = e,
                        e._cacheIndex = s.length,
                        s.push(e)
                    }
                    _removeInactiveBinding(e) {
                        const t = this._bindings
                          , n = e.binding
                          , i = n.rootNode.uuid
                          , s = n.path
                          , r = this._bindingsByRootAndName
                          , l = r[i]
                          , h = t[t.length - 1]
                          , d = e._cacheIndex;
                        h._cacheIndex = d,
                        t[d] = h,
                        t.pop(),
                        delete l[s],
                        Object.keys(l).length === 0 && delete r[i]
                    }
                    _lendBinding(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , i = this._nActiveBindings++
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _takeBackBinding(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , i = --this._nActiveBindings
                          , s = t[i];
                        e._cacheIndex = i,
                        t[i] = e,
                        s._cacheIndex = n,
                        t[n] = s
                    }
                    _lendControlInterpolant() {
                        const e = this._controlInterpolants
                          , t = this._nActiveControlInterpolants++;
                        let n = e[t];
                        return n === void 0 && (n = new wT(new Float32Array(2),new Float32Array(2),1,rI),
                        n.__cacheIndex = t,
                        e[t] = n),
                        n
                    }
                    _takeBackControlInterpolant(e) {
                        const t = this._controlInterpolants
                          , n = e.__cacheIndex
                          , i = --this._nActiveControlInterpolants
                          , s = t[i];
                        e.__cacheIndex = i,
                        t[i] = e,
                        s.__cacheIndex = n,
                        t[n] = s
                    }
                    clipAction(e, t, n) {
                        const i = t || this._root
                          , s = i.uuid;
                        let r = typeof e == "string" ? Ev.findByName(i, e) : e;
                        const l = r !== null ? r.uuid : e
                          , h = this._actionsByClip[l];
                        let d = null;
                        if (n === void 0 && (r !== null ? n = r.blendMode : n = y_),
                        h !== void 0) {
                            const m = h.actionByRoot[s];
                            if (m !== void 0 && m.blendMode === n)
                                return m;
                            d = h.knownActions[0],
                            r === null && (r = d._clip)
                        }
                        if (r === null)
                            return null;
                        const p = new u1(this,r,t,n);
                        return this._bindAction(p, d),
                        this._addInactiveAction(p, l, s),
                        p
                    }
                    existingAction(e, t) {
                        const n = t || this._root
                          , i = n.uuid
                          , s = typeof e == "string" ? Ev.findByName(n, e) : e
                          , r = s ? s.uuid : e
                          , l = this._actionsByClip[r];
                        return l !== void 0 && l.actionByRoot[i] || null
                    }
                    stopAllAction() {
                        const e = this._actions
                          , t = this._nActiveActions;
                        for (let n = t - 1; n >= 0; --n)
                            e[n].stop();
                        return this
                    }
                    update(e) {
                        e *= this.timeScale;
                        const t = this._actions
                          , n = this._nActiveActions
                          , i = this.time += e
                          , s = Math.sign(e)
                          , r = this._accuIndex ^= 1;
                        for (let d = 0; d !== n; ++d)
                            t[d]._update(i, e, s, r);
                        const l = this._bindings
                          , h = this._nActiveBindings;
                        for (let d = 0; d !== h; ++d)
                            l[d].apply(r);
                        return this
                    }
                    setTime(e) {
                        this.time = 0;
                        for (let t = 0; t < this._actions.length; t++)
                            this._actions[t].time = 0;
                        return this.update(e)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(e) {
                        const t = this._actions
                          , n = e.uuid
                          , i = this._actionsByClip
                          , s = i[n];
                        if (s !== void 0) {
                            const r = s.knownActions;
                            for (let l = 0, h = r.length; l !== h; ++l) {
                                const d = r[l];
                                this._deactivateAction(d);
                                const p = d._cacheIndex
                                  , m = t[t.length - 1];
                                d._cacheIndex = null,
                                d._byClipCacheIndex = null,
                                m._cacheIndex = p,
                                t[p] = m,
                                t.pop(),
                                this._removeInactiveBindingsForAction(d)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(e) {
                        const t = e.uuid
                          , n = this._actionsByClip;
                        for (const r in n) {
                            const l = n[r].actionByRoot
                              , h = l[t];
                            h !== void 0 && (this._deactivateAction(h),
                            this._removeInactiveAction(h))
                        }
                        const i = this._bindingsByRootAndName
                          , s = i[t];
                        if (s !== void 0)
                            for (const r in s) {
                                const l = s[r];
                                l.restoreOriginalState(),
                                this._removeInactiveBinding(l)
                            }
                    }
                    uncacheAction(e, t) {
                        const n = this.existingAction(e, t);
                        n !== null && (this._deactivateAction(n),
                        this._removeInactiveAction(n))
                    }
                }
                  , lI = class extends RA {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isRenderTarget3D = !0,
                        this.depth = n,
                        this.texture = new x_(null,e,t,n),
                        this._setTextureOptions(i),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , Ce = class JO {
                    constructor(t) {
                        this.value = t
                    }
                    clone() {
                        return new JO(this.value.clone === void 0 ? this.value : this.value.clone())
                    }
                }
                ;
                let cI = 0;
                var uI = class extends Er {
                    constructor() {
                        super(),
                        this.isUniformsGroup = !0,
                        Object.defineProperty(this, "id", {
                            value: cI++
                        }),
                        this.name = "",
                        this.usage = Qg,
                        this.uniforms = []
                    }
                    add(e) {
                        return this.uniforms.push(e),
                        this
                    }
                    remove(e) {
                        const t = this.uniforms.indexOf(e);
                        return t !== -1 && this.uniforms.splice(t, 1),
                        this
                    }
                    setName(e) {
                        return this.name = e,
                        this
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    copy(e) {
                        this.name = e.name,
                        this.usage = e.usage;
                        const t = e.uniforms;
                        this.uniforms.length = 0;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const s = Array.isArray(t[n]) ? t[n] : [t[n]];
                            for (let r = 0; r < s.length; r++)
                                this.uniforms.push(s[r].clone())
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , hI = class extends z_ {
                    constructor(e, t, n=1) {
                        super(e, t),
                        this.isInstancedInterleavedBuffer = !0,
                        this.meshPerAttribute = n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    }
                    clone(e) {
                        const t = super.clone(e);
                        return t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.isInstancedInterleavedBuffer = !0,
                        t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                }
                  , fI = class {
                    constructor(e, t, n, i, s, r=!1) {
                        this.isGLBufferAttribute = !0,
                        this.name = "",
                        this.buffer = e,
                        this.type = t,
                        this.itemSize = n,
                        this.elementSize = i,
                        this.count = s,
                        this.normalized = r,
                        this.version = 0
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this
                    }
                    setType(e, t) {
                        return this.type = e,
                        this.elementSize = t,
                        this
                    }
                    setItemSize(e) {
                        return this.itemSize = e,
                        this
                    }
                    setCount(e) {
                        return this.count = e,
                        this
                    }
                }
                ;
                const h1 = new Xt;
                var FT = class {
                    constructor(e, t, n=0, i=1 / 0) {
                        this.ray = new hf(e,t),
                        this.near = n,
                        this.far = i,
                        this.camera = null,
                        this.layers = new mp,
                        this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(e, t) {
                        this.ray.set(e, t)
                    }
                    setFromCamera(e, t) {
                        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                    }
                    setFromXRController(e) {
                        return h1.identity().extractRotation(e.matrixWorld),
                        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction.set(0, 0, -1).applyMatrix4(h1),
                        this
                    }
                    intersectObject(e, t=!0, n=[]) {
                        return HT(e, this, n, t),
                        n.sort(f1),
                        n
                    }
                    intersectObjects(e, t=!0, n=[]) {
                        for (let i = 0, s = e.length; i < s; i++)
                            HT(e[i], this, n, t);
                        return n.sort(f1),
                        n
                    }
                }
                ;
                function f1(e, t) {
                    return e.distance - t.distance
                }
                function HT(e, t, n, i) {
                    let s = !0;
                    if (e.layers.test(t.layers) && e.raycast(t, n) === !1 && (s = !1),
                    s === !0 && i === !0) {
                        const r = e.children;
                        for (let l = 0, h = r.length; l < h; l++)
                            HT(r[l], t, n, !0)
                    }
                }
                var dI = class {
                    constructor() {
                        this._previousTime = 0,
                        this._currentTime = 0,
                        this._startTime = performance.now(),
                        this._delta = 0,
                        this._elapsed = 0,
                        this._timescale = 1,
                        this._document = null,
                        this._pageVisibilityHandler = null
                    }
                    connect(e) {
                        this._document = e,
                        e.hidden !== void 0 && (this._pageVisibilityHandler = pI.bind(this),
                        e.addEventListener("visibilitychange", this._pageVisibilityHandler, !1))
                    }
                    disconnect() {
                        this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler),
                        this._pageVisibilityHandler = null),
                        this._document = null
                    }
                    getDelta() {
                        return this._delta / 1e3
                    }
                    getElapsed() {
                        return this._elapsed / 1e3
                    }
                    getTimescale() {
                        return this._timescale
                    }
                    setTimescale(e) {
                        return this._timescale = e,
                        this
                    }
                    reset() {
                        return this._currentTime = performance.now() - this._startTime,
                        this
                    }
                    dispose() {
                        this.disconnect()
                    }
                    update(e) {
                        return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime,
                        this._currentTime = (e !== void 0 ? e : performance.now()) - this._startTime,
                        this._delta = (this._currentTime - this._previousTime) * this._timescale,
                        this._elapsed += this._delta),
                        this
                    }
                }
                ;
                function pI() {
                    this._document.hidden === !1 && this.reset()
                }
                var px = class {
                    constructor(e=1, t=0, n=0) {
                        this.radius = e,
                        this.phi = t,
                        this.theta = n
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.phi = t,
                        this.theta = n,
                        this
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.phi = e.phi,
                        this.theta = e.theta,
                        this
                    }
                    makeSafe() {
                        return this.phi = kt(this.phi, 1e-6, Math.PI - 1e-6),
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + t * t + n * n),
                        this.radius === 0 ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(e, n),
                        this.phi = Math.acos(kt(t / this.radius, -1, 1))),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , mI = class {
                    constructor(e=1, t=0, n=0) {
                        this.radius = e,
                        this.theta = t,
                        this.y = n
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.theta = t,
                        this.y = n,
                        this
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.theta = e.theta,
                        this.y = e.y,
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + n * n),
                        this.theta = Math.atan2(e, n),
                        this.y = t,
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , gI = class $O {
                    constructor(t, n, i, s) {
                        $O.prototype.isMatrix2 = !0,
                        this.elements = [1, 0, 0, 1],
                        t !== void 0 && this.set(t, n, i, s)
                    }
                    identity() {
                        return this.set(1, 0, 0, 1),
                        this
                    }
                    fromArray(t, n=0) {
                        for (let i = 0; i < 4; i++)
                            this.elements[i] = t[i + n];
                        return this
                    }
                    set(t, n, i, s) {
                        const r = this.elements;
                        return r[0] = t,
                        r[2] = n,
                        r[1] = i,
                        r[3] = s,
                        this
                    }
                }
                ;
                const d1 = new ye;
                var vI = class {
                    constructor(e=new ye(1 / 0,1 / 0), t=new ye(-1 / 0,-1 / 0)) {
                        this.isBox2 = !0,
                        this.min = e,
                        this.max = t
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = d1.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0,
                        this.max.x = this.max.y = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(e) {
                        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    containsPoint(e) {
                        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                    }
                    getParameter(e, t) {
                        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(e) {
                        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return this.clampPoint(e, d1).distanceTo(e)
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                }
                ;
                const p1 = new Q
                  , mx = new Q
                  , Ip = new Q
                  , Lp = new Q
                  , VT = new Q
                  , yI = new Q
                  , _I = new Q;
                var xI = class {
                    constructor(e=new Q, t=new Q) {
                        this.start = e,
                        this.end = t
                    }
                    set(e, t) {
                        return this.start.copy(e),
                        this.end.copy(t),
                        this
                    }
                    copy(e) {
                        return this.start.copy(e.start),
                        this.end.copy(e.end),
                        this
                    }
                    getCenter(e) {
                        return e.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(e) {
                        return e.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(e, t) {
                        return this.delta(t).multiplyScalar(e).add(this.start)
                    }
                    closestPointToPointParameter(e, t) {
                        p1.subVectors(e, this.start),
                        mx.subVectors(this.end, this.start);
                        const n = mx.dot(mx);
                        let i = mx.dot(p1) / n;
                        return t && (i = kt(i, 0, 1)),
                        i
                    }
                    closestPointToPoint(e, t, n) {
                        const i = this.closestPointToPointParameter(e, t);
                        return this.delta(n).multiplyScalar(i).add(this.start)
                    }
                    distanceSqToLine3(e, t=yI, n=_I) {
                        const i = 10000000000000001e-32;
                        let s, r;
                        const l = this.start
                          , h = e.start
                          , d = this.end
                          , p = e.end;
                        Ip.subVectors(d, l),
                        Lp.subVectors(p, h),
                        VT.subVectors(l, h);
                        const m = Ip.dot(Ip)
                          , v = Lp.dot(Lp)
                          , _ = Lp.dot(VT);
                        if (m <= i && v <= i)
                            return t.copy(l),
                            n.copy(h),
                            t.sub(n),
                            t.dot(t);
                        if (m <= i)
                            s = 0,
                            r = _ / v,
                            r = kt(r, 0, 1);
                        else {
                            const x = Ip.dot(VT);
                            if (v <= i)
                                r = 0,
                                s = kt(-x / m, 0, 1);
                            else {
                                const b = Ip.dot(Lp)
                                  , E = m * v - b * b;
                                E !== 0 ? s = kt((b * _ - x * v) / E, 0, 1) : s = 0,
                                r = (b * s + _) / v,
                                r < 0 ? (r = 0,
                                s = kt(-x / m, 0, 1)) : r > 1 && (r = 1,
                                s = kt((b - x) / m, 0, 1))
                            }
                        }
                        return t.copy(l).add(Ip.multiplyScalar(s)),
                        n.copy(h).add(Lp.multiplyScalar(r)),
                        t.sub(n),
                        t.dot(t)
                    }
                    applyMatrix4(e) {
                        return this.start.applyMatrix4(e),
                        this.end.applyMatrix4(e),
                        this
                    }
                    equals(e) {
                        return e.start.equals(this.start) && e.end.equals(this.end)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const m1 = new Q;
                var SI = class extends jn {
                    constructor(e, t) {
                        super(),
                        this.light = e,
                        this.matrixAutoUpdate = !1,
                        this.color = t,
                        this.type = "SpotLightHelper";
                        const n = new an
                          , i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let r = 0, l = 1, h = 32; r < h; r++,
                        l++) {
                            const d = r / h * Math.PI * 2
                              , p = l / h * Math.PI * 2;
                            i.push(Math.cos(d), Math.sin(d), 1, Math.cos(p), Math.sin(p), 1)
                        }
                        n.setAttribute("position", new At(i,3));
                        const s = new Ia({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new Hl(n,s),
                        this.add(this.cone),
                        this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        this.parent ? (this.parent.updateWorldMatrix(!0),
                        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
                        this.matrixWorld.copy(this.light.matrixWorld);
                        const e = this.light.distance ? this.light.distance : 1e3
                          , t = e * Math.tan(this.light.angle);
                        this.cone.scale.set(t, t, e),
                        m1.setFromMatrixPosition(this.light.target.matrixWorld),
                        this.cone.lookAt(m1),
                        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                ;
                const Wu = new Q
                  , gx = new Xt
                  , GT = new Xt;
                var AI = class extends Hl {
                    constructor(e) {
                        const t = g1(e)
                          , n = new an
                          , i = []
                          , s = [];
                        for (let d = 0; d < t.length; d++) {
                            const p = t[d];
                            p.parent && p.parent.isBone && (i.push(0, 0, 0),
                            i.push(0, 0, 0),
                            s.push(0, 0, 0),
                            s.push(0, 0, 0))
                        }
                        n.setAttribute("position", new At(i,3)),
                        n.setAttribute("color", new At(s,3));
                        const r = new Ia({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        });
                        super(n, r),
                        this.isSkeletonHelper = !0,
                        this.type = "SkeletonHelper",
                        this.root = e,
                        this.bones = t,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1;
                        const l = new at(255)
                          , h = new at(65280);
                        this.setColors(l, h)
                    }
                    updateMatrixWorld(e) {
                        const t = this.bones
                          , n = this.geometry
                          , i = n.getAttribute("position");
                        GT.copy(this.root.matrixWorld).invert();
                        for (let s = 0, r = 0; s < t.length; s++) {
                            const l = t[s];
                            l.parent && l.parent.isBone && (gx.multiplyMatrices(GT, l.matrixWorld),
                            Wu.setFromMatrixPosition(gx),
                            i.setXYZ(r, Wu.x, Wu.y, Wu.z),
                            gx.multiplyMatrices(GT, l.parent.matrixWorld),
                            Wu.setFromMatrixPosition(gx),
                            i.setXYZ(r + 1, Wu.x, Wu.y, Wu.z),
                            r += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0,
                        super.updateMatrixWorld(e)
                    }
                    setColors(e, t) {
                        const n = this.geometry.getAttribute("color");
                        for (let i = 0; i < n.count; i += 2)
                            n.setXYZ(i, e.r, e.g, e.b),
                            n.setXYZ(i + 1, t.r, t.g, t.b);
                        return n.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function g1(e) {
                    const t = [];
                    e.isBone === !0 && t.push(e);
                    for (let n = 0; n < e.children.length; n++)
                        t.push(...g1(e.children[n]));
                    return t
                }
                var TI = class extends Fi {
                    constructor(e, t, n) {
                        const i = new ST(t,4,2)
                          , s = new Gu({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                        super(i, s),
                        this.light = e,
                        this.color = n,
                        this.type = "PointLightHelper",
                        this.matrix = this.light.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                ;
                const MI = new Q
                  , v1 = new at
                  , y1 = new at;
                var bI = class extends jn {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "HemisphereLightHelper";
                        const i = new xT(t);
                        i.rotateY(Math.PI * .5),
                        this.material = new Gu({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }),
                        this.color === void 0 && (this.material.vertexColors = !0);
                        const s = i.getAttribute("position")
                          , r = new Float32Array(s.count * 3);
                        i.setAttribute("color", new wn(r,3)),
                        this.add(new Fi(i,this.material)),
                        this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                    update() {
                        const e = this.children[0];
                        if (this.color !== void 0)
                            this.material.color.set(this.color);
                        else {
                            const t = e.geometry.getAttribute("color");
                            v1.copy(this.light.color),
                            y1.copy(this.light.groundColor);
                            for (let n = 0, i = t.count; n < i; n++) {
                                const s = n < i / 2 ? v1 : y1;
                                t.setXYZ(n, s.r, s.g, s.b)
                            }
                            t.needsUpdate = !0
                        }
                        this.light.updateWorldMatrix(!0, !1),
                        e.lookAt(MI.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                  , EI = class extends Hl {
                    constructor(e=10, t=10, n=4473924, i=8947848) {
                        n = new at(n),
                        i = new at(i);
                        const s = t / 2
                          , r = e / t
                          , l = e / 2
                          , h = []
                          , d = [];
                        for (let v = 0, _ = 0, x = -l; v <= t; v++,
                        x += r) {
                            h.push(-l, 0, x, l, 0, x),
                            h.push(x, 0, -l, x, 0, l);
                            const b = v === s ? n : i;
                            b.toArray(d, _),
                            _ += 3,
                            b.toArray(d, _),
                            _ += 3,
                            b.toArray(d, _),
                            _ += 3,
                            b.toArray(d, _),
                            _ += 3
                        }
                        const p = new an;
                        p.setAttribute("position", new At(h,3)),
                        p.setAttribute("color", new At(d,3));
                        const m = new Ia({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(p, m),
                        this.type = "GridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , wI = class extends Hl {
                    constructor(e=10, t=16, n=8, i=64, s=4473924, r=8947848) {
                        s = new at(s),
                        r = new at(r);
                        const l = []
                          , h = [];
                        if (t > 1)
                            for (let m = 0; m < t; m++) {
                                const v = m / t * (Math.PI * 2)
                                  , _ = Math.sin(v) * e
                                  , x = Math.cos(v) * e;
                                l.push(0, 0, 0),
                                l.push(_, 0, x);
                                const b = m & 1 ? s : r;
                                h.push(b.r, b.g, b.b),
                                h.push(b.r, b.g, b.b)
                            }
                        for (let m = 0; m < n; m++) {
                            const v = m & 1 ? s : r
                              , _ = e - e / n * m;
                            for (let x = 0; x < i; x++) {
                                let b = x / i * (Math.PI * 2)
                                  , E = Math.sin(b) * _
                                  , T = Math.cos(b) * _;
                                l.push(E, 0, T),
                                h.push(v.r, v.g, v.b),
                                b = (x + 1) / i * (Math.PI * 2),
                                E = Math.sin(b) * _,
                                T = Math.cos(b) * _,
                                l.push(E, 0, T),
                                h.push(v.r, v.g, v.b)
                            }
                        }
                        const d = new an;
                        d.setAttribute("position", new At(l,3)),
                        d.setAttribute("color", new At(h,3));
                        const p = new Ia({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(d, p),
                        this.type = "PolarGridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                const _1 = new Q
                  , vx = new Q
                  , x1 = new Q;
                var CI = class extends jn {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "DirectionalLightHelper",
                        t === void 0 && (t = 1);
                        let i = new an;
                        i.setAttribute("position", new At([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
                        const s = new Ia({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new Xu(i,s),
                        this.add(this.lightPlane),
                        i = new an,
                        i.setAttribute("position", new At([0, 0, 0, 0, 0, 1],3)),
                        this.targetLine = new Xu(i,s),
                        this.add(this.targetLine),
                        this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(),
                        this.lightPlane.material.dispose(),
                        this.targetLine.geometry.dispose(),
                        this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        _1.setFromMatrixPosition(this.light.matrixWorld),
                        vx.setFromMatrixPosition(this.light.target.matrixWorld),
                        x1.subVectors(vx, _1),
                        this.lightPlane.lookAt(vx),
                        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                        this.targetLine.lookAt(vx),
                        this.targetLine.scale.z = x1.length()
                    }
                }
                ;
                const yx = new Q
                  , Hi = new av;
                var RI = class extends Hl {
                    constructor(e) {
                        const t = new an
                          , n = new Ia({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        })
                          , i = []
                          , s = []
                          , r = {};
                        l("n1", "n2"),
                        l("n2", "n4"),
                        l("n4", "n3"),
                        l("n3", "n1"),
                        l("f1", "f2"),
                        l("f2", "f4"),
                        l("f4", "f3"),
                        l("f3", "f1"),
                        l("n1", "f1"),
                        l("n2", "f2"),
                        l("n3", "f3"),
                        l("n4", "f4"),
                        l("p", "n1"),
                        l("p", "n2"),
                        l("p", "n3"),
                        l("p", "n4"),
                        l("u1", "u2"),
                        l("u2", "u3"),
                        l("u3", "u1"),
                        l("c", "t"),
                        l("p", "c"),
                        l("cn1", "cn2"),
                        l("cn3", "cn4"),
                        l("cf1", "cf2"),
                        l("cf3", "cf4");
                        function l(x, b) {
                            h(x),
                            h(b)
                        }
                        function h(x) {
                            i.push(0, 0, 0),
                            s.push(0, 0, 0),
                            r[x] === void 0 && (r[x] = []),
                            r[x].push(i.length / 3 - 1)
                        }
                        t.setAttribute("position", new At(i,3)),
                        t.setAttribute("color", new At(s,3)),
                        super(t, n),
                        this.type = "CameraHelper",
                        this.camera = e,
                        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.pointMap = r,
                        this.update();
                        const d = new at(16755200)
                          , p = new at(16711680)
                          , m = new at(43775)
                          , v = new at(16777215)
                          , _ = new at(3355443);
                        this.setColors(d, p, m, v, _)
                    }
                    setColors(e, t, n, i, s) {
                        const r = this.geometry.getAttribute("color");
                        return r.setXYZ(0, e.r, e.g, e.b),
                        r.setXYZ(1, e.r, e.g, e.b),
                        r.setXYZ(2, e.r, e.g, e.b),
                        r.setXYZ(3, e.r, e.g, e.b),
                        r.setXYZ(4, e.r, e.g, e.b),
                        r.setXYZ(5, e.r, e.g, e.b),
                        r.setXYZ(6, e.r, e.g, e.b),
                        r.setXYZ(7, e.r, e.g, e.b),
                        r.setXYZ(8, e.r, e.g, e.b),
                        r.setXYZ(9, e.r, e.g, e.b),
                        r.setXYZ(10, e.r, e.g, e.b),
                        r.setXYZ(11, e.r, e.g, e.b),
                        r.setXYZ(12, e.r, e.g, e.b),
                        r.setXYZ(13, e.r, e.g, e.b),
                        r.setXYZ(14, e.r, e.g, e.b),
                        r.setXYZ(15, e.r, e.g, e.b),
                        r.setXYZ(16, e.r, e.g, e.b),
                        r.setXYZ(17, e.r, e.g, e.b),
                        r.setXYZ(18, e.r, e.g, e.b),
                        r.setXYZ(19, e.r, e.g, e.b),
                        r.setXYZ(20, e.r, e.g, e.b),
                        r.setXYZ(21, e.r, e.g, e.b),
                        r.setXYZ(22, e.r, e.g, e.b),
                        r.setXYZ(23, e.r, e.g, e.b),
                        r.setXYZ(24, t.r, t.g, t.b),
                        r.setXYZ(25, t.r, t.g, t.b),
                        r.setXYZ(26, t.r, t.g, t.b),
                        r.setXYZ(27, t.r, t.g, t.b),
                        r.setXYZ(28, t.r, t.g, t.b),
                        r.setXYZ(29, t.r, t.g, t.b),
                        r.setXYZ(30, t.r, t.g, t.b),
                        r.setXYZ(31, t.r, t.g, t.b),
                        r.setXYZ(32, n.r, n.g, n.b),
                        r.setXYZ(33, n.r, n.g, n.b),
                        r.setXYZ(34, n.r, n.g, n.b),
                        r.setXYZ(35, n.r, n.g, n.b),
                        r.setXYZ(36, n.r, n.g, n.b),
                        r.setXYZ(37, n.r, n.g, n.b),
                        r.setXYZ(38, i.r, i.g, i.b),
                        r.setXYZ(39, i.r, i.g, i.b),
                        r.setXYZ(40, s.r, s.g, s.b),
                        r.setXYZ(41, s.r, s.g, s.b),
                        r.setXYZ(42, s.r, s.g, s.b),
                        r.setXYZ(43, s.r, s.g, s.b),
                        r.setXYZ(44, s.r, s.g, s.b),
                        r.setXYZ(45, s.r, s.g, s.b),
                        r.setXYZ(46, s.r, s.g, s.b),
                        r.setXYZ(47, s.r, s.g, s.b),
                        r.setXYZ(48, s.r, s.g, s.b),
                        r.setXYZ(49, s.r, s.g, s.b),
                        r.needsUpdate = !0,
                        this
                    }
                    update() {
                        const e = this.geometry
                          , t = this.pointMap
                          , n = 1
                          , i = 1;
                        let s, r;
                        if (Hi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                        this.camera.reversedDepth === !0)
                            s = 1,
                            r = 0;
                        else if (this.camera.coordinateSystem === br)
                            s = -1,
                            r = 1;
                        else if (this.camera.coordinateSystem === rp)
                            s = 0,
                            r = 1;
                        else
                            throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem);
                        Qi("c", t, e, Hi, 0, 0, s),
                        Qi("t", t, e, Hi, 0, 0, r),
                        Qi("n1", t, e, Hi, -n, -i, s),
                        Qi("n2", t, e, Hi, n, -i, s),
                        Qi("n3", t, e, Hi, -n, i, s),
                        Qi("n4", t, e, Hi, n, i, s),
                        Qi("f1", t, e, Hi, -n, -i, r),
                        Qi("f2", t, e, Hi, n, -i, r),
                        Qi("f3", t, e, Hi, -n, i, r),
                        Qi("f4", t, e, Hi, n, i, r),
                        Qi("u1", t, e, Hi, n * .7, i * 1.1, s),
                        Qi("u2", t, e, Hi, -n * .7, i * 1.1, s),
                        Qi("u3", t, e, Hi, 0, i * 2, s),
                        Qi("cf1", t, e, Hi, -n, 0, r),
                        Qi("cf2", t, e, Hi, n, 0, r),
                        Qi("cf3", t, e, Hi, 0, -i, r),
                        Qi("cf4", t, e, Hi, 0, i, r),
                        Qi("cn1", t, e, Hi, -n, 0, s),
                        Qi("cn2", t, e, Hi, n, 0, s),
                        Qi("cn3", t, e, Hi, 0, -i, s),
                        Qi("cn4", t, e, Hi, 0, i, s),
                        e.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function Qi(e, t, n, i, s, r, l) {
                    yx.set(s, r, l).unproject(i);
                    const h = t[e];
                    if (h !== void 0) {
                        const d = n.getAttribute("position");
                        for (let p = 0, m = h.length; p < m; p++)
                            d.setXYZ(h[p], yx.x, yx.y, yx.z)
                    }
                }
                const _x = new aa;
                var DI = class extends Hl {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , i = new Float32Array(24)
                          , s = new an;
                        s.setIndex(new wn(n,1)),
                        s.setAttribute("position", new wn(i,3)),
                        super(s, new Ia({
                            color: t,
                            toneMapped: !1
                        })),
                        this.object = e,
                        this.type = "BoxHelper",
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    update() {
                        if (this.object !== void 0 && _x.setFromObject(this.object),
                        _x.isEmpty())
                            return;
                        const e = _x.min
                          , t = _x.max
                          , n = this.geometry.attributes.position
                          , i = n.array;
                        i[0] = t.x,
                        i[1] = t.y,
                        i[2] = t.z,
                        i[3] = e.x,
                        i[4] = t.y,
                        i[5] = t.z,
                        i[6] = e.x,
                        i[7] = e.y,
                        i[8] = t.z,
                        i[9] = t.x,
                        i[10] = e.y,
                        i[11] = t.z,
                        i[12] = t.x,
                        i[13] = t.y,
                        i[14] = e.z,
                        i[15] = e.x,
                        i[16] = t.y,
                        i[17] = e.z,
                        i[18] = e.x,
                        i[19] = e.y,
                        i[20] = e.z,
                        i[21] = t.x,
                        i[22] = e.y,
                        i[23] = e.z,
                        n.needsUpdate = !0,
                        this.geometry.computeBoundingSphere()
                    }
                    setFromObject(e) {
                        return this.object = e,
                        this.update(),
                        this
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.object = e.object,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , OI = class extends Hl {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
                          , s = new an;
                        s.setIndex(new wn(n,1)),
                        s.setAttribute("position", new At(i,3)),
                        super(s, new Ia({
                            color: t,
                            toneMapped: !1
                        })),
                        this.box = e,
                        this.type = "Box3Helper",
                        this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(e) {
                        const t = this.box;
                        t.isEmpty() || (t.getCenter(this.position),
                        t.getSize(this.scale),
                        this.scale.multiplyScalar(.5),
                        super.updateMatrixWorld(e))
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , NI = class extends Xu {
                    constructor(e, t=1, n=16776960) {
                        const i = n
                          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
                          , r = new an;
                        r.setAttribute("position", new At(s,3)),
                        r.computeBoundingSphere(),
                        super(r, new Ia({
                            color: i,
                            toneMapped: !1
                        })),
                        this.type = "PlaneHelper",
                        this.plane = e,
                        this.size = t;
                        const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
                          , h = new an;
                        h.setAttribute("position", new At(l,3)),
                        h.computeBoundingSphere(),
                        this.add(new Fi(h,new Gu({
                            color: i,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(e) {
                        this.position.set(0, 0, 0),
                        this.scale.set(.5 * this.size, .5 * this.size, 1),
                        this.lookAt(this.plane.normal),
                        this.translateZ(-this.plane.constant),
                        super.updateMatrixWorld(e)
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose(),
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                }
                ;
                const S1 = new Q;
                let xx, kT;
                var UI = class extends jn {
                    constructor(e=new Q(0,0,1), t=new Q(0,0,0), n=1, i=16776960, s=n * .2, r=s * .2) {
                        super(),
                        this.type = "ArrowHelper",
                        xx === void 0 && (xx = new an,
                        xx.setAttribute("position", new At([0, 0, 0, 0, 1, 0],3)),
                        kT = new oT(.5,1,5,1),
                        kT.translate(0, -.5, 0)),
                        this.position.copy(t),
                        this.line = new Xu(xx,new Ia({
                            color: i,
                            toneMapped: !1
                        })),
                        this.line.matrixAutoUpdate = !1,
                        this.add(this.line),
                        this.cone = new Fi(kT,new Gu({
                            color: i,
                            toneMapped: !1
                        })),
                        this.cone.matrixAutoUpdate = !1,
                        this.add(this.cone),
                        this.setDirection(e),
                        this.setLength(n, s, r)
                    }
                    setDirection(e) {
                        if (e.y > .99999)
                            this.quaternion.set(0, 0, 0, 1);
                        else if (e.y < -.99999)
                            this.quaternion.set(1, 0, 0, 0);
                        else {
                            S1.set(e.z, 0, -e.x).normalize();
                            const t = Math.acos(e.y);
                            this.quaternion.setFromAxisAngle(S1, t)
                        }
                    }
                    setLength(e, t=e * .2, n=t * .2) {
                        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                        this.line.updateMatrix(),
                        this.cone.scale.set(n, t, n),
                        this.cone.position.y = e,
                        this.cone.updateMatrix()
                    }
                    setColor(e) {
                        this.line.material.color.set(e),
                        this.cone.material.color.set(e)
                    }
                    copy(e) {
                        return super.copy(e, !1),
                        this.line.copy(e.line),
                        this.cone.copy(e.cone),
                        this
                    }
                    dispose() {
                        this.line.geometry.dispose(),
                        this.line.material.dispose(),
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                }
                  , BI = class extends Hl {
                    constructor(e=1) {
                        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
                          , n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
                          , i = new an;
                        i.setAttribute("position", new At(t,3)),
                        i.setAttribute("color", new At(n,3));
                        const s = new Ia({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(i, s),
                        this.type = "AxesHelper"
                    }
                    setColors(e, t, n) {
                        const i = new at
                          , s = this.geometry.attributes.color.array;
                        return i.set(e),
                        i.toArray(s, 0),
                        i.toArray(s, 3),
                        i.set(t),
                        i.toArray(s, 6),
                        i.toArray(s, 9),
                        i.set(n),
                        i.toArray(s, 12),
                        i.toArray(s, 15),
                        this.geometry.attributes.color.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , PI = class {
                    constructor() {
                        this.type = "ShapePath",
                        this.color = new at,
                        this.subPaths = [],
                        this.currentPath = null
                    }
                    moveTo(e, t) {
                        return this.currentPath = new ox,
                        this.subPaths.push(this.currentPath),
                        this.currentPath.moveTo(e, t),
                        this
                    }
                    lineTo(e, t) {
                        return this.currentPath.lineTo(e, t),
                        this
                    }
                    quadraticCurveTo(e, t, n, i) {
                        return this.currentPath.quadraticCurveTo(e, t, n, i),
                        this
                    }
                    bezierCurveTo(e, t, n, i, s, r) {
                        return this.currentPath.bezierCurveTo(e, t, n, i, s, r),
                        this
                    }
                    splineThru(e) {
                        return this.currentPath.splineThru(e),
                        this
                    }
                    toShapes(e) {
                        function t(T) {
                            const M = [];
                            for (let D = 0, R = T.length; D < R; D++) {
                                const O = T[D]
                                  , U = new gf;
                                U.curves = O.curves,
                                M.push(U)
                            }
                            return M
                        }
                        function n(T, M) {
                            const D = M.length;
                            let R = !1;
                            for (let O = D - 1, U = 0; U < D; O = U++) {
                                let B = M[O]
                                  , I = M[U]
                                  , F = I.x - B.x
                                  , P = I.y - B.y;
                                if (Math.abs(P) > Number.EPSILON) {
                                    if (P < 0 && (B = M[U],
                                    F = -F,
                                    I = M[O],
                                    P = -P),
                                    T.y < B.y || T.y > I.y)
                                        continue;
                                    if (T.y === B.y) {
                                        if (T.x === B.x)
                                            return !0
                                    } else {
                                        const L = P * (T.x - B.x) - F * (T.y - B.y);
                                        if (L === 0)
                                            return !0;
                                        if (L < 0)
                                            continue;
                                        R = !R
                                    }
                                } else {
                                    if (T.y !== B.y)
                                        continue;
                                    if (I.x <= T.x && T.x <= B.x || B.x <= T.x && T.x <= I.x)
                                        return !0
                                }
                            }
                            return R
                        }
                        const i = Dc.isClockWise
                          , s = this.subPaths;
                        if (s.length === 0)
                            return [];
                        let r, l, h;
                        const d = [];
                        if (s.length === 1)
                            return l = s[0],
                            h = new gf,
                            h.curves = l.curves,
                            d.push(h),
                            d;
                        let p = !i(s[0].getPoints());
                        p = e ? !p : p;
                        const m = []
                          , v = [];
                        let _ = [], x = 0, b;
                        v[x] = void 0,
                        _[x] = [];
                        for (let T = 0, M = s.length; T < M; T++)
                            l = s[T],
                            b = l.getPoints(),
                            r = i(b),
                            r = e ? !r : r,
                            r ? (!p && v[x] && x++,
                            v[x] = {
                                s: new gf,
                                p: b
                            },
                            v[x].s.curves = l.curves,
                            p && x++,
                            _[x] = []) : _[x].push({
                                h: l,
                                p: b[0]
                            });
                        if (!v[0])
                            return t(s);
                        if (v.length > 1) {
                            let T = !1
                              , M = 0;
                            for (let D = 0, R = v.length; D < R; D++)
                                m[D] = [];
                            for (let D = 0, R = v.length; D < R; D++) {
                                const O = _[D];
                                for (let U = 0; U < O.length; U++) {
                                    const B = O[U];
                                    let I = !0;
                                    for (let F = 0; F < v.length; F++)
                                        n(B.p, v[F].p) && (D !== F && M++,
                                        I ? (I = !1,
                                        m[F].push(B)) : T = !0);
                                    I && m[D].push(B)
                                }
                            }
                            M > 0 && T === !1 && (_ = m)
                        }
                        let E;
                        for (let T = 0, M = v.length; T < M; T++) {
                            h = v[T].s,
                            d.push(h),
                            E = _[T];
                            for (let D = 0, R = E.length; D < R; D++)
                                h.holes.push(E[D].h)
                        }
                        return d
                    }
                }
                  , II = class extends Er {
                    constructor(e, t=null) {
                        super(),
                        this.object = e,
                        this.domElement = t,
                        this.enabled = !0,
                        this.state = -1,
                        this.keys = {},
                        this.mouseButtons = {
                            LEFT: null,
                            MIDDLE: null,
                            RIGHT: null
                        },
                        this.touches = {
                            ONE: null,
                            TWO: null
                        }
                    }
                    connect(e) {
                        if (e === void 0) {
                            console.warn("THREE.Controls: connect() now requires an element.");
                            return
                        }
                        this.domElement !== null && this.disconnect(),
                        this.domElement = e
                    }
                    disconnect() {}
                    dispose() {}
                    update() {}
                }
                ;
                function LI(e, t) {
                    const n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = 1,
                    e.repeat.y = n / t,
                    e.offset.x = 0,
                    e.offset.y = (1 - e.repeat.y) / 2) : (e.repeat.x = t / n,
                    e.repeat.y = 1,
                    e.offset.x = (1 - e.repeat.x) / 2,
                    e.offset.y = 0),
                    e
                }
                function zI(e, t) {
                    const n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = t / n,
                    e.repeat.y = 1,
                    e.offset.x = (1 - e.repeat.x) / 2,
                    e.offset.y = 0) : (e.repeat.x = 1,
                    e.repeat.y = n / t,
                    e.offset.x = 0,
                    e.offset.y = (1 - e.repeat.y) / 2),
                    e
                }
                function FI(e) {
                    return e.repeat.x = 1,
                    e.repeat.y = 1,
                    e.offset.x = 0,
                    e.offset.y = 0,
                    e
                }
                function XT(e, t, n, i) {
                    const s = HI(i);
                    switch (n) {
                    case yA:
                        return e * t;
                    case ap:
                        return e * t / s.components * s.byteLength;
                    case Vg:
                        return e * t / s.components * s.byteLength;
                    case Fy:
                        return e * t * 2 / s.components * s.byteLength;
                    case Hy:
                        return e * t * 2 / s.components * s.byteLength;
                    case _A:
                        return e * t * 3 / s.components * s.byteLength;
                    case ss:
                        return e * t * 4 / s.components * s.byteLength;
                    case Vy:
                        return e * t * 4 / s.components * s.byteLength;
                    case Gg:
                    case kg:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case Xg:
                    case qg:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case ky:
                    case qy:
                        return Math.max(e, 16) * Math.max(t, 8) / 4;
                    case Gy:
                    case Xy:
                        return Math.max(e, 8) * Math.max(t, 8) / 2;
                    case Yy:
                    case Wy:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case jy:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case Qy:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case Zy:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                    case Ky:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                    case Jy:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                    case $y:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                    case e_:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                    case t_:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                    case n_:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                    case i_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                    case s_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                    case a_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                    case r_:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                    case o_:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                    case l_:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                    case c_:
                    case u_:
                    case h_:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                    case f_:
                    case d_:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                    case p_:
                    case m_:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                    }
                    throw new Error(`Unable to determine texture byte length for ${n} format.`)
                }
                function HI(e) {
                    switch (e) {
                    case ui:
                    case pA:
                        return {
                            byteLength: 1,
                            components: 1
                        };
                    case ip:
                    case mA:
                    case tf:
                        return {
                            byteLength: 2,
                            components: 1
                        };
                    case Ly:
                    case zy:
                        return {
                            byteLength: 2,
                            components: 4
                        };
                    case Il:
                    case Iy:
                    case Xs:
                        return {
                            byteLength: 4,
                            components: 1
                        };
                    case gA:
                    case vA:
                        return {
                            byteLength: 4,
                            components: 3
                        }
                    }
                    throw new Error(`Unknown texture type ${e}.`)
                }
                var VI = class {
                    static contain(e, t) {
                        return LI(e, t)
                    }
                    static cover(e, t) {
                        return zI(e, t)
                    }
                    static fill(e) {
                        return FI(e)
                    }
                    static getByteLength(e, t, n, i) {
                        return XT(e, t, n, i)
                    }
                }
                ;
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                    detail: {
                        revision: xc
                    }
                })),
                typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = xc);
                var GI = X3({
                    ACESFilmicToneMapping: () => hA,
                    AddEquation: () => Du,
                    AddOperation: () => DE,
                    AdditiveAnimationBlendMode: () => xA,
                    AdditiveBlending: () => Ny,
                    AgXToneMapping: () => PE,
                    AlphaFormat: () => yA,
                    AlwaysCompare: () => jE,
                    AlwaysDepth: () => Ug,
                    AlwaysStencilFunc: () => SA,
                    AmbientLight: () => QC,
                    AnimationAction: () => u1,
                    AnimationClip: () => Ev,
                    AnimationLoader: () => NP,
                    AnimationMixer: () => oI,
                    AnimationObjectGroup: () => aI,
                    AnimationUtils: () => CP,
                    ArcCurve: () => iC,
                    ArrayCamera: () => r1,
                    ArrowHelper: () => UI,
                    AttachedBindMode: () => fA,
                    Audio: () => o1,
                    AudioAnalyser: () => QP,
                    AudioContext: () => BT,
                    AudioListener: () => YP,
                    AudioLoader: () => kP,
                    AxesHelper: () => BI,
                    BackSide: () => ys,
                    BasicDepthPacking: () => ji,
                    BasicShadowMap: () => uE,
                    BatchedMesh: () => kw,
                    Bone: () => JA,
                    BooleanKeyframeTrack: () => _f,
                    Box2: () => vI,
                    Box3: () => aa,
                    Box3Helper: () => OI,
                    BoxGeometry: () => sv,
                    BoxHelper: () => DI,
                    BufferAttribute: () => wn,
                    BufferGeometry: () => an,
                    BufferGeometryLoader: () => t1,
                    ByteType: () => pA,
                    Cache: () => Vl,
                    Camera: () => av,
                    CameraHelper: () => RI,
                    CanvasTexture: () => KB,
                    CapsuleGeometry: () => $w,
                    CatmullRomCurve3: () => sC,
                    CineonToneMapping: () => UE,
                    CircleGeometry: () => eC,
                    ClampToEdgeWrapping: () => no,
                    Clock: () => PT,
                    Color: () => at,
                    ColorKeyframeTrack: () => CT,
                    ColorManagement: () => An,
                    CompressedArrayTexture: () => QB,
                    CompressedCubeTexture: () => ZB,
                    CompressedTexture: () => ex,
                    CompressedTextureLoader: () => UP,
                    ConeGeometry: () => oT,
                    ConstantAlphaFactor: () => wE,
                    ConstantColorFactor: () => bE,
                    Controls: () => II,
                    CubeCamera: () => _w,
                    CubeReflectionMapping: () => Sc,
                    CubeRefractionMapping: () => Nu,
                    CubeTexture: () => rv,
                    CubeTextureLoader: () => BP,
                    CubeUVReflectionMapping: () => tp,
                    CubicBezierCurve: () => dT,
                    CubicBezierCurve3: () => rC,
                    CubicInterpolant: () => zC,
                    CullFaceBack: () => lA,
                    CullFaceFront: () => cE,
                    CullFaceFrontBack: () => sU,
                    CullFaceNone: () => lE,
                    Curve: () => qo,
                    CurvePath: () => lC,
                    CustomBlending: () => hE,
                    CustomToneMapping: () => BE,
                    CylinderGeometry: () => rT,
                    Cylindrical: () => mI,
                    Data3DTexture: () => x_,
                    DataArrayTexture: () => __,
                    DataTexture: () => Xo,
                    DataTextureLoader: () => PP,
                    DataUtils: () => xB,
                    DecrementStencilOp: () => yU,
                    DecrementWrapStencilOp: () => xU,
                    DefaultLoadingManager: () => VC,
                    DepthFormat: () => sp,
                    DepthStencilFormat: () => sf,
                    DepthTexture: () => mv,
                    DetachedBindMode: () => LE,
                    DirectionalLight: () => jC,
                    DirectionalLightHelper: () => CI,
                    DiscreteInterpolant: () => FC,
                    DodecahedronGeometry: () => tC,
                    DoubleSide: () => nr,
                    DstAlphaFactor: () => xE,
                    DstColorFactor: () => AE,
                    DynamicCopyUsage: () => PU,
                    DynamicDrawUsage: () => RU,
                    DynamicReadUsage: () => NU,
                    EdgesGeometry: () => nC,
                    EllipseCurve: () => sx,
                    EqualCompare: () => XE,
                    EqualDepth: () => ef,
                    EqualStencilFunc: () => MU,
                    EquirectangularReflectionMapping: () => Lg,
                    EquirectangularRefractionMapping: () => zg,
                    Euler: () => io,
                    EventDispatcher: () => Er,
                    ExternalTexture: () => aT,
                    ExtrudeGeometry: () => gC,
                    FileLoader: () => Nc,
                    Float16BufferAttribute: () => wB,
                    Float32BufferAttribute: () => At,
                    FloatType: () => Xs,
                    Fog: () => Aw,
                    FogExp2: () => Sw,
                    FramebufferTexture: () => jB,
                    FrontSide: () => Bl,
                    Frustum: () => Np,
                    FrustumArray: () => Hw,
                    GLBufferAttribute: () => fI,
                    GLSL1: () => LU,
                    GLSL3: () => TA,
                    GreaterCompare: () => qE,
                    GreaterDepth: () => Pg,
                    GreaterEqualCompare: () => WE,
                    GreaterEqualDepth: () => Bg,
                    GreaterEqualStencilFunc: () => CU,
                    GreaterStencilFunc: () => EU,
                    GridHelper: () => EI,
                    Group: () => Mp,
                    HalfFloatType: () => tf,
                    HemisphereLight: () => GC,
                    HemisphereLightHelper: () => bI,
                    IcosahedronGeometry: () => vC,
                    ImageBitmapLoader: () => GP,
                    ImageLoader: () => wv,
                    ImageUtils: () => nw,
                    IncrementStencilOp: () => vU,
                    IncrementWrapStencilOp: () => _U,
                    InstancedBufferAttribute: () => Dp,
                    InstancedBufferGeometry: () => e1,
                    InstancedInterleavedBuffer: () => hI,
                    InstancedMesh: () => Fw,
                    Int16BufferAttribute: () => bB,
                    Int32BufferAttribute: () => EB,
                    Int8BufferAttribute: () => AB,
                    IntType: () => Iy,
                    InterleavedBuffer: () => z_,
                    InterleavedBufferAttribute: () => ov,
                    Interpolant: () => Av,
                    InterpolateDiscrete: () => Yg,
                    InterpolateLinear: () => g_,
                    InterpolateSmooth: () => v_,
                    InterpolationSamplingMode: () => HU,
                    InterpolationSamplingType: () => FU,
                    InvertStencilOp: () => SU,
                    KeepStencilOp: () => of,
                    KeyframeTrack: () => ao,
                    LOD: () => Cw,
                    LatheGeometry: () => yC,
                    Layers: () => mp,
                    LessCompare: () => kE,
                    LessDepth: () => $d,
                    LessEqualCompare: () => AA,
                    LessEqualDepth: () => Ou,
                    LessEqualStencilFunc: () => bU,
                    LessStencilFunc: () => TU,
                    Light: () => qu,
                    LightProbe: () => JC,
                    Line: () => Xu,
                    Line3: () => xI,
                    LineBasicMaterial: () => Ia,
                    LineCurve: () => pT,
                    LineCurve3: () => oC,
                    LineDashedMaterial: () => PC,
                    LineLoop: () => jw,
                    LineSegments: () => Hl,
                    LinearFilter: () => mi,
                    LinearInterpolant: () => wT,
                    LinearMipMapLinearFilter: () => lU,
                    LinearMipMapNearestFilter: () => oU,
                    LinearMipmapLinearFilter: () => Pl,
                    LinearMipmapNearestFilter: () => Hg,
                    LinearSRGBColorSpace: () => Ll,
                    LinearToneMapping: () => OE,
                    LinearTransfer: () => jg,
                    Loader: () => ar,
                    LoaderUtils: () => NT,
                    LoadingManager: () => fx,
                    LoopOnce: () => zE,
                    LoopPingPong: () => HE,
                    LoopRepeat: () => FE,
                    MOUSE: () => Kh,
                    Material: () => Os,
                    MaterialLoader: () => $C,
                    MathUtils: () => iB,
                    Matrix2: () => gI,
                    Matrix3: () => rn,
                    Matrix4: () => Xt,
                    MaxEquation: () => mE,
                    Mesh: () => Fi,
                    MeshBasicMaterial: () => Gu,
                    MeshDepthMaterial: () => hx,
                    MeshDistanceMaterial: () => MT,
                    MeshLambertMaterial: () => UC,
                    MeshMatcapMaterial: () => BC,
                    MeshNormalMaterial: () => TT,
                    MeshPhongMaterial: () => OC,
                    MeshPhysicalMaterial: () => DC,
                    MeshStandardMaterial: () => AT,
                    MeshToonMaterial: () => NC,
                    MinEquation: () => pE,
                    MirroredRepeatWrapping: () => Fg,
                    MixOperation: () => RE,
                    MultiplyBlending: () => uA,
                    MultiplyOperation: () => Ig,
                    NearestFilter: () => ti,
                    NearestMipMapLinearFilter: () => rU,
                    NearestMipMapNearestFilter: () => aU,
                    NearestMipmapLinearFilter: () => np,
                    NearestMipmapNearestFilter: () => dA,
                    NeutralToneMapping: () => IE,
                    NeverCompare: () => GE,
                    NeverDepth: () => Ng,
                    NeverStencilFunc: () => AU,
                    NoBlending: () => oi,
                    NoColorSpace: () => Ho,
                    NoToneMapping: () => zo,
                    NormalAnimationBlendMode: () => y_,
                    NormalBlending: () => $h,
                    NotEqualCompare: () => YE,
                    NotEqualDepth: () => ep,
                    NotEqualStencilFunc: () => wU,
                    NumberKeyframeTrack: () => Tv,
                    Object3D: () => jn,
                    ObjectLoader: () => HP,
                    ObjectSpaceNormalMap: () => VE,
                    OctahedronGeometry: () => xT,
                    OneFactor: () => vE,
                    OneMinusConstantAlphaFactor: () => CE,
                    OneMinusConstantColorFactor: () => EE,
                    OneMinusDstAlphaFactor: () => SE,
                    OneMinusDstColorFactor: () => TE,
                    OneMinusSrcAlphaFactor: () => By,
                    OneMinusSrcColorFactor: () => _E,
                    OrthographicCamera: () => Yu,
                    PCFShadowMap: () => Oy,
                    PCFSoftShadowMap: () => Og,
                    PMREMGenerator: () => ZT,
                    Path: () => ox,
                    PerspectiveCamera: () => hi,
                    Plane: () => Rc,
                    PlaneGeometry: () => ux,
                    PlaneHelper: () => NI,
                    PointLight: () => WC,
                    PointLightHelper: () => TI,
                    Points: () => Zw,
                    PointsMaterial: () => iT,
                    PolarGridHelper: () => wI,
                    PolyhedronGeometry: () => Up,
                    PositionalAudio: () => jP,
                    PropertyBinding: () => li,
                    PropertyMixer: () => c1,
                    QuadraticBezierCurve: () => mT,
                    QuadraticBezierCurve3: () => gT,
                    Quaternion: () => _s,
                    QuaternionKeyframeTrack: () => Mv,
                    QuaternionLinearInterpolant: () => HC,
                    RED_GREEN_RGTC2_Format: () => p_,
                    RED_RGTC1_Format: () => f_,
                    REVISION: () => xc,
                    RGBADepthPacking: () => Fo,
                    RGBAFormat: () => ss,
                    RGBAIntegerFormat: () => Vy,
                    RGBA_ASTC_10x10_Format: () => r_,
                    RGBA_ASTC_10x5_Format: () => i_,
                    RGBA_ASTC_10x6_Format: () => s_,
                    RGBA_ASTC_10x8_Format: () => a_,
                    RGBA_ASTC_12x10_Format: () => o_,
                    RGBA_ASTC_12x12_Format: () => l_,
                    RGBA_ASTC_4x4_Format: () => Qy,
                    RGBA_ASTC_5x4_Format: () => Zy,
                    RGBA_ASTC_5x5_Format: () => Ky,
                    RGBA_ASTC_6x5_Format: () => Jy,
                    RGBA_ASTC_6x6_Format: () => $y,
                    RGBA_ASTC_8x5_Format: () => e_,
                    RGBA_ASTC_8x6_Format: () => t_,
                    RGBA_ASTC_8x8_Format: () => n_,
                    RGBA_BPTC_Format: () => c_,
                    RGBA_ETC2_EAC_Format: () => jy,
                    RGBA_PVRTC_2BPPV1_Format: () => qy,
                    RGBA_PVRTC_4BPPV1_Format: () => Xy,
                    RGBA_S3TC_DXT1_Format: () => kg,
                    RGBA_S3TC_DXT3_Format: () => Xg,
                    RGBA_S3TC_DXT5_Format: () => qg,
                    RGBDepthPacking: () => dU,
                    RGBFormat: () => _A,
                    RGBIntegerFormat: () => cU,
                    RGB_BPTC_SIGNED_Format: () => u_,
                    RGB_BPTC_UNSIGNED_Format: () => h_,
                    RGB_ETC1_Format: () => Yy,
                    RGB_ETC2_Format: () => Wy,
                    RGB_PVRTC_2BPPV1_Format: () => ky,
                    RGB_PVRTC_4BPPV1_Format: () => Gy,
                    RGB_S3TC_DXT1_Format: () => Gg,
                    RGDepthPacking: () => pU,
                    RGFormat: () => Fy,
                    RGIntegerFormat: () => Hy,
                    RawShaderMaterial: () => RC,
                    Ray: () => hf,
                    Raycaster: () => FT,
                    RectAreaLight: () => ZC,
                    RedFormat: () => ap,
                    RedIntegerFormat: () => Vg,
                    ReinhardToneMapping: () => NE,
                    RenderTarget: () => RA,
                    RenderTarget3D: () => lI,
                    RepeatWrapping: () => Uu,
                    ReplaceStencilOp: () => gU,
                    ReverseSubtractEquation: () => dE,
                    RingGeometry: () => _C,
                    SIGNED_RED_GREEN_RGTC2_Format: () => m_,
                    SIGNED_RED_RGTC1_Format: () => d_,
                    SRGBColorSpace: () => $t,
                    SRGBTransfer: () => Wn,
                    Scene: () => bp,
                    ShaderChunk: () => on,
                    ShaderLib: () => Yo,
                    ShaderMaterial: () => Fn,
                    ShadowMaterial: () => CC,
                    Shape: () => gf,
                    ShapeGeometry: () => xC,
                    ShapePath: () => PI,
                    ShapeUtils: () => Dc,
                    ShortType: () => mA,
                    Skeleton: () => Iw,
                    SkeletonHelper: () => AI,
                    SkinnedMesh: () => Bw,
                    Source: () => Pu,
                    Sphere: () => qs,
                    SphereGeometry: () => ST,
                    Spherical: () => px,
                    SphericalHarmonics3: () => KC,
                    SplineCurve: () => vT,
                    SpotLight: () => qC,
                    SpotLightHelper: () => SI,
                    Sprite: () => Ew,
                    SpriteMaterial: () => jA,
                    SrcAlphaFactor: () => Uy,
                    SrcAlphaSaturateFactor: () => ME,
                    SrcColorFactor: () => yE,
                    StaticCopyUsage: () => BU,
                    StaticDrawUsage: () => Qg,
                    StaticReadUsage: () => OU,
                    StereoCamera: () => XP,
                    StreamCopyUsage: () => IU,
                    StreamDrawUsage: () => DU,
                    StreamReadUsage: () => UU,
                    StringKeyframeTrack: () => xf,
                    SubtractEquation: () => fE,
                    SubtractiveBlending: () => cA,
                    TOUCH: () => Jh,
                    TangentSpaceNormalMap: () => Bu,
                    TetrahedronGeometry: () => SC,
                    Texture: () => zi,
                    TextureLoader: () => IP,
                    TextureUtils: () => VI,
                    Timer: () => dI,
                    TimestampQuery: () => zU,
                    TorusGeometry: () => AC,
                    TorusKnotGeometry: () => TC,
                    Triangle: () => Hu,
                    TriangleFanDrawMode: () => fU,
                    TriangleStripDrawMode: () => hU,
                    TrianglesDrawMode: () => uU,
                    TubeGeometry: () => MC,
                    UVMapping: () => Py,
                    Uint16BufferAttribute: () => XA,
                    Uint32BufferAttribute: () => qA,
                    Uint8BufferAttribute: () => TB,
                    Uint8ClampedBufferAttribute: () => MB,
                    Uniform: () => Ce,
                    UniformsGroup: () => uI,
                    UniformsLib: () => pt,
                    UniformsUtils: () => gw,
                    UnsignedByteType: () => ui,
                    UnsignedInt101111Type: () => vA,
                    UnsignedInt248Type: () => nf,
                    UnsignedInt5999Type: () => gA,
                    UnsignedIntType: () => Il,
                    UnsignedShort4444Type: () => Ly,
                    UnsignedShort5551Type: () => zy,
                    UnsignedShortType: () => ip,
                    VSMShadowMap: () => Lo,
                    Vector2: () => ye,
                    Vector3: () => Q,
                    Vector4: () => gn,
                    VectorKeyframeTrack: () => bv,
                    VideoFrameTexture: () => WB,
                    VideoTexture: () => Jw,
                    WebGL3DRenderTarget: () => uB,
                    WebGLArrayRenderTarget: () => cB,
                    WebGLCoordinateSystem: () => br,
                    WebGLCubeRenderTarget: () => xw,
                    WebGLRenderTarget: () => Un,
                    WebGLRenderer: () => K1,
                    WebGLUtils: () => Z1,
                    WebGPUCoordinateSystem: () => rp,
                    WebXRController: () => L_,
                    WireframeGeometry: () => bC,
                    WrapAroundEnding: () => Wg,
                    ZeroCurvatureEnding: () => af,
                    ZeroFactor: () => gE,
                    ZeroSlopeEnding: () => rf,
                    ZeroStencilOp: () => mU,
                    createCanvasElement: () => JE
                });
                function A1() {
                    let e = null
                      , t = !1
                      , n = null
                      , i = null;
                    function s(r, l) {
                        n(r, l),
                        i = e.requestAnimationFrame(s)
                    }
                    return {
                        start: function() {
                            t !== !0 && n !== null && (i = e.requestAnimationFrame(s),
                            t = !0)
                        },
                        stop: function() {
                            e.cancelAnimationFrame(i),
                            t = !1
                        },
                        setAnimationLoop: function(r) {
                            n = r
                        },
                        setContext: function(r) {
                            e = r
                        }
                    }
                }
                function kI(e) {
                    const t = new WeakMap;
                    function n(h, d) {
                        const p = h.array
                          , m = h.usage
                          , v = p.byteLength
                          , _ = e.createBuffer();
                        e.bindBuffer(d, _),
                        e.bufferData(d, p, m),
                        h.onUploadCallback();
                        let x;
                        if (p instanceof Float32Array)
                            x = e.FLOAT;
                        else if (typeof Float16Array < "u" && p instanceof Float16Array)
                            x = e.HALF_FLOAT;
                        else if (p instanceof Uint16Array)
                            h.isFloat16BufferAttribute ? x = e.HALF_FLOAT : x = e.UNSIGNED_SHORT;
                        else if (p instanceof Int16Array)
                            x = e.SHORT;
                        else if (p instanceof Uint32Array)
                            x = e.UNSIGNED_INT;
                        else if (p instanceof Int32Array)
                            x = e.INT;
                        else if (p instanceof Int8Array)
                            x = e.BYTE;
                        else if (p instanceof Uint8Array)
                            x = e.UNSIGNED_BYTE;
                        else if (p instanceof Uint8ClampedArray)
                            x = e.UNSIGNED_BYTE;
                        else
                            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + p);
                        return {
                            buffer: _,
                            type: x,
                            bytesPerElement: p.BYTES_PER_ELEMENT,
                            version: h.version,
                            size: v
                        }
                    }
                    function i(h, d, p) {
                        const m = d.array
                          , v = d.updateRanges;
                        if (e.bindBuffer(p, h),
                        v.length === 0)
                            e.bufferSubData(p, 0, m);
                        else {
                            v.sort( (x, b) => x.start - b.start);
                            let _ = 0;
                            for (let x = 1; x < v.length; x++) {
                                const b = v[_]
                                  , E = v[x];
                                E.start <= b.start + b.count + 1 ? b.count = Math.max(b.count, E.start + E.count - b.start) : (++_,
                                v[_] = E)
                            }
                            v.length = _ + 1;
                            for (let x = 0, b = v.length; x < b; x++) {
                                const E = v[x];
                                e.bufferSubData(p, E.start * m.BYTES_PER_ELEMENT, m, E.start, E.count)
                            }
                            d.clearUpdateRanges()
                        }
                        d.onUploadCallback()
                    }
                    function s(h) {
                        return h.isInterleavedBufferAttribute && (h = h.data),
                        t.get(h)
                    }
                    function r(h) {
                        h.isInterleavedBufferAttribute && (h = h.data);
                        const d = t.get(h);
                        d && (e.deleteBuffer(d.buffer),
                        t.delete(h))
                    }
                    function l(h, d) {
                        if (h.isInterleavedBufferAttribute && (h = h.data),
                        h.isGLBufferAttribute) {
                            const m = t.get(h);
                            (!m || m.version < h.version) && t.set(h, {
                                buffer: h.buffer,
                                type: h.type,
                                bytesPerElement: h.elementSize,
                                version: h.version
                            });
                            return
                        }
                        const p = t.get(h);
                        if (p === void 0)
                            t.set(h, n(h, d));
                        else if (p.version < h.version) {
                            if (p.size !== h.array.byteLength)
                                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            i(p.buffer, h, d),
                            p.version = h.version
                        }
                    }
                    return {
                        get: s,
                        remove: r,
                        update: l
                    }
                }
                const on = {
                    alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
                    alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
                    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
                    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    alphatest_fragment: `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
                    alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
                    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
                    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
                    batching_pars_vertex: `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
                    batching_vertex: `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
                    begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
                    beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
                    bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
                    iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
                    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
                    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
                    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
                    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
                    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
                    color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
                    color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
                    color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
                    color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
                    common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
                    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
                    defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
                    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
                    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
                    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
                    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
                    envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
                    envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
                    envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
                    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
                    envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
                    envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
                    fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
                    fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
                    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
                    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
                    gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
                    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
                    lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
                    lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
                    lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
                    lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
                    lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
                    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
                    lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
                    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
                    lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
                    lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
                    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
                    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
                    logdepthbuf_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
                    logdepthbuf_pars_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_pars_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
                    map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
                    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
                    map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
                    map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
                    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
                    morphinstance_vertex: `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
                    morphcolor_vertex: `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
                    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
                    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
                    normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
                    normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
                    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
                    clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
                    clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
                    clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
                    iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
                    opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
                    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
                    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
                    project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
                    dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
                    dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
                    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
                    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
                    shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
                    shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
                    shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
                    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
                    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
                    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
                    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
                    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
                    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
                    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
                    tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
                    tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
                    transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
                    transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
                    uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
                    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
                    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                    background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
                    distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                    distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
                    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                    meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
                    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                    meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
                    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
                }
                  , pt = {
                    common: {
                        diffuse: {
                            value: new at(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new rn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new rn
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new rn
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new rn
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new rn
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new rn
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new rn
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new rn
                        },
                        normalScale: {
                            value: new ye(1,1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new rn
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new rn
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new rn
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new rn
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new at(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new at(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new rn
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new rn
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new at(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new ye(.5,.5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new rn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new rn
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                }
                  , Yo = {
                    basic: {
                        uniforms: Ba([pt.common, pt.specularmap, pt.envmap, pt.aomap, pt.lightmap, pt.fog]),
                        vertexShader: on.meshbasic_vert,
                        fragmentShader: on.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Ba([pt.common, pt.specularmap, pt.envmap, pt.aomap, pt.lightmap, pt.emissivemap, pt.bumpmap, pt.normalmap, pt.displacementmap, pt.fog, pt.lights, {
                            emissive: {
                                value: new at(0)
                            }
                        }]),
                        vertexShader: on.meshlambert_vert,
                        fragmentShader: on.meshlambert_frag
                    },
                    phong: {
                        uniforms: Ba([pt.common, pt.specularmap, pt.envmap, pt.aomap, pt.lightmap, pt.emissivemap, pt.bumpmap, pt.normalmap, pt.displacementmap, pt.fog, pt.lights, {
                            emissive: {
                                value: new at(0)
                            },
                            specular: {
                                value: new at(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: on.meshphong_vert,
                        fragmentShader: on.meshphong_frag
                    },
                    standard: {
                        uniforms: Ba([pt.common, pt.envmap, pt.aomap, pt.lightmap, pt.emissivemap, pt.bumpmap, pt.normalmap, pt.displacementmap, pt.roughnessmap, pt.metalnessmap, pt.fog, pt.lights, {
                            emissive: {
                                value: new at(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: on.meshphysical_vert,
                        fragmentShader: on.meshphysical_frag
                    },
                    toon: {
                        uniforms: Ba([pt.common, pt.aomap, pt.lightmap, pt.emissivemap, pt.bumpmap, pt.normalmap, pt.displacementmap, pt.gradientmap, pt.fog, pt.lights, {
                            emissive: {
                                value: new at(0)
                            }
                        }]),
                        vertexShader: on.meshtoon_vert,
                        fragmentShader: on.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Ba([pt.common, pt.bumpmap, pt.normalmap, pt.displacementmap, pt.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: on.meshmatcap_vert,
                        fragmentShader: on.meshmatcap_frag
                    },
                    points: {
                        uniforms: Ba([pt.points, pt.fog]),
                        vertexShader: on.points_vert,
                        fragmentShader: on.points_frag
                    },
                    dashed: {
                        uniforms: Ba([pt.common, pt.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: on.linedashed_vert,
                        fragmentShader: on.linedashed_frag
                    },
                    depth: {
                        uniforms: Ba([pt.common, pt.displacementmap]),
                        vertexShader: on.depth_vert,
                        fragmentShader: on.depth_frag
                    },
                    normal: {
                        uniforms: Ba([pt.common, pt.bumpmap, pt.normalmap, pt.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: on.meshnormal_vert,
                        fragmentShader: on.meshnormal_frag
                    },
                    sprite: {
                        uniforms: Ba([pt.sprite, pt.fog]),
                        vertexShader: on.sprite_vert,
                        fragmentShader: on.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new rn
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: on.background_vert,
                        fragmentShader: on.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new rn
                            }
                        },
                        vertexShader: on.backgroundCube_vert,
                        fragmentShader: on.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: on.cube_vert,
                        fragmentShader: on.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: on.equirect_vert,
                        fragmentShader: on.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Ba([pt.common, pt.displacementmap, {
                            referencePosition: {
                                value: new Q
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: on.distanceRGBA_vert,
                        fragmentShader: on.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Ba([pt.lights, pt.fog, {
                            color: {
                                value: new at(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: on.shadow_vert,
                        fragmentShader: on.shadow_frag
                    }
                };
                Yo.physical = {
                    uniforms: Ba([Yo.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatMapTransform: {
                            value: new rn
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        clearcoatNormalMapTransform: {
                            value: new rn
                        },
                        clearcoatNormalScale: {
                            value: new ye(1,1)
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatRoughnessMapTransform: {
                            value: new rn
                        },
                        dispersion: {
                            value: 0
                        },
                        iridescence: {
                            value: 0
                        },
                        iridescenceMap: {
                            value: null
                        },
                        iridescenceMapTransform: {
                            value: new rn
                        },
                        iridescenceIOR: {
                            value: 1.3
                        },
                        iridescenceThicknessMinimum: {
                            value: 100
                        },
                        iridescenceThicknessMaximum: {
                            value: 400
                        },
                        iridescenceThicknessMap: {
                            value: null
                        },
                        iridescenceThicknessMapTransform: {
                            value: new rn
                        },
                        sheen: {
                            value: 0
                        },
                        sheenColor: {
                            value: new at(0)
                        },
                        sheenColorMap: {
                            value: null
                        },
                        sheenColorMapTransform: {
                            value: new rn
                        },
                        sheenRoughness: {
                            value: 1
                        },
                        sheenRoughnessMap: {
                            value: null
                        },
                        sheenRoughnessMapTransform: {
                            value: new rn
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionMapTransform: {
                            value: new rn
                        },
                        transmissionSamplerSize: {
                            value: new ye
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        thicknessMapTransform: {
                            value: new rn
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new at(0)
                        },
                        specularColor: {
                            value: new at(1,1,1)
                        },
                        specularColorMap: {
                            value: null
                        },
                        specularColorMapTransform: {
                            value: new rn
                        },
                        specularIntensity: {
                            value: 1
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularIntensityMapTransform: {
                            value: new rn
                        },
                        anisotropyVector: {
                            value: new ye
                        },
                        anisotropyMap: {
                            value: null
                        },
                        anisotropyMapTransform: {
                            value: new rn
                        }
                    }]),
                    vertexShader: on.meshphysical_vert,
                    fragmentShader: on.meshphysical_frag
                };
                const Sx = {
                    r: 0,
                    b: 0,
                    g: 0
                }
                  , wf = new io
                  , XI = new Xt;
                function qI(e, t, n, i, s, r, l) {
                    const h = new at(0);
                    let d = r === !0 ? 0 : 1, p, m, v = null, _ = 0, x = null;
                    function b(R) {
                        let O = R.isScene === !0 ? R.background : null;
                        return O && O.isTexture && (O = (R.backgroundBlurriness > 0 ? n : t).get(O)),
                        O
                    }
                    function E(R) {
                        let O = !1;
                        const U = b(R);
                        U === null ? M(h, d) : U && U.isColor && (M(U, 1),
                        O = !0);
                        const B = e.xr.getEnvironmentBlendMode();
                        B === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, l) : B === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, l),
                        (e.autoClear || O) && (i.buffers.depth.setTest(!0),
                        i.buffers.depth.setMask(!0),
                        i.buffers.color.setMask(!0),
                        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                    }
                    function T(R, O) {
                        const U = b(O);
                        U && (U.isCubeTexture || U.mapping === tp) ? (m === void 0 && (m = new Fi(new sv(1,1,1),new Fn({
                            name: "BackgroundCubeMaterial",
                            uniforms: Sp(Yo.backgroundCube.uniforms),
                            vertexShader: Yo.backgroundCube.vertexShader,
                            fragmentShader: Yo.backgroundCube.fragmentShader,
                            side: ys,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        m.geometry.deleteAttribute("normal"),
                        m.geometry.deleteAttribute("uv"),
                        m.onBeforeRender = function(B, I, F) {
                            this.matrixWorld.copyPosition(F.matrixWorld)
                        }
                        ,
                        Object.defineProperty(m.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        s.update(m)),
                        wf.copy(O.backgroundRotation),
                        wf.x *= -1,
                        wf.y *= -1,
                        wf.z *= -1,
                        U.isCubeTexture && U.isRenderTargetTexture === !1 && (wf.y *= -1,
                        wf.z *= -1),
                        m.material.uniforms.envMap.value = U,
                        m.material.uniforms.flipEnvMap.value = U.isCubeTexture && U.isRenderTargetTexture === !1 ? -1 : 1,
                        m.material.uniforms.backgroundBlurriness.value = O.backgroundBlurriness,
                        m.material.uniforms.backgroundIntensity.value = O.backgroundIntensity,
                        m.material.uniforms.backgroundRotation.value.setFromMatrix4(XI.makeRotationFromEuler(wf)),
                        m.material.toneMapped = An.getTransfer(U.colorSpace) !== Wn,
                        (v !== U || _ !== U.version || x !== e.toneMapping) && (m.material.needsUpdate = !0,
                        v = U,
                        _ = U.version,
                        x = e.toneMapping),
                        m.layers.enableAll(),
                        R.unshift(m, m.geometry, m.material, 0, 0, null)) : U && U.isTexture && (p === void 0 && (p = new Fi(new ux(2,2),new Fn({
                            name: "BackgroundMaterial",
                            uniforms: Sp(Yo.background.uniforms),
                            vertexShader: Yo.background.vertexShader,
                            fragmentShader: Yo.background.fragmentShader,
                            side: Bl,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        p.geometry.deleteAttribute("normal"),
                        Object.defineProperty(p.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        s.update(p)),
                        p.material.uniforms.t2D.value = U,
                        p.material.uniforms.backgroundIntensity.value = O.backgroundIntensity,
                        p.material.toneMapped = An.getTransfer(U.colorSpace) !== Wn,
                        U.matrixAutoUpdate === !0 && U.updateMatrix(),
                        p.material.uniforms.uvTransform.value.copy(U.matrix),
                        (v !== U || _ !== U.version || x !== e.toneMapping) && (p.material.needsUpdate = !0,
                        v = U,
                        _ = U.version,
                        x = e.toneMapping),
                        p.layers.enableAll(),
                        R.unshift(p, p.geometry, p.material, 0, 0, null))
                    }
                    function M(R, O) {
                        R.getRGB(Sx, mw(e)),
                        i.buffers.color.setClear(Sx.r, Sx.g, Sx.b, O, l)
                    }
                    function D() {
                        m !== void 0 && (m.geometry.dispose(),
                        m.material.dispose(),
                        m = void 0),
                        p !== void 0 && (p.geometry.dispose(),
                        p.material.dispose(),
                        p = void 0)
                    }
                    return {
                        getClearColor: function() {
                            return h
                        },
                        setClearColor: function(R, O=1) {
                            h.set(R),
                            d = O,
                            M(h, d)
                        },
                        getClearAlpha: function() {
                            return d
                        },
                        setClearAlpha: function(R) {
                            d = R,
                            M(h, d)
                        },
                        render: E,
                        addToRenderList: T,
                        dispose: D
                    }
                }
                function YI(e, t) {
                    const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                      , i = {}
                      , s = _(null);
                    let r = s
                      , l = !1;
                    function h(L, H, Z, K, te) {
                        let ce = !1;
                        const G = v(K, Z, H);
                        r !== G && (r = G,
                        p(r.object)),
                        ce = x(L, K, Z, te),
                        ce && b(L, K, Z, te),
                        te !== null && t.update(te, e.ELEMENT_ARRAY_BUFFER),
                        (ce || l) && (l = !1,
                        O(L, H, Z, K),
                        te !== null && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(te).buffer))
                    }
                    function d() {
                        return e.createVertexArray()
                    }
                    function p(L) {
                        return e.bindVertexArray(L)
                    }
                    function m(L) {
                        return e.deleteVertexArray(L)
                    }
                    function v(L, H, Z) {
                        const K = Z.wireframe === !0;
                        let te = i[L.id];
                        te === void 0 && (te = {},
                        i[L.id] = te);
                        let ce = te[H.id];
                        ce === void 0 && (ce = {},
                        te[H.id] = ce);
                        let G = ce[K];
                        return G === void 0 && (G = _(d()),
                        ce[K] = G),
                        G
                    }
                    function _(L) {
                        const H = []
                          , Z = []
                          , K = [];
                        for (let te = 0; te < n; te++)
                            H[te] = 0,
                            Z[te] = 0,
                            K[te] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: H,
                            enabledAttributes: Z,
                            attributeDivisors: K,
                            object: L,
                            attributes: {},
                            index: null
                        }
                    }
                    function x(L, H, Z, K) {
                        const te = r.attributes
                          , ce = H.attributes;
                        let G = 0;
                        const V = Z.getAttributes();
                        for (const q in V)
                            if (V[q].location >= 0) {
                                const ee = te[q];
                                let se = ce[q];
                                if (se === void 0 && (q === "instanceMatrix" && L.instanceMatrix && (se = L.instanceMatrix),
                                q === "instanceColor" && L.instanceColor && (se = L.instanceColor)),
                                ee === void 0 || ee.attribute !== se || se && ee.data !== se.data)
                                    return !0;
                                G++
                            }
                        return r.attributesNum !== G || r.index !== K
                    }
                    function b(L, H, Z, K) {
                        const te = {}
                          , ce = H.attributes;
                        let G = 0;
                        const V = Z.getAttributes();
                        for (const q in V)
                            if (V[q].location >= 0) {
                                let ee = ce[q];
                                ee === void 0 && (q === "instanceMatrix" && L.instanceMatrix && (ee = L.instanceMatrix),
                                q === "instanceColor" && L.instanceColor && (ee = L.instanceColor));
                                const se = {};
                                se.attribute = ee,
                                ee && ee.data && (se.data = ee.data),
                                te[q] = se,
                                G++
                            }
                        r.attributes = te,
                        r.attributesNum = G,
                        r.index = K
                    }
                    function E() {
                        const L = r.newAttributes;
                        for (let H = 0, Z = L.length; H < Z; H++)
                            L[H] = 0
                    }
                    function T(L) {
                        M(L, 0)
                    }
                    function M(L, H) {
                        const Z = r.newAttributes
                          , K = r.enabledAttributes
                          , te = r.attributeDivisors;
                        Z[L] = 1,
                        K[L] === 0 && (e.enableVertexAttribArray(L),
                        K[L] = 1),
                        te[L] !== H && (e.vertexAttribDivisor(L, H),
                        te[L] = H)
                    }
                    function D() {
                        const L = r.newAttributes
                          , H = r.enabledAttributes;
                        for (let Z = 0, K = H.length; Z < K; Z++)
                            H[Z] !== L[Z] && (e.disableVertexAttribArray(Z),
                            H[Z] = 0)
                    }
                    function R(L, H, Z, K, te, ce, G) {
                        G === !0 ? e.vertexAttribIPointer(L, H, Z, te, ce) : e.vertexAttribPointer(L, H, Z, K, te, ce)
                    }
                    function O(L, H, Z, K) {
                        E();
                        const te = K.attributes
                          , ce = Z.getAttributes()
                          , G = H.defaultAttributeValues;
                        for (const V in ce) {
                            const q = ce[V];
                            if (q.location >= 0) {
                                let ee = te[V];
                                if (ee === void 0 && (V === "instanceMatrix" && L.instanceMatrix && (ee = L.instanceMatrix),
                                V === "instanceColor" && L.instanceColor && (ee = L.instanceColor)),
                                ee !== void 0) {
                                    const se = ee.normalized
                                      , X = ee.itemSize
                                      , J = t.get(ee);
                                    if (J === void 0)
                                        continue;
                                    const ze = J.buffer
                                      , xe = J.type
                                      , le = J.bytesPerElement
                                      , Ne = xe === e.INT || xe === e.UNSIGNED_INT || ee.gpuType === Iy;
                                    if (ee.isInterleavedBufferAttribute) {
                                        const be = ee.data
                                          , Ue = be.stride
                                          , $e = ee.offset;
                                        if (be.isInstancedInterleavedBuffer) {
                                            for (let rt = 0; rt < q.locationSize; rt++)
                                                M(q.location + rt, be.meshPerAttribute);
                                            L.isInstancedMesh !== !0 && K._maxInstanceCount === void 0 && (K._maxInstanceCount = be.meshPerAttribute * be.count)
                                        } else
                                            for (let rt = 0; rt < q.locationSize; rt++)
                                                T(q.location + rt);
                                        e.bindBuffer(e.ARRAY_BUFFER, ze);
                                        for (let rt = 0; rt < q.locationSize; rt++)
                                            R(q.location + rt, X / q.locationSize, xe, se, Ue * le, ($e + X / q.locationSize * rt) * le, Ne)
                                    } else {
                                        if (ee.isInstancedBufferAttribute) {
                                            for (let be = 0; be < q.locationSize; be++)
                                                M(q.location + be, ee.meshPerAttribute);
                                            L.isInstancedMesh !== !0 && K._maxInstanceCount === void 0 && (K._maxInstanceCount = ee.meshPerAttribute * ee.count)
                                        } else
                                            for (let be = 0; be < q.locationSize; be++)
                                                T(q.location + be);
                                        e.bindBuffer(e.ARRAY_BUFFER, ze);
                                        for (let be = 0; be < q.locationSize; be++)
                                            R(q.location + be, X / q.locationSize, xe, se, X * le, X / q.locationSize * be * le, Ne)
                                    }
                                } else if (G !== void 0) {
                                    const se = G[V];
                                    if (se !== void 0)
                                        switch (se.length) {
                                        case 2:
                                            e.vertexAttrib2fv(q.location, se);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(q.location, se);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(q.location, se);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(q.location, se)
                                        }
                                }
                            }
                        }
                        D()
                    }
                    function U() {
                        F();
                        for (const L in i) {
                            const H = i[L];
                            for (const Z in H) {
                                const K = H[Z];
                                for (const te in K)
                                    m(K[te].object),
                                    delete K[te];
                                delete H[Z]
                            }
                            delete i[L]
                        }
                    }
                    function B(L) {
                        if (i[L.id] === void 0)
                            return;
                        const H = i[L.id];
                        for (const Z in H) {
                            const K = H[Z];
                            for (const te in K)
                                m(K[te].object),
                                delete K[te];
                            delete H[Z]
                        }
                        delete i[L.id]
                    }
                    function I(L) {
                        for (const H in i) {
                            const Z = i[H];
                            if (Z[L.id] === void 0)
                                continue;
                            const K = Z[L.id];
                            for (const te in K)
                                m(K[te].object),
                                delete K[te];
                            delete Z[L.id]
                        }
                    }
                    function F() {
                        P(),
                        l = !0,
                        r !== s && (r = s,
                        p(r.object))
                    }
                    function P() {
                        s.geometry = null,
                        s.program = null,
                        s.wireframe = !1
                    }
                    return {
                        setup: h,
                        reset: F,
                        resetDefaultState: P,
                        dispose: U,
                        releaseStatesOfGeometry: B,
                        releaseStatesOfProgram: I,
                        initAttributes: E,
                        enableAttribute: T,
                        disableUnusedAttributes: D
                    }
                }
                function WI(e, t, n) {
                    let i;
                    function s(p) {
                        i = p
                    }
                    function r(p, m) {
                        e.drawArrays(i, p, m),
                        n.update(m, i, 1)
                    }
                    function l(p, m, v) {
                        v !== 0 && (e.drawArraysInstanced(i, p, m, v),
                        n.update(m, i, v))
                    }
                    function h(p, m, v) {
                        if (v === 0)
                            return;
                        t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, p, 0, m, 0, v);
                        let _ = 0;
                        for (let x = 0; x < v; x++)
                            _ += m[x];
                        n.update(_, i, 1)
                    }
                    function d(p, m, v, _) {
                        if (v === 0)
                            return;
                        const x = t.get("WEBGL_multi_draw");
                        if (x === null)
                            for (let b = 0; b < p.length; b++)
                                l(p[b], m[b], _[b]);
                        else {
                            x.multiDrawArraysInstancedWEBGL(i, p, 0, m, 0, _, 0, v);
                            let b = 0;
                            for (let E = 0; E < v; E++)
                                b += m[E] * _[E];
                            n.update(b, i, 1)
                        }
                    }
                    this.setMode = s,
                    this.render = r,
                    this.renderInstances = l,
                    this.renderMultiDraw = h,
                    this.renderMultiDrawInstances = d
                }
                function jI(e, t, n, i) {
                    let s;
                    function r() {
                        if (s !== void 0)
                            return s;
                        if (t.has("EXT_texture_filter_anisotropic") === !0) {
                            const I = t.get("EXT_texture_filter_anisotropic");
                            s = e.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else
                            s = 0;
                        return s
                    }
                    function l(I) {
                        return !(I !== ss && i.convert(I) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT))
                    }
                    function h(I) {
                        const F = I === tf && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                        return !(I !== ui && i.convert(I) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && I !== Xs && !F)
                    }
                    function d(I) {
                        if (I === "highp") {
                            if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                                return "highp";
                            I = "mediump"
                        }
                        return I === "mediump" && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                    }
                    let p = n.precision !== void 0 ? n.precision : "highp";
                    const m = d(p);
                    m !== p && (console.warn("THREE.WebGLRenderer:", p, "not supported, using", m, "instead."),
                    p = m);
                    const v = n.logarithmicDepthBuffer === !0
                      , _ = n.reversedDepthBuffer === !0 && t.has("EXT_clip_control")
                      , x = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
                      , b = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                      , E = e.getParameter(e.MAX_TEXTURE_SIZE)
                      , T = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
                      , M = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                      , D = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
                      , R = e.getParameter(e.MAX_VARYING_VECTORS)
                      , O = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
                      , U = b > 0
                      , B = e.getParameter(e.MAX_SAMPLES);
                    return {
                        isWebGL2: !0,
                        getMaxAnisotropy: r,
                        getMaxPrecision: d,
                        textureFormatReadable: l,
                        textureTypeReadable: h,
                        precision: p,
                        logarithmicDepthBuffer: v,
                        reversedDepthBuffer: _,
                        maxTextures: x,
                        maxVertexTextures: b,
                        maxTextureSize: E,
                        maxCubemapSize: T,
                        maxAttributes: M,
                        maxVertexUniforms: D,
                        maxVaryings: R,
                        maxFragmentUniforms: O,
                        vertexTextures: U,
                        maxSamples: B
                    }
                }
                function QI(e) {
                    const t = this;
                    let n = null
                      , i = 0
                      , s = !1
                      , r = !1;
                    const l = new Rc
                      , h = new rn
                      , d = {
                        value: null,
                        needsUpdate: !1
                    };
                    this.uniform = d,
                    this.numPlanes = 0,
                    this.numIntersection = 0,
                    this.init = function(v, _) {
                        const x = v.length !== 0 || _ || i !== 0 || s;
                        return s = _,
                        i = v.length,
                        x
                    }
                    ,
                    this.beginShadows = function() {
                        r = !0,
                        m(null)
                    }
                    ,
                    this.endShadows = function() {
                        r = !1
                    }
                    ,
                    this.setGlobalState = function(v, _) {
                        n = m(v, _, 0)
                    }
                    ,
                    this.setState = function(v, _, x) {
                        const b = v.clippingPlanes
                          , E = v.clipIntersection
                          , T = v.clipShadows
                          , M = e.get(v);
                        if (!s || b === null || b.length === 0 || r && !T)
                            r ? m(null) : p();
                        else {
                            const D = r ? 0 : i
                              , R = D * 4;
                            let O = M.clippingState || null;
                            d.value = O,
                            O = m(b, _, R, x);
                            for (let U = 0; U !== R; ++U)
                                O[U] = n[U];
                            M.clippingState = O,
                            this.numIntersection = E ? this.numPlanes : 0,
                            this.numPlanes += D
                        }
                    }
                    ;
                    function p() {
                        d.value !== n && (d.value = n,
                        d.needsUpdate = i > 0),
                        t.numPlanes = i,
                        t.numIntersection = 0
                    }
                    function m(v, _, x, b) {
                        const E = v !== null ? v.length : 0;
                        let T = null;
                        if (E !== 0) {
                            if (T = d.value,
                            b !== !0 || T === null) {
                                const M = x + E * 4
                                  , D = _.matrixWorldInverse;
                                h.getNormalMatrix(D),
                                (T === null || T.length < M) && (T = new Float32Array(M));
                                for (let R = 0, O = x; R !== E; ++R,
                                O += 4)
                                    l.copy(v[R]).applyMatrix4(D, h),
                                    l.normal.toArray(T, O),
                                    T[O + 3] = l.constant
                            }
                            d.value = T,
                            d.needsUpdate = !0
                        }
                        return t.numPlanes = E,
                        t.numIntersection = 0,
                        T
                    }
                }
                function ZI(e) {
                    let t = new WeakMap;
                    function n(l, h) {
                        return h === Lg ? l.mapping = Sc : h === zg && (l.mapping = Nu),
                        l
                    }
                    function i(l) {
                        if (l && l.isTexture) {
                            const h = l.mapping;
                            if (h === Lg || h === zg)
                                if (t.has(l)) {
                                    const d = t.get(l).texture;
                                    return n(d, l.mapping)
                                } else {
                                    const d = l.image;
                                    if (d && d.height > 0) {
                                        const p = new xw(d.height);
                                        return p.fromEquirectangularTexture(e, l),
                                        t.set(l, p),
                                        l.addEventListener("dispose", s),
                                        n(p.texture, l.mapping)
                                    } else
                                        return null
                                }
                        }
                        return l
                    }
                    function s(l) {
                        const h = l.target;
                        h.removeEventListener("dispose", s);
                        const d = t.get(h);
                        d !== void 0 && (t.delete(h),
                        d.dispose())
                    }
                    function r() {
                        t = new WeakMap
                    }
                    return {
                        get: i,
                        dispose: r
                    }
                }
                const zp = 4
                  , T1 = [.125, .215, .35, .446, .526, .582]
                  , Cf = 20
                  , qT = new Yu
                  , M1 = new at;
                let YT = null
                  , WT = 0
                  , jT = 0
                  , QT = !1;
                const Rf = (1 + Math.sqrt(5)) / 2
                  , Fp = 1 / Rf
                  , b1 = [new Q(-Rf,Fp,0), new Q(Rf,Fp,0), new Q(-Fp,0,Rf), new Q(Fp,0,Rf), new Q(0,Rf,-Fp), new Q(0,Rf,Fp), new Q(-1,1,-1), new Q(1,1,-1), new Q(-1,1,1), new Q(1,1,1)]
                  , KI = new Q;
                var ZT = class {
                    constructor(e) {
                        this._renderer = e,
                        this._pingPongRenderTarget = null,
                        this._lodMax = 0,
                        this._cubeSize = 0,
                        this._lodPlanes = [],
                        this._sizeLods = [],
                        this._sigmas = [],
                        this._blurMaterial = null,
                        this._cubemapMaterial = null,
                        this._equirectMaterial = null,
                        this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(e, t=0, n=.1, i=100, s={}) {
                        const {size: r=256, position: l=KI} = s;
                        YT = this._renderer.getRenderTarget(),
                        WT = this._renderer.getActiveCubeFace(),
                        jT = this._renderer.getActiveMipmapLevel(),
                        QT = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1,
                        this._setSize(r);
                        const h = this._allocateTargets();
                        return h.depthBuffer = !0,
                        this._sceneToCubeUV(e, n, i, h, l),
                        t > 0 && this._blur(h, 0, 0, t),
                        this._applyPMREM(h),
                        this._cleanup(h),
                        h
                    }
                    fromEquirectangular(e, t=null) {
                        return this._fromTexture(e, t)
                    }
                    fromCubemap(e, t=null) {
                        return this._fromTexture(e, t)
                    }
                    compileCubemapShader() {
                        this._cubemapMaterial === null && (this._cubemapMaterial = C1(),
                        this._compileMaterial(this._cubemapMaterial))
                    }
                    compileEquirectangularShader() {
                        this._equirectMaterial === null && (this._equirectMaterial = w1(),
                        this._compileMaterial(this._equirectMaterial))
                    }
                    dispose() {
                        this._dispose(),
                        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                        this._equirectMaterial !== null && this._equirectMaterial.dispose()
                    }
                    _setSize(e) {
                        this._lodMax = Math.floor(Math.log2(e)),
                        this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        this._blurMaterial !== null && this._blurMaterial.dispose(),
                        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                        for (let e = 0; e < this._lodPlanes.length; e++)
                            this._lodPlanes[e].dispose()
                    }
                    _cleanup(e) {
                        this._renderer.setRenderTarget(YT, WT, jT),
                        this._renderer.xr.enabled = QT,
                        e.scissorTest = !1,
                        Ax(e, 0, 0, e.width, e.height)
                    }
                    _fromTexture(e, t) {
                        e.mapping === Sc || e.mapping === Nu ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                        YT = this._renderer.getRenderTarget(),
                        WT = this._renderer.getActiveCubeFace(),
                        jT = this._renderer.getActiveMipmapLevel(),
                        QT = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1;
                        const n = t || this._allocateTargets();
                        return this._textureToCubeUV(e, n),
                        this._applyPMREM(n),
                        this._cleanup(n),
                        n
                    }
                    _allocateTargets() {
                        const e = 3 * Math.max(this._cubeSize, 112)
                          , t = 4 * this._cubeSize
                          , n = {
                            magFilter: mi,
                            minFilter: mi,
                            generateMipmaps: !1,
                            type: tf,
                            format: ss,
                            colorSpace: Ll,
                            depthBuffer: !1
                        }
                          , i = E1(e, t, n);
                        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                            this._pingPongRenderTarget !== null && this._dispose(),
                            this._pingPongRenderTarget = E1(e, t, n);
                            const {_lodMax: s} = this;
                            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = JI(s)),
                            this._blurMaterial = $I(s, e, t)
                        }
                        return i
                    }
                    _compileMaterial(e) {
                        const t = new Fi(this._lodPlanes[0],e);
                        this._renderer.compile(t, qT)
                    }
                    _sceneToCubeUV(e, t, n, i, s) {
                        const r = new hi(90,1,t,n)
                          , l = [1, -1, 1, 1, 1, 1]
                          , h = [1, 1, 1, -1, -1, -1]
                          , d = this._renderer
                          , p = d.autoClear
                          , m = d.toneMapping;
                        d.getClearColor(M1),
                        d.toneMapping = zo,
                        d.autoClear = !1,
                        d.state.buffers.depth.getReversed() && (d.setRenderTarget(i),
                        d.clearDepth(),
                        d.setRenderTarget(null));
                        const v = new Gu({
                            name: "PMREM.Background",
                            side: ys,
                            depthWrite: !1,
                            depthTest: !1
                        })
                          , _ = new Fi(new sv,v);
                        let x = !1;
                        const b = e.background;
                        b ? b.isColor && (v.color.copy(b),
                        e.background = null,
                        x = !0) : (v.color.copy(M1),
                        x = !0);
                        for (let E = 0; E < 6; E++) {
                            const T = E % 3;
                            T === 0 ? (r.up.set(0, l[E], 0),
                            r.position.set(s.x, s.y, s.z),
                            r.lookAt(s.x + h[E], s.y, s.z)) : T === 1 ? (r.up.set(0, 0, l[E]),
                            r.position.set(s.x, s.y, s.z),
                            r.lookAt(s.x, s.y + h[E], s.z)) : (r.up.set(0, l[E], 0),
                            r.position.set(s.x, s.y, s.z),
                            r.lookAt(s.x, s.y, s.z + h[E]));
                            const M = this._cubeSize;
                            Ax(i, T * M, E > 2 ? M : 0, M, M),
                            d.setRenderTarget(i),
                            x && d.render(_, r),
                            d.render(e, r)
                        }
                        _.geometry.dispose(),
                        _.material.dispose(),
                        d.toneMapping = m,
                        d.autoClear = p,
                        e.background = b
                    }
                    _textureToCubeUV(e, t) {
                        const n = this._renderer
                          , i = e.mapping === Sc || e.mapping === Nu;
                        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = C1()),
                        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = w1());
                        const s = i ? this._cubemapMaterial : this._equirectMaterial
                          , r = new Fi(this._lodPlanes[0],s)
                          , l = s.uniforms;
                        l.envMap.value = e;
                        const h = this._cubeSize;
                        Ax(t, 0, 0, 3 * h, 2 * h),
                        n.setRenderTarget(t),
                        n.render(r, qT)
                    }
                    _applyPMREM(e) {
                        const t = this._renderer
                          , n = t.autoClear;
                        t.autoClear = !1;
                        const i = this._lodPlanes.length;
                        for (let s = 1; s < i; s++) {
                            const r = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
                              , l = b1[(i - s - 1) % b1.length];
                            this._blur(e, s - 1, s, r, l)
                        }
                        t.autoClear = n
                    }
                    _blur(e, t, n, i, s) {
                        const r = this._pingPongRenderTarget;
                        this._halfBlur(e, r, t, n, i, "latitudinal", s),
                        this._halfBlur(r, e, n, n, i, "longitudinal", s)
                    }
                    _halfBlur(e, t, n, i, s, r, l) {
                        const h = this._renderer
                          , d = this._blurMaterial;
                        r !== "latitudinal" && r !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                        const p = 3
                          , m = new Fi(this._lodPlanes[i],d)
                          , v = d.uniforms
                          , _ = this._sizeLods[n] - 1
                          , x = isFinite(s) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * Cf - 1)
                          , b = s / x
                          , E = isFinite(s) ? 1 + Math.floor(p * b) : Cf;
                        E > Cf && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${Cf}`);
                        const T = [];
                        let M = 0;
                        for (let B = 0; B < Cf; ++B) {
                            const I = B / b
                              , F = Math.exp(-I * I / 2);
                            T.push(F),
                            B === 0 ? M += F : B < E && (M += 2 * F)
                        }
                        for (let B = 0; B < T.length; B++)
                            T[B] = T[B] / M;
                        v.envMap.value = e.texture,
                        v.samples.value = E,
                        v.weights.value = T,
                        v.latitudinal.value = r === "latitudinal",
                        l && (v.poleAxis.value = l);
                        const {_lodMax: D} = this;
                        v.dTheta.value = x,
                        v.mipInt.value = D - n;
                        const R = this._sizeLods[i]
                          , O = 3 * R * (i > D - zp ? i - D + zp : 0)
                          , U = 4 * (this._cubeSize - R);
                        Ax(t, O, U, 3 * R, 2 * R),
                        h.setRenderTarget(t),
                        h.render(m, qT)
                    }
                }
                ;
                function JI(e) {
                    const t = []
                      , n = []
                      , i = [];
                    let s = e;
                    const r = e - zp + 1 + T1.length;
                    for (let l = 0; l < r; l++) {
                        const h = Math.pow(2, s);
                        n.push(h);
                        let d = 1 / h;
                        l > e - zp ? d = T1[l - e + zp - 1] : l === 0 && (d = 0),
                        i.push(d);
                        const p = 1 / (h - 2)
                          , m = -p
                          , v = 1 + p
                          , _ = [m, m, v, m, v, v, m, m, v, v, m, v]
                          , x = 6
                          , b = 6
                          , E = 3
                          , T = 2
                          , M = 1
                          , D = new Float32Array(E * b * x)
                          , R = new Float32Array(T * b * x)
                          , O = new Float32Array(M * b * x);
                        for (let B = 0; B < x; B++) {
                            const I = B % 3 * 2 / 3 - 1
                              , F = B > 2 ? 0 : -1
                              , P = [I, F, 0, I + 2 / 3, F, 0, I + 2 / 3, F + 1, 0, I, F, 0, I + 2 / 3, F + 1, 0, I, F + 1, 0];
                            D.set(P, E * b * B),
                            R.set(_, T * b * B);
                            const L = [B, B, B, B, B, B];
                            O.set(L, M * b * B)
                        }
                        const U = new an;
                        U.setAttribute("position", new wn(D,E)),
                        U.setAttribute("uv", new wn(R,T)),
                        U.setAttribute("faceIndex", new wn(O,M)),
                        t.push(U),
                        s > zp && s--
                    }
                    return {
                        lodPlanes: t,
                        sizeLods: n,
                        sigmas: i
                    }
                }
                function E1(e, t, n) {
                    const i = new Un(e,t,n);
                    return i.texture.mapping = tp,
                    i.texture.name = "PMREM.cubeUv",
                    i.scissorTest = !0,
                    i
                }
                function Ax(e, t, n, i, s) {
                    e.viewport.set(t, n, i, s),
                    e.scissor.set(t, n, i, s)
                }
                function $I(e, t, n) {
                    const i = new Float32Array(Cf)
                      , s = new Q(0,1,0);
                    return new Fn({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: Cf,
                            CUBEUV_TEXEL_WIDTH: 1 / t,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${e}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: i
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: s
                            }
                        },
                        vertexShader: KT(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                        blending: oi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function w1() {
                    return new Fn({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            }
                        },
                        vertexShader: KT(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                        blending: oi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function C1() {
                    return new Fn({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            }
                        },
                        vertexShader: KT(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                        blending: oi,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function KT() {
                    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                }
                function eL(e) {
                    let t = new WeakMap
                      , n = null;
                    function i(h) {
                        if (h && h.isTexture) {
                            const d = h.mapping
                              , p = d === Lg || d === zg
                              , m = d === Sc || d === Nu;
                            if (p || m) {
                                let v = t.get(h);
                                const _ = v !== void 0 ? v.texture.pmremVersion : 0;
                                if (h.isRenderTargetTexture && h.pmremVersion !== _)
                                    return n === null && (n = new ZT(e)),
                                    v = p ? n.fromEquirectangular(h, v) : n.fromCubemap(h, v),
                                    v.texture.pmremVersion = h.pmremVersion,
                                    t.set(h, v),
                                    v.texture;
                                if (v !== void 0)
                                    return v.texture;
                                {
                                    const x = h.image;
                                    return p && x && x.height > 0 || m && x && s(x) ? (n === null && (n = new ZT(e)),
                                    v = p ? n.fromEquirectangular(h) : n.fromCubemap(h),
                                    v.texture.pmremVersion = h.pmremVersion,
                                    t.set(h, v),
                                    h.addEventListener("dispose", r),
                                    v.texture) : null
                                }
                            }
                        }
                        return h
                    }
                    function s(h) {
                        let d = 0;
                        const p = 6;
                        for (let m = 0; m < p; m++)
                            h[m] !== void 0 && d++;
                        return d === p
                    }
                    function r(h) {
                        const d = h.target;
                        d.removeEventListener("dispose", r);
                        const p = t.get(d);
                        p !== void 0 && (t.delete(d),
                        p.dispose())
                    }
                    function l() {
                        t = new WeakMap,
                        n !== null && (n.dispose(),
                        n = null)
                    }
                    return {
                        get: i,
                        dispose: l
                    }
                }
                function tL(e) {
                    const t = {};
                    function n(i) {
                        if (t[i] !== void 0)
                            return t[i];
                        let s;
                        switch (i) {
                        case "WEBGL_depth_texture":
                            s = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            s = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            s = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            s = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            s = e.getExtension(i)
                        }
                        return t[i] = s,
                        s
                    }
                    return {
                        has: function(i) {
                            return n(i) !== null
                        },
                        init: function() {
                            n("EXT_color_buffer_float"),
                            n("WEBGL_clip_cull_distance"),
                            n("OES_texture_float_linear"),
                            n("EXT_color_buffer_half_float"),
                            n("WEBGL_multisampled_render_to_texture"),
                            n("WEBGL_render_shared_exponent")
                        },
                        get: function(i) {
                            const s = n(i);
                            return s === null && Jg("THREE.WebGLRenderer: " + i + " extension not supported."),
                            s
                        }
                    }
                }
                function nL(e, t, n, i) {
                    const s = {}
                      , r = new WeakMap;
                    function l(v) {
                        const _ = v.target;
                        _.index !== null && t.remove(_.index);
                        for (const b in _.attributes)
                            t.remove(_.attributes[b]);
                        _.removeEventListener("dispose", l),
                        delete s[_.id];
                        const x = r.get(_);
                        x && (t.remove(x),
                        r.delete(_)),
                        i.releaseStatesOfGeometry(_),
                        _.isInstancedBufferGeometry === !0 && delete _._maxInstanceCount,
                        n.memory.geometries--
                    }
                    function h(v, _) {
                        return s[_.id] === !0 || (_.addEventListener("dispose", l),
                        s[_.id] = !0,
                        n.memory.geometries++),
                        _
                    }
                    function d(v) {
                        const _ = v.attributes;
                        for (const x in _)
                            t.update(_[x], e.ARRAY_BUFFER)
                    }
                    function p(v) {
                        const _ = []
                          , x = v.index
                          , b = v.attributes.position;
                        let E = 0;
                        if (x !== null) {
                            const D = x.array;
                            E = x.version;
                            for (let R = 0, O = D.length; R < O; R += 3) {
                                const U = D[R + 0]
                                  , B = D[R + 1]
                                  , I = D[R + 2];
                                _.push(U, B, B, I, I, U)
                            }
                        } else if (b !== void 0) {
                            const D = b.array;
                            E = b.version;
                            for (let R = 0, O = D.length / 3 - 1; R < O; R += 3) {
                                const U = R + 0
                                  , B = R + 1
                                  , I = R + 2;
                                _.push(U, B, B, I, I, U)
                            }
                        } else
                            return;
                        const T = new (KE(_) ? qA : XA)(_,1);
                        T.version = E;
                        const M = r.get(v);
                        M && t.remove(M),
                        r.set(v, T)
                    }
                    function m(v) {
                        const _ = r.get(v);
                        if (_) {
                            const x = v.index;
                            x !== null && _.version < x.version && p(v)
                        } else
                            p(v);
                        return r.get(v)
                    }
                    return {
                        get: h,
                        update: d,
                        getWireframeAttribute: m
                    }
                }
                function iL(e, t, n) {
                    let i;
                    function s(_) {
                        i = _
                    }
                    let r, l;
                    function h(_) {
                        r = _.type,
                        l = _.bytesPerElement
                    }
                    function d(_, x) {
                        e.drawElements(i, x, r, _ * l),
                        n.update(x, i, 1)
                    }
                    function p(_, x, b) {
                        b !== 0 && (e.drawElementsInstanced(i, x, r, _ * l, b),
                        n.update(x, i, b))
                    }
                    function m(_, x, b) {
                        if (b === 0)
                            return;
                        t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, x, 0, r, _, 0, b);
                        let E = 0;
                        for (let T = 0; T < b; T++)
                            E += x[T];
                        n.update(E, i, 1)
                    }
                    function v(_, x, b, E) {
                        if (b === 0)
                            return;
                        const T = t.get("WEBGL_multi_draw");
                        if (T === null)
                            for (let M = 0; M < _.length; M++)
                                p(_[M] / l, x[M], E[M]);
                        else {
                            T.multiDrawElementsInstancedWEBGL(i, x, 0, r, _, 0, E, 0, b);
                            let M = 0;
                            for (let D = 0; D < b; D++)
                                M += x[D] * E[D];
                            n.update(M, i, 1)
                        }
                    }
                    this.setMode = s,
                    this.setIndex = h,
                    this.render = d,
                    this.renderInstances = p,
                    this.renderMultiDraw = m,
                    this.renderMultiDrawInstances = v
                }
                function sL(e) {
                    const t = {
                        geometries: 0,
                        textures: 0
                    }
                      , n = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    function i(r, l, h) {
                        switch (n.calls++,
                        l) {
                        case e.TRIANGLES:
                            n.triangles += h * (r / 3);
                            break;
                        case e.LINES:
                            n.lines += h * (r / 2);
                            break;
                        case e.LINE_STRIP:
                            n.lines += h * (r - 1);
                            break;
                        case e.LINE_LOOP:
                            n.lines += h * r;
                            break;
                        case e.POINTS:
                            n.points += h * r;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", l);
                            break
                        }
                    }
                    function s() {
                        n.calls = 0,
                        n.triangles = 0,
                        n.points = 0,
                        n.lines = 0
                    }
                    return {
                        memory: t,
                        render: n,
                        programs: null,
                        autoReset: !0,
                        reset: s,
                        update: i
                    }
                }
                function aL(e, t, n) {
                    const i = new WeakMap
                      , s = new gn;
                    function r(l, h, d) {
                        const p = l.morphTargetInfluences
                          , m = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
                          , v = m !== void 0 ? m.length : 0;
                        let _ = i.get(h);
                        if (_ === void 0 || _.count !== v) {
                            let L = function() {
                                F.dispose(),
                                i.delete(h),
                                h.removeEventListener("dispose", L)
                            };
                            var x = L;
                            _ !== void 0 && _.texture.dispose();
                            const b = h.morphAttributes.position !== void 0
                              , E = h.morphAttributes.normal !== void 0
                              , T = h.morphAttributes.color !== void 0
                              , M = h.morphAttributes.position || []
                              , D = h.morphAttributes.normal || []
                              , R = h.morphAttributes.color || [];
                            let O = 0;
                            b === !0 && (O = 1),
                            E === !0 && (O = 2),
                            T === !0 && (O = 3);
                            let U = h.attributes.position.count * O
                              , B = 1;
                            U > t.maxTextureSize && (B = Math.ceil(U / t.maxTextureSize),
                            U = t.maxTextureSize);
                            const I = new Float32Array(U * B * 4 * v)
                              , F = new __(I,U,B,v);
                            F.type = Xs,
                            F.needsUpdate = !0;
                            const P = O * 4;
                            for (let H = 0; H < v; H++) {
                                const Z = M[H]
                                  , K = D[H]
                                  , te = R[H]
                                  , ce = U * B * 4 * H;
                                for (let G = 0; G < Z.count; G++) {
                                    const V = G * P;
                                    b === !0 && (s.fromBufferAttribute(Z, G),
                                    I[ce + V + 0] = s.x,
                                    I[ce + V + 1] = s.y,
                                    I[ce + V + 2] = s.z,
                                    I[ce + V + 3] = 0),
                                    E === !0 && (s.fromBufferAttribute(K, G),
                                    I[ce + V + 4] = s.x,
                                    I[ce + V + 5] = s.y,
                                    I[ce + V + 6] = s.z,
                                    I[ce + V + 7] = 0),
                                    T === !0 && (s.fromBufferAttribute(te, G),
                                    I[ce + V + 8] = s.x,
                                    I[ce + V + 9] = s.y,
                                    I[ce + V + 10] = s.z,
                                    I[ce + V + 11] = te.itemSize === 4 ? s.w : 1)
                                }
                            }
                            _ = {
                                count: v,
                                texture: F,
                                size: new ye(U,B)
                            },
                            i.set(h, _),
                            h.addEventListener("dispose", L)
                        }
                        if (l.isInstancedMesh === !0 && l.morphTexture !== null)
                            d.getUniforms().setValue(e, "morphTexture", l.morphTexture, n);
                        else {
                            let b = 0;
                            for (let T = 0; T < p.length; T++)
                                b += p[T];
                            const E = h.morphTargetsRelative ? 1 : 1 - b;
                            d.getUniforms().setValue(e, "morphTargetBaseInfluence", E),
                            d.getUniforms().setValue(e, "morphTargetInfluences", p)
                        }
                        d.getUniforms().setValue(e, "morphTargetsTexture", _.texture, n),
                        d.getUniforms().setValue(e, "morphTargetsTextureSize", _.size)
                    }
                    return {
                        update: r
                    }
                }
                function rL(e, t, n, i) {
                    let s = new WeakMap;
                    function r(d) {
                        const p = i.render.frame
                          , m = d.geometry
                          , v = t.get(d, m);
                        if (s.get(v) !== p && (t.update(v),
                        s.set(v, p)),
                        d.isInstancedMesh && (d.hasEventListener("dispose", h) === !1 && d.addEventListener("dispose", h),
                        s.get(d) !== p && (n.update(d.instanceMatrix, e.ARRAY_BUFFER),
                        d.instanceColor !== null && n.update(d.instanceColor, e.ARRAY_BUFFER),
                        s.set(d, p))),
                        d.isSkinnedMesh) {
                            const _ = d.skeleton;
                            s.get(_) !== p && (_.update(),
                            s.set(_, p))
                        }
                        return v
                    }
                    function l() {
                        s = new WeakMap
                    }
                    function h(d) {
                        const p = d.target;
                        p.removeEventListener("dispose", h),
                        n.remove(p.instanceMatrix),
                        p.instanceColor !== null && n.remove(p.instanceColor)
                    }
                    return {
                        update: r,
                        dispose: l
                    }
                }
                const R1 = new zi
                  , D1 = new mv(1,1)
                  , O1 = new __
                  , N1 = new x_
                  , U1 = new rv
                  , B1 = []
                  , P1 = []
                  , I1 = new Float32Array(16)
                  , L1 = new Float32Array(9)
                  , z1 = new Float32Array(4);
                function Hp(e, t, n) {
                    const i = e[0];
                    if (i <= 0 || i > 0)
                        return e;
                    const s = t * n;
                    let r = B1[s];
                    if (r === void 0 && (r = new Float32Array(s),
                    B1[s] = r),
                    t !== 0) {
                        i.toArray(r, 0);
                        for (let l = 1, h = 0; l !== t; ++l)
                            h += n,
                            e[l].toArray(r, h)
                    }
                    return r
                }
                function xs(e, t) {
                    if (e.length !== t.length)
                        return !1;
                    for (let n = 0, i = e.length; n < i; n++)
                        if (e[n] !== t[n])
                            return !1;
                    return !0
                }
                function Ss(e, t) {
                    for (let n = 0, i = t.length; n < i; n++)
                        e[n] = t[n]
                }
                function Tx(e, t) {
                    let n = P1[t];
                    n === void 0 && (n = new Int32Array(t),
                    P1[t] = n);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e.allocateTextureUnit();
                    return n
                }
                function oL(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1f(this.addr, t),
                    n[0] = t)
                }
                function lL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform2fv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function cL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else if (t.r !== void 0)
                        (n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b),
                        n[0] = t.r,
                        n[1] = t.g,
                        n[2] = t.b);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform3fv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function uL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform4fv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function hL(e, t) {
                    const n = this.cache
                      , i = t.elements;
                    if (i === void 0) {
                        if (xs(n, t))
                            return;
                        e.uniformMatrix2fv(this.addr, !1, t),
                        Ss(n, t)
                    } else {
                        if (xs(n, i))
                            return;
                        z1.set(i),
                        e.uniformMatrix2fv(this.addr, !1, z1),
                        Ss(n, i)
                    }
                }
                function fL(e, t) {
                    const n = this.cache
                      , i = t.elements;
                    if (i === void 0) {
                        if (xs(n, t))
                            return;
                        e.uniformMatrix3fv(this.addr, !1, t),
                        Ss(n, t)
                    } else {
                        if (xs(n, i))
                            return;
                        L1.set(i),
                        e.uniformMatrix3fv(this.addr, !1, L1),
                        Ss(n, i)
                    }
                }
                function dL(e, t) {
                    const n = this.cache
                      , i = t.elements;
                    if (i === void 0) {
                        if (xs(n, t))
                            return;
                        e.uniformMatrix4fv(this.addr, !1, t),
                        Ss(n, t)
                    } else {
                        if (xs(n, i))
                            return;
                        I1.set(i),
                        e.uniformMatrix4fv(this.addr, !1, I1),
                        Ss(n, i)
                    }
                }
                function pL(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1i(this.addr, t),
                    n[0] = t)
                }
                function mL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform2iv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function gL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform3iv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function vL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform4iv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function yL(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1ui(this.addr, t),
                    n[0] = t)
                }
                function _L(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform2uiv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function xL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform3uiv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function SL(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (xs(n, t))
                            return;
                        e.uniform4uiv(this.addr, t),
                        Ss(n, t)
                    }
                }
                function AL(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s);
                    let r;
                    this.type === e.SAMPLER_2D_SHADOW ? (D1.compareFunction = AA,
                    r = D1) : r = R1,
                    n.setTexture2D(t || r, s)
                }
                function TL(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s),
                    n.setTexture3D(t || N1, s)
                }
                function ML(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s),
                    n.setTextureCube(t || U1, s)
                }
                function bL(e, t, n) {
                    const i = this.cache
                      , s = n.allocateTextureUnit();
                    i[0] !== s && (e.uniform1i(this.addr, s),
                    i[0] = s),
                    n.setTexture2DArray(t || O1, s)
                }
                function EL(e) {
                    switch (e) {
                    case 5126:
                        return oL;
                    case 35664:
                        return lL;
                    case 35665:
                        return cL;
                    case 35666:
                        return uL;
                    case 35674:
                        return hL;
                    case 35675:
                        return fL;
                    case 35676:
                        return dL;
                    case 5124:
                    case 35670:
                        return pL;
                    case 35667:
                    case 35671:
                        return mL;
                    case 35668:
                    case 35672:
                        return gL;
                    case 35669:
                    case 35673:
                        return vL;
                    case 5125:
                        return yL;
                    case 36294:
                        return _L;
                    case 36295:
                        return xL;
                    case 36296:
                        return SL;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return AL;
                    case 35679:
                    case 36299:
                    case 36307:
                        return TL;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return ML;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return bL
                    }
                }
                function wL(e, t) {
                    e.uniform1fv(this.addr, t)
                }
                function CL(e, t) {
                    const n = Hp(t, this.size, 2);
                    e.uniform2fv(this.addr, n)
                }
                function RL(e, t) {
                    const n = Hp(t, this.size, 3);
                    e.uniform3fv(this.addr, n)
                }
                function DL(e, t) {
                    const n = Hp(t, this.size, 4);
                    e.uniform4fv(this.addr, n)
                }
                function OL(e, t) {
                    const n = Hp(t, this.size, 4);
                    e.uniformMatrix2fv(this.addr, !1, n)
                }
                function NL(e, t) {
                    const n = Hp(t, this.size, 9);
                    e.uniformMatrix3fv(this.addr, !1, n)
                }
                function UL(e, t) {
                    const n = Hp(t, this.size, 16);
                    e.uniformMatrix4fv(this.addr, !1, n)
                }
                function BL(e, t) {
                    e.uniform1iv(this.addr, t)
                }
                function PL(e, t) {
                    e.uniform2iv(this.addr, t)
                }
                function IL(e, t) {
                    e.uniform3iv(this.addr, t)
                }
                function LL(e, t) {
                    e.uniform4iv(this.addr, t)
                }
                function zL(e, t) {
                    e.uniform1uiv(this.addr, t)
                }
                function FL(e, t) {
                    e.uniform2uiv(this.addr, t)
                }
                function HL(e, t) {
                    e.uniform3uiv(this.addr, t)
                }
                function VL(e, t) {
                    e.uniform4uiv(this.addr, t)
                }
                function GL(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , r = Tx(n, s);
                    xs(i, r) || (e.uniform1iv(this.addr, r),
                    Ss(i, r));
                    for (let l = 0; l !== s; ++l)
                        n.setTexture2D(t[l] || R1, r[l])
                }
                function kL(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , r = Tx(n, s);
                    xs(i, r) || (e.uniform1iv(this.addr, r),
                    Ss(i, r));
                    for (let l = 0; l !== s; ++l)
                        n.setTexture3D(t[l] || N1, r[l])
                }
                function XL(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , r = Tx(n, s);
                    xs(i, r) || (e.uniform1iv(this.addr, r),
                    Ss(i, r));
                    for (let l = 0; l !== s; ++l)
                        n.setTextureCube(t[l] || U1, r[l])
                }
                function qL(e, t, n) {
                    const i = this.cache
                      , s = t.length
                      , r = Tx(n, s);
                    xs(i, r) || (e.uniform1iv(this.addr, r),
                    Ss(i, r));
                    for (let l = 0; l !== s; ++l)
                        n.setTexture2DArray(t[l] || O1, r[l])
                }
                function YL(e) {
                    switch (e) {
                    case 5126:
                        return wL;
                    case 35664:
                        return CL;
                    case 35665:
                        return RL;
                    case 35666:
                        return DL;
                    case 35674:
                        return OL;
                    case 35675:
                        return NL;
                    case 35676:
                        return UL;
                    case 5124:
                    case 35670:
                        return BL;
                    case 35667:
                    case 35671:
                        return PL;
                    case 35668:
                    case 35672:
                        return IL;
                    case 35669:
                    case 35673:
                        return LL;
                    case 5125:
                        return zL;
                    case 36294:
                        return FL;
                    case 36295:
                        return HL;
                    case 36296:
                        return VL;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return GL;
                    case 35679:
                    case 36299:
                    case 36307:
                        return kL;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return XL;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return qL
                    }
                }
                var WL = class {
                    constructor(e, t, n) {
                        this.id = e,
                        this.addr = n,
                        this.cache = [],
                        this.type = t.type,
                        this.setValue = EL(t.type)
                    }
                }
                  , jL = class {
                    constructor(e, t, n) {
                        this.id = e,
                        this.addr = n,
                        this.cache = [],
                        this.type = t.type,
                        this.size = t.size,
                        this.setValue = YL(t.type)
                    }
                }
                  , QL = class {
                    constructor(e) {
                        this.id = e,
                        this.seq = [],
                        this.map = {}
                    }
                    setValue(e, t, n) {
                        const i = this.seq;
                        for (let s = 0, r = i.length; s !== r; ++s) {
                            const l = i[s];
                            l.setValue(e, t[l.id], n)
                        }
                    }
                }
                ;
                const JT = /(\w+)(\])?(\[|\.)?/g;
                function F1(e, t) {
                    e.seq.push(t),
                    e.map[t.id] = t
                }
                function ZL(e, t, n) {
                    const i = e.name
                      , s = i.length;
                    for (JT.lastIndex = 0; ; ) {
                        const r = JT.exec(i)
                          , l = JT.lastIndex;
                        let h = r[1];
                        const d = r[2] === "]"
                          , p = r[3];
                        if (d && (h = h | 0),
                        p === void 0 || p === "[" && l + 2 === s) {
                            F1(n, p === void 0 ? new WL(h,e,t) : new jL(h,e,t));
                            break
                        } else {
                            let m = n.map[h];
                            m === void 0 && (m = new QL(h),
                            F1(n, m)),
                            n = m
                        }
                    }
                }
                var Mx = class {
                    constructor(e, t) {
                        this.seq = [],
                        this.map = {};
                        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                        for (let i = 0; i < n; ++i) {
                            const s = e.getActiveUniform(t, i)
                              , r = e.getUniformLocation(t, s.name);
                            ZL(s, r, this)
                        }
                    }
                    setValue(e, t, n, i) {
                        const s = this.map[t];
                        s !== void 0 && s.setValue(e, n, i)
                    }
                    setOptional(e, t, n) {
                        const i = t[n];
                        i !== void 0 && this.setValue(e, n, i)
                    }
                    static upload(e, t, n, i) {
                        for (let s = 0, r = t.length; s !== r; ++s) {
                            const l = t[s]
                              , h = n[l.id];
                            h.needsUpdate !== !1 && l.setValue(e, h.value, i)
                        }
                    }
                    static seqWithValue(e, t) {
                        const n = [];
                        for (let i = 0, s = e.length; i !== s; ++i) {
                            const r = e[i];
                            r.id in t && n.push(r)
                        }
                        return n
                    }
                }
                ;
                function H1(e, t, n) {
                    const i = e.createShader(t);
                    return e.shaderSource(i, n),
                    e.compileShader(i),
                    i
                }
                const KL = 37297;
                let JL = 0;
                function $L(e, t) {
                    const n = e.split(`
`)
                      , i = []
                      , s = Math.max(t - 6, 0)
                      , r = Math.min(t + 6, n.length);
                    for (let l = s; l < r; l++) {
                        const h = l + 1;
                        i.push(`${h === t ? ">" : " "} ${h}: ${n[l]}`)
                    }
                    return i.join(`
`)
                }
                const V1 = new rn;
                function e4(e) {
                    An._getMatrix(V1, An.workingColorSpace, e);
                    const t = `mat3( ${V1.elements.map(n => n.toFixed(4))} )`;
                    switch (An.getTransfer(e)) {
                    case jg:
                        return [t, "LinearTransferOETF"];
                    case Wn:
                        return [t, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space: ", e),
                        [t, "LinearTransferOETF"]
                    }
                }
                function G1(e, t, n) {
                    const i = e.getShaderParameter(t, e.COMPILE_STATUS)
                      , s = (e.getShaderInfoLog(t) || "").trim();
                    if (i && s === "")
                        return "";
                    const r = /ERROR: 0:(\d+)/.exec(s);
                    if (r) {
                        const l = parseInt(r[1]);
                        return n.toUpperCase() + `

` + s + `

` + $L(e.getShaderSource(t), l)
                    } else
                        return s
                }
                function t4(e, t) {
                    const n = e4(t);
                    return [`vec4 ${e}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
                }
                function n4(e, t) {
                    let n;
                    switch (t) {
                    case OE:
                        n = "Linear";
                        break;
                    case NE:
                        n = "Reinhard";
                        break;
                    case UE:
                        n = "Cineon";
                        break;
                    case hA:
                        n = "ACESFilmic";
                        break;
                    case PE:
                        n = "AgX";
                        break;
                    case IE:
                        n = "Neutral";
                        break;
                    case BE:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                        n = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }
                const bx = new Q;
                function i4() {
                    An.getLuminanceCoefficients(bx);
                    const e = bx.x.toFixed(4)
                      , t = bx.y.toFixed(4)
                      , n = bx.z.toFixed(4);
                    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${e}, ${t}, ${n} );`, "	return dot( weights, rgb );", "}"].join(`
`)
                }
                function s4(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Rv).join(`
`)
                }
                function a4(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        i !== !1 && t.push("#define " + n + " " + i)
                    }
                    return t.join(`
`)
                }
                function r4(e, t) {
                    const n = {}
                      , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let s = 0; s < i; s++) {
                        const r = e.getActiveAttrib(t, s)
                          , l = r.name;
                        let h = 1;
                        r.type === e.FLOAT_MAT2 && (h = 2),
                        r.type === e.FLOAT_MAT3 && (h = 3),
                        r.type === e.FLOAT_MAT4 && (h = 4),
                        n[l] = {
                            type: r.type,
                            location: e.getAttribLocation(t, l),
                            locationSize: h
                        }
                    }
                    return n
                }
                function Rv(e) {
                    return e !== ""
                }
                function k1(e, t) {
                    const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
                }
                function X1(e, t) {
                    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
                }
                const o4 = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function $T(e) {
                    return e.replace(o4, c4)
                }
                const l4 = new Map;
                function c4(e, t) {
                    let n = on[t];
                    if (n === void 0) {
                        const i = l4.get(t);
                        if (i !== void 0)
                            n = on[i],
                            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, i);
                        else
                            throw new Error("Can not resolve #include <" + t + ">")
                    }
                    return $T(n)
                }
                const u4 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function q1(e) {
                    return e.replace(u4, h4)
                }
                function h4(e, t, n, i) {
                    let s = "";
                    for (let r = parseInt(t); r < parseInt(n); r++)
                        s += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
                    return s
                }
                function Y1(e) {
                    let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`;
                    return e.precision === "highp" ? t += `
#define HIGH_PRECISION` : e.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : e.precision === "lowp" && (t += `
#define LOW_PRECISION`),
                    t
                }
                function f4(e) {
                    let t = "SHADOWMAP_TYPE_BASIC";
                    return e.shadowMapType === Oy ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === Og ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === Lo && (t = "SHADOWMAP_TYPE_VSM"),
                    t
                }
                function d4(e) {
                    let t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap)
                        switch (e.envMapMode) {
                        case Sc:
                        case Nu:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case tp:
                            t = "ENVMAP_TYPE_CUBE_UV";
                            break
                        }
                    return t
                }
                function p4(e) {
                    let t = "ENVMAP_MODE_REFLECTION";
                    if (e.envMap)
                        switch (e.envMapMode) {
                        case Nu:
                            t = "ENVMAP_MODE_REFRACTION";
                            break
                        }
                    return t
                }
                function m4(e) {
                    let t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap)
                        switch (e.combine) {
                        case Ig:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case RE:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case DE:
                            t = "ENVMAP_BLENDING_ADD";
                            break
                        }
                    return t
                }
                function g4(e) {
                    const t = e.envMapCubeUVHeight;
                    if (t === null)
                        return null;
                    const n = Math.log2(t) - 2
                      , i = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }
                function v4(e, t, n, i) {
                    const s = e.getContext()
                      , r = n.defines;
                    let l = n.vertexShader
                      , h = n.fragmentShader;
                    const d = f4(n)
                      , p = d4(n)
                      , m = p4(n)
                      , v = m4(n)
                      , _ = g4(n)
                      , x = s4(n)
                      , b = a4(r)
                      , E = s.createProgram();
                    let T, M, D = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
                    n.isRawShaderMaterial ? (T = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b].filter(Rv).join(`
`),
                    T.length > 0 && (T += `
`),
                    M = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b].filter(Rv).join(`
`),
                    M.length > 0 && (M += `
`)) : (T = [Y1(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Rv).join(`
`),
                    M = [Y1(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, b, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + v : "", _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "", _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "", _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== zo ? "#define TONE_MAPPING" : "", n.toneMapping !== zo ? on.tonemapping_pars_fragment : "", n.toneMapping !== zo ? n4("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", on.colorspace_pars_fragment, t4("linearToOutputTexel", n.outputColorSpace), i4(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(Rv).join(`
`)),
                    l = $T(l),
                    l = k1(l, n),
                    l = X1(l, n),
                    h = $T(h),
                    h = k1(h, n),
                    h = X1(h, n),
                    l = q1(l),
                    h = q1(h),
                    n.isRawShaderMaterial !== !0 && (D = `#version 300 es
`,
                    T = [x, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + T,
                    M = ["#define varying in", n.glslVersion === TA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === TA ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + M);
                    const R = D + T + l
                      , O = D + M + h
                      , U = H1(s, s.VERTEX_SHADER, R)
                      , B = H1(s, s.FRAGMENT_SHADER, O);
                    s.attachShader(E, U),
                    s.attachShader(E, B),
                    n.index0AttributeName !== void 0 ? s.bindAttribLocation(E, 0, n.index0AttributeName) : n.morphTargets === !0 && s.bindAttribLocation(E, 0, "position"),
                    s.linkProgram(E);
                    function I(H) {
                        if (e.debug.checkShaderErrors) {
                            const Z = s.getProgramInfoLog(E) || ""
                              , K = s.getShaderInfoLog(U) || ""
                              , te = s.getShaderInfoLog(B) || ""
                              , ce = Z.trim()
                              , G = K.trim()
                              , V = te.trim();
                            let q = !0
                              , ee = !0;
                            if (s.getProgramParameter(E, s.LINK_STATUS) === !1)
                                if (q = !1,
                                typeof e.debug.onShaderError == "function")
                                    e.debug.onShaderError(s, E, U, B);
                                else {
                                    const se = G1(s, U, "vertex")
                                      , X = G1(s, B, "fragment");
                                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(E, s.VALIDATE_STATUS) + `

Material Name: ` + H.name + `
Material Type: ` + H.type + `

Program Info Log: ` + ce + `
` + se + `
` + X)
                                }
                            else
                                ce !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", ce) : (G === "" || V === "") && (ee = !1);
                            ee && (H.diagnostics = {
                                runnable: q,
                                programLog: ce,
                                vertexShader: {
                                    log: G,
                                    prefix: T
                                },
                                fragmentShader: {
                                    log: V,
                                    prefix: M
                                }
                            })
                        }
                        s.deleteShader(U),
                        s.deleteShader(B),
                        F = new Mx(s,E),
                        P = r4(s, E)
                    }
                    let F;
                    this.getUniforms = function() {
                        return F === void 0 && I(this),
                        F
                    }
                    ;
                    let P;
                    this.getAttributes = function() {
                        return P === void 0 && I(this),
                        P
                    }
                    ;
                    let L = n.rendererExtensionParallelShaderCompile === !1;
                    return this.isReady = function() {
                        return L === !1 && (L = s.getProgramParameter(E, KL)),
                        L
                    }
                    ,
                    this.destroy = function() {
                        i.releaseStatesOfProgram(this),
                        s.deleteProgram(E),
                        this.program = void 0
                    }
                    ,
                    this.type = n.shaderType,
                    this.name = n.shaderName,
                    this.id = JL++,
                    this.cacheKey = t,
                    this.usedTimes = 1,
                    this.program = E,
                    this.vertexShader = U,
                    this.fragmentShader = B,
                    this
                }
                let y4 = 0;
                var _4 = class {
                    constructor() {
                        this.shaderCache = new Map,
                        this.materialCache = new Map
                    }
                    update(e) {
                        const t = e.vertexShader
                          , n = e.fragmentShader
                          , i = this._getShaderStage(t)
                          , s = this._getShaderStage(n)
                          , r = this._getShaderCacheForMaterial(e);
                        return r.has(i) === !1 && (r.add(i),
                        i.usedTimes++),
                        r.has(s) === !1 && (r.add(s),
                        s.usedTimes++),
                        this
                    }
                    remove(e) {
                        const t = this.materialCache.get(e);
                        for (const n of t)
                            n.usedTimes--,
                            n.usedTimes === 0 && this.shaderCache.delete(n.code);
                        return this.materialCache.delete(e),
                        this
                    }
                    getVertexShaderID(e) {
                        return this._getShaderStage(e.vertexShader).id
                    }
                    getFragmentShaderID(e) {
                        return this._getShaderStage(e.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear(),
                        this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(e) {
                        const t = this.materialCache;
                        let n = t.get(e);
                        return n === void 0 && (n = new Set,
                        t.set(e, n)),
                        n
                    }
                    _getShaderStage(e) {
                        const t = this.shaderCache;
                        let n = t.get(e);
                        return n === void 0 && (n = new x4(e),
                        t.set(e, n)),
                        n
                    }
                }
                  , x4 = class {
                    constructor(e) {
                        this.id = y4++,
                        this.code = e,
                        this.usedTimes = 0
                    }
                }
                ;
                function S4(e, t, n, i, s, r, l) {
                    const h = new mp
                      , d = new _4
                      , p = new Set
                      , m = []
                      , v = s.logarithmicDepthBuffer
                      , _ = s.vertexTextures;
                    let x = s.precision;
                    const b = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                    function E(P) {
                        return p.add(P),
                        P === 0 ? "uv" : `uv${P}`
                    }
                    function T(P, L, H, Z, K) {
                        const te = Z.fog
                          , ce = K.geometry
                          , G = P.isMeshStandardMaterial ? Z.environment : null
                          , V = (P.isMeshStandardMaterial ? n : t).get(P.envMap || G)
                          , q = V && V.mapping === tp ? V.image.height : null
                          , ee = b[P.type];
                        P.precision !== null && (x = s.getMaxPrecision(P.precision),
                        x !== P.precision && console.warn("THREE.WebGLProgram.getParameters:", P.precision, "not supported, using", x, "instead."));
                        const se = ce.morphAttributes.position || ce.morphAttributes.normal || ce.morphAttributes.color
                          , X = se !== void 0 ? se.length : 0;
                        let J = 0;
                        ce.morphAttributes.position !== void 0 && (J = 1),
                        ce.morphAttributes.normal !== void 0 && (J = 2),
                        ce.morphAttributes.color !== void 0 && (J = 3);
                        let ze, xe, le, Ne;
                        if (ee) {
                            const Zt = Yo[ee];
                            ze = Zt.vertexShader,
                            xe = Zt.fragmentShader
                        } else
                            ze = P.vertexShader,
                            xe = P.fragmentShader,
                            d.update(P),
                            le = d.getVertexShaderID(P),
                            Ne = d.getFragmentShaderID(P);
                        const be = e.getRenderTarget()
                          , Ue = e.state.buffers.depth.getReversed()
                          , $e = K.isInstancedMesh === !0
                          , rt = K.isBatchedMesh === !0
                          , Et = !!P.map
                          , ne = !!P.matcap
                          , Ve = !!V
                          , de = !!P.aoMap
                          , Te = !!P.lightMap
                          , Pe = !!P.bumpMap
                          , Ye = !!P.normalMap
                          , Ie = !!P.displacementMap
                          , Fe = !!P.emissiveMap
                          , xt = !!P.metalnessMap
                          , yt = !!P.roughnessMap
                          , wt = P.anisotropy > 0
                          , $ = P.clearcoat > 0
                          , k = P.dispersion > 0
                          , pe = P.iridescence > 0
                          , Ge = P.sheen > 0
                          , Qe = P.transmission > 0
                          , Be = wt && !!P.anisotropyMap
                          , ct = $ && !!P.clearcoatMap
                          , Ke = $ && !!P.clearcoatNormalMap
                          , _t = $ && !!P.clearcoatRoughnessMap
                          , Ct = pe && !!P.iridescenceMap
                          , et = pe && !!P.iridescenceThicknessMap
                          , st = Ge && !!P.sheenColorMap
                          , ie = Ge && !!P.sheenRoughnessMap
                          , Re = !!P.specularMap
                          , He = !!P.specularColorMap
                          , lt = !!P.specularIntensityMap
                          , ae = Qe && !!P.transmissionMap
                          , ot = Qe && !!P.thicknessMap
                          , tt = !!P.gradientMap
                          , gt = !!P.alphaMap
                          , Je = P.alphaTest > 0
                          , ke = !!P.alphaHash
                          , ht = !!P.extensions;
                        let Mt = zo;
                        P.toneMapped && (be === null || be.isXRRenderTarget === !0) && (Mt = e.toneMapping);
                        const Tn = {
                            shaderID: ee,
                            shaderType: P.type,
                            shaderName: P.name,
                            vertexShader: ze,
                            fragmentShader: xe,
                            defines: P.defines,
                            customVertexShaderID: le,
                            customFragmentShaderID: Ne,
                            isRawShaderMaterial: P.isRawShaderMaterial === !0,
                            glslVersion: P.glslVersion,
                            precision: x,
                            batching: rt,
                            batchingColor: rt && K._colorsTexture !== null,
                            instancing: $e,
                            instancingColor: $e && K.instanceColor !== null,
                            instancingMorph: $e && K.morphTexture !== null,
                            supportsVertexTextures: _,
                            outputColorSpace: be === null ? e.outputColorSpace : be.isXRRenderTarget === !0 ? be.texture.colorSpace : Ll,
                            alphaToCoverage: !!P.alphaToCoverage,
                            map: Et,
                            matcap: ne,
                            envMap: Ve,
                            envMapMode: Ve && V.mapping,
                            envMapCubeUVHeight: q,
                            aoMap: de,
                            lightMap: Te,
                            bumpMap: Pe,
                            normalMap: Ye,
                            displacementMap: _ && Ie,
                            emissiveMap: Fe,
                            normalMapObjectSpace: Ye && P.normalMapType === VE,
                            normalMapTangentSpace: Ye && P.normalMapType === Bu,
                            metalnessMap: xt,
                            roughnessMap: yt,
                            anisotropy: wt,
                            anisotropyMap: Be,
                            clearcoat: $,
                            clearcoatMap: ct,
                            clearcoatNormalMap: Ke,
                            clearcoatRoughnessMap: _t,
                            dispersion: k,
                            iridescence: pe,
                            iridescenceMap: Ct,
                            iridescenceThicknessMap: et,
                            sheen: Ge,
                            sheenColorMap: st,
                            sheenRoughnessMap: ie,
                            specularMap: Re,
                            specularColorMap: He,
                            specularIntensityMap: lt,
                            transmission: Qe,
                            transmissionMap: ae,
                            thicknessMap: ot,
                            gradientMap: tt,
                            opaque: P.transparent === !1 && P.blending === $h && P.alphaToCoverage === !1,
                            alphaMap: gt,
                            alphaTest: Je,
                            alphaHash: ke,
                            combine: P.combine,
                            mapUv: Et && E(P.map.channel),
                            aoMapUv: de && E(P.aoMap.channel),
                            lightMapUv: Te && E(P.lightMap.channel),
                            bumpMapUv: Pe && E(P.bumpMap.channel),
                            normalMapUv: Ye && E(P.normalMap.channel),
                            displacementMapUv: Ie && E(P.displacementMap.channel),
                            emissiveMapUv: Fe && E(P.emissiveMap.channel),
                            metalnessMapUv: xt && E(P.metalnessMap.channel),
                            roughnessMapUv: yt && E(P.roughnessMap.channel),
                            anisotropyMapUv: Be && E(P.anisotropyMap.channel),
                            clearcoatMapUv: ct && E(P.clearcoatMap.channel),
                            clearcoatNormalMapUv: Ke && E(P.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: _t && E(P.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: Ct && E(P.iridescenceMap.channel),
                            iridescenceThicknessMapUv: et && E(P.iridescenceThicknessMap.channel),
                            sheenColorMapUv: st && E(P.sheenColorMap.channel),
                            sheenRoughnessMapUv: ie && E(P.sheenRoughnessMap.channel),
                            specularMapUv: Re && E(P.specularMap.channel),
                            specularColorMapUv: He && E(P.specularColorMap.channel),
                            specularIntensityMapUv: lt && E(P.specularIntensityMap.channel),
                            transmissionMapUv: ae && E(P.transmissionMap.channel),
                            thicknessMapUv: ot && E(P.thicknessMap.channel),
                            alphaMapUv: gt && E(P.alphaMap.channel),
                            vertexTangents: !!ce.attributes.tangent && (Ye || wt),
                            vertexColors: P.vertexColors,
                            vertexAlphas: P.vertexColors === !0 && !!ce.attributes.color && ce.attributes.color.itemSize === 4,
                            pointsUvs: K.isPoints === !0 && !!ce.attributes.uv && (Et || gt),
                            fog: !!te,
                            useFog: P.fog === !0,
                            fogExp2: !!te && te.isFogExp2,
                            flatShading: P.flatShading === !0 && P.wireframe === !1,
                            sizeAttenuation: P.sizeAttenuation === !0,
                            logarithmicDepthBuffer: v,
                            reversedDepthBuffer: Ue,
                            skinning: K.isSkinnedMesh === !0,
                            morphTargets: ce.morphAttributes.position !== void 0,
                            morphNormals: ce.morphAttributes.normal !== void 0,
                            morphColors: ce.morphAttributes.color !== void 0,
                            morphTargetsCount: X,
                            morphTextureStride: J,
                            numDirLights: L.directional.length,
                            numPointLights: L.point.length,
                            numSpotLights: L.spot.length,
                            numSpotLightMaps: L.spotLightMap.length,
                            numRectAreaLights: L.rectArea.length,
                            numHemiLights: L.hemi.length,
                            numDirLightShadows: L.directionalShadowMap.length,
                            numPointLightShadows: L.pointShadowMap.length,
                            numSpotLightShadows: L.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
                            numLightProbes: L.numLightProbes,
                            numClippingPlanes: l.numPlanes,
                            numClipIntersection: l.numIntersection,
                            dithering: P.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && H.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: Mt,
                            decodeVideoTexture: Et && P.map.isVideoTexture === !0 && An.getTransfer(P.map.colorSpace) === Wn,
                            decodeVideoTextureEmissive: Fe && P.emissiveMap.isVideoTexture === !0 && An.getTransfer(P.emissiveMap.colorSpace) === Wn,
                            premultipliedAlpha: P.premultipliedAlpha,
                            doubleSided: P.side === nr,
                            flipSided: P.side === ys,
                            useDepthPacking: P.depthPacking >= 0,
                            depthPacking: P.depthPacking || 0,
                            index0AttributeName: P.index0AttributeName,
                            extensionClipCullDistance: ht && P.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (ht && P.extensions.multiDraw === !0 || rt) && i.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: P.customProgramCacheKey()
                        };
                        return Tn.vertexUv1s = p.has(1),
                        Tn.vertexUv2s = p.has(2),
                        Tn.vertexUv3s = p.has(3),
                        p.clear(),
                        Tn
                    }
                    function M(P) {
                        const L = [];
                        if (P.shaderID ? L.push(P.shaderID) : (L.push(P.customVertexShaderID),
                        L.push(P.customFragmentShaderID)),
                        P.defines !== void 0)
                            for (const H in P.defines)
                                L.push(H),
                                L.push(P.defines[H]);
                        return P.isRawShaderMaterial === !1 && (D(L, P),
                        R(L, P),
                        L.push(e.outputColorSpace)),
                        L.push(P.customProgramCacheKey),
                        L.join()
                    }
                    function D(P, L) {
                        P.push(L.precision),
                        P.push(L.outputColorSpace),
                        P.push(L.envMapMode),
                        P.push(L.envMapCubeUVHeight),
                        P.push(L.mapUv),
                        P.push(L.alphaMapUv),
                        P.push(L.lightMapUv),
                        P.push(L.aoMapUv),
                        P.push(L.bumpMapUv),
                        P.push(L.normalMapUv),
                        P.push(L.displacementMapUv),
                        P.push(L.emissiveMapUv),
                        P.push(L.metalnessMapUv),
                        P.push(L.roughnessMapUv),
                        P.push(L.anisotropyMapUv),
                        P.push(L.clearcoatMapUv),
                        P.push(L.clearcoatNormalMapUv),
                        P.push(L.clearcoatRoughnessMapUv),
                        P.push(L.iridescenceMapUv),
                        P.push(L.iridescenceThicknessMapUv),
                        P.push(L.sheenColorMapUv),
                        P.push(L.sheenRoughnessMapUv),
                        P.push(L.specularMapUv),
                        P.push(L.specularColorMapUv),
                        P.push(L.specularIntensityMapUv),
                        P.push(L.transmissionMapUv),
                        P.push(L.thicknessMapUv),
                        P.push(L.combine),
                        P.push(L.fogExp2),
                        P.push(L.sizeAttenuation),
                        P.push(L.morphTargetsCount),
                        P.push(L.morphAttributeCount),
                        P.push(L.numDirLights),
                        P.push(L.numPointLights),
                        P.push(L.numSpotLights),
                        P.push(L.numSpotLightMaps),
                        P.push(L.numHemiLights),
                        P.push(L.numRectAreaLights),
                        P.push(L.numDirLightShadows),
                        P.push(L.numPointLightShadows),
                        P.push(L.numSpotLightShadows),
                        P.push(L.numSpotLightShadowsWithMaps),
                        P.push(L.numLightProbes),
                        P.push(L.shadowMapType),
                        P.push(L.toneMapping),
                        P.push(L.numClippingPlanes),
                        P.push(L.numClipIntersection),
                        P.push(L.depthPacking)
                    }
                    function R(P, L) {
                        h.disableAll(),
                        L.supportsVertexTextures && h.enable(0),
                        L.instancing && h.enable(1),
                        L.instancingColor && h.enable(2),
                        L.instancingMorph && h.enable(3),
                        L.matcap && h.enable(4),
                        L.envMap && h.enable(5),
                        L.normalMapObjectSpace && h.enable(6),
                        L.normalMapTangentSpace && h.enable(7),
                        L.clearcoat && h.enable(8),
                        L.iridescence && h.enable(9),
                        L.alphaTest && h.enable(10),
                        L.vertexColors && h.enable(11),
                        L.vertexAlphas && h.enable(12),
                        L.vertexUv1s && h.enable(13),
                        L.vertexUv2s && h.enable(14),
                        L.vertexUv3s && h.enable(15),
                        L.vertexTangents && h.enable(16),
                        L.anisotropy && h.enable(17),
                        L.alphaHash && h.enable(18),
                        L.batching && h.enable(19),
                        L.dispersion && h.enable(20),
                        L.batchingColor && h.enable(21),
                        L.gradientMap && h.enable(22),
                        P.push(h.mask),
                        h.disableAll(),
                        L.fog && h.enable(0),
                        L.useFog && h.enable(1),
                        L.flatShading && h.enable(2),
                        L.logarithmicDepthBuffer && h.enable(3),
                        L.reversedDepthBuffer && h.enable(4),
                        L.skinning && h.enable(5),
                        L.morphTargets && h.enable(6),
                        L.morphNormals && h.enable(7),
                        L.morphColors && h.enable(8),
                        L.premultipliedAlpha && h.enable(9),
                        L.shadowMapEnabled && h.enable(10),
                        L.doubleSided && h.enable(11),
                        L.flipSided && h.enable(12),
                        L.useDepthPacking && h.enable(13),
                        L.dithering && h.enable(14),
                        L.transmission && h.enable(15),
                        L.sheen && h.enable(16),
                        L.opaque && h.enable(17),
                        L.pointsUvs && h.enable(18),
                        L.decodeVideoTexture && h.enable(19),
                        L.decodeVideoTextureEmissive && h.enable(20),
                        L.alphaToCoverage && h.enable(21),
                        P.push(h.mask)
                    }
                    function O(P) {
                        const L = b[P.type];
                        let H;
                        if (L) {
                            const Z = Yo[L];
                            H = gw.clone(Z.uniforms)
                        } else
                            H = P.uniforms;
                        return H
                    }
                    function U(P, L) {
                        let H;
                        for (let Z = 0, K = m.length; Z < K; Z++) {
                            const te = m[Z];
                            if (te.cacheKey === L) {
                                H = te,
                                ++H.usedTimes;
                                break
                            }
                        }
                        return H === void 0 && (H = new v4(e,L,P,r),
                        m.push(H)),
                        H
                    }
                    function B(P) {
                        if (--P.usedTimes === 0) {
                            const L = m.indexOf(P);
                            m[L] = m[m.length - 1],
                            m.pop(),
                            P.destroy()
                        }
                    }
                    function I(P) {
                        d.remove(P)
                    }
                    function F() {
                        d.dispose()
                    }
                    return {
                        getParameters: T,
                        getProgramCacheKey: M,
                        getUniforms: O,
                        acquireProgram: U,
                        releaseProgram: B,
                        releaseShaderCache: I,
                        programs: m,
                        dispose: F
                    }
                }
                function A4() {
                    let e = new WeakMap;
                    function t(l) {
                        return e.has(l)
                    }
                    function n(l) {
                        let h = e.get(l);
                        return h === void 0 && (h = {},
                        e.set(l, h)),
                        h
                    }
                    function i(l) {
                        e.delete(l)
                    }
                    function s(l, h, d) {
                        e.get(l)[h] = d
                    }
                    function r() {
                        e = new WeakMap
                    }
                    return {
                        has: t,
                        get: n,
                        remove: i,
                        update: s,
                        dispose: r
                    }
                }
                function T4(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                }
                function W1(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                }
                function j1() {
                    const e = [];
                    let t = 0;
                    const n = []
                      , i = []
                      , s = [];
                    function r() {
                        t = 0,
                        n.length = 0,
                        i.length = 0,
                        s.length = 0
                    }
                    function l(v, _, x, b, E, T) {
                        let M = e[t];
                        return M === void 0 ? (M = {
                            id: v.id,
                            object: v,
                            geometry: _,
                            material: x,
                            groupOrder: b,
                            renderOrder: v.renderOrder,
                            z: E,
                            group: T
                        },
                        e[t] = M) : (M.id = v.id,
                        M.object = v,
                        M.geometry = _,
                        M.material = x,
                        M.groupOrder = b,
                        M.renderOrder = v.renderOrder,
                        M.z = E,
                        M.group = T),
                        t++,
                        M
                    }
                    function h(v, _, x, b, E, T) {
                        const M = l(v, _, x, b, E, T);
                        x.transmission > 0 ? i.push(M) : x.transparent === !0 ? s.push(M) : n.push(M)
                    }
                    function d(v, _, x, b, E, T) {
                        const M = l(v, _, x, b, E, T);
                        x.transmission > 0 ? i.unshift(M) : x.transparent === !0 ? s.unshift(M) : n.unshift(M)
                    }
                    function p(v, _) {
                        n.length > 1 && n.sort(v || T4),
                        i.length > 1 && i.sort(_ || W1),
                        s.length > 1 && s.sort(_ || W1)
                    }
                    function m() {
                        for (let v = t, _ = e.length; v < _; v++) {
                            const x = e[v];
                            if (x.id === null)
                                break;
                            x.id = null,
                            x.object = null,
                            x.geometry = null,
                            x.material = null,
                            x.group = null
                        }
                    }
                    return {
                        opaque: n,
                        transmissive: i,
                        transparent: s,
                        init: r,
                        push: h,
                        unshift: d,
                        finish: m,
                        sort: p
                    }
                }
                function M4() {
                    let e = new WeakMap;
                    function t(i, s) {
                        const r = e.get(i);
                        let l;
                        return r === void 0 ? (l = new j1,
                        e.set(i, [l])) : s >= r.length ? (l = new j1,
                        r.push(l)) : l = r[s],
                        l
                    }
                    function n() {
                        e = new WeakMap
                    }
                    return {
                        get: t,
                        dispose: n
                    }
                }
                function b4() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (e[t.id] !== void 0)
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Q,
                                    color: new at
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Q,
                                    direction: new Q,
                                    color: new at,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Q,
                                    color: new at,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Q,
                                    skyColor: new at,
                                    groundColor: new at
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new at,
                                    position: new Q,
                                    halfWidth: new Q,
                                    halfHeight: new Q
                                };
                                break
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                function E4() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (e[t.id] !== void 0)
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ye
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ye
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ye,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                let w4 = 0;
                function C4(e, t) {
                    return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
                }
                function R4(e) {
                    const t = new b4
                      , n = E4()
                      , i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                    for (let p = 0; p < 9; p++)
                        i.probe.push(new Q);
                    const s = new Q
                      , r = new Xt
                      , l = new Xt;
                    function h(p) {
                        let m = 0
                          , v = 0
                          , _ = 0;
                        for (let P = 0; P < 9; P++)
                            i.probe[P].set(0, 0, 0);
                        let x = 0
                          , b = 0
                          , E = 0
                          , T = 0
                          , M = 0
                          , D = 0
                          , R = 0
                          , O = 0
                          , U = 0
                          , B = 0
                          , I = 0;
                        p.sort(C4);
                        for (let P = 0, L = p.length; P < L; P++) {
                            const H = p[P]
                              , Z = H.color
                              , K = H.intensity
                              , te = H.distance
                              , ce = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
                            if (H.isAmbientLight)
                                m += Z.r * K,
                                v += Z.g * K,
                                _ += Z.b * K;
                            else if (H.isLightProbe) {
                                for (let G = 0; G < 9; G++)
                                    i.probe[G].addScaledVector(H.sh.coefficients[G], K);
                                I++
                            } else if (H.isDirectionalLight) {
                                const G = t.get(H);
                                if (G.color.copy(H.color).multiplyScalar(H.intensity),
                                H.castShadow) {
                                    const V = H.shadow
                                      , q = n.get(H);
                                    q.shadowIntensity = V.intensity,
                                    q.shadowBias = V.bias,
                                    q.shadowNormalBias = V.normalBias,
                                    q.shadowRadius = V.radius,
                                    q.shadowMapSize = V.mapSize,
                                    i.directionalShadow[x] = q,
                                    i.directionalShadowMap[x] = ce,
                                    i.directionalShadowMatrix[x] = H.shadow.matrix,
                                    D++
                                }
                                i.directional[x] = G,
                                x++
                            } else if (H.isSpotLight) {
                                const G = t.get(H);
                                G.position.setFromMatrixPosition(H.matrixWorld),
                                G.color.copy(Z).multiplyScalar(K),
                                G.distance = te,
                                G.coneCos = Math.cos(H.angle),
                                G.penumbraCos = Math.cos(H.angle * (1 - H.penumbra)),
                                G.decay = H.decay,
                                i.spot[E] = G;
                                const V = H.shadow;
                                if (H.map && (i.spotLightMap[U] = H.map,
                                U++,
                                V.updateMatrices(H),
                                H.castShadow && B++),
                                i.spotLightMatrix[E] = V.matrix,
                                H.castShadow) {
                                    const q = n.get(H);
                                    q.shadowIntensity = V.intensity,
                                    q.shadowBias = V.bias,
                                    q.shadowNormalBias = V.normalBias,
                                    q.shadowRadius = V.radius,
                                    q.shadowMapSize = V.mapSize,
                                    i.spotShadow[E] = q,
                                    i.spotShadowMap[E] = ce,
                                    O++
                                }
                                E++
                            } else if (H.isRectAreaLight) {
                                const G = t.get(H);
                                G.color.copy(Z).multiplyScalar(K),
                                G.halfWidth.set(H.width * .5, 0, 0),
                                G.halfHeight.set(0, H.height * .5, 0),
                                i.rectArea[T] = G,
                                T++
                            } else if (H.isPointLight) {
                                const G = t.get(H);
                                if (G.color.copy(H.color).multiplyScalar(H.intensity),
                                G.distance = H.distance,
                                G.decay = H.decay,
                                H.castShadow) {
                                    const V = H.shadow
                                      , q = n.get(H);
                                    q.shadowIntensity = V.intensity,
                                    q.shadowBias = V.bias,
                                    q.shadowNormalBias = V.normalBias,
                                    q.shadowRadius = V.radius,
                                    q.shadowMapSize = V.mapSize,
                                    q.shadowCameraNear = V.camera.near,
                                    q.shadowCameraFar = V.camera.far,
                                    i.pointShadow[b] = q,
                                    i.pointShadowMap[b] = ce,
                                    i.pointShadowMatrix[b] = H.shadow.matrix,
                                    R++
                                }
                                i.point[b] = G,
                                b++
                            } else if (H.isHemisphereLight) {
                                const G = t.get(H);
                                G.skyColor.copy(H.color).multiplyScalar(K),
                                G.groundColor.copy(H.groundColor).multiplyScalar(K),
                                i.hemi[M] = G,
                                M++
                            }
                        }
                        T > 0 && (e.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = pt.LTC_FLOAT_1,
                        i.rectAreaLTC2 = pt.LTC_FLOAT_2) : (i.rectAreaLTC1 = pt.LTC_HALF_1,
                        i.rectAreaLTC2 = pt.LTC_HALF_2)),
                        i.ambient[0] = m,
                        i.ambient[1] = v,
                        i.ambient[2] = _;
                        const F = i.hash;
                        (F.directionalLength !== x || F.pointLength !== b || F.spotLength !== E || F.rectAreaLength !== T || F.hemiLength !== M || F.numDirectionalShadows !== D || F.numPointShadows !== R || F.numSpotShadows !== O || F.numSpotMaps !== U || F.numLightProbes !== I) && (i.directional.length = x,
                        i.spot.length = E,
                        i.rectArea.length = T,
                        i.point.length = b,
                        i.hemi.length = M,
                        i.directionalShadow.length = D,
                        i.directionalShadowMap.length = D,
                        i.pointShadow.length = R,
                        i.pointShadowMap.length = R,
                        i.spotShadow.length = O,
                        i.spotShadowMap.length = O,
                        i.directionalShadowMatrix.length = D,
                        i.pointShadowMatrix.length = R,
                        i.spotLightMatrix.length = O + U - B,
                        i.spotLightMap.length = U,
                        i.numSpotLightShadowsWithMaps = B,
                        i.numLightProbes = I,
                        F.directionalLength = x,
                        F.pointLength = b,
                        F.spotLength = E,
                        F.rectAreaLength = T,
                        F.hemiLength = M,
                        F.numDirectionalShadows = D,
                        F.numPointShadows = R,
                        F.numSpotShadows = O,
                        F.numSpotMaps = U,
                        F.numLightProbes = I,
                        i.version = w4++)
                    }
                    function d(p, m) {
                        let v = 0
                          , _ = 0
                          , x = 0
                          , b = 0
                          , E = 0;
                        const T = m.matrixWorldInverse;
                        for (let M = 0, D = p.length; M < D; M++) {
                            const R = p[M];
                            if (R.isDirectionalLight) {
                                const O = i.directional[v];
                                O.direction.setFromMatrixPosition(R.matrixWorld),
                                s.setFromMatrixPosition(R.target.matrixWorld),
                                O.direction.sub(s),
                                O.direction.transformDirection(T),
                                v++
                            } else if (R.isSpotLight) {
                                const O = i.spot[x];
                                O.position.setFromMatrixPosition(R.matrixWorld),
                                O.position.applyMatrix4(T),
                                O.direction.setFromMatrixPosition(R.matrixWorld),
                                s.setFromMatrixPosition(R.target.matrixWorld),
                                O.direction.sub(s),
                                O.direction.transformDirection(T),
                                x++
                            } else if (R.isRectAreaLight) {
                                const O = i.rectArea[b];
                                O.position.setFromMatrixPosition(R.matrixWorld),
                                O.position.applyMatrix4(T),
                                l.identity(),
                                r.copy(R.matrixWorld),
                                r.premultiply(T),
                                l.extractRotation(r),
                                O.halfWidth.set(R.width * .5, 0, 0),
                                O.halfHeight.set(0, R.height * .5, 0),
                                O.halfWidth.applyMatrix4(l),
                                O.halfHeight.applyMatrix4(l),
                                b++
                            } else if (R.isPointLight) {
                                const O = i.point[_];
                                O.position.setFromMatrixPosition(R.matrixWorld),
                                O.position.applyMatrix4(T),
                                _++
                            } else if (R.isHemisphereLight) {
                                const O = i.hemi[E];
                                O.direction.setFromMatrixPosition(R.matrixWorld),
                                O.direction.transformDirection(T),
                                E++
                            }
                        }
                    }
                    return {
                        setup: h,
                        setupView: d,
                        state: i
                    }
                }
                function Q1(e) {
                    const t = new R4(e)
                      , n = []
                      , i = [];
                    function s(m) {
                        p.camera = m,
                        n.length = 0,
                        i.length = 0
                    }
                    function r(m) {
                        n.push(m)
                    }
                    function l(m) {
                        i.push(m)
                    }
                    function h() {
                        t.setup(n)
                    }
                    function d(m) {
                        t.setupView(n, m)
                    }
                    const p = {
                        lightsArray: n,
                        shadowsArray: i,
                        camera: null,
                        lights: t,
                        transmissionRenderTarget: {}
                    };
                    return {
                        init: s,
                        state: p,
                        setupLights: h,
                        setupLightsView: d,
                        pushLight: r,
                        pushShadow: l
                    }
                }
                function D4(e) {
                    let t = new WeakMap;
                    function n(s, r=0) {
                        const l = t.get(s);
                        let h;
                        return l === void 0 ? (h = new Q1(e),
                        t.set(s, [h])) : r >= l.length ? (h = new Q1(e),
                        l.push(h)) : h = l[r],
                        h
                    }
                    function i() {
                        t = new WeakMap
                    }
                    return {
                        get: n,
                        dispose: i
                    }
                }
                const O4 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
                  , N4 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
                function U4(e, t, n) {
                    let i = new Np;
                    const s = new ye
                      , r = new ye
                      , l = new gn
                      , h = new hx({
                        depthPacking: Fo
                    })
                      , d = new MT
                      , p = {}
                      , m = n.maxTextureSize
                      , v = {
                        [Bl]: ys,
                        [ys]: Bl,
                        [nr]: nr
                    }
                      , _ = new Fn({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new ye
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: O4,
                        fragmentShader: N4
                    })
                      , x = _.clone();
                    x.defines.HORIZONTAL_PASS = 1;
                    const b = new an;
                    b.setAttribute("position", new wn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                    const E = new Fi(b,_)
                      , T = this;
                    this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = Oy;
                    let M = this.type;
                    this.render = function(B, I, F) {
                        if (T.enabled === !1 || T.autoUpdate === !1 && T.needsUpdate === !1 || B.length === 0)
                            return;
                        const P = e.getRenderTarget()
                          , L = e.getActiveCubeFace()
                          , H = e.getActiveMipmapLevel()
                          , Z = e.state;
                        Z.setBlending(oi),
                        Z.buffers.depth.getReversed() === !0 ? Z.buffers.color.setClear(0, 0, 0, 0) : Z.buffers.color.setClear(1, 1, 1, 1),
                        Z.buffers.depth.setTest(!0),
                        Z.setScissorTest(!1);
                        const K = M !== Lo && this.type === Lo
                          , te = M === Lo && this.type !== Lo;
                        for (let ce = 0, G = B.length; ce < G; ce++) {
                            const V = B[ce]
                              , q = V.shadow;
                            if (q === void 0) {
                                console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
                                continue
                            }
                            if (q.autoUpdate === !1 && q.needsUpdate === !1)
                                continue;
                            s.copy(q.mapSize);
                            const ee = q.getFrameExtents();
                            if (s.multiply(ee),
                            r.copy(q.mapSize),
                            (s.x > m || s.y > m) && (s.x > m && (r.x = Math.floor(m / ee.x),
                            s.x = r.x * ee.x,
                            q.mapSize.x = r.x),
                            s.y > m && (r.y = Math.floor(m / ee.y),
                            s.y = r.y * ee.y,
                            q.mapSize.y = r.y)),
                            q.map === null || K === !0 || te === !0) {
                                const X = this.type !== Lo ? {
                                    minFilter: ti,
                                    magFilter: ti
                                } : {};
                                q.map !== null && q.map.dispose(),
                                q.map = new Un(s.x,s.y,X),
                                q.map.texture.name = V.name + ".shadowMap",
                                q.camera.updateProjectionMatrix()
                            }
                            e.setRenderTarget(q.map),
                            e.clear();
                            const se = q.getViewportCount();
                            for (let X = 0; X < se; X++) {
                                const J = q.getViewport(X);
                                l.set(r.x * J.x, r.y * J.y, r.x * J.z, r.y * J.w),
                                Z.viewport(l),
                                q.updateMatrices(V, X),
                                i = q.getFrustum(),
                                O(I, F, q.camera, V, this.type)
                            }
                            q.isPointLightShadow !== !0 && this.type === Lo && D(q, F),
                            q.needsUpdate = !1
                        }
                        M = this.type,
                        T.needsUpdate = !1,
                        e.setRenderTarget(P, L, H)
                    }
                    ;
                    function D(B, I) {
                        const F = t.update(E);
                        _.defines.VSM_SAMPLES !== B.blurSamples && (_.defines.VSM_SAMPLES = B.blurSamples,
                        x.defines.VSM_SAMPLES = B.blurSamples,
                        _.needsUpdate = !0,
                        x.needsUpdate = !0),
                        B.mapPass === null && (B.mapPass = new Un(s.x,s.y)),
                        _.uniforms.shadow_pass.value = B.map.texture,
                        _.uniforms.resolution.value = B.mapSize,
                        _.uniforms.radius.value = B.radius,
                        e.setRenderTarget(B.mapPass),
                        e.clear(),
                        e.renderBufferDirect(I, null, F, _, E, null),
                        x.uniforms.shadow_pass.value = B.mapPass.texture,
                        x.uniforms.resolution.value = B.mapSize,
                        x.uniforms.radius.value = B.radius,
                        e.setRenderTarget(B.map),
                        e.clear(),
                        e.renderBufferDirect(I, null, F, x, E, null)
                    }
                    function R(B, I, F, P) {
                        let L = null;
                        const H = F.isPointLight === !0 ? B.customDistanceMaterial : B.customDepthMaterial;
                        if (H !== void 0)
                            L = H;
                        else if (L = F.isPointLight === !0 ? d : h,
                        e.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0 || I.alphaToCoverage === !0) {
                            const Z = L.uuid
                              , K = I.uuid;
                            let te = p[Z];
                            te === void 0 && (te = {},
                            p[Z] = te);
                            let ce = te[K];
                            ce === void 0 && (ce = L.clone(),
                            te[K] = ce,
                            I.addEventListener("dispose", U)),
                            L = ce
                        }
                        if (L.visible = I.visible,
                        L.wireframe = I.wireframe,
                        P === Lo ? L.side = I.shadowSide !== null ? I.shadowSide : I.side : L.side = I.shadowSide !== null ? I.shadowSide : v[I.side],
                        L.alphaMap = I.alphaMap,
                        L.alphaTest = I.alphaToCoverage === !0 ? .5 : I.alphaTest,
                        L.map = I.map,
                        L.clipShadows = I.clipShadows,
                        L.clippingPlanes = I.clippingPlanes,
                        L.clipIntersection = I.clipIntersection,
                        L.displacementMap = I.displacementMap,
                        L.displacementScale = I.displacementScale,
                        L.displacementBias = I.displacementBias,
                        L.wireframeLinewidth = I.wireframeLinewidth,
                        L.linewidth = I.linewidth,
                        F.isPointLight === !0 && L.isMeshDistanceMaterial === !0) {
                            const Z = e.properties.get(L);
                            Z.light = F
                        }
                        return L
                    }
                    function O(B, I, F, P, L) {
                        if (B.visible === !1)
                            return;
                        if (B.layers.test(I.layers) && (B.isMesh || B.isLine || B.isPoints) && (B.castShadow || B.receiveShadow && L === Lo) && (!B.frustumCulled || i.intersectsObject(B))) {
                            B.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse, B.matrixWorld);
                            const Z = t.update(B)
                              , K = B.material;
                            if (Array.isArray(K)) {
                                const te = Z.groups;
                                for (let ce = 0, G = te.length; ce < G; ce++) {
                                    const V = te[ce]
                                      , q = K[V.materialIndex];
                                    if (q && q.visible) {
                                        const ee = R(B, q, P, L);
                                        B.onBeforeShadow(e, B, I, F, Z, ee, V),
                                        e.renderBufferDirect(F, null, Z, ee, B, V),
                                        B.onAfterShadow(e, B, I, F, Z, ee, V)
                                    }
                                }
                            } else if (K.visible) {
                                const te = R(B, K, P, L);
                                B.onBeforeShadow(e, B, I, F, Z, te, null),
                                e.renderBufferDirect(F, null, Z, te, B, null),
                                B.onAfterShadow(e, B, I, F, Z, te, null)
                            }
                        }
                        const H = B.children;
                        for (let Z = 0, K = H.length; Z < K; Z++)
                            O(H[Z], I, F, P, L)
                    }
                    function U(B) {
                        B.target.removeEventListener("dispose", U);
                        for (const I in p) {
                            const F = p[I]
                              , P = B.target.uuid;
                            P in F && (F[P].dispose(),
                            delete F[P])
                        }
                    }
                }
                const B4 = {
                    [Ng]: Ug,
                    [$d]: Pg,
                    [ef]: ep,
                    [Ou]: Bg,
                    [Ug]: Ng,
                    [Pg]: $d,
                    [ep]: ef,
                    [Bg]: Ou
                };
                function P4(e, t) {
                    function n() {
                        let ae = !1;
                        const ot = new gn;
                        let tt = null;
                        const gt = new gn(0,0,0,0);
                        return {
                            setMask: function(Je) {
                                tt !== Je && !ae && (e.colorMask(Je, Je, Je, Je),
                                tt = Je)
                            },
                            setLocked: function(Je) {
                                ae = Je
                            },
                            setClear: function(Je, ke, ht, Mt, Tn) {
                                Tn === !0 && (Je *= Mt,
                                ke *= Mt,
                                ht *= Mt),
                                ot.set(Je, ke, ht, Mt),
                                gt.equals(ot) === !1 && (e.clearColor(Je, ke, ht, Mt),
                                gt.copy(ot))
                            },
                            reset: function() {
                                ae = !1,
                                tt = null,
                                gt.set(-1, 0, 0, 0)
                            }
                        }
                    }
                    function i() {
                        let ae = !1
                          , ot = !1
                          , tt = null
                          , gt = null
                          , Je = null;
                        return {
                            setReversed: function(ke) {
                                if (ot !== ke) {
                                    const ht = t.get("EXT_clip_control");
                                    ke ? ht.clipControlEXT(ht.LOWER_LEFT_EXT, ht.ZERO_TO_ONE_EXT) : ht.clipControlEXT(ht.LOWER_LEFT_EXT, ht.NEGATIVE_ONE_TO_ONE_EXT),
                                    ot = ke;
                                    const Mt = Je;
                                    Je = null,
                                    this.setClear(Mt)
                                }
                            },
                            getReversed: function() {
                                return ot
                            },
                            setTest: function(ke) {
                                ke ? be(e.DEPTH_TEST) : Ue(e.DEPTH_TEST)
                            },
                            setMask: function(ke) {
                                tt !== ke && !ae && (e.depthMask(ke),
                                tt = ke)
                            },
                            setFunc: function(ke) {
                                if (ot && (ke = B4[ke]),
                                gt !== ke) {
                                    switch (ke) {
                                    case Ng:
                                        e.depthFunc(e.NEVER);
                                        break;
                                    case Ug:
                                        e.depthFunc(e.ALWAYS);
                                        break;
                                    case $d:
                                        e.depthFunc(e.LESS);
                                        break;
                                    case Ou:
                                        e.depthFunc(e.LEQUAL);
                                        break;
                                    case ef:
                                        e.depthFunc(e.EQUAL);
                                        break;
                                    case Bg:
                                        e.depthFunc(e.GEQUAL);
                                        break;
                                    case Pg:
                                        e.depthFunc(e.GREATER);
                                        break;
                                    case ep:
                                        e.depthFunc(e.NOTEQUAL);
                                        break;
                                    default:
                                        e.depthFunc(e.LEQUAL)
                                    }
                                    gt = ke
                                }
                            },
                            setLocked: function(ke) {
                                ae = ke
                            },
                            setClear: function(ke) {
                                Je !== ke && (ot && (ke = 1 - ke),
                                e.clearDepth(ke),
                                Je = ke)
                            },
                            reset: function() {
                                ae = !1,
                                tt = null,
                                gt = null,
                                Je = null,
                                ot = !1
                            }
                        }
                    }
                    function s() {
                        let ae = !1
                          , ot = null
                          , tt = null
                          , gt = null
                          , Je = null
                          , ke = null
                          , ht = null
                          , Mt = null
                          , Tn = null;
                        return {
                            setTest: function(Zt) {
                                ae || (Zt ? be(e.STENCIL_TEST) : Ue(e.STENCIL_TEST))
                            },
                            setMask: function(Zt) {
                                ot !== Zt && !ae && (e.stencilMask(Zt),
                                ot = Zt)
                            },
                            setFunc: function(Zt, Ai, pa) {
                                (tt !== Zt || gt !== Ai || Je !== pa) && (e.stencilFunc(Zt, Ai, pa),
                                tt = Zt,
                                gt = Ai,
                                Je = pa)
                            },
                            setOp: function(Zt, Ai, pa) {
                                (ke !== Zt || ht !== Ai || Mt !== pa) && (e.stencilOp(Zt, Ai, pa),
                                ke = Zt,
                                ht = Ai,
                                Mt = pa)
                            },
                            setLocked: function(Zt) {
                                ae = Zt
                            },
                            setClear: function(Zt) {
                                Tn !== Zt && (e.clearStencil(Zt),
                                Tn = Zt)
                            },
                            reset: function() {
                                ae = !1,
                                ot = null,
                                tt = null,
                                gt = null,
                                Je = null,
                                ke = null,
                                ht = null,
                                Mt = null,
                                Tn = null
                            }
                        }
                    }
                    const r = new n
                      , l = new i
                      , h = new s
                      , d = new WeakMap
                      , p = new WeakMap;
                    let m = {}
                      , v = {}
                      , _ = new WeakMap
                      , x = []
                      , b = null
                      , E = !1
                      , T = null
                      , M = null
                      , D = null
                      , R = null
                      , O = null
                      , U = null
                      , B = null
                      , I = new at(0,0,0)
                      , F = 0
                      , P = !1
                      , L = null
                      , H = null
                      , Z = null
                      , K = null
                      , te = null;
                    const ce = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    let G = !1
                      , V = 0;
                    const q = e.getParameter(e.VERSION);
                    q.indexOf("WebGL") !== -1 ? (V = parseFloat(/^WebGL (\d)/.exec(q)[1]),
                    G = V >= 1) : q.indexOf("OpenGL ES") !== -1 && (V = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),
                    G = V >= 2);
                    let ee = null
                      , se = {};
                    const X = e.getParameter(e.SCISSOR_BOX)
                      , J = e.getParameter(e.VIEWPORT)
                      , ze = new gn().fromArray(X)
                      , xe = new gn().fromArray(J);
                    function le(ae, ot, tt, gt) {
                        const Je = new Uint8Array(4)
                          , ke = e.createTexture();
                        e.bindTexture(ae, ke),
                        e.texParameteri(ae, e.TEXTURE_MIN_FILTER, e.NEAREST),
                        e.texParameteri(ae, e.TEXTURE_MAG_FILTER, e.NEAREST);
                        for (let ht = 0; ht < tt; ht++)
                            ae === e.TEXTURE_3D || ae === e.TEXTURE_2D_ARRAY ? e.texImage3D(ot, 0, e.RGBA, 1, 1, gt, 0, e.RGBA, e.UNSIGNED_BYTE, Je) : e.texImage2D(ot + ht, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, Je);
                        return ke
                    }
                    const Ne = {};
                    Ne[e.TEXTURE_2D] = le(e.TEXTURE_2D, e.TEXTURE_2D, 1),
                    Ne[e.TEXTURE_CUBE_MAP] = le(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                    Ne[e.TEXTURE_2D_ARRAY] = le(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
                    Ne[e.TEXTURE_3D] = le(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
                    r.setClear(0, 0, 0, 1),
                    l.setClear(1),
                    h.setClear(0),
                    be(e.DEPTH_TEST),
                    l.setFunc(Ou),
                    Pe(!1),
                    Ye(lA),
                    be(e.CULL_FACE),
                    de(oi);
                    function be(ae) {
                        m[ae] !== !0 && (e.enable(ae),
                        m[ae] = !0)
                    }
                    function Ue(ae) {
                        m[ae] !== !1 && (e.disable(ae),
                        m[ae] = !1)
                    }
                    function $e(ae, ot) {
                        return v[ae] !== ot ? (e.bindFramebuffer(ae, ot),
                        v[ae] = ot,
                        ae === e.DRAW_FRAMEBUFFER && (v[e.FRAMEBUFFER] = ot),
                        ae === e.FRAMEBUFFER && (v[e.DRAW_FRAMEBUFFER] = ot),
                        !0) : !1
                    }
                    function rt(ae, ot) {
                        let tt = x
                          , gt = !1;
                        if (ae) {
                            tt = _.get(ot),
                            tt === void 0 && (tt = [],
                            _.set(ot, tt));
                            const Je = ae.textures;
                            if (tt.length !== Je.length || tt[0] !== e.COLOR_ATTACHMENT0) {
                                for (let ke = 0, ht = Je.length; ke < ht; ke++)
                                    tt[ke] = e.COLOR_ATTACHMENT0 + ke;
                                tt.length = Je.length,
                                gt = !0
                            }
                        } else
                            tt[0] !== e.BACK && (tt[0] = e.BACK,
                            gt = !0);
                        gt && e.drawBuffers(tt)
                    }
                    function Et(ae) {
                        return b !== ae ? (e.useProgram(ae),
                        b = ae,
                        !0) : !1
                    }
                    const ne = {
                        [Du]: e.FUNC_ADD,
                        [fE]: e.FUNC_SUBTRACT,
                        [dE]: e.FUNC_REVERSE_SUBTRACT
                    };
                    ne[pE] = e.MIN,
                    ne[mE] = e.MAX;
                    const Ve = {
                        [gE]: e.ZERO,
                        [vE]: e.ONE,
                        [yE]: e.SRC_COLOR,
                        [Uy]: e.SRC_ALPHA,
                        [ME]: e.SRC_ALPHA_SATURATE,
                        [AE]: e.DST_COLOR,
                        [xE]: e.DST_ALPHA,
                        [_E]: e.ONE_MINUS_SRC_COLOR,
                        [By]: e.ONE_MINUS_SRC_ALPHA,
                        [TE]: e.ONE_MINUS_DST_COLOR,
                        [SE]: e.ONE_MINUS_DST_ALPHA,
                        [bE]: e.CONSTANT_COLOR,
                        [EE]: e.ONE_MINUS_CONSTANT_COLOR,
                        [wE]: e.CONSTANT_ALPHA,
                        [CE]: e.ONE_MINUS_CONSTANT_ALPHA
                    };
                    function de(ae, ot, tt, gt, Je, ke, ht, Mt, Tn, Zt) {
                        if (ae === oi) {
                            E === !0 && (Ue(e.BLEND),
                            E = !1);
                            return
                        }
                        if (E === !1 && (be(e.BLEND),
                        E = !0),
                        ae !== hE) {
                            if (ae !== T || Zt !== P) {
                                if ((M !== Du || O !== Du) && (e.blendEquation(e.FUNC_ADD),
                                M = Du,
                                O = Du),
                                Zt)
                                    switch (ae) {
                                    case $h:
                                        e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case Ny:
                                        e.blendFunc(e.ONE, e.ONE);
                                        break;
                                    case cA:
                                        e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                        break;
                                    case uA:
                                        e.blendFuncSeparate(e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ZERO, e.ONE);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", ae);
                                        break
                                    }
                                else
                                    switch (ae) {
                                    case $h:
                                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case Ny:
                                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE);
                                        break;
                                    case cA:
                                        console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                                        break;
                                    case uA:
                                        console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", ae);
                                        break
                                    }
                                D = null,
                                R = null,
                                U = null,
                                B = null,
                                I.set(0, 0, 0),
                                F = 0,
                                T = ae,
                                P = Zt
                            }
                            return
                        }
                        Je = Je || ot,
                        ke = ke || tt,
                        ht = ht || gt,
                        (ot !== M || Je !== O) && (e.blendEquationSeparate(ne[ot], ne[Je]),
                        M = ot,
                        O = Je),
                        (tt !== D || gt !== R || ke !== U || ht !== B) && (e.blendFuncSeparate(Ve[tt], Ve[gt], Ve[ke], Ve[ht]),
                        D = tt,
                        R = gt,
                        U = ke,
                        B = ht),
                        (Mt.equals(I) === !1 || Tn !== F) && (e.blendColor(Mt.r, Mt.g, Mt.b, Tn),
                        I.copy(Mt),
                        F = Tn),
                        T = ae,
                        P = !1
                    }
                    function Te(ae, ot) {
                        ae.side === nr ? Ue(e.CULL_FACE) : be(e.CULL_FACE);
                        let tt = ae.side === ys;
                        ot && (tt = !tt),
                        Pe(tt),
                        ae.blending === $h && ae.transparent === !1 ? de(oi) : de(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.blendColor, ae.blendAlpha, ae.premultipliedAlpha),
                        l.setFunc(ae.depthFunc),
                        l.setTest(ae.depthTest),
                        l.setMask(ae.depthWrite),
                        r.setMask(ae.colorWrite);
                        const gt = ae.stencilWrite;
                        h.setTest(gt),
                        gt && (h.setMask(ae.stencilWriteMask),
                        h.setFunc(ae.stencilFunc, ae.stencilRef, ae.stencilFuncMask),
                        h.setOp(ae.stencilFail, ae.stencilZFail, ae.stencilZPass)),
                        Fe(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits),
                        ae.alphaToCoverage === !0 ? be(e.SAMPLE_ALPHA_TO_COVERAGE) : Ue(e.SAMPLE_ALPHA_TO_COVERAGE)
                    }
                    function Pe(ae) {
                        L !== ae && (ae ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                        L = ae)
                    }
                    function Ye(ae) {
                        ae !== lE ? (be(e.CULL_FACE),
                        ae !== H && (ae === lA ? e.cullFace(e.BACK) : ae === cE ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : Ue(e.CULL_FACE),
                        H = ae
                    }
                    function Ie(ae) {
                        ae !== Z && (G && e.lineWidth(ae),
                        Z = ae)
                    }
                    function Fe(ae, ot, tt) {
                        ae ? (be(e.POLYGON_OFFSET_FILL),
                        (K !== ot || te !== tt) && (e.polygonOffset(ot, tt),
                        K = ot,
                        te = tt)) : Ue(e.POLYGON_OFFSET_FILL)
                    }
                    function xt(ae) {
                        ae ? be(e.SCISSOR_TEST) : Ue(e.SCISSOR_TEST)
                    }
                    function yt(ae) {
                        ae === void 0 && (ae = e.TEXTURE0 + ce - 1),
                        ee !== ae && (e.activeTexture(ae),
                        ee = ae)
                    }
                    function wt(ae, ot, tt) {
                        tt === void 0 && (ee === null ? tt = e.TEXTURE0 + ce - 1 : tt = ee);
                        let gt = se[tt];
                        gt === void 0 && (gt = {
                            type: void 0,
                            texture: void 0
                        },
                        se[tt] = gt),
                        (gt.type !== ae || gt.texture !== ot) && (ee !== tt && (e.activeTexture(tt),
                        ee = tt),
                        e.bindTexture(ae, ot || Ne[ae]),
                        gt.type = ae,
                        gt.texture = ot)
                    }
                    function $() {
                        const ae = se[ee];
                        ae !== void 0 && ae.type !== void 0 && (e.bindTexture(ae.type, null),
                        ae.type = void 0,
                        ae.texture = void 0)
                    }
                    function k() {
                        try {
                            e.compressedTexImage2D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function pe() {
                        try {
                            e.compressedTexImage3D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function Ge() {
                        try {
                            e.texSubImage2D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function Qe() {
                        try {
                            e.texSubImage3D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function Be() {
                        try {
                            e.compressedTexSubImage2D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function ct() {
                        try {
                            e.compressedTexSubImage3D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function Ke() {
                        try {
                            e.texStorage2D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function _t() {
                        try {
                            e.texStorage3D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function Ct() {
                        try {
                            e.texImage2D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function et() {
                        try {
                            e.texImage3D(...arguments)
                        } catch (ae) {
                            console.error("THREE.WebGLState:", ae)
                        }
                    }
                    function st(ae) {
                        ze.equals(ae) === !1 && (e.scissor(ae.x, ae.y, ae.z, ae.w),
                        ze.copy(ae))
                    }
                    function ie(ae) {
                        xe.equals(ae) === !1 && (e.viewport(ae.x, ae.y, ae.z, ae.w),
                        xe.copy(ae))
                    }
                    function Re(ae, ot) {
                        let tt = p.get(ot);
                        tt === void 0 && (tt = new WeakMap,
                        p.set(ot, tt));
                        let gt = tt.get(ae);
                        gt === void 0 && (gt = e.getUniformBlockIndex(ot, ae.name),
                        tt.set(ae, gt))
                    }
                    function He(ae, ot) {
                        const tt = p.get(ot).get(ae);
                        d.get(ot) !== tt && (e.uniformBlockBinding(ot, tt, ae.__bindingPointIndex),
                        d.set(ot, tt))
                    }
                    function lt() {
                        e.disable(e.BLEND),
                        e.disable(e.CULL_FACE),
                        e.disable(e.DEPTH_TEST),
                        e.disable(e.POLYGON_OFFSET_FILL),
                        e.disable(e.SCISSOR_TEST),
                        e.disable(e.STENCIL_TEST),
                        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                        e.blendEquation(e.FUNC_ADD),
                        e.blendFunc(e.ONE, e.ZERO),
                        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                        e.blendColor(0, 0, 0, 0),
                        e.colorMask(!0, !0, !0, !0),
                        e.clearColor(0, 0, 0, 0),
                        e.depthMask(!0),
                        e.depthFunc(e.LESS),
                        l.setReversed(!1),
                        e.clearDepth(1),
                        e.stencilMask(4294967295),
                        e.stencilFunc(e.ALWAYS, 0, 4294967295),
                        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                        e.clearStencil(0),
                        e.cullFace(e.BACK),
                        e.frontFace(e.CCW),
                        e.polygonOffset(0, 0),
                        e.activeTexture(e.TEXTURE0),
                        e.bindFramebuffer(e.FRAMEBUFFER, null),
                        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        e.useProgram(null),
                        e.lineWidth(1),
                        e.scissor(0, 0, e.canvas.width, e.canvas.height),
                        e.viewport(0, 0, e.canvas.width, e.canvas.height),
                        m = {},
                        ee = null,
                        se = {},
                        v = {},
                        _ = new WeakMap,
                        x = [],
                        b = null,
                        E = !1,
                        T = null,
                        M = null,
                        D = null,
                        R = null,
                        O = null,
                        U = null,
                        B = null,
                        I = new at(0,0,0),
                        F = 0,
                        P = !1,
                        L = null,
                        H = null,
                        Z = null,
                        K = null,
                        te = null,
                        ze.set(0, 0, e.canvas.width, e.canvas.height),
                        xe.set(0, 0, e.canvas.width, e.canvas.height),
                        r.reset(),
                        l.reset(),
                        h.reset()
                    }
                    return {
                        buffers: {
                            color: r,
                            depth: l,
                            stencil: h
                        },
                        enable: be,
                        disable: Ue,
                        bindFramebuffer: $e,
                        drawBuffers: rt,
                        useProgram: Et,
                        setBlending: de,
                        setMaterial: Te,
                        setFlipSided: Pe,
                        setCullFace: Ye,
                        setLineWidth: Ie,
                        setPolygonOffset: Fe,
                        setScissorTest: xt,
                        activeTexture: yt,
                        bindTexture: wt,
                        unbindTexture: $,
                        compressedTexImage2D: k,
                        compressedTexImage3D: pe,
                        texImage2D: Ct,
                        texImage3D: et,
                        updateUBOMapping: Re,
                        uniformBlockBinding: He,
                        texStorage2D: Ke,
                        texStorage3D: _t,
                        texSubImage2D: Ge,
                        texSubImage3D: Qe,
                        compressedTexSubImage2D: Be,
                        compressedTexSubImage3D: ct,
                        scissor: st,
                        viewport: ie,
                        reset: lt
                    }
                }
                function I4(e, t, n, i, s, r, l) {
                    const h = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
                      , d = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
                      , p = new ye
                      , m = new WeakMap;
                    let v;
                    const _ = new WeakMap;
                    let x = !1;
                    try {
                        x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
                    } catch {}
                    function b($, k) {
                        return x ? new OffscreenCanvas($,k) : Kg("canvas")
                    }
                    function E($, k, pe) {
                        let Ge = 1;
                        const Qe = wt($);
                        if ((Qe.width > pe || Qe.height > pe) && (Ge = pe / Math.max(Qe.width, Qe.height)),
                        Ge < 1)
                            if (typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && $ instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && $ instanceof ImageBitmap || typeof VideoFrame < "u" && $ instanceof VideoFrame) {
                                const Be = Math.floor(Ge * Qe.width)
                                  , ct = Math.floor(Ge * Qe.height);
                                v === void 0 && (v = b(Be, ct));
                                const Ke = k ? b(Be, ct) : v;
                                return Ke.width = Be,
                                Ke.height = ct,
                                Ke.getContext("2d").drawImage($, 0, 0, Be, ct),
                                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Qe.width + "x" + Qe.height + ") to (" + Be + "x" + ct + ")."),
                                Ke
                            } else
                                return "data"in $ && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Qe.width + "x" + Qe.height + ")."),
                                $;
                        return $
                    }
                    function T($) {
                        return $.generateMipmaps
                    }
                    function M($) {
                        e.generateMipmap($)
                    }
                    function D($) {
                        return $.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : $.isWebGL3DRenderTarget ? e.TEXTURE_3D : $.isWebGLArrayRenderTarget || $.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
                    }
                    function R($, k, pe, Ge, Qe=!1) {
                        if ($ !== null) {
                            if (e[$] !== void 0)
                                return e[$];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + $ + "'")
                        }
                        let Be = k;
                        if (k === e.RED && (pe === e.FLOAT && (Be = e.R32F),
                        pe === e.HALF_FLOAT && (Be = e.R16F),
                        pe === e.UNSIGNED_BYTE && (Be = e.R8)),
                        k === e.RED_INTEGER && (pe === e.UNSIGNED_BYTE && (Be = e.R8UI),
                        pe === e.UNSIGNED_SHORT && (Be = e.R16UI),
                        pe === e.UNSIGNED_INT && (Be = e.R32UI),
                        pe === e.BYTE && (Be = e.R8I),
                        pe === e.SHORT && (Be = e.R16I),
                        pe === e.INT && (Be = e.R32I)),
                        k === e.RG && (pe === e.FLOAT && (Be = e.RG32F),
                        pe === e.HALF_FLOAT && (Be = e.RG16F),
                        pe === e.UNSIGNED_BYTE && (Be = e.RG8)),
                        k === e.RG_INTEGER && (pe === e.UNSIGNED_BYTE && (Be = e.RG8UI),
                        pe === e.UNSIGNED_SHORT && (Be = e.RG16UI),
                        pe === e.UNSIGNED_INT && (Be = e.RG32UI),
                        pe === e.BYTE && (Be = e.RG8I),
                        pe === e.SHORT && (Be = e.RG16I),
                        pe === e.INT && (Be = e.RG32I)),
                        k === e.RGB_INTEGER && (pe === e.UNSIGNED_BYTE && (Be = e.RGB8UI),
                        pe === e.UNSIGNED_SHORT && (Be = e.RGB16UI),
                        pe === e.UNSIGNED_INT && (Be = e.RGB32UI),
                        pe === e.BYTE && (Be = e.RGB8I),
                        pe === e.SHORT && (Be = e.RGB16I),
                        pe === e.INT && (Be = e.RGB32I)),
                        k === e.RGBA_INTEGER && (pe === e.UNSIGNED_BYTE && (Be = e.RGBA8UI),
                        pe === e.UNSIGNED_SHORT && (Be = e.RGBA16UI),
                        pe === e.UNSIGNED_INT && (Be = e.RGBA32UI),
                        pe === e.BYTE && (Be = e.RGBA8I),
                        pe === e.SHORT && (Be = e.RGBA16I),
                        pe === e.INT && (Be = e.RGBA32I)),
                        k === e.RGB && (pe === e.UNSIGNED_INT_5_9_9_9_REV && (Be = e.RGB9_E5),
                        pe === e.UNSIGNED_INT_10F_11F_11F_REV && (Be = e.R11F_G11F_B10F)),
                        k === e.RGBA) {
                            const ct = Qe ? jg : An.getTransfer(Ge);
                            pe === e.FLOAT && (Be = e.RGBA32F),
                            pe === e.HALF_FLOAT && (Be = e.RGBA16F),
                            pe === e.UNSIGNED_BYTE && (Be = ct === Wn ? e.SRGB8_ALPHA8 : e.RGBA8),
                            pe === e.UNSIGNED_SHORT_4_4_4_4 && (Be = e.RGBA4),
                            pe === e.UNSIGNED_SHORT_5_5_5_1 && (Be = e.RGB5_A1)
                        }
                        return (Be === e.R16F || Be === e.R32F || Be === e.RG16F || Be === e.RG32F || Be === e.RGBA16F || Be === e.RGBA32F) && t.get("EXT_color_buffer_float"),
                        Be
                    }
                    function O($, k) {
                        let pe;
                        return $ ? k === null || k === Il || k === nf ? pe = e.DEPTH24_STENCIL8 : k === Xs ? pe = e.DEPTH32F_STENCIL8 : k === ip && (pe = e.DEPTH24_STENCIL8,
                        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : k === null || k === Il || k === nf ? pe = e.DEPTH_COMPONENT24 : k === Xs ? pe = e.DEPTH_COMPONENT32F : k === ip && (pe = e.DEPTH_COMPONENT16),
                        pe
                    }
                    function U($, k) {
                        return T($) === !0 || $.isFramebufferTexture && $.minFilter !== ti && $.minFilter !== mi ? Math.log2(Math.max(k.width, k.height)) + 1 : $.mipmaps !== void 0 && $.mipmaps.length > 0 ? $.mipmaps.length : $.isCompressedTexture && Array.isArray($.image) ? k.mipmaps.length : 1
                    }
                    function B($) {
                        const k = $.target;
                        k.removeEventListener("dispose", B),
                        F(k),
                        k.isVideoTexture && m.delete(k)
                    }
                    function I($) {
                        const k = $.target;
                        k.removeEventListener("dispose", I),
                        L(k)
                    }
                    function F($) {
                        const k = i.get($);
                        if (k.__webglInit === void 0)
                            return;
                        const pe = $.source
                          , Ge = _.get(pe);
                        if (Ge) {
                            const Qe = Ge[k.__cacheKey];
                            Qe.usedTimes--,
                            Qe.usedTimes === 0 && P($),
                            Object.keys(Ge).length === 0 && _.delete(pe)
                        }
                        i.remove($)
                    }
                    function P($) {
                        const k = i.get($);
                        e.deleteTexture(k.__webglTexture);
                        const pe = $.source
                          , Ge = _.get(pe);
                        delete Ge[k.__cacheKey],
                        l.memory.textures--
                    }
                    function L($) {
                        const k = i.get($);
                        if ($.depthTexture && ($.depthTexture.dispose(),
                        i.remove($.depthTexture)),
                        $.isWebGLCubeRenderTarget)
                            for (let Ge = 0; Ge < 6; Ge++) {
                                if (Array.isArray(k.__webglFramebuffer[Ge]))
                                    for (let Qe = 0; Qe < k.__webglFramebuffer[Ge].length; Qe++)
                                        e.deleteFramebuffer(k.__webglFramebuffer[Ge][Qe]);
                                else
                                    e.deleteFramebuffer(k.__webglFramebuffer[Ge]);
                                k.__webglDepthbuffer && e.deleteRenderbuffer(k.__webglDepthbuffer[Ge])
                            }
                        else {
                            if (Array.isArray(k.__webglFramebuffer))
                                for (let Ge = 0; Ge < k.__webglFramebuffer.length; Ge++)
                                    e.deleteFramebuffer(k.__webglFramebuffer[Ge]);
                            else
                                e.deleteFramebuffer(k.__webglFramebuffer);
                            if (k.__webglDepthbuffer && e.deleteRenderbuffer(k.__webglDepthbuffer),
                            k.__webglMultisampledFramebuffer && e.deleteFramebuffer(k.__webglMultisampledFramebuffer),
                            k.__webglColorRenderbuffer)
                                for (let Ge = 0; Ge < k.__webglColorRenderbuffer.length; Ge++)
                                    k.__webglColorRenderbuffer[Ge] && e.deleteRenderbuffer(k.__webglColorRenderbuffer[Ge]);
                            k.__webglDepthRenderbuffer && e.deleteRenderbuffer(k.__webglDepthRenderbuffer)
                        }
                        const pe = $.textures;
                        for (let Ge = 0, Qe = pe.length; Ge < Qe; Ge++) {
                            const Be = i.get(pe[Ge]);
                            Be.__webglTexture && (e.deleteTexture(Be.__webglTexture),
                            l.memory.textures--),
                            i.remove(pe[Ge])
                        }
                        i.remove($)
                    }
                    let H = 0;
                    function Z() {
                        H = 0
                    }
                    function K() {
                        const $ = H;
                        return $ >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + $ + " texture units while this GPU supports only " + s.maxTextures),
                        H += 1,
                        $
                    }
                    function te($) {
                        const k = [];
                        return k.push($.wrapS),
                        k.push($.wrapT),
                        k.push($.wrapR || 0),
                        k.push($.magFilter),
                        k.push($.minFilter),
                        k.push($.anisotropy),
                        k.push($.internalFormat),
                        k.push($.format),
                        k.push($.type),
                        k.push($.generateMipmaps),
                        k.push($.premultiplyAlpha),
                        k.push($.flipY),
                        k.push($.unpackAlignment),
                        k.push($.colorSpace),
                        k.join()
                    }
                    function ce($, k) {
                        const pe = i.get($);
                        if ($.isVideoTexture && xt($),
                        $.isRenderTargetTexture === !1 && $.isExternalTexture !== !0 && $.version > 0 && pe.__version !== $.version) {
                            const Ge = $.image;
                            if (Ge === null)
                                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                            else if (Ge.complete === !1)
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                            else {
                                Ne(pe, $, k);
                                return
                            }
                        } else
                            $.isExternalTexture && (pe.__webglTexture = $.sourceTexture ? $.sourceTexture : null);
                        n.bindTexture(e.TEXTURE_2D, pe.__webglTexture, e.TEXTURE0 + k)
                    }
                    function G($, k) {
                        const pe = i.get($);
                        if ($.isRenderTargetTexture === !1 && $.version > 0 && pe.__version !== $.version) {
                            Ne(pe, $, k);
                            return
                        }
                        n.bindTexture(e.TEXTURE_2D_ARRAY, pe.__webglTexture, e.TEXTURE0 + k)
                    }
                    function V($, k) {
                        const pe = i.get($);
                        if ($.isRenderTargetTexture === !1 && $.version > 0 && pe.__version !== $.version) {
                            Ne(pe, $, k);
                            return
                        }
                        n.bindTexture(e.TEXTURE_3D, pe.__webglTexture, e.TEXTURE0 + k)
                    }
                    function q($, k) {
                        const pe = i.get($);
                        if ($.version > 0 && pe.__version !== $.version) {
                            be(pe, $, k);
                            return
                        }
                        n.bindTexture(e.TEXTURE_CUBE_MAP, pe.__webglTexture, e.TEXTURE0 + k)
                    }
                    const ee = {
                        [Uu]: e.REPEAT,
                        [no]: e.CLAMP_TO_EDGE,
                        [Fg]: e.MIRRORED_REPEAT
                    }
                      , se = {
                        [ti]: e.NEAREST,
                        [dA]: e.NEAREST_MIPMAP_NEAREST,
                        [np]: e.NEAREST_MIPMAP_LINEAR,
                        [mi]: e.LINEAR,
                        [Hg]: e.LINEAR_MIPMAP_NEAREST,
                        [Pl]: e.LINEAR_MIPMAP_LINEAR
                    }
                      , X = {
                        [GE]: e.NEVER,
                        [jE]: e.ALWAYS,
                        [kE]: e.LESS,
                        [AA]: e.LEQUAL,
                        [XE]: e.EQUAL,
                        [WE]: e.GEQUAL,
                        [qE]: e.GREATER,
                        [YE]: e.NOTEQUAL
                    };
                    function J($, k) {
                        if (k.type === Xs && t.has("OES_texture_float_linear") === !1 && (k.magFilter === mi || k.magFilter === Hg || k.magFilter === np || k.magFilter === Pl || k.minFilter === mi || k.minFilter === Hg || k.minFilter === np || k.minFilter === Pl) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                        e.texParameteri($, e.TEXTURE_WRAP_S, ee[k.wrapS]),
                        e.texParameteri($, e.TEXTURE_WRAP_T, ee[k.wrapT]),
                        ($ === e.TEXTURE_3D || $ === e.TEXTURE_2D_ARRAY) && e.texParameteri($, e.TEXTURE_WRAP_R, ee[k.wrapR]),
                        e.texParameteri($, e.TEXTURE_MAG_FILTER, se[k.magFilter]),
                        e.texParameteri($, e.TEXTURE_MIN_FILTER, se[k.minFilter]),
                        k.compareFunction && (e.texParameteri($, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                        e.texParameteri($, e.TEXTURE_COMPARE_FUNC, X[k.compareFunction])),
                        t.has("EXT_texture_filter_anisotropic") === !0) {
                            if (k.magFilter === ti || k.minFilter !== np && k.minFilter !== Pl || k.type === Xs && t.has("OES_texture_float_linear") === !1)
                                return;
                            if (k.anisotropy > 1 || i.get(k).__currentAnisotropy) {
                                const pe = t.get("EXT_texture_filter_anisotropic");
                                e.texParameterf($, pe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(k.anisotropy, s.getMaxAnisotropy())),
                                i.get(k).__currentAnisotropy = k.anisotropy
                            }
                        }
                    }
                    function ze($, k) {
                        let pe = !1;
                        $.__webglInit === void 0 && ($.__webglInit = !0,
                        k.addEventListener("dispose", B));
                        const Ge = k.source;
                        let Qe = _.get(Ge);
                        Qe === void 0 && (Qe = {},
                        _.set(Ge, Qe));
                        const Be = te(k);
                        if (Be !== $.__cacheKey) {
                            Qe[Be] === void 0 && (Qe[Be] = {
                                texture: e.createTexture(),
                                usedTimes: 0
                            },
                            l.memory.textures++,
                            pe = !0),
                            Qe[Be].usedTimes++;
                            const ct = Qe[$.__cacheKey];
                            ct !== void 0 && (Qe[$.__cacheKey].usedTimes--,
                            ct.usedTimes === 0 && P(k)),
                            $.__cacheKey = Be,
                            $.__webglTexture = Qe[Be].texture
                        }
                        return pe
                    }
                    function xe($, k, pe) {
                        return Math.floor(Math.floor($ / pe) / k)
                    }
                    function le($, k, pe, Ge) {
                        const Be = $.updateRanges;
                        if (Be.length === 0)
                            n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, k.width, k.height, pe, Ge, k.data);
                        else {
                            Be.sort( (et, st) => et.start - st.start);
                            let ct = 0;
                            for (let et = 1; et < Be.length; et++) {
                                const st = Be[ct]
                                  , ie = Be[et]
                                  , Re = st.start + st.count
                                  , He = xe(ie.start, k.width, 4)
                                  , lt = xe(st.start, k.width, 4);
                                ie.start <= Re + 1 && He === lt && xe(ie.start + ie.count - 1, k.width, 4) === He ? st.count = Math.max(st.count, ie.start + ie.count - st.start) : (++ct,
                                Be[ct] = ie)
                            }
                            Be.length = ct + 1;
                            const Ke = e.getParameter(e.UNPACK_ROW_LENGTH)
                              , _t = e.getParameter(e.UNPACK_SKIP_PIXELS)
                              , Ct = e.getParameter(e.UNPACK_SKIP_ROWS);
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, k.width);
                            for (let et = 0, st = Be.length; et < st; et++) {
                                const ie = Be[et]
                                  , Re = Math.floor(ie.start / 4)
                                  , He = Math.ceil(ie.count / 4)
                                  , lt = Re % k.width
                                  , ae = Math.floor(Re / k.width)
                                  , ot = He
                                  , tt = 1;
                                e.pixelStorei(e.UNPACK_SKIP_PIXELS, lt),
                                e.pixelStorei(e.UNPACK_SKIP_ROWS, ae),
                                n.texSubImage2D(e.TEXTURE_2D, 0, lt, ae, ot, tt, pe, Ge, k.data)
                            }
                            $.clearUpdateRanges(),
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, Ke),
                            e.pixelStorei(e.UNPACK_SKIP_PIXELS, _t),
                            e.pixelStorei(e.UNPACK_SKIP_ROWS, Ct)
                        }
                    }
                    function Ne($, k, pe) {
                        let Ge = e.TEXTURE_2D;
                        (k.isDataArrayTexture || k.isCompressedArrayTexture) && (Ge = e.TEXTURE_2D_ARRAY),
                        k.isData3DTexture && (Ge = e.TEXTURE_3D);
                        const Qe = ze($, k)
                          , Be = k.source;
                        n.bindTexture(Ge, $.__webglTexture, e.TEXTURE0 + pe);
                        const ct = i.get(Be);
                        if (Be.version !== ct.__version || Qe === !0) {
                            n.activeTexture(e.TEXTURE0 + pe);
                            const Ke = An.getPrimaries(An.workingColorSpace)
                              , _t = k.colorSpace === Ho ? null : An.getPrimaries(k.colorSpace)
                              , Ct = k.colorSpace === Ho || Ke === _t ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, k.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, k.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ct);
                            let et = E(k.image, !1, s.maxTextureSize);
                            et = yt(k, et);
                            const st = r.convert(k.format, k.colorSpace)
                              , ie = r.convert(k.type);
                            let Re = R(k.internalFormat, st, ie, k.colorSpace, k.isVideoTexture);
                            J(Ge, k);
                            let He;
                            const lt = k.mipmaps
                              , ae = k.isVideoTexture !== !0
                              , ot = ct.__version === void 0 || Qe === !0
                              , tt = Be.dataReady
                              , gt = U(k, et);
                            if (k.isDepthTexture)
                                Re = O(k.format === sf, k.type),
                                ot && (ae ? n.texStorage2D(e.TEXTURE_2D, 1, Re, et.width, et.height) : n.texImage2D(e.TEXTURE_2D, 0, Re, et.width, et.height, 0, st, ie, null));
                            else if (k.isDataTexture)
                                if (lt.length > 0) {
                                    ae && ot && n.texStorage2D(e.TEXTURE_2D, gt, Re, lt[0].width, lt[0].height);
                                    for (let Je = 0, ke = lt.length; Je < ke; Je++)
                                        He = lt[Je],
                                        ae ? tt && n.texSubImage2D(e.TEXTURE_2D, Je, 0, 0, He.width, He.height, st, ie, He.data) : n.texImage2D(e.TEXTURE_2D, Je, Re, He.width, He.height, 0, st, ie, He.data);
                                    k.generateMipmaps = !1
                                } else
                                    ae ? (ot && n.texStorage2D(e.TEXTURE_2D, gt, Re, et.width, et.height),
                                    tt && le(k, et, st, ie)) : n.texImage2D(e.TEXTURE_2D, 0, Re, et.width, et.height, 0, st, ie, et.data);
                            else if (k.isCompressedTexture)
                                if (k.isCompressedArrayTexture) {
                                    ae && ot && n.texStorage3D(e.TEXTURE_2D_ARRAY, gt, Re, lt[0].width, lt[0].height, et.depth);
                                    for (let Je = 0, ke = lt.length; Je < ke; Je++)
                                        if (He = lt[Je],
                                        k.format !== ss)
                                            if (st !== null)
                                                if (ae) {
                                                    if (tt)
                                                        if (k.layerUpdates.size > 0) {
                                                            const ht = XT(He.width, He.height, k.format, k.type);
                                                            for (const Mt of k.layerUpdates) {
                                                                const Tn = He.data.subarray(Mt * ht / He.data.BYTES_PER_ELEMENT, (Mt + 1) * ht / He.data.BYTES_PER_ELEMENT);
                                                                n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, Je, 0, 0, Mt, He.width, He.height, 1, st, Tn)
                                                            }
                                                            k.clearLayerUpdates()
                                                        } else
                                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, Je, 0, 0, 0, He.width, He.height, et.depth, st, He.data)
                                                } else
                                                    n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, Je, Re, He.width, He.height, et.depth, 0, He.data, 0, 0);
                                            else
                                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                        else
                                            ae ? tt && n.texSubImage3D(e.TEXTURE_2D_ARRAY, Je, 0, 0, 0, He.width, He.height, et.depth, st, ie, He.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, Je, Re, He.width, He.height, et.depth, 0, st, ie, He.data)
                                } else {
                                    ae && ot && n.texStorage2D(e.TEXTURE_2D, gt, Re, lt[0].width, lt[0].height);
                                    for (let Je = 0, ke = lt.length; Je < ke; Je++)
                                        He = lt[Je],
                                        k.format !== ss ? st !== null ? ae ? tt && n.compressedTexSubImage2D(e.TEXTURE_2D, Je, 0, 0, He.width, He.height, st, He.data) : n.compressedTexImage2D(e.TEXTURE_2D, Je, Re, He.width, He.height, 0, He.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ae ? tt && n.texSubImage2D(e.TEXTURE_2D, Je, 0, 0, He.width, He.height, st, ie, He.data) : n.texImage2D(e.TEXTURE_2D, Je, Re, He.width, He.height, 0, st, ie, He.data)
                                }
                            else if (k.isDataArrayTexture)
                                if (ae) {
                                    if (ot && n.texStorage3D(e.TEXTURE_2D_ARRAY, gt, Re, et.width, et.height, et.depth),
                                    tt)
                                        if (k.layerUpdates.size > 0) {
                                            const Je = XT(et.width, et.height, k.format, k.type);
                                            for (const ke of k.layerUpdates) {
                                                const ht = et.data.subarray(ke * Je / et.data.BYTES_PER_ELEMENT, (ke + 1) * Je / et.data.BYTES_PER_ELEMENT);
                                                n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, ke, et.width, et.height, 1, st, ie, ht)
                                            }
                                            k.clearLayerUpdates()
                                        } else
                                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, et.width, et.height, et.depth, st, ie, et.data)
                                } else
                                    n.texImage3D(e.TEXTURE_2D_ARRAY, 0, Re, et.width, et.height, et.depth, 0, st, ie, et.data);
                            else if (k.isData3DTexture)
                                ae ? (ot && n.texStorage3D(e.TEXTURE_3D, gt, Re, et.width, et.height, et.depth),
                                tt && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, et.width, et.height, et.depth, st, ie, et.data)) : n.texImage3D(e.TEXTURE_3D, 0, Re, et.width, et.height, et.depth, 0, st, ie, et.data);
                            else if (k.isFramebufferTexture) {
                                if (ot)
                                    if (ae)
                                        n.texStorage2D(e.TEXTURE_2D, gt, Re, et.width, et.height);
                                    else {
                                        let Je = et.width
                                          , ke = et.height;
                                        for (let ht = 0; ht < gt; ht++)
                                            n.texImage2D(e.TEXTURE_2D, ht, Re, Je, ke, 0, st, ie, null),
                                            Je >>= 1,
                                            ke >>= 1
                                    }
                            } else if (lt.length > 0) {
                                if (ae && ot) {
                                    const Je = wt(lt[0]);
                                    n.texStorage2D(e.TEXTURE_2D, gt, Re, Je.width, Je.height)
                                }
                                for (let Je = 0, ke = lt.length; Je < ke; Je++)
                                    He = lt[Je],
                                    ae ? tt && n.texSubImage2D(e.TEXTURE_2D, Je, 0, 0, st, ie, He) : n.texImage2D(e.TEXTURE_2D, Je, Re, st, ie, He);
                                k.generateMipmaps = !1
                            } else if (ae) {
                                if (ot) {
                                    const Je = wt(et);
                                    n.texStorage2D(e.TEXTURE_2D, gt, Re, Je.width, Je.height)
                                }
                                tt && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, st, ie, et)
                            } else
                                n.texImage2D(e.TEXTURE_2D, 0, Re, st, ie, et);
                            T(k) && M(Ge),
                            ct.__version = Be.version,
                            k.onUpdate && k.onUpdate(k)
                        }
                        $.__version = k.version
                    }
                    function be($, k, pe) {
                        if (k.image.length !== 6)
                            return;
                        const Ge = ze($, k)
                          , Qe = k.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, $.__webglTexture, e.TEXTURE0 + pe);
                        const Be = i.get(Qe);
                        if (Qe.version !== Be.__version || Ge === !0) {
                            n.activeTexture(e.TEXTURE0 + pe);
                            const ct = An.getPrimaries(An.workingColorSpace)
                              , Ke = k.colorSpace === Ho ? null : An.getPrimaries(k.colorSpace)
                              , _t = k.colorSpace === Ho || ct === Ke ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, k.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, k.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, _t);
                            const Ct = k.isCompressedTexture || k.image[0].isCompressedTexture
                              , et = k.image[0] && k.image[0].isDataTexture
                              , st = [];
                            for (let ke = 0; ke < 6; ke++)
                                !Ct && !et ? st[ke] = E(k.image[ke], !0, s.maxCubemapSize) : st[ke] = et ? k.image[ke].image : k.image[ke],
                                st[ke] = yt(k, st[ke]);
                            const ie = st[0]
                              , Re = r.convert(k.format, k.colorSpace)
                              , He = r.convert(k.type)
                              , lt = R(k.internalFormat, Re, He, k.colorSpace)
                              , ae = k.isVideoTexture !== !0
                              , ot = Be.__version === void 0 || Ge === !0
                              , tt = Qe.dataReady;
                            let gt = U(k, ie);
                            J(e.TEXTURE_CUBE_MAP, k);
                            let Je;
                            if (Ct) {
                                ae && ot && n.texStorage2D(e.TEXTURE_CUBE_MAP, gt, lt, ie.width, ie.height);
                                for (let ke = 0; ke < 6; ke++) {
                                    Je = st[ke].mipmaps;
                                    for (let ht = 0; ht < Je.length; ht++) {
                                        const Mt = Je[ht];
                                        k.format !== ss ? Re !== null ? ae ? tt && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht, 0, 0, Mt.width, Mt.height, Re, Mt.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht, lt, Mt.width, Mt.height, 0, Mt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ae ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht, 0, 0, Mt.width, Mt.height, Re, He, Mt.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht, lt, Mt.width, Mt.height, 0, Re, He, Mt.data)
                                    }
                                }
                            } else {
                                if (Je = k.mipmaps,
                                ae && ot) {
                                    Je.length > 0 && gt++;
                                    const ke = wt(st[0]);
                                    n.texStorage2D(e.TEXTURE_CUBE_MAP, gt, lt, ke.width, ke.height)
                                }
                                for (let ke = 0; ke < 6; ke++)
                                    if (et) {
                                        ae ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, 0, 0, st[ke].width, st[ke].height, Re, He, st[ke].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, lt, st[ke].width, st[ke].height, 0, Re, He, st[ke].data);
                                        for (let ht = 0; ht < Je.length; ht++) {
                                            const Mt = Je[ht].image[ke].image;
                                            ae ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht + 1, 0, 0, Mt.width, Mt.height, Re, He, Mt.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht + 1, lt, Mt.width, Mt.height, 0, Re, He, Mt.data)
                                        }
                                    } else {
                                        ae ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, 0, 0, Re, He, st[ke]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, 0, lt, Re, He, st[ke]);
                                        for (let ht = 0; ht < Je.length; ht++) {
                                            const Mt = Je[ht];
                                            ae ? tt && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht + 1, 0, 0, Re, He, Mt.image[ke]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + ke, ht + 1, lt, Re, He, Mt.image[ke])
                                        }
                                    }
                            }
                            T(k) && M(e.TEXTURE_CUBE_MAP),
                            Be.__version = Qe.version,
                            k.onUpdate && k.onUpdate(k)
                        }
                        $.__version = k.version
                    }
                    function Ue($, k, pe, Ge, Qe, Be) {
                        const ct = r.convert(pe.format, pe.colorSpace)
                          , Ke = r.convert(pe.type)
                          , _t = R(pe.internalFormat, ct, Ke, pe.colorSpace)
                          , Ct = i.get(k)
                          , et = i.get(pe);
                        if (et.__renderTarget = k,
                        !Ct.__hasExternalTextures) {
                            const st = Math.max(1, k.width >> Be)
                              , ie = Math.max(1, k.height >> Be);
                            Qe === e.TEXTURE_3D || Qe === e.TEXTURE_2D_ARRAY ? n.texImage3D(Qe, Be, _t, st, ie, k.depth, 0, ct, Ke, null) : n.texImage2D(Qe, Be, _t, st, ie, 0, ct, Ke, null)
                        }
                        n.bindFramebuffer(e.FRAMEBUFFER, $),
                        Fe(k) ? h.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, Ge, Qe, et.__webglTexture, 0, Ie(k)) : (Qe === e.TEXTURE_2D || Qe >= e.TEXTURE_CUBE_MAP_POSITIVE_X && Qe <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, Ge, Qe, et.__webglTexture, Be),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                    function $e($, k, pe) {
                        if (e.bindRenderbuffer(e.RENDERBUFFER, $),
                        k.depthBuffer) {
                            const Ge = k.depthTexture
                              , Qe = Ge && Ge.isDepthTexture ? Ge.type : null
                              , Be = O(k.stencilBuffer, Qe)
                              , ct = k.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                              , Ke = Ie(k);
                            Fe(k) ? h.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, Ke, Be, k.width, k.height) : pe ? e.renderbufferStorageMultisample(e.RENDERBUFFER, Ke, Be, k.width, k.height) : e.renderbufferStorage(e.RENDERBUFFER, Be, k.width, k.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, ct, e.RENDERBUFFER, $)
                        } else {
                            const Ge = k.textures;
                            for (let Qe = 0; Qe < Ge.length; Qe++) {
                                const Be = Ge[Qe]
                                  , ct = r.convert(Be.format, Be.colorSpace)
                                  , Ke = r.convert(Be.type)
                                  , _t = R(Be.internalFormat, ct, Ke, Be.colorSpace)
                                  , Ct = Ie(k);
                                pe && Fe(k) === !1 ? e.renderbufferStorageMultisample(e.RENDERBUFFER, Ct, _t, k.width, k.height) : Fe(k) ? h.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, Ct, _t, k.width, k.height) : e.renderbufferStorage(e.RENDERBUFFER, _t, k.width, k.height)
                            }
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null)
                    }
                    function rt($, k) {
                        if (k && k.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, $),
                        !(k.depthTexture && k.depthTexture.isDepthTexture))
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        const pe = i.get(k.depthTexture);
                        pe.__renderTarget = k,
                        (!pe.__webglTexture || k.depthTexture.image.width !== k.width || k.depthTexture.image.height !== k.height) && (k.depthTexture.image.width = k.width,
                        k.depthTexture.image.height = k.height,
                        k.depthTexture.needsUpdate = !0),
                        ce(k.depthTexture, 0);
                        const Ge = pe.__webglTexture
                          , Qe = Ie(k);
                        if (k.depthTexture.format === sp)
                            Fe(k) ? h.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, Ge, 0, Qe) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, Ge, 0);
                        else if (k.depthTexture.format === sf)
                            Fe(k) ? h.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, Ge, 0, Qe) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, Ge, 0);
                        else
                            throw new Error("Unknown depthTexture format")
                    }
                    function Et($) {
                        const k = i.get($)
                          , pe = $.isWebGLCubeRenderTarget === !0;
                        if (k.__boundDepthTexture !== $.depthTexture) {
                            const Ge = $.depthTexture;
                            if (k.__depthDisposeCallback && k.__depthDisposeCallback(),
                            Ge) {
                                const Qe = () => {
                                    delete k.__boundDepthTexture,
                                    delete k.__depthDisposeCallback,
                                    Ge.removeEventListener("dispose", Qe)
                                }
                                ;
                                Ge.addEventListener("dispose", Qe),
                                k.__depthDisposeCallback = Qe
                            }
                            k.__boundDepthTexture = Ge
                        }
                        if ($.depthTexture && !k.__autoAllocateDepthBuffer) {
                            if (pe)
                                throw new Error("target.depthTexture not supported in Cube render targets");
                            const Ge = $.texture.mipmaps;
                            Ge && Ge.length > 0 ? rt(k.__webglFramebuffer[0], $) : rt(k.__webglFramebuffer, $)
                        } else if (pe) {
                            k.__webglDepthbuffer = [];
                            for (let Ge = 0; Ge < 6; Ge++)
                                if (n.bindFramebuffer(e.FRAMEBUFFER, k.__webglFramebuffer[Ge]),
                                k.__webglDepthbuffer[Ge] === void 0)
                                    k.__webglDepthbuffer[Ge] = e.createRenderbuffer(),
                                    $e(k.__webglDepthbuffer[Ge], $, !1);
                                else {
                                    const Qe = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                      , Be = k.__webglDepthbuffer[Ge];
                                    e.bindRenderbuffer(e.RENDERBUFFER, Be),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, Qe, e.RENDERBUFFER, Be)
                                }
                        } else {
                            const Ge = $.texture.mipmaps;
                            if (Ge && Ge.length > 0 ? n.bindFramebuffer(e.FRAMEBUFFER, k.__webglFramebuffer[0]) : n.bindFramebuffer(e.FRAMEBUFFER, k.__webglFramebuffer),
                            k.__webglDepthbuffer === void 0)
                                k.__webglDepthbuffer = e.createRenderbuffer(),
                                $e(k.__webglDepthbuffer, $, !1);
                            else {
                                const Qe = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , Be = k.__webglDepthbuffer;
                                e.bindRenderbuffer(e.RENDERBUFFER, Be),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, Qe, e.RENDERBUFFER, Be)
                            }
                        }
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                    function ne($, k, pe) {
                        const Ge = i.get($);
                        k !== void 0 && Ue(Ge.__webglFramebuffer, $, $.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                        pe !== void 0 && Et($)
                    }
                    function Ve($) {
                        const k = $.texture
                          , pe = i.get($)
                          , Ge = i.get(k);
                        $.addEventListener("dispose", I);
                        const Qe = $.textures
                          , Be = $.isWebGLCubeRenderTarget === !0
                          , ct = Qe.length > 1;
                        if (ct || (Ge.__webglTexture === void 0 && (Ge.__webglTexture = e.createTexture()),
                        Ge.__version = k.version,
                        l.memory.textures++),
                        Be) {
                            pe.__webglFramebuffer = [];
                            for (let Ke = 0; Ke < 6; Ke++)
                                if (k.mipmaps && k.mipmaps.length > 0) {
                                    pe.__webglFramebuffer[Ke] = [];
                                    for (let _t = 0; _t < k.mipmaps.length; _t++)
                                        pe.__webglFramebuffer[Ke][_t] = e.createFramebuffer()
                                } else
                                    pe.__webglFramebuffer[Ke] = e.createFramebuffer()
                        } else {
                            if (k.mipmaps && k.mipmaps.length > 0) {
                                pe.__webglFramebuffer = [];
                                for (let Ke = 0; Ke < k.mipmaps.length; Ke++)
                                    pe.__webglFramebuffer[Ke] = e.createFramebuffer()
                            } else
                                pe.__webglFramebuffer = e.createFramebuffer();
                            if (ct)
                                for (let Ke = 0, _t = Qe.length; Ke < _t; Ke++) {
                                    const Ct = i.get(Qe[Ke]);
                                    Ct.__webglTexture === void 0 && (Ct.__webglTexture = e.createTexture(),
                                    l.memory.textures++)
                                }
                            if ($.samples > 0 && Fe($) === !1) {
                                pe.__webglMultisampledFramebuffer = e.createFramebuffer(),
                                pe.__webglColorRenderbuffer = [],
                                n.bindFramebuffer(e.FRAMEBUFFER, pe.__webglMultisampledFramebuffer);
                                for (let Ke = 0; Ke < Qe.length; Ke++) {
                                    const _t = Qe[Ke];
                                    pe.__webglColorRenderbuffer[Ke] = e.createRenderbuffer(),
                                    e.bindRenderbuffer(e.RENDERBUFFER, pe.__webglColorRenderbuffer[Ke]);
                                    const Ct = r.convert(_t.format, _t.colorSpace)
                                      , et = r.convert(_t.type)
                                      , st = R(_t.internalFormat, Ct, et, _t.colorSpace, $.isXRRenderTarget === !0)
                                      , ie = Ie($);
                                    e.renderbufferStorageMultisample(e.RENDERBUFFER, ie, st, $.width, $.height),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ke, e.RENDERBUFFER, pe.__webglColorRenderbuffer[Ke])
                                }
                                e.bindRenderbuffer(e.RENDERBUFFER, null),
                                $.depthBuffer && (pe.__webglDepthRenderbuffer = e.createRenderbuffer(),
                                $e(pe.__webglDepthRenderbuffer, $, !0)),
                                n.bindFramebuffer(e.FRAMEBUFFER, null)
                            }
                        }
                        if (Be) {
                            n.bindTexture(e.TEXTURE_CUBE_MAP, Ge.__webglTexture),
                            J(e.TEXTURE_CUBE_MAP, k);
                            for (let Ke = 0; Ke < 6; Ke++)
                                if (k.mipmaps && k.mipmaps.length > 0)
                                    for (let _t = 0; _t < k.mipmaps.length; _t++)
                                        Ue(pe.__webglFramebuffer[Ke][_t], $, k, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + Ke, _t);
                                else
                                    Ue(pe.__webglFramebuffer[Ke], $, k, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + Ke, 0);
                            T(k) && M(e.TEXTURE_CUBE_MAP),
                            n.unbindTexture()
                        } else if (ct) {
                            for (let Ke = 0, _t = Qe.length; Ke < _t; Ke++) {
                                const Ct = Qe[Ke]
                                  , et = i.get(Ct);
                                let st = e.TEXTURE_2D;
                                ($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) && (st = $.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                                n.bindTexture(st, et.__webglTexture),
                                J(st, Ct),
                                Ue(pe.__webglFramebuffer, $, Ct, e.COLOR_ATTACHMENT0 + Ke, st, 0),
                                T(Ct) && M(st)
                            }
                            n.unbindTexture()
                        } else {
                            let Ke = e.TEXTURE_2D;
                            if (($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) && (Ke = $.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                            n.bindTexture(Ke, Ge.__webglTexture),
                            J(Ke, k),
                            k.mipmaps && k.mipmaps.length > 0)
                                for (let _t = 0; _t < k.mipmaps.length; _t++)
                                    Ue(pe.__webglFramebuffer[_t], $, k, e.COLOR_ATTACHMENT0, Ke, _t);
                            else
                                Ue(pe.__webglFramebuffer, $, k, e.COLOR_ATTACHMENT0, Ke, 0);
                            T(k) && M(Ke),
                            n.unbindTexture()
                        }
                        $.depthBuffer && Et($)
                    }
                    function de($) {
                        const k = $.textures;
                        for (let pe = 0, Ge = k.length; pe < Ge; pe++) {
                            const Qe = k[pe];
                            if (T(Qe)) {
                                const Be = D($)
                                  , ct = i.get(Qe).__webglTexture;
                                n.bindTexture(Be, ct),
                                M(Be),
                                n.unbindTexture()
                            }
                        }
                    }
                    const Te = []
                      , Pe = [];
                    function Ye($) {
                        if ($.samples > 0) {
                            if (Fe($) === !1) {
                                const k = $.textures
                                  , pe = $.width
                                  , Ge = $.height;
                                let Qe = e.COLOR_BUFFER_BIT;
                                const Be = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , ct = i.get($)
                                  , Ke = k.length > 1;
                                if (Ke)
                                    for (let Ct = 0; Ct < k.length; Ct++)
                                        n.bindFramebuffer(e.FRAMEBUFFER, ct.__webglMultisampledFramebuffer),
                                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.RENDERBUFFER, null),
                                        n.bindFramebuffer(e.FRAMEBUFFER, ct.__webglFramebuffer),
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.TEXTURE_2D, null, 0);
                                n.bindFramebuffer(e.READ_FRAMEBUFFER, ct.__webglMultisampledFramebuffer);
                                const _t = $.texture.mipmaps;
                                _t && _t.length > 0 ? n.bindFramebuffer(e.DRAW_FRAMEBUFFER, ct.__webglFramebuffer[0]) : n.bindFramebuffer(e.DRAW_FRAMEBUFFER, ct.__webglFramebuffer);
                                for (let Ct = 0; Ct < k.length; Ct++) {
                                    if ($.resolveDepthBuffer && ($.depthBuffer && (Qe |= e.DEPTH_BUFFER_BIT),
                                    $.stencilBuffer && $.resolveStencilBuffer && (Qe |= e.STENCIL_BUFFER_BIT)),
                                    Ke) {
                                        e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, ct.__webglColorRenderbuffer[Ct]);
                                        const et = i.get(k[Ct]).__webglTexture;
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, et, 0)
                                    }
                                    e.blitFramebuffer(0, 0, pe, Ge, 0, 0, pe, Ge, Qe, e.NEAREST),
                                    d === !0 && (Te.length = 0,
                                    Pe.length = 0,
                                    Te.push(e.COLOR_ATTACHMENT0 + Ct),
                                    $.depthBuffer && $.resolveDepthBuffer === !1 && (Te.push(Be),
                                    Pe.push(Be),
                                    e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, Pe)),
                                    e.invalidateFramebuffer(e.READ_FRAMEBUFFER, Te))
                                }
                                if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                                Ke)
                                    for (let Ct = 0; Ct < k.length; Ct++) {
                                        n.bindFramebuffer(e.FRAMEBUFFER, ct.__webglMultisampledFramebuffer),
                                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.RENDERBUFFER, ct.__webglColorRenderbuffer[Ct]);
                                        const et = i.get(k[Ct]).__webglTexture;
                                        n.bindFramebuffer(e.FRAMEBUFFER, ct.__webglFramebuffer),
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.TEXTURE_2D, et, 0)
                                    }
                                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, ct.__webglMultisampledFramebuffer)
                            } else if ($.depthBuffer && $.resolveDepthBuffer === !1 && d) {
                                const k = $.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [k])
                            }
                        }
                    }
                    function Ie($) {
                        return Math.min(s.maxSamples, $.samples)
                    }
                    function Fe($) {
                        const k = i.get($);
                        return $.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && k.__useRenderToTexture !== !1
                    }
                    function xt($) {
                        const k = l.render.frame;
                        m.get($) !== k && (m.set($, k),
                        $.update())
                    }
                    function yt($, k) {
                        const pe = $.colorSpace
                          , Ge = $.format
                          , Qe = $.type;
                        return $.isCompressedTexture === !0 || $.isVideoTexture === !0 || pe !== Ll && pe !== Ho && (An.getTransfer(pe) === Wn ? (Ge !== ss || Qe !== ui) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", pe)),
                        k
                    }
                    function wt($) {
                        return typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement ? (p.width = $.naturalWidth || $.width,
                        p.height = $.naturalHeight || $.height) : typeof VideoFrame < "u" && $ instanceof VideoFrame ? (p.width = $.displayWidth,
                        p.height = $.displayHeight) : (p.width = $.width,
                        p.height = $.height),
                        p
                    }
                    this.allocateTextureUnit = K,
                    this.resetTextureUnits = Z,
                    this.setTexture2D = ce,
                    this.setTexture2DArray = G,
                    this.setTexture3D = V,
                    this.setTextureCube = q,
                    this.rebindTextures = ne,
                    this.setupRenderTarget = Ve,
                    this.updateRenderTargetMipmap = de,
                    this.updateMultisampleRenderTarget = Ye,
                    this.setupDepthRenderbuffer = Et,
                    this.setupFrameBufferTexture = Ue,
                    this.useMultisampledRTT = Fe
                }
                function Z1(e, t) {
                    function n(i, s=Ho) {
                        let r;
                        const l = An.getTransfer(s);
                        if (i === ui)
                            return e.UNSIGNED_BYTE;
                        if (i === Ly)
                            return e.UNSIGNED_SHORT_4_4_4_4;
                        if (i === zy)
                            return e.UNSIGNED_SHORT_5_5_5_1;
                        if (i === gA)
                            return e.UNSIGNED_INT_5_9_9_9_REV;
                        if (i === vA)
                            return e.UNSIGNED_INT_10F_11F_11F_REV;
                        if (i === pA)
                            return e.BYTE;
                        if (i === mA)
                            return e.SHORT;
                        if (i === ip)
                            return e.UNSIGNED_SHORT;
                        if (i === Iy)
                            return e.INT;
                        if (i === Il)
                            return e.UNSIGNED_INT;
                        if (i === Xs)
                            return e.FLOAT;
                        if (i === tf)
                            return e.HALF_FLOAT;
                        if (i === yA)
                            return e.ALPHA;
                        if (i === _A)
                            return e.RGB;
                        if (i === ss)
                            return e.RGBA;
                        if (i === sp)
                            return e.DEPTH_COMPONENT;
                        if (i === sf)
                            return e.DEPTH_STENCIL;
                        if (i === ap)
                            return e.RED;
                        if (i === Vg)
                            return e.RED_INTEGER;
                        if (i === Fy)
                            return e.RG;
                        if (i === Hy)
                            return e.RG_INTEGER;
                        if (i === Vy)
                            return e.RGBA_INTEGER;
                        if (i === Gg || i === kg || i === Xg || i === qg)
                            if (l === Wn)
                                if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                                r !== null) {
                                    if (i === Gg)
                                        return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (i === kg)
                                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (i === Xg)
                                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (i === qg)
                                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                } else
                                    return null;
                            else if (r = t.get("WEBGL_compressed_texture_s3tc"),
                            r !== null) {
                                if (i === Gg)
                                    return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (i === kg)
                                    return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (i === Xg)
                                    return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (i === qg)
                                    return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } else
                                return null;
                        if (i === Gy || i === ky || i === Xy || i === qy)
                            if (r = t.get("WEBGL_compressed_texture_pvrtc"),
                            r !== null) {
                                if (i === Gy)
                                    return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (i === ky)
                                    return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (i === Xy)
                                    return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (i === qy)
                                    return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            } else
                                return null;
                        if (i === Yy || i === Wy || i === jy)
                            if (r = t.get("WEBGL_compressed_texture_etc"),
                            r !== null) {
                                if (i === Yy || i === Wy)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                                if (i === jy)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                            } else
                                return null;
                        if (i === Qy || i === Zy || i === Ky || i === Jy || i === $y || i === e_ || i === t_ || i === n_ || i === i_ || i === s_ || i === a_ || i === r_ || i === o_ || i === l_)
                            if (r = t.get("WEBGL_compressed_texture_astc"),
                            r !== null) {
                                if (i === Qy)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (i === Zy)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (i === Ky)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (i === Jy)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (i === $y)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (i === e_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (i === t_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (i === n_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (i === i_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (i === s_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (i === a_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (i === r_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (i === o_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (i === l_)
                                    return l === Wn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                            } else
                                return null;
                        if (i === c_ || i === u_ || i === h_)
                            if (r = t.get("EXT_texture_compression_bptc"),
                            r !== null) {
                                if (i === c_)
                                    return l === Wn ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (i === u_)
                                    return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (i === h_)
                                    return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            } else
                                return null;
                        if (i === f_ || i === d_ || i === p_ || i === m_)
                            if (r = t.get("EXT_texture_compression_rgtc"),
                            r !== null) {
                                if (i === f_)
                                    return r.COMPRESSED_RED_RGTC1_EXT;
                                if (i === d_)
                                    return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (i === p_)
                                    return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (i === m_)
                                    return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            } else
                                return null;
                        return i === nf ? e.UNSIGNED_INT_24_8 : e[i] !== void 0 ? e[i] : null
                    }
                    return {
                        convert: n
                    }
                }
                const L4 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
                  , z4 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
                var F4 = class {
                    constructor() {
                        this.texture = null,
                        this.mesh = null,
                        this.depthNear = 0,
                        this.depthFar = 0
                    }
                    init(e, t) {
                        if (this.texture === null) {
                            const n = new aT(e.texture);
                            (e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) && (this.depthNear = e.depthNear,
                            this.depthFar = e.depthFar),
                            this.texture = n
                        }
                    }
                    getMesh(e) {
                        if (this.texture !== null && this.mesh === null) {
                            const t = e.cameras[0].viewport
                              , n = new Fn({
                                vertexShader: L4,
                                fragmentShader: z4,
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: t.z
                                    },
                                    depthHeight: {
                                        value: t.w
                                    }
                                }
                            });
                            this.mesh = new Fi(new ux(20,20),n)
                        }
                        return this.mesh
                    }
                    reset() {
                        this.texture = null,
                        this.mesh = null
                    }
                    getDepthTexture() {
                        return this.texture
                    }
                }
                  , H4 = class extends Er {
                    constructor(e, t) {
                        super();
                        const n = this;
                        let i = null
                          , s = 1
                          , r = null
                          , l = "local-floor"
                          , h = 1
                          , d = null
                          , p = null
                          , m = null
                          , v = null
                          , _ = null
                          , x = null;
                        const b = typeof XRWebGLBinding < "u"
                          , E = new F4
                          , T = {}
                          , M = t.getContextAttributes();
                        let D = null
                          , R = null;
                        const O = []
                          , U = []
                          , B = new ye;
                        let I = null;
                        const F = new hi;
                        F.viewport = new gn;
                        const P = new hi;
                        P.viewport = new gn;
                        const L = [F, P]
                          , H = new r1;
                        let Z = null
                          , K = null;
                        this.cameraAutoUpdate = !0,
                        this.enabled = !1,
                        this.isPresenting = !1,
                        this.getController = function(le) {
                            let Ne = O[le];
                            return Ne === void 0 && (Ne = new L_,
                            O[le] = Ne),
                            Ne.getTargetRaySpace()
                        }
                        ,
                        this.getControllerGrip = function(le) {
                            let Ne = O[le];
                            return Ne === void 0 && (Ne = new L_,
                            O[le] = Ne),
                            Ne.getGripSpace()
                        }
                        ,
                        this.getHand = function(le) {
                            let Ne = O[le];
                            return Ne === void 0 && (Ne = new L_,
                            O[le] = Ne),
                            Ne.getHandSpace()
                        }
                        ;
                        function te(le) {
                            const Ne = U.indexOf(le.inputSource);
                            if (Ne === -1)
                                return;
                            const be = O[Ne];
                            be !== void 0 && (be.update(le.inputSource, le.frame, d || r),
                            be.dispatchEvent({
                                type: le.type,
                                data: le.inputSource
                            }))
                        }
                        function ce() {
                            i.removeEventListener("select", te),
                            i.removeEventListener("selectstart", te),
                            i.removeEventListener("selectend", te),
                            i.removeEventListener("squeeze", te),
                            i.removeEventListener("squeezestart", te),
                            i.removeEventListener("squeezeend", te),
                            i.removeEventListener("end", ce),
                            i.removeEventListener("inputsourceschange", G);
                            for (let le = 0; le < O.length; le++) {
                                const Ne = U[le];
                                Ne !== null && (U[le] = null,
                                O[le].disconnect(Ne))
                            }
                            Z = null,
                            K = null,
                            E.reset();
                            for (const le in T)
                                delete T[le];
                            e.setRenderTarget(D),
                            _ = null,
                            v = null,
                            m = null,
                            i = null,
                            R = null,
                            xe.stop(),
                            n.isPresenting = !1,
                            e.setPixelRatio(I),
                            e.setSize(B.width, B.height, !1),
                            n.dispatchEvent({
                                type: "sessionend"
                            })
                        }
                        this.setFramebufferScaleFactor = function(le) {
                            s = le,
                            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }
                        ,
                        this.setReferenceSpaceType = function(le) {
                            l = le,
                            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }
                        ,
                        this.getReferenceSpace = function() {
                            return d || r
                        }
                        ,
                        this.setReferenceSpace = function(le) {
                            d = le
                        }
                        ,
                        this.getBaseLayer = function() {
                            return v !== null ? v : _
                        }
                        ,
                        this.getBinding = function() {
                            return m === null && b && (m = new XRWebGLBinding(i,t)),
                            m
                        }
                        ,
                        this.getFrame = function() {
                            return x
                        }
                        ,
                        this.getSession = function() {
                            return i
                        }
                        ,
                        this.setSession = async function(le) {
                            if (i = le,
                            i !== null) {
                                if (D = e.getRenderTarget(),
                                i.addEventListener("select", te),
                                i.addEventListener("selectstart", te),
                                i.addEventListener("selectend", te),
                                i.addEventListener("squeeze", te),
                                i.addEventListener("squeezestart", te),
                                i.addEventListener("squeezeend", te),
                                i.addEventListener("end", ce),
                                i.addEventListener("inputsourceschange", G),
                                M.xrCompatible !== !0 && await t.makeXRCompatible(),
                                I = e.getPixelRatio(),
                                e.getSize(B),
                                b && "createProjectionLayer"in XRWebGLBinding.prototype) {
                                    let Ne = null
                                      , be = null
                                      , Ue = null;
                                    M.depth && (Ue = M.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                                    Ne = M.stencil ? sf : sp,
                                    be = M.stencil ? nf : Il);
                                    const $e = {
                                        colorFormat: t.RGBA8,
                                        depthFormat: Ue,
                                        scaleFactor: s
                                    };
                                    m = this.getBinding(),
                                    v = m.createProjectionLayer($e),
                                    i.updateRenderState({
                                        layers: [v]
                                    }),
                                    e.setPixelRatio(1),
                                    e.setSize(v.textureWidth, v.textureHeight, !1),
                                    R = new Un(v.textureWidth,v.textureHeight,{
                                        format: ss,
                                        type: ui,
                                        depthTexture: new mv(v.textureWidth,v.textureHeight,be,void 0,void 0,void 0,void 0,void 0,void 0,Ne),
                                        stencilBuffer: M.stencil,
                                        colorSpace: e.outputColorSpace,
                                        samples: M.antialias ? 4 : 0,
                                        resolveDepthBuffer: v.ignoreDepthValues === !1,
                                        resolveStencilBuffer: v.ignoreDepthValues === !1
                                    })
                                } else {
                                    const Ne = {
                                        antialias: M.antialias,
                                        alpha: !0,
                                        depth: M.depth,
                                        stencil: M.stencil,
                                        framebufferScaleFactor: s
                                    };
                                    _ = new XRWebGLLayer(i,t,Ne),
                                    i.updateRenderState({
                                        baseLayer: _
                                    }),
                                    e.setPixelRatio(1),
                                    e.setSize(_.framebufferWidth, _.framebufferHeight, !1),
                                    R = new Un(_.framebufferWidth,_.framebufferHeight,{
                                        format: ss,
                                        type: ui,
                                        colorSpace: e.outputColorSpace,
                                        stencilBuffer: M.stencil,
                                        resolveDepthBuffer: _.ignoreDepthValues === !1,
                                        resolveStencilBuffer: _.ignoreDepthValues === !1
                                    })
                                }
                                R.isXRRenderTarget = !0,
                                this.setFoveation(h),
                                d = null,
                                r = await i.requestReferenceSpace(l),
                                xe.setContext(i),
                                xe.start(),
                                n.isPresenting = !0,
                                n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        }
                        ,
                        this.getEnvironmentBlendMode = function() {
                            if (i !== null)
                                return i.environmentBlendMode
                        }
                        ,
                        this.getDepthTexture = function() {
                            return E.getDepthTexture()
                        }
                        ;
                        function G(le) {
                            for (let Ne = 0; Ne < le.removed.length; Ne++) {
                                const be = le.removed[Ne]
                                  , Ue = U.indexOf(be);
                                Ue >= 0 && (U[Ue] = null,
                                O[Ue].disconnect(be))
                            }
                            for (let Ne = 0; Ne < le.added.length; Ne++) {
                                const be = le.added[Ne];
                                let Ue = U.indexOf(be);
                                if (Ue === -1) {
                                    for (let rt = 0; rt < O.length; rt++)
                                        if (rt >= U.length) {
                                            U.push(be),
                                            Ue = rt;
                                            break
                                        } else if (U[rt] === null) {
                                            U[rt] = be,
                                            Ue = rt;
                                            break
                                        }
                                    if (Ue === -1)
                                        break
                                }
                                const $e = O[Ue];
                                $e && $e.connect(be)
                            }
                        }
                        const V = new Q
                          , q = new Q;
                        function ee(le, Ne, be) {
                            V.setFromMatrixPosition(Ne.matrixWorld),
                            q.setFromMatrixPosition(be.matrixWorld);
                            const Ue = V.distanceTo(q)
                              , $e = Ne.projectionMatrix.elements
                              , rt = be.projectionMatrix.elements
                              , Et = $e[14] / ($e[10] - 1)
                              , ne = $e[14] / ($e[10] + 1)
                              , Ve = ($e[9] + 1) / $e[5]
                              , de = ($e[9] - 1) / $e[5]
                              , Te = ($e[8] - 1) / $e[0]
                              , Pe = (rt[8] + 1) / rt[0]
                              , Ye = Et * Te
                              , Ie = Et * Pe
                              , Fe = Ue / (-Te + Pe)
                              , xt = Fe * -Te;
                            if (Ne.matrixWorld.decompose(le.position, le.quaternion, le.scale),
                            le.translateX(xt),
                            le.translateZ(Fe),
                            le.matrixWorld.compose(le.position, le.quaternion, le.scale),
                            le.matrixWorldInverse.copy(le.matrixWorld).invert(),
                            $e[10] === -1)
                                le.projectionMatrix.copy(Ne.projectionMatrix),
                                le.projectionMatrixInverse.copy(Ne.projectionMatrixInverse);
                            else {
                                const yt = Et + Fe
                                  , wt = ne + Fe
                                  , $ = Ye - xt
                                  , k = Ie + (Ue - xt)
                                  , pe = Ve * ne / wt * yt
                                  , Ge = de * ne / wt * yt;
                                le.projectionMatrix.makePerspective($, k, pe, Ge, yt, wt),
                                le.projectionMatrixInverse.copy(le.projectionMatrix).invert()
                            }
                        }
                        function se(le, Ne) {
                            Ne === null ? le.matrixWorld.copy(le.matrix) : le.matrixWorld.multiplyMatrices(Ne.matrixWorld, le.matrix),
                            le.matrixWorldInverse.copy(le.matrixWorld).invert()
                        }
                        this.updateCamera = function(le) {
                            if (i === null)
                                return;
                            let Ne = le.near
                              , be = le.far;
                            E.texture !== null && (E.depthNear > 0 && (Ne = E.depthNear),
                            E.depthFar > 0 && (be = E.depthFar)),
                            H.near = P.near = F.near = Ne,
                            H.far = P.far = F.far = be,
                            (Z !== H.near || K !== H.far) && (i.updateRenderState({
                                depthNear: H.near,
                                depthFar: H.far
                            }),
                            Z = H.near,
                            K = H.far),
                            H.layers.mask = le.layers.mask | 6,
                            F.layers.mask = H.layers.mask & 3,
                            P.layers.mask = H.layers.mask & 5;
                            const Ue = le.parent
                              , $e = H.cameras;
                            se(H, Ue);
                            for (let rt = 0; rt < $e.length; rt++)
                                se($e[rt], Ue);
                            $e.length === 2 ? ee(H, F, P) : H.projectionMatrix.copy(F.projectionMatrix),
                            X(le, H, Ue)
                        }
                        ;
                        function X(le, Ne, be) {
                            be === null ? le.matrix.copy(Ne.matrixWorld) : (le.matrix.copy(be.matrixWorld),
                            le.matrix.invert(),
                            le.matrix.multiply(Ne.matrixWorld)),
                            le.matrix.decompose(le.position, le.quaternion, le.scale),
                            le.updateMatrixWorld(!0),
                            le.projectionMatrix.copy(Ne.projectionMatrix),
                            le.projectionMatrixInverse.copy(Ne.projectionMatrixInverse),
                            le.isPerspectiveCamera && (le.fov = op * 2 * Math.atan(1 / le.projectionMatrix.elements[5]),
                            le.zoom = 1)
                        }
                        this.getCamera = function() {
                            return H
                        }
                        ,
                        this.getFoveation = function() {
                            if (!(v === null && _ === null))
                                return h
                        }
                        ,
                        this.setFoveation = function(le) {
                            h = le,
                            v !== null && (v.fixedFoveation = le),
                            _ !== null && _.fixedFoveation !== void 0 && (_.fixedFoveation = le)
                        }
                        ,
                        this.hasDepthSensing = function() {
                            return E.texture !== null
                        }
                        ,
                        this.getDepthSensingMesh = function() {
                            return E.getMesh(H)
                        }
                        ,
                        this.getCameraTexture = function(le) {
                            return T[le]
                        }
                        ;
                        let J = null;
                        function ze(le, Ne) {
                            if (p = Ne.getViewerPose(d || r),
                            x = Ne,
                            p !== null) {
                                const be = p.views;
                                _ !== null && (e.setRenderTargetFramebuffer(R, _.framebuffer),
                                e.setRenderTarget(R));
                                let Ue = !1;
                                be.length !== H.cameras.length && (H.cameras.length = 0,
                                Ue = !0);
                                for (let rt = 0; rt < be.length; rt++) {
                                    const Et = be[rt];
                                    let ne = null;
                                    if (_ !== null)
                                        ne = _.getViewport(Et);
                                    else {
                                        const de = m.getViewSubImage(v, Et);
                                        ne = de.viewport,
                                        rt === 0 && (e.setRenderTargetTextures(R, de.colorTexture, de.depthStencilTexture),
                                        e.setRenderTarget(R))
                                    }
                                    let Ve = L[rt];
                                    Ve === void 0 && (Ve = new hi,
                                    Ve.layers.enable(rt),
                                    Ve.viewport = new gn,
                                    L[rt] = Ve),
                                    Ve.matrix.fromArray(Et.transform.matrix),
                                    Ve.matrix.decompose(Ve.position, Ve.quaternion, Ve.scale),
                                    Ve.projectionMatrix.fromArray(Et.projectionMatrix),
                                    Ve.projectionMatrixInverse.copy(Ve.projectionMatrix).invert(),
                                    Ve.viewport.set(ne.x, ne.y, ne.width, ne.height),
                                    rt === 0 && (H.matrix.copy(Ve.matrix),
                                    H.matrix.decompose(H.position, H.quaternion, H.scale)),
                                    Ue === !0 && H.cameras.push(Ve)
                                }
                                const $e = i.enabledFeatures;
                                if ($e && $e.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && b) {
                                    m = n.getBinding();
                                    const rt = m.getDepthInformation(be[0]);
                                    rt && rt.isValid && rt.texture && E.init(rt, i.renderState)
                                }
                                if ($e && $e.includes("camera-access") && b) {
                                    e.state.unbindTexture(),
                                    m = n.getBinding();
                                    for (let rt = 0; rt < be.length; rt++) {
                                        const Et = be[rt].camera;
                                        if (Et) {
                                            let ne = T[Et];
                                            ne || (ne = new aT,
                                            T[Et] = ne),
                                            ne.sourceTexture = m.getCameraImage(Et)
                                        }
                                    }
                                }
                            }
                            for (let be = 0; be < O.length; be++) {
                                const Ue = U[be]
                                  , $e = O[be];
                                Ue !== null && $e !== void 0 && $e.update(Ue, Ne, d || r)
                            }
                            J && J(le, Ne),
                            Ne.detectedPlanes && n.dispatchEvent({
                                type: "planesdetected",
                                data: Ne
                            }),
                            x = null
                        }
                        const xe = new A1;
                        xe.setAnimationLoop(ze),
                        this.setAnimationLoop = function(le) {
                            J = le
                        }
                        ,
                        this.dispose = function() {}
                    }
                }
                ;
                const Df = new io
                  , V4 = new Xt;
                function G4(e, t) {
                    function n(T, M) {
                        T.matrixAutoUpdate === !0 && T.updateMatrix(),
                        M.value.copy(T.matrix)
                    }
                    function i(T, M) {
                        M.color.getRGB(T.fogColor.value, mw(e)),
                        M.isFog ? (T.fogNear.value = M.near,
                        T.fogFar.value = M.far) : M.isFogExp2 && (T.fogDensity.value = M.density)
                    }
                    function s(T, M, D, R, O) {
                        M.isMeshBasicMaterial || M.isMeshLambertMaterial ? r(T, M) : M.isMeshToonMaterial ? (r(T, M),
                        v(T, M)) : M.isMeshPhongMaterial ? (r(T, M),
                        m(T, M)) : M.isMeshStandardMaterial ? (r(T, M),
                        _(T, M),
                        M.isMeshPhysicalMaterial && x(T, M, O)) : M.isMeshMatcapMaterial ? (r(T, M),
                        b(T, M)) : M.isMeshDepthMaterial ? r(T, M) : M.isMeshDistanceMaterial ? (r(T, M),
                        E(T, M)) : M.isMeshNormalMaterial ? r(T, M) : M.isLineBasicMaterial ? (l(T, M),
                        M.isLineDashedMaterial && h(T, M)) : M.isPointsMaterial ? d(T, M, D, R) : M.isSpriteMaterial ? p(T, M) : M.isShadowMaterial ? (T.color.value.copy(M.color),
                        T.opacity.value = M.opacity) : M.isShaderMaterial && (M.uniformsNeedUpdate = !1)
                    }
                    function r(T, M) {
                        T.opacity.value = M.opacity,
                        M.color && T.diffuse.value.copy(M.color),
                        M.emissive && T.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity),
                        M.map && (T.map.value = M.map,
                        n(M.map, T.mapTransform)),
                        M.alphaMap && (T.alphaMap.value = M.alphaMap,
                        n(M.alphaMap, T.alphaMapTransform)),
                        M.bumpMap && (T.bumpMap.value = M.bumpMap,
                        n(M.bumpMap, T.bumpMapTransform),
                        T.bumpScale.value = M.bumpScale,
                        M.side === ys && (T.bumpScale.value *= -1)),
                        M.normalMap && (T.normalMap.value = M.normalMap,
                        n(M.normalMap, T.normalMapTransform),
                        T.normalScale.value.copy(M.normalScale),
                        M.side === ys && T.normalScale.value.negate()),
                        M.displacementMap && (T.displacementMap.value = M.displacementMap,
                        n(M.displacementMap, T.displacementMapTransform),
                        T.displacementScale.value = M.displacementScale,
                        T.displacementBias.value = M.displacementBias),
                        M.emissiveMap && (T.emissiveMap.value = M.emissiveMap,
                        n(M.emissiveMap, T.emissiveMapTransform)),
                        M.specularMap && (T.specularMap.value = M.specularMap,
                        n(M.specularMap, T.specularMapTransform)),
                        M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest);
                        const D = t.get(M)
                          , R = D.envMap
                          , O = D.envMapRotation;
                        R && (T.envMap.value = R,
                        Df.copy(O),
                        Df.x *= -1,
                        Df.y *= -1,
                        Df.z *= -1,
                        R.isCubeTexture && R.isRenderTargetTexture === !1 && (Df.y *= -1,
                        Df.z *= -1),
                        T.envMapRotation.value.setFromMatrix4(V4.makeRotationFromEuler(Df)),
                        T.flipEnvMap.value = R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1,
                        T.reflectivity.value = M.reflectivity,
                        T.ior.value = M.ior,
                        T.refractionRatio.value = M.refractionRatio),
                        M.lightMap && (T.lightMap.value = M.lightMap,
                        T.lightMapIntensity.value = M.lightMapIntensity,
                        n(M.lightMap, T.lightMapTransform)),
                        M.aoMap && (T.aoMap.value = M.aoMap,
                        T.aoMapIntensity.value = M.aoMapIntensity,
                        n(M.aoMap, T.aoMapTransform))
                    }
                    function l(T, M) {
                        T.diffuse.value.copy(M.color),
                        T.opacity.value = M.opacity,
                        M.map && (T.map.value = M.map,
                        n(M.map, T.mapTransform))
                    }
                    function h(T, M) {
                        T.dashSize.value = M.dashSize,
                        T.totalSize.value = M.dashSize + M.gapSize,
                        T.scale.value = M.scale
                    }
                    function d(T, M, D, R) {
                        T.diffuse.value.copy(M.color),
                        T.opacity.value = M.opacity,
                        T.size.value = M.size * D,
                        T.scale.value = R * .5,
                        M.map && (T.map.value = M.map,
                        n(M.map, T.uvTransform)),
                        M.alphaMap && (T.alphaMap.value = M.alphaMap,
                        n(M.alphaMap, T.alphaMapTransform)),
                        M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest)
                    }
                    function p(T, M) {
                        T.diffuse.value.copy(M.color),
                        T.opacity.value = M.opacity,
                        T.rotation.value = M.rotation,
                        M.map && (T.map.value = M.map,
                        n(M.map, T.mapTransform)),
                        M.alphaMap && (T.alphaMap.value = M.alphaMap,
                        n(M.alphaMap, T.alphaMapTransform)),
                        M.alphaTest > 0 && (T.alphaTest.value = M.alphaTest)
                    }
                    function m(T, M) {
                        T.specular.value.copy(M.specular),
                        T.shininess.value = Math.max(M.shininess, 1e-4)
                    }
                    function v(T, M) {
                        M.gradientMap && (T.gradientMap.value = M.gradientMap)
                    }
                    function _(T, M) {
                        T.metalness.value = M.metalness,
                        M.metalnessMap && (T.metalnessMap.value = M.metalnessMap,
                        n(M.metalnessMap, T.metalnessMapTransform)),
                        T.roughness.value = M.roughness,
                        M.roughnessMap && (T.roughnessMap.value = M.roughnessMap,
                        n(M.roughnessMap, T.roughnessMapTransform)),
                        M.envMap && (T.envMapIntensity.value = M.envMapIntensity)
                    }
                    function x(T, M, D) {
                        T.ior.value = M.ior,
                        M.sheen > 0 && (T.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen),
                        T.sheenRoughness.value = M.sheenRoughness,
                        M.sheenColorMap && (T.sheenColorMap.value = M.sheenColorMap,
                        n(M.sheenColorMap, T.sheenColorMapTransform)),
                        M.sheenRoughnessMap && (T.sheenRoughnessMap.value = M.sheenRoughnessMap,
                        n(M.sheenRoughnessMap, T.sheenRoughnessMapTransform))),
                        M.clearcoat > 0 && (T.clearcoat.value = M.clearcoat,
                        T.clearcoatRoughness.value = M.clearcoatRoughness,
                        M.clearcoatMap && (T.clearcoatMap.value = M.clearcoatMap,
                        n(M.clearcoatMap, T.clearcoatMapTransform)),
                        M.clearcoatRoughnessMap && (T.clearcoatRoughnessMap.value = M.clearcoatRoughnessMap,
                        n(M.clearcoatRoughnessMap, T.clearcoatRoughnessMapTransform)),
                        M.clearcoatNormalMap && (T.clearcoatNormalMap.value = M.clearcoatNormalMap,
                        n(M.clearcoatNormalMap, T.clearcoatNormalMapTransform),
                        T.clearcoatNormalScale.value.copy(M.clearcoatNormalScale),
                        M.side === ys && T.clearcoatNormalScale.value.negate())),
                        M.dispersion > 0 && (T.dispersion.value = M.dispersion),
                        M.iridescence > 0 && (T.iridescence.value = M.iridescence,
                        T.iridescenceIOR.value = M.iridescenceIOR,
                        T.iridescenceThicknessMinimum.value = M.iridescenceThicknessRange[0],
                        T.iridescenceThicknessMaximum.value = M.iridescenceThicknessRange[1],
                        M.iridescenceMap && (T.iridescenceMap.value = M.iridescenceMap,
                        n(M.iridescenceMap, T.iridescenceMapTransform)),
                        M.iridescenceThicknessMap && (T.iridescenceThicknessMap.value = M.iridescenceThicknessMap,
                        n(M.iridescenceThicknessMap, T.iridescenceThicknessMapTransform))),
                        M.transmission > 0 && (T.transmission.value = M.transmission,
                        T.transmissionSamplerMap.value = D.texture,
                        T.transmissionSamplerSize.value.set(D.width, D.height),
                        M.transmissionMap && (T.transmissionMap.value = M.transmissionMap,
                        n(M.transmissionMap, T.transmissionMapTransform)),
                        T.thickness.value = M.thickness,
                        M.thicknessMap && (T.thicknessMap.value = M.thicknessMap,
                        n(M.thicknessMap, T.thicknessMapTransform)),
                        T.attenuationDistance.value = M.attenuationDistance,
                        T.attenuationColor.value.copy(M.attenuationColor)),
                        M.anisotropy > 0 && (T.anisotropyVector.value.set(M.anisotropy * Math.cos(M.anisotropyRotation), M.anisotropy * Math.sin(M.anisotropyRotation)),
                        M.anisotropyMap && (T.anisotropyMap.value = M.anisotropyMap,
                        n(M.anisotropyMap, T.anisotropyMapTransform))),
                        T.specularIntensity.value = M.specularIntensity,
                        T.specularColor.value.copy(M.specularColor),
                        M.specularColorMap && (T.specularColorMap.value = M.specularColorMap,
                        n(M.specularColorMap, T.specularColorMapTransform)),
                        M.specularIntensityMap && (T.specularIntensityMap.value = M.specularIntensityMap,
                        n(M.specularIntensityMap, T.specularIntensityMapTransform))
                    }
                    function b(T, M) {
                        M.matcap && (T.matcap.value = M.matcap)
                    }
                    function E(T, M) {
                        const D = t.get(M).light;
                        T.referencePosition.value.setFromMatrixPosition(D.matrixWorld),
                        T.nearDistance.value = D.shadow.camera.near,
                        T.farDistance.value = D.shadow.camera.far
                    }
                    return {
                        refreshFogUniforms: i,
                        refreshMaterialUniforms: s
                    }
                }
                function k4(e, t, n, i) {
                    let s = {}
                      , r = {}
                      , l = [];
                    const h = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
                    function d(D, R) {
                        const O = R.program;
                        i.uniformBlockBinding(D, O)
                    }
                    function p(D, R) {
                        let O = s[D.id];
                        O === void 0 && (b(D),
                        O = m(D),
                        s[D.id] = O,
                        D.addEventListener("dispose", T));
                        const U = R.program;
                        i.updateUBOMapping(D, U);
                        const B = t.render.frame;
                        r[D.id] !== B && (_(D),
                        r[D.id] = B)
                    }
                    function m(D) {
                        const R = v();
                        D.__bindingPointIndex = R;
                        const O = e.createBuffer()
                          , U = D.__size
                          , B = D.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, O),
                        e.bufferData(e.UNIFORM_BUFFER, U, B),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, R, O),
                        O
                    }
                    function v() {
                        for (let D = 0; D < h; D++)
                            if (l.indexOf(D) === -1)
                                return l.push(D),
                                D;
                        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                        0
                    }
                    function _(D) {
                        const R = s[D.id]
                          , O = D.uniforms
                          , U = D.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, R);
                        for (let B = 0, I = O.length; B < I; B++) {
                            const F = Array.isArray(O[B]) ? O[B] : [O[B]];
                            for (let P = 0, L = F.length; P < L; P++) {
                                const H = F[P];
                                if (x(H, B, P, U) === !0) {
                                    const Z = H.__offset
                                      , K = Array.isArray(H.value) ? H.value : [H.value];
                                    let te = 0;
                                    for (let ce = 0; ce < K.length; ce++) {
                                        const G = K[ce]
                                          , V = E(G);
                                        typeof G == "number" || typeof G == "boolean" ? (H.__data[0] = G,
                                        e.bufferSubData(e.UNIFORM_BUFFER, Z + te, H.__data)) : G.isMatrix3 ? (H.__data[0] = G.elements[0],
                                        H.__data[1] = G.elements[1],
                                        H.__data[2] = G.elements[2],
                                        H.__data[3] = 0,
                                        H.__data[4] = G.elements[3],
                                        H.__data[5] = G.elements[4],
                                        H.__data[6] = G.elements[5],
                                        H.__data[7] = 0,
                                        H.__data[8] = G.elements[6],
                                        H.__data[9] = G.elements[7],
                                        H.__data[10] = G.elements[8],
                                        H.__data[11] = 0) : (G.toArray(H.__data, te),
                                        te += V.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, Z, H.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }
                    function x(D, R, O, U) {
                        const B = D.value
                          , I = R + "_" + O;
                        if (U[I] === void 0)
                            return typeof B == "number" || typeof B == "boolean" ? U[I] = B : U[I] = B.clone(),
                            !0;
                        {
                            const F = U[I];
                            if (typeof B == "number" || typeof B == "boolean") {
                                if (F !== B)
                                    return U[I] = B,
                                    !0
                            } else if (F.equals(B) === !1)
                                return F.copy(B),
                                !0
                        }
                        return !1
                    }
                    function b(D) {
                        const R = D.uniforms;
                        let O = 0;
                        const U = 16;
                        for (let I = 0, F = R.length; I < F; I++) {
                            const P = Array.isArray(R[I]) ? R[I] : [R[I]];
                            for (let L = 0, H = P.length; L < H; L++) {
                                const Z = P[L]
                                  , K = Array.isArray(Z.value) ? Z.value : [Z.value];
                                for (let te = 0, ce = K.length; te < ce; te++) {
                                    const G = K[te]
                                      , V = E(G)
                                      , q = O % U
                                      , ee = q % V.boundary
                                      , se = q + ee;
                                    O += ee,
                                    se !== 0 && U - se < V.storage && (O += U - se),
                                    Z.__data = new Float32Array(V.storage / Float32Array.BYTES_PER_ELEMENT),
                                    Z.__offset = O,
                                    O += V.storage
                                }
                            }
                        }
                        const B = O % U;
                        return B > 0 && (O += U - B),
                        D.__size = O,
                        D.__cache = {},
                        this
                    }
                    function E(D) {
                        const R = {
                            boundary: 0,
                            storage: 0
                        };
                        return typeof D == "number" || typeof D == "boolean" ? (R.boundary = 4,
                        R.storage = 4) : D.isVector2 ? (R.boundary = 8,
                        R.storage = 8) : D.isVector3 || D.isColor ? (R.boundary = 16,
                        R.storage = 12) : D.isVector4 ? (R.boundary = 16,
                        R.storage = 16) : D.isMatrix3 ? (R.boundary = 48,
                        R.storage = 48) : D.isMatrix4 ? (R.boundary = 64,
                        R.storage = 64) : D.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", D),
                        R
                    }
                    function T(D) {
                        const R = D.target;
                        R.removeEventListener("dispose", T);
                        const O = l.indexOf(R.__bindingPointIndex);
                        l.splice(O, 1),
                        e.deleteBuffer(s[R.id]),
                        delete s[R.id],
                        delete r[R.id]
                    }
                    function M() {
                        for (const D in s)
                            e.deleteBuffer(s[D]);
                        l = [],
                        s = {},
                        r = {}
                    }
                    return {
                        bind: d,
                        update: p,
                        dispose: M
                    }
                }
                var K1 = class {
                    constructor(e={}) {
                        const {canvas: t=JE(), context: n=null, depth: i=!0, stencil: s=!1, alpha: r=!1, antialias: l=!1, premultipliedAlpha: h=!0, preserveDrawingBuffer: d=!1, powerPreference: p="default", failIfMajorPerformanceCaveat: m=!1, reversedDepthBuffer: v=!1} = e;
                        this.isWebGLRenderer = !0;
                        let _;
                        if (n !== null) {
                            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                            _ = n.getContextAttributes().alpha
                        } else
                            _ = r;
                        const x = new Uint32Array(4)
                          , b = new Int32Array(4);
                        let E = null
                          , T = null;
                        const M = []
                          , D = [];
                        this.domElement = t,
                        this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        },
                        this.autoClear = !0,
                        this.autoClearColor = !0,
                        this.autoClearDepth = !0,
                        this.autoClearStencil = !0,
                        this.sortObjects = !0,
                        this.clippingPlanes = [],
                        this.localClippingEnabled = !1,
                        this.toneMapping = zo,
                        this.toneMappingExposure = 1,
                        this.transmissionResolutionScale = 1;
                        const R = this;
                        let O = !1;
                        this._outputColorSpace = $t;
                        let U = 0
                          , B = 0
                          , I = null
                          , F = -1
                          , P = null;
                        const L = new gn
                          , H = new gn;
                        let Z = null;
                        const K = new at(0);
                        let te = 0
                          , ce = t.width
                          , G = t.height
                          , V = 1
                          , q = null
                          , ee = null;
                        const se = new gn(0,0,ce,G)
                          , X = new gn(0,0,ce,G);
                        let J = !1;
                        const ze = new Np;
                        let xe = !1
                          , le = !1;
                        const Ne = new Xt
                          , be = new Q
                          , Ue = new gn
                          , $e = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };
                        let rt = !1;
                        function Et() {
                            return I === null ? V : 1
                        }
                        let ne = n;
                        function Ve(j, me) {
                            return t.getContext(j, me)
                        }
                        try {
                            const j = {
                                alpha: !0,
                                depth: i,
                                stencil: s,
                                antialias: l,
                                premultipliedAlpha: h,
                                preserveDrawingBuffer: d,
                                powerPreference: p,
                                failIfMajorPerformanceCaveat: m
                            };
                            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${xc}`),
                            t.addEventListener("webglcontextlost", ot, !1),
                            t.addEventListener("webglcontextrestored", tt, !1),
                            t.addEventListener("webglcontextcreationerror", gt, !1),
                            ne === null) {
                                const me = "webgl2";
                                if (ne = Ve(me, j),
                                ne === null)
                                    throw Ve(me) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                            }
                        } catch (j) {
                            throw console.error("THREE.WebGLRenderer: " + j.message),
                            j
                        }
                        let de, Te, Pe, Ye, Ie, Fe, xt, yt, wt, $, k, pe, Ge, Qe, Be, ct, Ke, _t, Ct, et, st, ie, Re, He;
                        function lt() {
                            de = new tL(ne),
                            de.init(),
                            ie = new Z1(ne,de),
                            Te = new jI(ne,de,e,ie),
                            Pe = new P4(ne,de),
                            Te.reversedDepthBuffer && v && Pe.buffers.depth.setReversed(!0),
                            Ye = new sL(ne),
                            Ie = new A4,
                            Fe = new I4(ne,de,Pe,Ie,Te,ie,Ye),
                            xt = new ZI(R),
                            yt = new eL(R),
                            wt = new kI(ne),
                            Re = new YI(ne,wt),
                            $ = new nL(ne,wt,Ye,Re),
                            k = new rL(ne,$,wt,Ye),
                            Ct = new aL(ne,Te,Fe),
                            ct = new QI(Ie),
                            pe = new S4(R,xt,yt,de,Te,Re,ct),
                            Ge = new G4(R,Ie),
                            Qe = new M4,
                            Be = new D4(de),
                            _t = new qI(R,xt,yt,Pe,k,_,h),
                            Ke = new U4(R,k,Te),
                            He = new k4(ne,Ye,Te,Pe),
                            et = new WI(ne,de,Ye),
                            st = new iL(ne,de,Ye),
                            Ye.programs = pe.programs,
                            R.capabilities = Te,
                            R.extensions = de,
                            R.properties = Ie,
                            R.renderLists = Qe,
                            R.shadowMap = Ke,
                            R.state = Pe,
                            R.info = Ye
                        }
                        lt();
                        const ae = new H4(R,ne);
                        this.xr = ae,
                        this.getContext = function() {
                            return ne
                        }
                        ,
                        this.getContextAttributes = function() {
                            return ne.getContextAttributes()
                        }
                        ,
                        this.forceContextLoss = function() {
                            const j = de.get("WEBGL_lose_context");
                            j && j.loseContext()
                        }
                        ,
                        this.forceContextRestore = function() {
                            const j = de.get("WEBGL_lose_context");
                            j && j.restoreContext()
                        }
                        ,
                        this.getPixelRatio = function() {
                            return V
                        }
                        ,
                        this.setPixelRatio = function(j) {
                            j !== void 0 && (V = j,
                            this.setSize(ce, G, !1))
                        }
                        ,
                        this.getSize = function(j) {
                            return j.set(ce, G)
                        }
                        ,
                        this.setSize = function(j, me, Ee=!0) {
                            if (ae.isPresenting) {
                                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                                return
                            }
                            ce = j,
                            G = me,
                            t.width = Math.floor(j * V),
                            t.height = Math.floor(me * V),
                            Ee === !0 && (t.style.width = j + "px",
                            t.style.height = me + "px"),
                            this.setViewport(0, 0, j, me)
                        }
                        ,
                        this.getDrawingBufferSize = function(j) {
                            return j.set(ce * V, G * V).floor()
                        }
                        ,
                        this.setDrawingBufferSize = function(j, me, Ee) {
                            ce = j,
                            G = me,
                            V = Ee,
                            t.width = Math.floor(j * Ee),
                            t.height = Math.floor(me * Ee),
                            this.setViewport(0, 0, j, me)
                        }
                        ,
                        this.getCurrentViewport = function(j) {
                            return j.copy(L)
                        }
                        ,
                        this.getViewport = function(j) {
                            return j.copy(se)
                        }
                        ,
                        this.setViewport = function(j, me, Ee, Se) {
                            j.isVector4 ? se.set(j.x, j.y, j.z, j.w) : se.set(j, me, Ee, Se),
                            Pe.viewport(L.copy(se).multiplyScalar(V).round())
                        }
                        ,
                        this.getScissor = function(j) {
                            return j.copy(X)
                        }
                        ,
                        this.setScissor = function(j, me, Ee, Se) {
                            j.isVector4 ? X.set(j.x, j.y, j.z, j.w) : X.set(j, me, Ee, Se),
                            Pe.scissor(H.copy(X).multiplyScalar(V).round())
                        }
                        ,
                        this.getScissorTest = function() {
                            return J
                        }
                        ,
                        this.setScissorTest = function(j) {
                            Pe.setScissorTest(J = j)
                        }
                        ,
                        this.setOpaqueSort = function(j) {
                            q = j
                        }
                        ,
                        this.setTransparentSort = function(j) {
                            ee = j
                        }
                        ,
                        this.getClearColor = function(j) {
                            return j.copy(_t.getClearColor())
                        }
                        ,
                        this.setClearColor = function() {
                            _t.setClearColor(...arguments)
                        }
                        ,
                        this.getClearAlpha = function() {
                            return _t.getClearAlpha()
                        }
                        ,
                        this.setClearAlpha = function() {
                            _t.setClearAlpha(...arguments)
                        }
                        ,
                        this.clear = function(j=!0, me=!0, Ee=!0) {
                            let Se = 0;
                            if (j) {
                                let he = !1;
                                if (I !== null) {
                                    const Ze = I.texture.format;
                                    he = Ze === Vy || Ze === Hy || Ze === Vg
                                }
                                if (he) {
                                    const Ze = I.texture.type
                                      , ft = Ze === ui || Ze === Il || Ze === ip || Ze === nf || Ze === Ly || Ze === zy
                                      , vt = _t.getClearColor()
                                      , ut = _t.getClearAlpha()
                                      , Dt = vt.r
                                      , bt = vt.g
                                      , Nt = vt.b;
                                    ft ? (x[0] = Dt,
                                    x[1] = bt,
                                    x[2] = Nt,
                                    x[3] = ut,
                                    ne.clearBufferuiv(ne.COLOR, 0, x)) : (b[0] = Dt,
                                    b[1] = bt,
                                    b[2] = Nt,
                                    b[3] = ut,
                                    ne.clearBufferiv(ne.COLOR, 0, b))
                                } else
                                    Se |= ne.COLOR_BUFFER_BIT
                            }
                            me && (Se |= ne.DEPTH_BUFFER_BIT),
                            Ee && (Se |= ne.STENCIL_BUFFER_BIT,
                            this.state.buffers.stencil.setMask(4294967295)),
                            ne.clear(Se)
                        }
                        ,
                        this.clearColor = function() {
                            this.clear(!0, !1, !1)
                        }
                        ,
                        this.clearDepth = function() {
                            this.clear(!1, !0, !1)
                        }
                        ,
                        this.clearStencil = function() {
                            this.clear(!1, !1, !0)
                        }
                        ,
                        this.dispose = function() {
                            t.removeEventListener("webglcontextlost", ot, !1),
                            t.removeEventListener("webglcontextrestored", tt, !1),
                            t.removeEventListener("webglcontextcreationerror", gt, !1),
                            _t.dispose(),
                            Qe.dispose(),
                            Be.dispose(),
                            Ie.dispose(),
                            xt.dispose(),
                            yt.dispose(),
                            k.dispose(),
                            Re.dispose(),
                            He.dispose(),
                            pe.dispose(),
                            ae.dispose(),
                            ae.removeEventListener("sessionstart", Ai),
                            ae.removeEventListener("sessionend", pa),
                            os.stop()
                        }
                        ;
                        function ot(j) {
                            j.preventDefault(),
                            console.log("THREE.WebGLRenderer: Context Lost."),
                            O = !0
                        }
                        function tt() {
                            console.log("THREE.WebGLRenderer: Context Restored."),
                            O = !1;
                            const j = Ye.autoReset
                              , me = Ke.enabled
                              , Ee = Ke.autoUpdate
                              , Se = Ke.needsUpdate
                              , he = Ke.type;
                            lt(),
                            Ye.autoReset = j,
                            Ke.enabled = me,
                            Ke.autoUpdate = Ee,
                            Ke.needsUpdate = Se,
                            Ke.type = he
                        }
                        function gt(j) {
                            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", j.statusMessage)
                        }
                        function Je(j) {
                            const me = j.target;
                            me.removeEventListener("dispose", Je),
                            ke(me)
                        }
                        function ke(j) {
                            ht(j),
                            Ie.remove(j)
                        }
                        function ht(j) {
                            const me = Ie.get(j).programs;
                            me !== void 0 && (me.forEach(function(Ee) {
                                pe.releaseProgram(Ee)
                            }),
                            j.isShaderMaterial && pe.releaseShaderCache(j))
                        }
                        this.renderBufferDirect = function(j, me, Ee, Se, he, Ze) {
                            me === null && (me = $e);
                            const ft = he.isMesh && he.matrixWorld.determinant() < 0
                              , vt = si(j, me, Ee, Se, he);
                            Pe.setMaterial(Se, ft);
                            let ut = Ee.index
                              , Dt = 1;
                            if (Se.wireframe === !0) {
                                if (ut = $.getWireframeAttribute(Ee),
                                ut === void 0)
                                    return;
                                Dt = 2
                            }
                            const bt = Ee.drawRange
                              , Nt = Ee.attributes.position;
                            let un = bt.start * Dt
                              , yn = (bt.start + bt.count) * Dt;
                            Ze !== null && (un = Math.max(un, Ze.start * Dt),
                            yn = Math.min(yn, (Ze.start + Ze.count) * Dt)),
                            ut !== null ? (un = Math.max(un, 0),
                            yn = Math.min(yn, ut.count)) : Nt != null && (un = Math.max(un, 0),
                            yn = Math.min(yn, Nt.count));
                            const Cn = yn - un;
                            if (Cn < 0 || Cn === 1 / 0)
                                return;
                            Re.setup(he, Se, vt, Ee, ut);
                            let Ln, Pn = et;
                            if (ut !== null && (Ln = wt.get(ut),
                            Pn = st,
                            Pn.setIndex(Ln)),
                            he.isMesh)
                                Se.wireframe === !0 ? (Pe.setLineWidth(Se.wireframeLinewidth * Et()),
                                Pn.setMode(ne.LINES)) : Pn.setMode(ne.TRIANGLES);
                            else if (he.isLine) {
                                let Tt = Se.linewidth;
                                Tt === void 0 && (Tt = 1),
                                Pe.setLineWidth(Tt * Et()),
                                he.isLineSegments ? Pn.setMode(ne.LINES) : he.isLineLoop ? Pn.setMode(ne.LINE_LOOP) : Pn.setMode(ne.LINE_STRIP)
                            } else
                                he.isPoints ? Pn.setMode(ne.POINTS) : he.isSprite && Pn.setMode(ne.TRIANGLES);
                            if (he.isBatchedMesh)
                                if (he._multiDrawInstances !== null)
                                    Jg("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                                    Pn.renderMultiDrawInstances(he._multiDrawStarts, he._multiDrawCounts, he._multiDrawCount, he._multiDrawInstances);
                                else if (de.get("WEBGL_multi_draw"))
                                    Pn.renderMultiDraw(he._multiDrawStarts, he._multiDrawCounts, he._multiDrawCount);
                                else {
                                    const Tt = he._multiDrawStarts
                                      , Mn = he._multiDrawCounts
                                      , dn = he._multiDrawCount
                                      , va = ut ? wt.get(ut).bytesPerElement : 1
                                      , Va = Ie.get(Se).currentProgram.getUniforms();
                                    for (let ls = 0; ls < dn; ls++)
                                        Va.setValue(ne, "_gl_DrawID", ls),
                                        Pn.render(Tt[ls] / va, Mn[ls])
                                }
                            else if (he.isInstancedMesh)
                                Pn.renderInstances(un, Cn, he.count);
                            else if (Ee.isInstancedBufferGeometry) {
                                const Tt = Ee._maxInstanceCount !== void 0 ? Ee._maxInstanceCount : 1 / 0
                                  , Mn = Math.min(Ee.instanceCount, Tt);
                                Pn.renderInstances(un, Cn, Mn)
                            } else
                                Pn.render(un, Cn)
                        }
                        ;
                        function Mt(j, me, Ee) {
                            j.transparent === !0 && j.side === nr && j.forceSinglePass === !1 ? (j.side = ys,
                            j.needsUpdate = !0,
                            ma(j, me, Ee),
                            j.side = Bl,
                            j.needsUpdate = !0,
                            ma(j, me, Ee),
                            j.side = nr) : ma(j, me, Ee)
                        }
                        this.compile = function(j, me, Ee=null) {
                            Ee === null && (Ee = j),
                            T = Be.get(Ee),
                            T.init(me),
                            D.push(T),
                            Ee.traverseVisible(function(he) {
                                he.isLight && he.layers.test(me.layers) && (T.pushLight(he),
                                he.castShadow && T.pushShadow(he))
                            }),
                            j !== Ee && j.traverseVisible(function(he) {
                                he.isLight && he.layers.test(me.layers) && (T.pushLight(he),
                                he.castShadow && T.pushShadow(he))
                            }),
                            T.setupLights();
                            const Se = new Set;
                            return j.traverse(function(he) {
                                if (!(he.isMesh || he.isPoints || he.isLine || he.isSprite))
                                    return;
                                const Ze = he.material;
                                if (Ze)
                                    if (Array.isArray(Ze))
                                        for (let ft = 0; ft < Ze.length; ft++) {
                                            const vt = Ze[ft];
                                            Mt(vt, Ee, he),
                                            Se.add(vt)
                                        }
                                    else
                                        Mt(Ze, Ee, he),
                                        Se.add(Ze)
                            }),
                            T = D.pop(),
                            Se
                        }
                        ,
                        this.compileAsync = function(j, me, Ee=null) {
                            const Se = this.compile(j, me, Ee);
                            return new Promise(he => {
                                function Ze() {
                                    if (Se.forEach(function(ft) {
                                        Ie.get(ft).currentProgram.isReady() && Se.delete(ft)
                                    }),
                                    Se.size === 0) {
                                        he(j);
                                        return
                                    }
                                    setTimeout(Ze, 10)
                                }
                                de.get("KHR_parallel_shader_compile") !== null ? Ze() : setTimeout(Ze, 10)
                            }
                            )
                        }
                        ;
                        let Tn = null;
                        function Zt(j) {
                            Tn && Tn(j)
                        }
                        function Ai() {
                            os.stop()
                        }
                        function pa() {
                            os.start()
                        }
                        const os = new A1;
                        os.setAnimationLoop(Zt),
                        typeof self < "u" && os.setContext(self),
                        this.setAnimationLoop = function(j) {
                            Tn = j,
                            ae.setAnimationLoop(j),
                            j === null ? os.stop() : os.start()
                        }
                        ,
                        ae.addEventListener("sessionstart", Ai),
                        ae.addEventListener("sessionend", pa),
                        this.render = function(j, me) {
                            if (me !== void 0 && me.isCamera !== !0) {
                                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                return
                            }
                            if (O === !0)
                                return;
                            if (j.matrixWorldAutoUpdate === !0 && j.updateMatrixWorld(),
                            me.parent === null && me.matrixWorldAutoUpdate === !0 && me.updateMatrixWorld(),
                            ae.enabled === !0 && ae.isPresenting === !0 && (ae.cameraAutoUpdate === !0 && ae.updateCamera(me),
                            me = ae.getCamera()),
                            j.isScene === !0 && j.onBeforeRender(R, j, me, I),
                            T = Be.get(j, D.length),
                            T.init(me),
                            D.push(T),
                            Ne.multiplyMatrices(me.projectionMatrix, me.matrixWorldInverse),
                            ze.setFromProjectionMatrix(Ne, br, me.reversedDepth),
                            le = this.localClippingEnabled,
                            xe = ct.init(this.clippingPlanes, le),
                            E = Qe.get(j, M.length),
                            E.init(),
                            M.push(E),
                            ae.enabled === !0 && ae.isPresenting === !0) {
                                const Ze = R.xr.getDepthSensingMesh();
                                Ze !== null && Ti(Ze, me, -1 / 0, R.sortObjects)
                            }
                            Ti(j, me, 0, R.sortObjects),
                            E.finish(),
                            R.sortObjects === !0 && E.sort(q, ee),
                            rt = ae.enabled === !1 || ae.isPresenting === !1 || ae.hasDepthSensing() === !1,
                            rt && _t.addToRenderList(E, j),
                            this.info.render.frame++,
                            xe === !0 && ct.beginShadows();
                            const Ee = T.state.shadowsArray;
                            Ke.render(Ee, j, me),
                            xe === !0 && ct.endShadows(),
                            this.info.autoReset === !0 && this.info.reset();
                            const Se = E.opaque
                              , he = E.transmissive;
                            if (T.setupLights(),
                            me.isArrayCamera) {
                                const Ze = me.cameras;
                                if (he.length > 0)
                                    for (let ft = 0, vt = Ze.length; ft < vt; ft++) {
                                        const ut = Ze[ft];
                                        Pr(Se, he, j, ut)
                                    }
                                rt && _t.render(j);
                                for (let ft = 0, vt = Ze.length; ft < vt; ft++) {
                                    const ut = Ze[ft];
                                    ki(E, j, ut, ut.viewport)
                                }
                            } else
                                he.length > 0 && Pr(Se, he, j, me),
                                rt && _t.render(j),
                                ki(E, j, me);
                            I !== null && B === 0 && (Fe.updateMultisampleRenderTarget(I),
                            Fe.updateRenderTargetMipmap(I)),
                            j.isScene === !0 && j.onAfterRender(R, j, me),
                            Re.resetDefaultState(),
                            F = -1,
                            P = null,
                            D.pop(),
                            D.length > 0 ? (T = D[D.length - 1],
                            xe === !0 && ct.setGlobalState(R.clippingPlanes, T.state.camera)) : T = null,
                            M.pop(),
                            M.length > 0 ? E = M[M.length - 1] : E = null
                        }
                        ;
                        function Ti(j, me, Ee, Se) {
                            if (j.visible === !1)
                                return;
                            if (j.layers.test(me.layers)) {
                                if (j.isGroup)
                                    Ee = j.renderOrder;
                                else if (j.isLOD)
                                    j.autoUpdate === !0 && j.update(me);
                                else if (j.isLight)
                                    T.pushLight(j),
                                    j.castShadow && T.pushShadow(j);
                                else if (j.isSprite) {
                                    if (!j.frustumCulled || ze.intersectsSprite(j)) {
                                        Se && Ue.setFromMatrixPosition(j.matrixWorld).applyMatrix4(Ne);
                                        const Ze = k.update(j)
                                          , ft = j.material;
                                        ft.visible && E.push(j, Ze, ft, Ee, Ue.z, null)
                                    }
                                } else if ((j.isMesh || j.isLine || j.isPoints) && (!j.frustumCulled || ze.intersectsObject(j))) {
                                    const Ze = k.update(j)
                                      , ft = j.material;
                                    if (Se && (j.boundingSphere !== void 0 ? (j.boundingSphere === null && j.computeBoundingSphere(),
                                    Ue.copy(j.boundingSphere.center)) : (Ze.boundingSphere === null && Ze.computeBoundingSphere(),
                                    Ue.copy(Ze.boundingSphere.center)),
                                    Ue.applyMatrix4(j.matrixWorld).applyMatrix4(Ne)),
                                    Array.isArray(ft)) {
                                        const vt = Ze.groups;
                                        for (let ut = 0, Dt = vt.length; ut < Dt; ut++) {
                                            const bt = vt[ut]
                                              , Nt = ft[bt.materialIndex];
                                            Nt && Nt.visible && E.push(j, Ze, Nt, Ee, Ue.z, bt)
                                        }
                                    } else
                                        ft.visible && E.push(j, Ze, ft, Ee, Ue.z, null)
                                }
                            }
                            const he = j.children;
                            for (let Ze = 0, ft = he.length; Ze < ft; Ze++)
                                Ti(he[Ze], me, Ee, Se)
                        }
                        function ki(j, me, Ee, Se) {
                            const he = j.opaque
                              , Ze = j.transmissive
                              , ft = j.transparent;
                            T.setupLightsView(Ee),
                            xe === !0 && ct.setGlobalState(R.clippingPlanes, Ee),
                            Se && Pe.viewport(L.copy(Se)),
                            he.length > 0 && Bs(he, me, Ee),
                            Ze.length > 0 && Bs(Ze, me, Ee),
                            ft.length > 0 && Bs(ft, me, Ee),
                            Pe.buffers.depth.setTest(!0),
                            Pe.buffers.depth.setMask(!0),
                            Pe.buffers.color.setMask(!0),
                            Pe.setPolygonOffset(!1)
                        }
                        function Pr(j, me, Ee, Se) {
                            if ((Ee.isScene === !0 ? Ee.overrideMaterial : null) !== null)
                                return;
                            T.state.transmissionRenderTarget[Se.id] === void 0 && (T.state.transmissionRenderTarget[Se.id] = new Un(1,1,{
                                generateMipmaps: !0,
                                type: de.has("EXT_color_buffer_half_float") || de.has("EXT_color_buffer_float") ? tf : ui,
                                minFilter: Pl,
                                samples: 4,
                                stencilBuffer: s,
                                resolveDepthBuffer: !1,
                                resolveStencilBuffer: !1,
                                colorSpace: An.workingColorSpace
                            }));
                            const he = T.state.transmissionRenderTarget[Se.id]
                              , Ze = Se.viewport || L;
                            he.setSize(Ze.z * R.transmissionResolutionScale, Ze.w * R.transmissionResolutionScale);
                            const ft = R.getRenderTarget()
                              , vt = R.getActiveCubeFace()
                              , ut = R.getActiveMipmapLevel();
                            R.setRenderTarget(he),
                            R.getClearColor(K),
                            te = R.getClearAlpha(),
                            te < 1 && R.setClearColor(16777215, .5),
                            R.clear(),
                            rt && _t.render(Ee);
                            const Dt = R.toneMapping;
                            R.toneMapping = zo;
                            const bt = Se.viewport;
                            if (Se.viewport !== void 0 && (Se.viewport = void 0),
                            T.setupLightsView(Se),
                            xe === !0 && ct.setGlobalState(R.clippingPlanes, Se),
                            Bs(j, Ee, Se),
                            Fe.updateMultisampleRenderTarget(he),
                            Fe.updateRenderTargetMipmap(he),
                            de.has("WEBGL_multisampled_render_to_texture") === !1) {
                                let Nt = !1;
                                for (let un = 0, yn = me.length; un < yn; un++) {
                                    const Cn = me[un]
                                      , Ln = Cn.object
                                      , Pn = Cn.geometry
                                      , Tt = Cn.material
                                      , Mn = Cn.group;
                                    if (Tt.side === nr && Ln.layers.test(Se.layers)) {
                                        const dn = Tt.side;
                                        Tt.side = ys,
                                        Tt.needsUpdate = !0,
                                        rh(Ln, Ee, Se, Pn, Tt, Mn),
                                        Tt.side = dn,
                                        Tt.needsUpdate = !0,
                                        Nt = !0
                                    }
                                }
                                Nt === !0 && (Fe.updateMultisampleRenderTarget(he),
                                Fe.updateRenderTargetMipmap(he))
                            }
                            R.setRenderTarget(ft, vt, ut),
                            R.setClearColor(K, te),
                            bt !== void 0 && (Se.viewport = bt),
                            R.toneMapping = Dt
                        }
                        function Bs(j, me, Ee) {
                            const Se = me.isScene === !0 ? me.overrideMaterial : null;
                            for (let he = 0, Ze = j.length; he < Ze; he++) {
                                const ft = j[he]
                                  , vt = ft.object
                                  , ut = ft.geometry
                                  , Dt = ft.group;
                                let bt = ft.material;
                                bt.allowOverride === !0 && Se !== null && (bt = Se),
                                vt.layers.test(Ee.layers) && rh(vt, me, Ee, ut, bt, Dt)
                            }
                        }
                        function rh(j, me, Ee, Se, he, Ze) {
                            j.onBeforeRender(R, me, Ee, Se, he, Ze),
                            j.modelViewMatrix.multiplyMatrices(Ee.matrixWorldInverse, j.matrixWorld),
                            j.normalMatrix.getNormalMatrix(j.modelViewMatrix),
                            he.onBeforeRender(R, me, Ee, Se, j, Ze),
                            he.transparent === !0 && he.side === nr && he.forceSinglePass === !1 ? (he.side = ys,
                            he.needsUpdate = !0,
                            R.renderBufferDirect(Ee, me, Se, he, j, Ze),
                            he.side = Bl,
                            he.needsUpdate = !0,
                            R.renderBufferDirect(Ee, me, Se, he, j, Ze),
                            he.side = nr) : R.renderBufferDirect(Ee, me, Se, he, j, Ze),
                            j.onAfterRender(R, me, Ee, Se, he, Ze)
                        }
                        function ma(j, me, Ee) {
                            me.isScene !== !0 && (me = $e);
                            const Se = Ie.get(j)
                              , he = T.state.lights
                              , Ze = T.state.shadowsArray
                              , ft = he.state.version
                              , vt = pe.getParameters(j, he.state, Ze, me, Ee)
                              , ut = pe.getProgramCacheKey(vt);
                            let Dt = Se.programs;
                            Se.environment = j.isMeshStandardMaterial ? me.environment : null,
                            Se.fog = me.fog,
                            Se.envMap = (j.isMeshStandardMaterial ? yt : xt).get(j.envMap || Se.environment),
                            Se.envMapRotation = Se.environment !== null && j.envMap === null ? me.environmentRotation : j.envMapRotation,
                            Dt === void 0 && (j.addEventListener("dispose", Je),
                            Dt = new Map,
                            Se.programs = Dt);
                            let bt = Dt.get(ut);
                            if (bt !== void 0) {
                                if (Se.currentProgram === bt && Se.lightsStateVersion === ft)
                                    return cr(j, vt),
                                    bt
                            } else
                                vt.uniforms = pe.getUniforms(j),
                                j.onBeforeCompile(vt, R),
                                bt = pe.acquireProgram(vt, ut),
                                Dt.set(ut, bt),
                                Se.uniforms = vt.uniforms;
                            const Nt = Se.uniforms;
                            return (!j.isShaderMaterial && !j.isRawShaderMaterial || j.clipping === !0) && (Nt.clippingPlanes = ct.uniform),
                            cr(j, vt),
                            Se.needsLights = Lr(j),
                            Se.lightsStateVersion = ft,
                            Se.needsLights && (Nt.ambientLightColor.value = he.state.ambient,
                            Nt.lightProbe.value = he.state.probe,
                            Nt.directionalLights.value = he.state.directional,
                            Nt.directionalLightShadows.value = he.state.directionalShadow,
                            Nt.spotLights.value = he.state.spot,
                            Nt.spotLightShadows.value = he.state.spotShadow,
                            Nt.rectAreaLights.value = he.state.rectArea,
                            Nt.ltc_1.value = he.state.rectAreaLTC1,
                            Nt.ltc_2.value = he.state.rectAreaLTC2,
                            Nt.pointLights.value = he.state.point,
                            Nt.pointLightShadows.value = he.state.pointShadow,
                            Nt.hemisphereLights.value = he.state.hemi,
                            Nt.directionalShadowMap.value = he.state.directionalShadowMap,
                            Nt.directionalShadowMatrix.value = he.state.directionalShadowMatrix,
                            Nt.spotShadowMap.value = he.state.spotShadowMap,
                            Nt.spotLightMatrix.value = he.state.spotLightMatrix,
                            Nt.spotLightMap.value = he.state.spotLightMap,
                            Nt.pointShadowMap.value = he.state.pointShadowMap,
                            Nt.pointShadowMatrix.value = he.state.pointShadowMatrix),
                            Se.currentProgram = bt,
                            Se.uniformsList = null,
                            bt
                        }
                        function ga(j) {
                            if (j.uniformsList === null) {
                                const me = j.currentProgram.getUniforms();
                                j.uniformsList = Mx.seqWithValue(me.seq, j.uniforms)
                            }
                            return j.uniformsList
                        }
                        function cr(j, me) {
                            const Ee = Ie.get(j);
                            Ee.outputColorSpace = me.outputColorSpace,
                            Ee.batching = me.batching,
                            Ee.batchingColor = me.batchingColor,
                            Ee.instancing = me.instancing,
                            Ee.instancingColor = me.instancingColor,
                            Ee.instancingMorph = me.instancingMorph,
                            Ee.skinning = me.skinning,
                            Ee.morphTargets = me.morphTargets,
                            Ee.morphNormals = me.morphNormals,
                            Ee.morphColors = me.morphColors,
                            Ee.morphTargetsCount = me.morphTargetsCount,
                            Ee.numClippingPlanes = me.numClippingPlanes,
                            Ee.numIntersection = me.numClipIntersection,
                            Ee.vertexAlphas = me.vertexAlphas,
                            Ee.vertexTangents = me.vertexTangents,
                            Ee.toneMapping = me.toneMapping
                        }
                        function si(j, me, Ee, Se, he) {
                            me.isScene !== !0 && (me = $e),
                            Fe.resetTextureUnits();
                            const Ze = me.fog
                              , ft = Se.isMeshStandardMaterial ? me.environment : null
                              , vt = I === null ? R.outputColorSpace : I.isXRRenderTarget === !0 ? I.texture.colorSpace : Ll
                              , ut = (Se.isMeshStandardMaterial ? yt : xt).get(Se.envMap || ft)
                              , Dt = Se.vertexColors === !0 && !!Ee.attributes.color && Ee.attributes.color.itemSize === 4
                              , bt = !!Ee.attributes.tangent && (!!Se.normalMap || Se.anisotropy > 0)
                              , Nt = !!Ee.morphAttributes.position
                              , un = !!Ee.morphAttributes.normal
                              , yn = !!Ee.morphAttributes.color;
                            let Cn = zo;
                            Se.toneMapped && (I === null || I.isXRRenderTarget === !0) && (Cn = R.toneMapping);
                            const Ln = Ee.morphAttributes.position || Ee.morphAttributes.normal || Ee.morphAttributes.color
                              , Pn = Ln !== void 0 ? Ln.length : 0
                              , Tt = Ie.get(Se)
                              , Mn = T.state.lights;
                            if (xe === !0 && (le === !0 || j !== P)) {
                                const Mi = j === P && Se.id === F;
                                ct.setState(Se, j, Mi)
                            }
                            let dn = !1;
                            Se.version === Tt.__version ? (Tt.needsLights && Tt.lightsStateVersion !== Mn.state.version || Tt.outputColorSpace !== vt || he.isBatchedMesh && Tt.batching === !1 || !he.isBatchedMesh && Tt.batching === !0 || he.isBatchedMesh && Tt.batchingColor === !0 && he.colorTexture === null || he.isBatchedMesh && Tt.batchingColor === !1 && he.colorTexture !== null || he.isInstancedMesh && Tt.instancing === !1 || !he.isInstancedMesh && Tt.instancing === !0 || he.isSkinnedMesh && Tt.skinning === !1 || !he.isSkinnedMesh && Tt.skinning === !0 || he.isInstancedMesh && Tt.instancingColor === !0 && he.instanceColor === null || he.isInstancedMesh && Tt.instancingColor === !1 && he.instanceColor !== null || he.isInstancedMesh && Tt.instancingMorph === !0 && he.morphTexture === null || he.isInstancedMesh && Tt.instancingMorph === !1 && he.morphTexture !== null || Tt.envMap !== ut || Se.fog === !0 && Tt.fog !== Ze || Tt.numClippingPlanes !== void 0 && (Tt.numClippingPlanes !== ct.numPlanes || Tt.numIntersection !== ct.numIntersection) || Tt.vertexAlphas !== Dt || Tt.vertexTangents !== bt || Tt.morphTargets !== Nt || Tt.morphNormals !== un || Tt.morphColors !== yn || Tt.toneMapping !== Cn || Tt.morphTargetsCount !== Pn) && (dn = !0) : (dn = !0,
                            Tt.__version = Se.version);
                            let va = Tt.currentProgram;
                            dn === !0 && (va = ma(Se, me, he));
                            let Va = !1
                              , ls = !1
                              , ur = !1;
                            const Gn = va.getUniforms()
                              , Qn = Tt.uniforms;
                            if (Pe.useProgram(va.program) && (Va = !0,
                            ls = !0,
                            ur = !0),
                            Se.id !== F && (F = Se.id,
                            ls = !0),
                            Va || P !== j) {
                                Pe.buffers.depth.getReversed() && j.reversedDepth !== !0 && (j._reversedDepth = !0,
                                j.updateProjectionMatrix()),
                                Gn.setValue(ne, "projectionMatrix", j.projectionMatrix),
                                Gn.setValue(ne, "viewMatrix", j.matrixWorldInverse);
                                const Mi = Gn.map.cameraPosition;
                                Mi !== void 0 && Mi.setValue(ne, be.setFromMatrixPosition(j.matrixWorld)),
                                Te.logarithmicDepthBuffer && Gn.setValue(ne, "logDepthBufFC", 2 / (Math.log(j.far + 1) / Math.LN2)),
                                (Se.isMeshPhongMaterial || Se.isMeshToonMaterial || Se.isMeshLambertMaterial || Se.isMeshBasicMaterial || Se.isMeshStandardMaterial || Se.isShaderMaterial) && Gn.setValue(ne, "isOrthographic", j.isOrthographicCamera === !0),
                                P !== j && (P = j,
                                ls = !0,
                                ur = !0)
                            }
                            if (he.isSkinnedMesh) {
                                Gn.setOptional(ne, he, "bindMatrix"),
                                Gn.setOptional(ne, he, "bindMatrixInverse");
                                const Mi = he.skeleton;
                                Mi && (Mi.boneTexture === null && Mi.computeBoneTexture(),
                                Gn.setValue(ne, "boneTexture", Mi.boneTexture, Fe))
                            }
                            he.isBatchedMesh && (Gn.setOptional(ne, he, "batchingTexture"),
                            Gn.setValue(ne, "batchingTexture", he._matricesTexture, Fe),
                            Gn.setOptional(ne, he, "batchingIdTexture"),
                            Gn.setValue(ne, "batchingIdTexture", he._indirectTexture, Fe),
                            Gn.setOptional(ne, he, "batchingColorTexture"),
                            he._colorsTexture !== null && Gn.setValue(ne, "batchingColorTexture", he._colorsTexture, Fe));
                            const cs = Ee.morphAttributes;
                            if ((cs.position !== void 0 || cs.normal !== void 0 || cs.color !== void 0) && Ct.update(he, Ee, va),
                            (ls || Tt.receiveShadow !== he.receiveShadow) && (Tt.receiveShadow = he.receiveShadow,
                            Gn.setValue(ne, "receiveShadow", he.receiveShadow)),
                            Se.isMeshGouraudMaterial && Se.envMap !== null && (Qn.envMap.value = ut,
                            Qn.flipEnvMap.value = ut.isCubeTexture && ut.isRenderTargetTexture === !1 ? -1 : 1),
                            Se.isMeshStandardMaterial && Se.envMap === null && me.environment !== null && (Qn.envMapIntensity.value = me.environmentIntensity),
                            ls && (Gn.setValue(ne, "toneMappingExposure", R.toneMappingExposure),
                            Tt.needsLights && Ir(Qn, ur),
                            Ze && Se.fog === !0 && Ge.refreshFogUniforms(Qn, Ze),
                            Ge.refreshMaterialUniforms(Qn, Se, V, G, T.state.transmissionRenderTarget[j.id]),
                            Mx.upload(ne, ga(Tt), Qn, Fe)),
                            Se.isShaderMaterial && Se.uniformsNeedUpdate === !0 && (Mx.upload(ne, ga(Tt), Qn, Fe),
                            Se.uniformsNeedUpdate = !1),
                            Se.isSpriteMaterial && Gn.setValue(ne, "center", he.center),
                            Gn.setValue(ne, "modelViewMatrix", he.modelViewMatrix),
                            Gn.setValue(ne, "normalMatrix", he.normalMatrix),
                            Gn.setValue(ne, "modelMatrix", he.matrixWorld),
                            Se.isShaderMaterial || Se.isRawShaderMaterial) {
                                const Mi = Se.uniformsGroups;
                                for (let bs = 0, hr = Mi.length; bs < hr; bs++) {
                                    const zr = Mi[bs];
                                    He.update(zr, va),
                                    He.bind(zr, va)
                                }
                            }
                            return va
                        }
                        function Ir(j, me) {
                            j.ambientLightColor.needsUpdate = me,
                            j.lightProbe.needsUpdate = me,
                            j.directionalLights.needsUpdate = me,
                            j.directionalLightShadows.needsUpdate = me,
                            j.pointLights.needsUpdate = me,
                            j.pointLightShadows.needsUpdate = me,
                            j.spotLights.needsUpdate = me,
                            j.spotLightShadows.needsUpdate = me,
                            j.rectAreaLights.needsUpdate = me,
                            j.hemisphereLights.needsUpdate = me
                        }
                        function Lr(j) {
                            return j.isMeshLambertMaterial || j.isMeshToonMaterial || j.isMeshPhongMaterial || j.isMeshStandardMaterial || j.isShadowMaterial || j.isShaderMaterial && j.lights === !0
                        }
                        this.getActiveCubeFace = function() {
                            return U
                        }
                        ,
                        this.getActiveMipmapLevel = function() {
                            return B
                        }
                        ,
                        this.getRenderTarget = function() {
                            return I
                        }
                        ,
                        this.setRenderTargetTextures = function(j, me, Ee) {
                            const Se = Ie.get(j);
                            Se.__autoAllocateDepthBuffer = j.resolveDepthBuffer === !1,
                            Se.__autoAllocateDepthBuffer === !1 && (Se.__useRenderToTexture = !1),
                            Ie.get(j.texture).__webglTexture = me,
                            Ie.get(j.depthTexture).__webglTexture = Se.__autoAllocateDepthBuffer ? void 0 : Ee,
                            Se.__hasExternalTextures = !0
                        }
                        ,
                        this.setRenderTargetFramebuffer = function(j, me) {
                            const Ee = Ie.get(j);
                            Ee.__webglFramebuffer = me,
                            Ee.__useDefaultFramebuffer = me === void 0
                        }
                        ;
                        const $o = ne.createFramebuffer();
                        this.setRenderTarget = function(j, me=0, Ee=0) {
                            I = j,
                            U = me,
                            B = Ee;
                            let Se = !0
                              , he = null
                              , Ze = !1
                              , ft = !1;
                            if (j) {
                                const vt = Ie.get(j);
                                if (vt.__useDefaultFramebuffer !== void 0)
                                    Pe.bindFramebuffer(ne.FRAMEBUFFER, null),
                                    Se = !1;
                                else if (vt.__webglFramebuffer === void 0)
                                    Fe.setupRenderTarget(j);
                                else if (vt.__hasExternalTextures)
                                    Fe.rebindTextures(j, Ie.get(j.texture).__webglTexture, Ie.get(j.depthTexture).__webglTexture);
                                else if (j.depthBuffer) {
                                    const bt = j.depthTexture;
                                    if (vt.__boundDepthTexture !== bt) {
                                        if (bt !== null && Ie.has(bt) && (j.width !== bt.image.width || j.height !== bt.image.height))
                                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                        Fe.setupDepthRenderbuffer(j)
                                    }
                                }
                                const ut = j.texture;
                                (ut.isData3DTexture || ut.isDataArrayTexture || ut.isCompressedArrayTexture) && (ft = !0);
                                const Dt = Ie.get(j).__webglFramebuffer;
                                j.isWebGLCubeRenderTarget ? (Array.isArray(Dt[me]) ? he = Dt[me][Ee] : he = Dt[me],
                                Ze = !0) : j.samples > 0 && Fe.useMultisampledRTT(j) === !1 ? he = Ie.get(j).__webglMultisampledFramebuffer : Array.isArray(Dt) ? he = Dt[Ee] : he = Dt,
                                L.copy(j.viewport),
                                H.copy(j.scissor),
                                Z = j.scissorTest
                            } else
                                L.copy(se).multiplyScalar(V).floor(),
                                H.copy(X).multiplyScalar(V).floor(),
                                Z = J;
                            if (Ee !== 0 && (he = $o),
                            Pe.bindFramebuffer(ne.FRAMEBUFFER, he) && Se && Pe.drawBuffers(j, he),
                            Pe.viewport(L),
                            Pe.scissor(H),
                            Pe.setScissorTest(Z),
                            Ze) {
                                const vt = Ie.get(j.texture);
                                ne.framebufferTexture2D(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_CUBE_MAP_POSITIVE_X + me, vt.__webglTexture, Ee)
                            } else if (ft) {
                                const vt = me;
                                for (let ut = 0; ut < j.textures.length; ut++) {
                                    const Dt = Ie.get(j.textures[ut]);
                                    ne.framebufferTextureLayer(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0 + ut, Dt.__webglTexture, Ee, vt)
                                }
                            } else if (j !== null && Ee !== 0) {
                                const vt = Ie.get(j.texture);
                                ne.framebufferTexture2D(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_2D, vt.__webglTexture, Ee)
                            }
                            F = -1
                        }
                        ,
                        this.readRenderTargetPixels = function(j, me, Ee, Se, he, Ze, ft, vt=0) {
                            if (!(j && j.isWebGLRenderTarget)) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                return
                            }
                            let ut = Ie.get(j).__webglFramebuffer;
                            if (j.isWebGLCubeRenderTarget && ft !== void 0 && (ut = ut[ft]),
                            ut) {
                                Pe.bindFramebuffer(ne.FRAMEBUFFER, ut);
                                try {
                                    const Dt = j.textures[vt]
                                      , bt = Dt.format
                                      , Nt = Dt.type;
                                    if (!Te.textureFormatReadable(bt)) {
                                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                        return
                                    }
                                    if (!Te.textureTypeReadable(Nt)) {
                                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        return
                                    }
                                    me >= 0 && me <= j.width - Se && Ee >= 0 && Ee <= j.height - he && (j.textures.length > 1 && ne.readBuffer(ne.COLOR_ATTACHMENT0 + vt),
                                    ne.readPixels(me, Ee, Se, he, ie.convert(bt), ie.convert(Nt), Ze))
                                } finally {
                                    const Dt = I !== null ? Ie.get(I).__webglFramebuffer : null;
                                    Pe.bindFramebuffer(ne.FRAMEBUFFER, Dt)
                                }
                            }
                        }
                        ,
                        this.readRenderTargetPixelsAsync = async function(j, me, Ee, Se, he, Ze, ft, vt=0) {
                            if (!(j && j.isWebGLRenderTarget))
                                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                            let ut = Ie.get(j).__webglFramebuffer;
                            if (j.isWebGLCubeRenderTarget && ft !== void 0 && (ut = ut[ft]),
                            ut)
                                if (me >= 0 && me <= j.width - Se && Ee >= 0 && Ee <= j.height - he) {
                                    Pe.bindFramebuffer(ne.FRAMEBUFFER, ut);
                                    const Dt = j.textures[vt]
                                      , bt = Dt.format
                                      , Nt = Dt.type;
                                    if (!Te.textureFormatReadable(bt))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                    if (!Te.textureTypeReadable(Nt))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                    const un = ne.createBuffer();
                                    ne.bindBuffer(ne.PIXEL_PACK_BUFFER, un),
                                    ne.bufferData(ne.PIXEL_PACK_BUFFER, Ze.byteLength, ne.STREAM_READ),
                                    j.textures.length > 1 && ne.readBuffer(ne.COLOR_ATTACHMENT0 + vt),
                                    ne.readPixels(me, Ee, Se, he, ie.convert(bt), ie.convert(Nt), 0);
                                    const yn = I !== null ? Ie.get(I).__webglFramebuffer : null;
                                    Pe.bindFramebuffer(ne.FRAMEBUFFER, yn);
                                    const Cn = ne.fenceSync(ne.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                    return ne.flush(),
                                    await aB(ne, Cn, 4),
                                    ne.bindBuffer(ne.PIXEL_PACK_BUFFER, un),
                                    ne.getBufferSubData(ne.PIXEL_PACK_BUFFER, 0, Ze),
                                    ne.deleteBuffer(un),
                                    ne.deleteSync(Cn),
                                    Ze
                                } else
                                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                        ,
                        this.copyFramebufferToTexture = function(j, me=null, Ee=0) {
                            const Se = Math.pow(2, -Ee)
                              , he = Math.floor(j.image.width * Se)
                              , Ze = Math.floor(j.image.height * Se)
                              , ft = me !== null ? me.x : 0
                              , vt = me !== null ? me.y : 0;
                            Fe.setTexture2D(j, 0),
                            ne.copyTexSubImage2D(ne.TEXTURE_2D, Ee, 0, 0, ft, vt, he, Ze),
                            Pe.unbindTexture()
                        }
                        ;
                        const ho = ne.createFramebuffer()
                          , Bi = ne.createFramebuffer();
                        this.copyTextureToTexture = function(j, me, Ee=null, Se=null, he=0, Ze=null) {
                            Ze === null && (he !== 0 ? (Jg("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                            Ze = he,
                            he = 0) : Ze = 0);
                            let ft, vt, ut, Dt, bt, Nt, un, yn, Cn;
                            const Ln = j.isCompressedTexture ? j.mipmaps[Ze] : j.image;
                            if (Ee !== null)
                                ft = Ee.max.x - Ee.min.x,
                                vt = Ee.max.y - Ee.min.y,
                                ut = Ee.isBox3 ? Ee.max.z - Ee.min.z : 1,
                                Dt = Ee.min.x,
                                bt = Ee.min.y,
                                Nt = Ee.isBox3 ? Ee.min.z : 0;
                            else {
                                const cs = Math.pow(2, -he);
                                ft = Math.floor(Ln.width * cs),
                                vt = Math.floor(Ln.height * cs),
                                j.isDataArrayTexture ? ut = Ln.depth : j.isData3DTexture ? ut = Math.floor(Ln.depth * cs) : ut = 1,
                                Dt = 0,
                                bt = 0,
                                Nt = 0
                            }
                            Se !== null ? (un = Se.x,
                            yn = Se.y,
                            Cn = Se.z) : (un = 0,
                            yn = 0,
                            Cn = 0);
                            const Pn = ie.convert(me.format)
                              , Tt = ie.convert(me.type);
                            let Mn;
                            me.isData3DTexture ? (Fe.setTexture3D(me, 0),
                            Mn = ne.TEXTURE_3D) : me.isDataArrayTexture || me.isCompressedArrayTexture ? (Fe.setTexture2DArray(me, 0),
                            Mn = ne.TEXTURE_2D_ARRAY) : (Fe.setTexture2D(me, 0),
                            Mn = ne.TEXTURE_2D),
                            ne.pixelStorei(ne.UNPACK_FLIP_Y_WEBGL, me.flipY),
                            ne.pixelStorei(ne.UNPACK_PREMULTIPLY_ALPHA_WEBGL, me.premultiplyAlpha),
                            ne.pixelStorei(ne.UNPACK_ALIGNMENT, me.unpackAlignment);
                            const dn = ne.getParameter(ne.UNPACK_ROW_LENGTH)
                              , va = ne.getParameter(ne.UNPACK_IMAGE_HEIGHT)
                              , Va = ne.getParameter(ne.UNPACK_SKIP_PIXELS)
                              , ls = ne.getParameter(ne.UNPACK_SKIP_ROWS)
                              , ur = ne.getParameter(ne.UNPACK_SKIP_IMAGES);
                            ne.pixelStorei(ne.UNPACK_ROW_LENGTH, Ln.width),
                            ne.pixelStorei(ne.UNPACK_IMAGE_HEIGHT, Ln.height),
                            ne.pixelStorei(ne.UNPACK_SKIP_PIXELS, Dt),
                            ne.pixelStorei(ne.UNPACK_SKIP_ROWS, bt),
                            ne.pixelStorei(ne.UNPACK_SKIP_IMAGES, Nt);
                            const Gn = j.isDataArrayTexture || j.isData3DTexture
                              , Qn = me.isDataArrayTexture || me.isData3DTexture;
                            if (j.isDepthTexture) {
                                const cs = Ie.get(j)
                                  , Mi = Ie.get(me)
                                  , bs = Ie.get(cs.__renderTarget)
                                  , hr = Ie.get(Mi.__renderTarget);
                                Pe.bindFramebuffer(ne.READ_FRAMEBUFFER, bs.__webglFramebuffer),
                                Pe.bindFramebuffer(ne.DRAW_FRAMEBUFFER, hr.__webglFramebuffer);
                                for (let zr = 0; zr < ut; zr++)
                                    Gn && (ne.framebufferTextureLayer(ne.READ_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, Ie.get(j).__webglTexture, he, Nt + zr),
                                    ne.framebufferTextureLayer(ne.DRAW_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, Ie.get(me).__webglTexture, Ze, Cn + zr)),
                                    ne.blitFramebuffer(Dt, bt, ft, vt, un, yn, ft, vt, ne.DEPTH_BUFFER_BIT, ne.NEAREST);
                                Pe.bindFramebuffer(ne.READ_FRAMEBUFFER, null),
                                Pe.bindFramebuffer(ne.DRAW_FRAMEBUFFER, null)
                            } else if (he !== 0 || j.isRenderTargetTexture || Ie.has(j)) {
                                const cs = Ie.get(j)
                                  , Mi = Ie.get(me);
                                Pe.bindFramebuffer(ne.READ_FRAMEBUFFER, ho),
                                Pe.bindFramebuffer(ne.DRAW_FRAMEBUFFER, Bi);
                                for (let bs = 0; bs < ut; bs++)
                                    Gn ? ne.framebufferTextureLayer(ne.READ_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, cs.__webglTexture, he, Nt + bs) : ne.framebufferTexture2D(ne.READ_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_2D, cs.__webglTexture, he),
                                    Qn ? ne.framebufferTextureLayer(ne.DRAW_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, Mi.__webglTexture, Ze, Cn + bs) : ne.framebufferTexture2D(ne.DRAW_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_2D, Mi.__webglTexture, Ze),
                                    he !== 0 ? ne.blitFramebuffer(Dt, bt, ft, vt, un, yn, ft, vt, ne.COLOR_BUFFER_BIT, ne.NEAREST) : Qn ? ne.copyTexSubImage3D(Mn, Ze, un, yn, Cn + bs, Dt, bt, ft, vt) : ne.copyTexSubImage2D(Mn, Ze, un, yn, Dt, bt, ft, vt);
                                Pe.bindFramebuffer(ne.READ_FRAMEBUFFER, null),
                                Pe.bindFramebuffer(ne.DRAW_FRAMEBUFFER, null)
                            } else
                                Qn ? j.isDataTexture || j.isData3DTexture ? ne.texSubImage3D(Mn, Ze, un, yn, Cn, ft, vt, ut, Pn, Tt, Ln.data) : me.isCompressedArrayTexture ? ne.compressedTexSubImage3D(Mn, Ze, un, yn, Cn, ft, vt, ut, Pn, Ln.data) : ne.texSubImage3D(Mn, Ze, un, yn, Cn, ft, vt, ut, Pn, Tt, Ln) : j.isDataTexture ? ne.texSubImage2D(ne.TEXTURE_2D, Ze, un, yn, ft, vt, Pn, Tt, Ln.data) : j.isCompressedTexture ? ne.compressedTexSubImage2D(ne.TEXTURE_2D, Ze, un, yn, Ln.width, Ln.height, Pn, Ln.data) : ne.texSubImage2D(ne.TEXTURE_2D, Ze, un, yn, ft, vt, Pn, Tt, Ln);
                            ne.pixelStorei(ne.UNPACK_ROW_LENGTH, dn),
                            ne.pixelStorei(ne.UNPACK_IMAGE_HEIGHT, va),
                            ne.pixelStorei(ne.UNPACK_SKIP_PIXELS, Va),
                            ne.pixelStorei(ne.UNPACK_SKIP_ROWS, ls),
                            ne.pixelStorei(ne.UNPACK_SKIP_IMAGES, ur),
                            Ze === 0 && me.generateMipmaps && ne.generateMipmap(Mn),
                            Pe.unbindTexture()
                        }
                        ,
                        this.initRenderTarget = function(j) {
                            Ie.get(j).__webglFramebuffer === void 0 && Fe.setupRenderTarget(j)
                        }
                        ,
                        this.initTexture = function(j) {
                            j.isCubeTexture ? Fe.setTextureCube(j, 0) : j.isData3DTexture ? Fe.setTexture3D(j, 0) : j.isDataArrayTexture || j.isCompressedArrayTexture ? Fe.setTexture2DArray(j, 0) : Fe.setTexture2D(j, 0),
                            Pe.unbindTexture()
                        }
                        ,
                        this.resetState = function() {
                            U = 0,
                            B = 0,
                            I = null,
                            Pe.reset(),
                            Re.reset()
                        }
                        ,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    get coordinateSystem() {
                        return br
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e;
                        const t = this.getContext();
                        t.drawingBufferColorSpace = An._getDrawingBufferColorSpace(e),
                        t.unpackColorSpace = An._getUnpackColorSpace()
                    }
                }
                  , X4 = cn({
                    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js": (e => {
                        var t = Jd();
                        function n(_, x) {
                            return _ === x && (_ !== 0 || 1 / _ === 1 / x) || _ !== _ && x !== x
                        }
                        var i = typeof Object.is == "function" ? Object.is : n
                          , s = t.useState
                          , r = t.useEffect
                          , l = t.useLayoutEffect
                          , h = t.useDebugValue;
                        function d(_, x) {
                            var b = x()
                              , E = s({
                                inst: {
                                    value: b,
                                    getSnapshot: x
                                }
                            })
                              , T = E[0].inst
                              , M = E[1];
                            return l(function() {
                                T.value = b,
                                T.getSnapshot = x,
                                p(T) && M({
                                    inst: T
                                })
                            }, [_, b, x]),
                            r(function() {
                                return p(T) && M({
                                    inst: T
                                }),
                                _(function() {
                                    p(T) && M({
                                        inst: T
                                    })
                                })
                            }, [_]),
                            h(b),
                            b
                        }
                        function p(_) {
                            var x = _.getSnapshot;
                            _ = _.value;
                            try {
                                var b = x();
                                return !i(_, b)
                            } catch {
                                return !0
                            }
                        }
                        function m(_, x) {
                            return x()
                        }
                        var v = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? m : d;
                        e.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : v
                    }
                    )
                })
                  , q4 = cn({
                    "node_modules/use-sync-external-store/shim/index.js": ( (e, t) => {
                        t.exports = X4()
                    }
                    )
                })
                  , Y4 = cn({
                    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js": (e => {
                        var t = Jd()
                          , n = q4();
                        function i(m, v) {
                            return m === v && (m !== 0 || 1 / m === 1 / v) || m !== m && v !== v
                        }
                        var s = typeof Object.is == "function" ? Object.is : i
                          , r = n.useSyncExternalStore
                          , l = t.useRef
                          , h = t.useEffect
                          , d = t.useMemo
                          , p = t.useDebugValue;
                        e.useSyncExternalStoreWithSelector = function(m, v, _, x, b) {
                            var E = l(null);
                            if (E.current === null) {
                                var T = {
                                    hasValue: !1,
                                    value: null
                                };
                                E.current = T
                            } else
                                T = E.current;
                            E = d(function() {
                                function D(I) {
                                    if (!R) {
                                        if (R = !0,
                                        O = I,
                                        I = x(I),
                                        b !== void 0 && T.hasValue) {
                                            var F = T.value;
                                            if (b(F, I))
                                                return U = F
                                        }
                                        return U = I
                                    }
                                    if (F = U,
                                    s(O, I))
                                        return F;
                                    var P = x(I);
                                    return b !== void 0 && b(F, P) ? (O = I,
                                    F) : (O = I,
                                    U = P)
                                }
                                var R = !1, O, U, B = _ === void 0 ? null : _;
                                return [function() {
                                    return D(v())
                                }
                                , B === null ? void 0 : function() {
                                    return D(B())
                                }
                                ]
                            }, [v, _, x, b]);
                            var M = r(m, E[0], E[1]);
                            return h(function() {
                                T.hasValue = !0,
                                T.value = M
                            }, [M]),
                            p(M),
                            M
                        }
                    }
                    )
                })
                  , W4 = cn({
                    "node_modules/use-sync-external-store/shim/with-selector.js": ( (e, t) => {
                        t.exports = Y4()
                    }
                    )
                })
                  , j4 = tr(W4(), 1);
                const J1 = e => {
                    let t;
                    const n = new Set
                      , i = (p, m) => {
                        const v = typeof p == "function" ? p(t) : p;
                        if (!Object.is(v, t)) {
                            const _ = t;
                            t = m ?? (typeof v != "object" || v === null) ? v : Object.assign({}, t, v),
                            n.forEach(x => x(t, _))
                        }
                    }
                      , s = () => t
                      , h = {
                        setState: i,
                        getState: s,
                        getInitialState: () => d,
                        subscribe: p => (n.add(p),
                        () => n.delete(p))
                    }
                      , d = t = e(i, s, h);
                    return h
                }
                  , Q4 = (e => e ? J1(e) : J1)
                  , {useSyncExternalStoreWithSelector: Z4} = j4.default
                  , K4 = e => e;
                function J4(e, t=K4, n) {
                    const i = Z4(e.subscribe, e.getState, e.getInitialState, t, n);
                    return Le.useDebugValue(i),
                    i
                }
                const $1 = (e, t) => {
                    const n = Q4(e)
                      , i = (s, r=t) => J4(n, s, r);
                    return Object.assign(i, n),
                    i
                }
                  , eR = ( (e, t) => e ? $1(e, t) : $1)
                  , $4 = e => typeof e == "object" && typeof e.then == "function"
                  , Of = [];
                function tR(e, t, n= (i, s) => i === s) {
                    if (e === t)
                        return !0;
                    if (!e || !t)
                        return !1;
                    const i = e.length;
                    if (t.length !== i)
                        return !1;
                    for (let s = 0; s < i; s++)
                        if (!n(e[s], t[s]))
                            return !1;
                    return !0
                }
                function nR(e, t=null, n=!1, i={}) {
                    t === null && (t = [e]);
                    for (const r of Of)
                        if (tR(t, r.keys, r.equal)) {
                            if (n)
                                return;
                            if (Object.prototype.hasOwnProperty.call(r, "error"))
                                throw r.error;
                            if (Object.prototype.hasOwnProperty.call(r, "response"))
                                return i.lifespan && i.lifespan > 0 && (r.timeout && clearTimeout(r.timeout),
                                r.timeout = setTimeout(r.remove, i.lifespan)),
                                r.response;
                            if (!n)
                                throw r.promise
                        }
                    const s = {
                        keys: t,
                        equal: i.equal,
                        remove: () => {
                            const r = Of.indexOf(s);
                            r !== -1 && Of.splice(r, 1)
                        }
                        ,
                        promise: ($4(e) ? e : e(...t)).then(r => {
                            s.response = r,
                            i.lifespan && i.lifespan > 0 && (s.timeout = setTimeout(s.remove, i.lifespan))
                        }
                        ).catch(r => s.error = r)
                    };
                    if (Of.push(s),
                    !n)
                        throw s.promise
                }
                const ez = (e, t, n) => nR(e, t, !1, n)
                  , tz = (e, t, n) => void nR(e, t, !0, n)
                  , nz = e => {
                    if (e === void 0 || e.length === 0)
                        Of.splice(0, Of.length);
                    else {
                        const t = Of.find(n => tR(e, n.keys, n.equal));
                        t && t.remove()
                    }
                }
                ;
                var iz = cn({
                    "node_modules/scheduler/cjs/scheduler.production.js": (e => {
                        function t(G, V) {
                            var q = G.length;
                            G.push(V);
                            e: for (; 0 < q; ) {
                                var ee = q - 1 >>> 1
                                  , se = G[ee];
                                if (0 < s(se, V))
                                    G[ee] = V,
                                    G[q] = se,
                                    q = ee;
                                else
                                    break e
                            }
                        }
                        function n(G) {
                            return G.length === 0 ? null : G[0]
                        }
                        function i(G) {
                            if (G.length === 0)
                                return null;
                            var V = G[0]
                              , q = G.pop();
                            if (q !== V) {
                                G[0] = q;
                                e: for (var ee = 0, se = G.length, X = se >>> 1; ee < X; ) {
                                    var J = 2 * (ee + 1) - 1
                                      , ze = G[J]
                                      , xe = J + 1
                                      , le = G[xe];
                                    if (0 > s(ze, q))
                                        xe < se && 0 > s(le, ze) ? (G[ee] = le,
                                        G[xe] = q,
                                        ee = xe) : (G[ee] = ze,
                                        G[J] = q,
                                        ee = J);
                                    else if (xe < se && 0 > s(le, q))
                                        G[ee] = le,
                                        G[xe] = q,
                                        ee = xe;
                                    else
                                        break e
                                }
                            }
                            return V
                        }
                        function s(G, V) {
                            var q = G.sortIndex - V.sortIndex;
                            return q !== 0 ? q : G.id - V.id
                        }
                        if (typeof performance == "object" && typeof performance.now == "function") {
                            var r = performance;
                            e.unstable_now = function() {
                                return r.now()
                            }
                        } else {
                            var l = Date
                              , h = l.now();
                            e.unstable_now = function() {
                                return l.now() - h
                            }
                        }
                        var d = []
                          , p = []
                          , m = 1
                          , v = null
                          , _ = 3
                          , x = !1
                          , b = !1
                          , E = !1
                          , T = typeof setTimeout == "function" ? setTimeout : null
                          , M = typeof clearTimeout == "function" ? clearTimeout : null
                          , D = typeof setImmediate < "u" ? setImmediate : null;
                        function R(G) {
                            for (var V = n(p); V !== null; ) {
                                if (V.callback === null)
                                    i(p);
                                else if (V.startTime <= G)
                                    i(p),
                                    V.sortIndex = V.expirationTime,
                                    t(d, V);
                                else
                                    break;
                                V = n(p)
                            }
                        }
                        function O(G) {
                            if (E = !1,
                            R(G),
                            !b)
                                if (n(d) !== null)
                                    b = !0,
                                    te();
                                else {
                                    var V = n(p);
                                    V !== null && ce(O, V.startTime - G)
                                }
                        }
                        var U = !1
                          , B = -1
                          , I = 5
                          , F = -1;
                        function P() {
                            return !(e.unstable_now() - F < I)
                        }
                        function L() {
                            if (U) {
                                var G = e.unstable_now();
                                F = G;
                                var V = !0;
                                try {
                                    e: {
                                        b = !1,
                                        E && (E = !1,
                                        M(B),
                                        B = -1),
                                        x = !0;
                                        var q = _;
                                        try {
                                            t: {
                                                for (R(G),
                                                v = n(d); v !== null && !(v.expirationTime > G && P()); ) {
                                                    var ee = v.callback;
                                                    if (typeof ee == "function") {
                                                        v.callback = null,
                                                        _ = v.priorityLevel;
                                                        var se = ee(v.expirationTime <= G);
                                                        if (G = e.unstable_now(),
                                                        typeof se == "function") {
                                                            v.callback = se,
                                                            R(G),
                                                            V = !0;
                                                            break t
                                                        }
                                                        v === n(d) && i(d),
                                                        R(G)
                                                    } else
                                                        i(d);
                                                    v = n(d)
                                                }
                                                if (v !== null)
                                                    V = !0;
                                                else {
                                                    var X = n(p);
                                                    X !== null && ce(O, X.startTime - G),
                                                    V = !1
                                                }
                                            }
                                            break e
                                        } finally {
                                            v = null,
                                            _ = q,
                                            x = !1
                                        }
                                        V = void 0
                                    }
                                } finally {
                                    V ? H() : U = !1
                                }
                            }
                        }
                        var H;
                        if (typeof D == "function")
                            H = function() {
                                D(L)
                            }
                            ;
                        else if (typeof MessageChannel < "u") {
                            var Z = new MessageChannel
                              , K = Z.port2;
                            Z.port1.onmessage = L,
                            H = function() {
                                K.postMessage(null)
                            }
                        } else
                            H = function() {
                                T(L, 0)
                            }
                            ;
                        function te() {
                            U || (U = !0,
                            H())
                        }
                        function ce(G, V) {
                            B = T(function() {
                                G(e.unstable_now())
                            }, V)
                        }
                        e.unstable_IdlePriority = 5,
                        e.unstable_ImmediatePriority = 1,
                        e.unstable_LowPriority = 4,
                        e.unstable_NormalPriority = 3,
                        e.unstable_Profiling = null,
                        e.unstable_UserBlockingPriority = 2,
                        e.unstable_cancelCallback = function(G) {
                            G.callback = null
                        }
                        ,
                        e.unstable_continueExecution = function() {
                            b || x || (b = !0,
                            te())
                        }
                        ,
                        e.unstable_forceFrameRate = function(G) {
                            0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < G ? Math.floor(1e3 / G) : 5
                        }
                        ,
                        e.unstable_getCurrentPriorityLevel = function() {
                            return _
                        }
                        ,
                        e.unstable_getFirstCallbackNode = function() {
                            return n(d)
                        }
                        ,
                        e.unstable_next = function(G) {
                            switch (_) {
                            case 1:
                            case 2:
                            case 3:
                                var V = 3;
                                break;
                            default:
                                V = _
                            }
                            var q = _;
                            _ = V;
                            try {
                                return G()
                            } finally {
                                _ = q
                            }
                        }
                        ,
                        e.unstable_pauseExecution = function() {}
                        ,
                        e.unstable_requestPaint = function() {}
                        ,
                        e.unstable_runWithPriority = function(G, V) {
                            switch (G) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            default:
                                G = 3
                            }
                            var q = _;
                            _ = G;
                            try {
                                return V()
                            } finally {
                                _ = q
                            }
                        }
                        ,
                        e.unstable_scheduleCallback = function(G, V, q) {
                            var ee = e.unstable_now();
                            switch (typeof q == "object" && q !== null ? (q = q.delay,
                            q = typeof q == "number" && 0 < q ? ee + q : ee) : q = ee,
                            G) {
                            case 1:
                                var se = -1;
                                break;
                            case 2:
                                se = 250;
                                break;
                            case 5:
                                se = 1073741823;
                                break;
                            case 4:
                                se = 1e4;
                                break;
                            default:
                                se = 5e3
                            }
                            return se = q + se,
                            G = {
                                id: m++,
                                callback: V,
                                priorityLevel: G,
                                startTime: q,
                                expirationTime: se,
                                sortIndex: -1
                            },
                            q > ee ? (G.sortIndex = q,
                            t(p, G),
                            n(d) === null && G === n(p) && (E ? (M(B),
                            B = -1) : E = !0,
                            ce(O, q - ee))) : (G.sortIndex = se,
                            t(d, G),
                            b || x || (b = !0,
                            te())),
                            G
                        }
                        ,
                        e.unstable_shouldYield = P,
                        e.unstable_wrapCallback = function(G) {
                            var V = _;
                            return function() {
                                var q = _;
                                _ = V;
                                try {
                                    return G.apply(this, arguments)
                                } finally {
                                    _ = q
                                }
                            }
                        }
                    }
                    )
                })
                  , eM = cn({
                    "node_modules/scheduler/index.js": ( (e, t) => {
                        t.exports = iz()
                    }
                    )
                })
                  , sz = cn({
                    "node_modules/react-reconciler/cjs/react-reconciler.production.js": ( (e, t) => {
                        t.exports = function(n) {
                            function i(c, u, y, A) {
                                return new qm(c,u,y,A)
                            }
                            function s() {}
                            function r(c) {
                                var u = "https://react.dev/errors/" + c;
                                if (1 < arguments.length) {
                                    u += "?args[]=" + encodeURIComponent(arguments[1]);
                                    for (var y = 2; y < arguments.length; y++)
                                        u += "&args[]=" + encodeURIComponent(arguments[y])
                                }
                                return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                            }
                            function l(c) {
                                return c === null || typeof c != "object" ? null : (c = bo && c[bo] || c["@@iterator"],
                                typeof c == "function" ? c : null)
                            }
                            function h(c) {
                                if (c == null)
                                    return null;
                                if (typeof c == "function")
                                    return c.$$typeof === Qm ? null : c.displayName || c.name || null;
                                if (typeof c == "string")
                                    return c;
                                switch (c) {
                                case ml:
                                    return "Fragment";
                                case qa:
                                    return "Portal";
                                case xd:
                                    return "Profiler";
                                case Bh:
                                    return "StrictMode";
                                case Sd:
                                    return "Suspense";
                                case su:
                                    return "SuspenseList"
                                }
                                if (typeof c == "object")
                                    switch (c.$$typeof) {
                                    case mr:
                                        return (c.displayName || "Context") + ".Provider";
                                    case Wm:
                                        return (c._context.displayName || "Context") + ".Consumer";
                                    case Ih:
                                        var u = c.render;
                                        return c = c.displayName,
                                        c || (c = u.displayName || u.name || "",
                                        c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"),
                                        c;
                                    case Ad:
                                        return u = c.displayName || null,
                                        u !== null ? u : h(c.type) || "Memo";
                                    case Ya:
                                        u = c._payload,
                                        c = c._init;
                                        try {
                                            return h(c(u))
                                        } catch {}
                                    }
                                return null
                            }
                            function d(c) {
                                if (Eo === void 0)
                                    try {
                                        throw Error()
                                    } catch (y) {
                                        var u = y.stack.trim().match(/\n( *(at )?)/);
                                        Eo = u && u[1] || "",
                                        gl = -1 < y.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < y.stack.indexOf("@") ? "@unknown:0:0" : ""
                                    }
                                return `
` + Eo + c + gl
                            }
                            function p(c, u) {
                                if (!c || ec)
                                    return "";
                                ec = !0;
                                var y = Error.prepareStackTrace;
                                Error.prepareStackTrace = void 0;
                                try {
                                    var A = {
                                        DetermineComponentFrameRoot: function() {
                                            try {
                                                if (u) {
                                                    var dt = function() {
                                                        throw Error()
                                                    };
                                                    if (Object.defineProperty(dt.prototype, "props", {
                                                        set: function() {
                                                            throw Error()
                                                        }
                                                    }),
                                                    typeof Reflect == "object" && Reflect.construct) {
                                                        try {
                                                            Reflect.construct(dt, [])
                                                        } catch (Qt) {
                                                            var mt = Qt
                                                        }
                                                        Reflect.construct(c, [], dt)
                                                    } else {
                                                        try {
                                                            dt.call()
                                                        } catch (Qt) {
                                                            mt = Qt
                                                        }
                                                        c.call(dt.prototype)
                                                    }
                                                } else {
                                                    try {
                                                        throw Error()
                                                    } catch (Qt) {
                                                        mt = Qt
                                                    }
                                                    (dt = c()) && typeof dt.catch == "function" && dt.catch(function() {})
                                                }
                                            } catch (Qt) {
                                                if (Qt && mt && typeof Qt.stack == "string")
                                                    return [Qt.stack, mt.stack]
                                            }
                                            return [null, null]
                                        }
                                    };
                                    A.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                                    var C = Object.getOwnPropertyDescriptor(A.DetermineComponentFrameRoot, "name");
                                    C && C.configurable && Object.defineProperty(A.DetermineComponentFrameRoot, "name", {
                                        value: "DetermineComponentFrameRoot"
                                    });
                                    var N = A.DetermineComponentFrameRoot()
                                      , W = N[0]
                                      , oe = N[1];
                                    if (W && oe) {
                                        var ve = W.split(`
`)
                                          , Xe = oe.split(`
`);
                                        for (C = A = 0; A < ve.length && !ve[A].includes("DetermineComponentFrameRoot"); )
                                            A++;
                                        for (; C < Xe.length && !Xe[C].includes("DetermineComponentFrameRoot"); )
                                            C++;
                                        if (A === ve.length || C === Xe.length)
                                            for (A = ve.length - 1,
                                            C = Xe.length - 1; 1 <= A && 0 <= C && ve[A] !== Xe[C]; )
                                                C--;
                                        for (; 1 <= A && 0 <= C; A--,
                                        C--)
                                            if (ve[A] !== Xe[C]) {
                                                if (A !== 1 || C !== 1)
                                                    do
                                                        if (A--,
                                                        C--,
                                                        0 > C || ve[A] !== Xe[C]) {
                                                            var it = `
` + ve[A].replace(" at new ", " at ");
                                                            return c.displayName && it.includes("<anonymous>") && (it = it.replace("<anonymous>", c.displayName)),
                                                            it
                                                        }
                                                    while (1 <= A && 0 <= C);
                                                break
                                            }
                                    }
                                } finally {
                                    ec = !1,
                                    Error.prepareStackTrace = y
                                }
                                return (y = c ? c.displayName || c.name : "") ? d(y) : ""
                            }
                            function m(c) {
                                switch (c.tag) {
                                case 26:
                                case 27:
                                case 5:
                                    return d(c.type);
                                case 16:
                                    return d("Lazy");
                                case 13:
                                    return d("Suspense");
                                case 19:
                                    return d("SuspenseList");
                                case 0:
                                case 15:
                                    return c = p(c.type, !1),
                                    c;
                                case 11:
                                    return c = p(c.type.render, !1),
                                    c;
                                case 1:
                                    return c = p(c.type, !0),
                                    c;
                                default:
                                    return ""
                                }
                            }
                            function v(c) {
                                try {
                                    var u = "";
                                    do
                                        u += m(c),
                                        c = c.return;
                                    while (c);
                                    return u
                                } catch (y) {
                                    return `
Error generating stack: ` + y.message + `
` + y.stack
                                }
                            }
                            function _(c) {
                                var u = c
                                  , y = c;
                                if (c.alternate)
                                    for (; u.return; )
                                        u = u.return;
                                else {
                                    c = u;
                                    do
                                        u = c,
                                        (u.flags & 4098) !== 0 && (y = u.return),
                                        c = u.return;
                                    while (c)
                                }
                                return u.tag === 3 ? y : null
                            }
                            function x(c) {
                                if (_(c) !== c)
                                    throw Error(r(188))
                            }
                            function b(c) {
                                var u = c.alternate;
                                if (!u) {
                                    if (u = _(c),
                                    u === null)
                                        throw Error(r(188));
                                    return u !== c ? null : c
                                }
                                for (var y = c, A = u; ; ) {
                                    var C = y.return;
                                    if (C === null)
                                        break;
                                    var N = C.alternate;
                                    if (N === null) {
                                        if (A = C.return,
                                        A !== null) {
                                            y = A;
                                            continue
                                        }
                                        break
                                    }
                                    if (C.child === N.child) {
                                        for (N = C.child; N; ) {
                                            if (N === y)
                                                return x(C),
                                                c;
                                            if (N === A)
                                                return x(C),
                                                u;
                                            N = N.sibling
                                        }
                                        throw Error(r(188))
                                    }
                                    if (y.return !== A.return)
                                        y = C,
                                        A = N;
                                    else {
                                        for (var W = !1, oe = C.child; oe; ) {
                                            if (oe === y) {
                                                W = !0,
                                                y = C,
                                                A = N;
                                                break
                                            }
                                            if (oe === A) {
                                                W = !0,
                                                A = C,
                                                y = N;
                                                break
                                            }
                                            oe = oe.sibling
                                        }
                                        if (!W) {
                                            for (oe = N.child; oe; ) {
                                                if (oe === y) {
                                                    W = !0,
                                                    y = N,
                                                    A = C;
                                                    break
                                                }
                                                if (oe === A) {
                                                    W = !0,
                                                    A = N,
                                                    y = C;
                                                    break
                                                }
                                                oe = oe.sibling
                                            }
                                            if (!W)
                                                throw Error(r(189))
                                        }
                                    }
                                    if (y.alternate !== A)
                                        throw Error(r(190))
                                }
                                if (y.tag !== 3)
                                    throw Error(r(188));
                                return y.stateNode.current === y ? c : u
                            }
                            function E(c) {
                                var u = c.tag;
                                if (u === 5 || u === 26 || u === 27 || u === 6)
                                    return c;
                                for (c = c.child; c !== null; ) {
                                    if (u = E(c),
                                    u !== null)
                                        return u;
                                    c = c.sibling
                                }
                                return null
                            }
                            function T(c) {
                                var u = c.tag;
                                if (u === 5 || u === 26 || u === 27 || u === 6)
                                    return c;
                                for (c = c.child; c !== null; ) {
                                    if (c.tag !== 4 && (u = T(c),
                                    u !== null))
                                        return u;
                                    c = c.sibling
                                }
                                return null
                            }
                            function M(c) {
                                return {
                                    current: c
                                }
                            }
                            function D(c) {
                                0 > Do || (c.current = wi[Do],
                                wi[Do] = null,
                                Do--)
                            }
                            function R(c, u) {
                                Do++,
                                wi[Do] = c.current,
                                c.current = u
                            }
                            function O(c) {
                                return c >>>= 0,
                                c === 0 ? 32 : 31 - (cy(c) / uy | 0) | 0
                            }
                            function U(c) {
                                var u = c & 42;
                                if (u !== 0)
                                    return u;
                                switch (c & -c) {
                                case 1:
                                    return 1;
                                case 2:
                                    return 2;
                                case 4:
                                    return 4;
                                case 8:
                                    return 8;
                                case 16:
                                    return 16;
                                case 32:
                                    return 32;
                                case 64:
                                    return 64;
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                    return c & 4194176;
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    return c & 62914560;
                                case 67108864:
                                    return 67108864;
                                case 134217728:
                                    return 134217728;
                                case 268435456:
                                    return 268435456;
                                case 536870912:
                                    return 536870912;
                                case 1073741824:
                                    return 0;
                                default:
                                    return c
                                }
                            }
                            function B(c, u) {
                                var y = c.pendingLanes;
                                if (y === 0)
                                    return 0;
                                var A = 0
                                  , C = c.suspendedLanes
                                  , N = c.pingedLanes
                                  , W = c.warmLanes;
                                c = c.finishedLanes !== 0;
                                var oe = y & 134217727;
                                return oe !== 0 ? (y = oe & ~C,
                                y !== 0 ? A = U(y) : (N &= oe,
                                N !== 0 ? A = U(N) : c || (W = oe & ~W,
                                W !== 0 && (A = U(W))))) : (oe = y & ~C,
                                oe !== 0 ? A = U(oe) : N !== 0 ? A = U(N) : c || (W = y & ~W,
                                W !== 0 && (A = U(W)))),
                                A === 0 ? 0 : u !== 0 && u !== A && (u & C) === 0 && (C = A & -A,
                                W = u & -u,
                                C >= W || C === 32 && (W & 4194176) !== 0) ? u : A
                            }
                            function I(c, u) {
                                return (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & u) === 0
                            }
                            function F(c, u) {
                                switch (c) {
                                case 1:
                                case 2:
                                case 4:
                                case 8:
                                    return u + 250;
                                case 16:
                                case 32:
                                case 64:
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                    return u + 5e3;
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    return -1;
                                case 67108864:
                                case 134217728:
                                case 268435456:
                                case 536870912:
                                case 1073741824:
                                    return -1;
                                default:
                                    return -1
                                }
                            }
                            function P() {
                                var c = Xr;
                                return Xr <<= 1,
                                (Xr & 4194176) === 0 && (Xr = 128),
                                c
                            }
                            function L() {
                                var c = ic;
                                return ic <<= 1,
                                (ic & 62914560) === 0 && (ic = 4194304),
                                c
                            }
                            function H(c) {
                                for (var u = [], y = 0; 31 > y; y++)
                                    u.push(c);
                                return u
                            }
                            function Z(c, u) {
                                c.pendingLanes |= u,
                                u !== 268435456 && (c.suspendedLanes = 0,
                                c.pingedLanes = 0,
                                c.warmLanes = 0)
                            }
                            function K(c, u, y, A, C, N) {
                                var W = c.pendingLanes;
                                c.pendingLanes = y,
                                c.suspendedLanes = 0,
                                c.pingedLanes = 0,
                                c.warmLanes = 0,
                                c.expiredLanes &= y,
                                c.entangledLanes &= y,
                                c.errorRecoveryDisabledLanes &= y,
                                c.shellSuspendCounter = 0;
                                var oe = c.entanglements
                                  , ve = c.expirationTimes
                                  , Xe = c.hiddenUpdates;
                                for (y = W & ~y; 0 < y; ) {
                                    var it = 31 - Hs(y)
                                      , dt = 1 << it;
                                    oe[it] = 0,
                                    ve[it] = -1;
                                    var mt = Xe[it];
                                    if (mt !== null)
                                        for (Xe[it] = null,
                                        it = 0; it < mt.length; it++) {
                                            var Qt = mt[it];
                                            Qt !== null && (Qt.lane &= -536870913)
                                        }
                                    y &= ~dt
                                }
                                A !== 0 && te(c, A, 0),
                                N !== 0 && C === 0 && c.tag !== 0 && (c.suspendedLanes |= N & ~(W & ~u))
                            }
                            function te(c, u, y) {
                                c.pendingLanes |= u,
                                c.suspendedLanes &= ~u;
                                var A = 31 - Hs(u);
                                c.entangledLanes |= u,
                                c.entanglements[A] = c.entanglements[A] | 1073741824 | y & 4194218
                            }
                            function ce(c, u) {
                                var y = c.entangledLanes |= u;
                                for (c = c.entanglements; y; ) {
                                    var A = 31 - Hs(y)
                                      , C = 1 << A;
                                    C & u | c[A] & u && (c[A] |= u),
                                    y &= ~C
                                }
                            }
                            function G(c) {
                                return c &= -c,
                                2 < c ? 8 < c ? (c & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                            }
                            function V(c) {
                                if (na && typeof na.onCommitFiberRoot == "function")
                                    try {
                                        na.onCommitFiberRoot(Ci, c, void 0, (c.current.flags & 128) === 128)
                                    } catch {}
                            }
                            function q(c) {
                                if (typeof fy == "function" && ts(c),
                                na && typeof na.setStrictMode == "function")
                                    try {
                                        na.setStrictMode(Ci, c)
                                    } catch {}
                            }
                            function ee(c, u) {
                                return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u
                            }
                            function se(c, u) {
                                if (typeof c == "object" && c !== null) {
                                    var y = mg.get(c);
                                    return y !== void 0 ? y : (u = {
                                        value: c,
                                        source: u,
                                        stack: v(u)
                                    },
                                    mg.set(c, u),
                                    u)
                                }
                                return {
                                    value: c,
                                    source: u,
                                    stack: v(u)
                                }
                            }
                            function X(c, u) {
                                sc[ac++] = du,
                                sc[ac++] = rc,
                                rc = c,
                                du = u
                            }
                            function J(c, u, y) {
                                Aa[Ta++] = yr,
                                Aa[Ta++] = _r,
                                Aa[Ta++] = Tl,
                                Tl = c;
                                var A = yr;
                                c = _r;
                                var C = 32 - Hs(A) - 1;
                                A &= ~(1 << C),
                                y += 1;
                                var N = 32 - Hs(u) + C;
                                if (30 < N) {
                                    var W = C - C % 5;
                                    N = (A & (1 << W) - 1).toString(32),
                                    A >>= W,
                                    C -= W,
                                    yr = 1 << 32 - Hs(u) + C | y << C | A,
                                    _r = N + c
                                } else
                                    yr = 1 << N | y << C | A,
                                    _r = c
                            }
                            function ze(c) {
                                c.return !== null && (X(c, 1),
                                J(c, 1, 0))
                            }
                            function xe(c) {
                                for (; c === rc; )
                                    rc = sc[--ac],
                                    sc[ac] = null,
                                    du = sc[--ac],
                                    sc[ac] = null;
                                for (; c === Tl; )
                                    Tl = Aa[--Ta],
                                    Aa[Ta] = null,
                                    _r = Aa[--Ta],
                                    Aa[Ta] = null,
                                    yr = Aa[--Ta],
                                    Aa[Ta] = null
                            }
                            function le(c, u) {
                                R(qr, u),
                                R(pu, c),
                                R(qi, null),
                                c = C0(u),
                                D(qi),
                                R(qi, c)
                            }
                            function Ne() {
                                D(qi),
                                D(pu),
                                D(qr)
                            }
                            function be(c) {
                                c.memoizedState !== null && R(oc, c);
                                var u = qi.current
                                  , y = lu(u, c.type);
                                u !== y && (R(pu, c),
                                R(qi, y))
                            }
                            function Ue(c) {
                                pu.current === c && (D(qi),
                                D(pu)),
                                oc.current === c && (D(oc),
                                zs ? gr._currentValue = yl : gr._currentValue2 = yl)
                            }
                            function $e(c) {
                                var u = Error(r(418, ""));
                                throw de(se(u, c)),
                                Xh
                            }
                            function rt(c, u) {
                                if (!ms)
                                    throw Error(r(175));
                                $0(c.stateNode, c.type, c.memoizedProps, u, c) || $e(c)
                            }
                            function Et(c) {
                                for (gs = c.return; gs; )
                                    switch (gs.tag) {
                                    case 3:
                                    case 27:
                                        ns = !0;
                                        return;
                                    case 5:
                                    case 13:
                                        ns = !1;
                                        return;
                                    default:
                                        gs = gs.return
                                    }
                            }
                            function ne(c) {
                                if (!ms || c !== gs)
                                    return !1;
                                if (!_n)
                                    return Et(c),
                                    _n = !0,
                                    !1;
                                var u = !1;
                                if (kn ? c.tag !== 3 && c.tag !== 27 && (c.tag !== 5 || Od(c.type) && !Jt(c.type, c.memoizedProps)) && (u = !0) : c.tag !== 3 && (c.tag !== 5 || Od(c.type) && !Jt(c.type, c.memoizedProps)) && (u = !0),
                                u && vs && $e(c),
                                Et(c),
                                c.tag === 13) {
                                    if (!ms)
                                        throw Error(r(316));
                                    if (c = c.memoizedState,
                                    c = c !== null ? c.dehydrated : null,
                                    !c)
                                        throw Error(r(317));
                                    vs = ty(c)
                                } else
                                    vs = gs ? ug(c.stateNode) : null;
                                return !0
                            }
                            function Ve() {
                                ms && (vs = gs = null,
                                _n = !1)
                            }
                            function de(c) {
                                Qa === null ? Qa = [c] : Qa.push(c)
                            }
                            function Te() {
                                for (var c = lc, u = xr = lc = 0; u < c; ) {
                                    var y = Za[u];
                                    Za[u++] = null;
                                    var A = Za[u];
                                    Za[u++] = null;
                                    var C = Za[u];
                                    Za[u++] = null;
                                    var N = Za[u];
                                    if (Za[u++] = null,
                                    A !== null && C !== null) {
                                        var W = A.pending;
                                        W === null ? C.next = C : (C.next = W.next,
                                        W.next = C),
                                        A.pending = C
                                    }
                                    N !== 0 && Fe(y, C, N)
                                }
                            }
                            function Pe(c, u, y, A) {
                                Za[lc++] = c,
                                Za[lc++] = u,
                                Za[lc++] = y,
                                Za[lc++] = A,
                                xr |= A,
                                c.lanes |= A,
                                c = c.alternate,
                                c !== null && (c.lanes |= A)
                            }
                            function Ye(c, u, y, A) {
                                return Pe(c, u, y, A),
                                xt(c)
                            }
                            function Ie(c, u) {
                                return Pe(c, null, null, u),
                                xt(c)
                            }
                            function Fe(c, u, y) {
                                c.lanes |= y;
                                var A = c.alternate;
                                A !== null && (A.lanes |= y);
                                for (var C = !1, N = c.return; N !== null; )
                                    N.childLanes |= y,
                                    A = N.alternate,
                                    A !== null && (A.childLanes |= y),
                                    N.tag === 22 && (c = N.stateNode,
                                    c === null || c._visibility & 1 || (C = !0)),
                                    c = N,
                                    N = N.return;
                                C && u !== null && c.tag === 3 && (N = c.stateNode,
                                C = 31 - Hs(y),
                                N = N.hiddenUpdates,
                                c = N[C],
                                c === null ? N[C] = [u] : c.push(u),
                                u.lane = y | 536870912)
                            }
                            function xt(c) {
                                if (50 < Tu)
                                    throw Tu = 0,
                                    Yd = null,
                                    Error(r(185));
                                for (var u = c.return; u !== null; )
                                    c = u,
                                    u = c.return;
                                return c.tag === 3 ? c.stateNode : null
                            }
                            function yt(c) {
                                c !== Oo && c.next === null && (Oo === null ? qh = Oo = c : Oo = Oo.next = c),
                                Zn = !0,
                                cc || (cc = !0,
                                Qe($))
                            }
                            function wt(c, u) {
                                if (!gg && Zn) {
                                    gg = !0;
                                    do
                                        for (var y = !1, A = qh; A !== null; ) {
                                            if (!u)
                                                if (c !== 0) {
                                                    var C = A.pendingLanes;
                                                    if (C === 0)
                                                        var N = 0;
                                                    else {
                                                        var W = A.suspendedLanes
                                                          , oe = A.pingedLanes;
                                                        N = (1 << 31 - Hs(42 | c) + 1) - 1,
                                                        N &= C & ~(W & ~oe),
                                                        N = N & 201326677 ? N & 201326677 | 1 : N ? N | 2 : 0
                                                    }
                                                    N !== 0 && (y = !0,
                                                    Ge(A, N))
                                                } else
                                                    N = pn,
                                                    N = B(A, A === On ? N : 0),
                                                    (N & 3) === 0 || I(A, N) || (y = !0,
                                                    Ge(A, N));
                                            A = A.next
                                        }
                                    while (y);
                                    gg = !1
                                }
                            }
                            function $() {
                                Zn = cc = !1;
                                var c = 0;
                                mu !== 0 && (N0() && (c = mu),
                                mu = 0);
                                for (var u = ja(), y = null, A = qh; A !== null; ) {
                                    var C = A.next
                                      , N = k(A, u);
                                    N === 0 ? (A.next = null,
                                    y === null ? qh = C : y.next = C,
                                    C === null && (Oo = y)) : (y = A,
                                    (c !== 0 || (N & 3) !== 0) && (Zn = !0)),
                                    A = C
                                }
                                wt(c, !1)
                            }
                            function k(c, u) {
                                for (var y = c.suspendedLanes, A = c.pingedLanes, C = c.expirationTimes, N = c.pendingLanes & -62914561; 0 < N; ) {
                                    var W = 31 - Hs(N)
                                      , oe = 1 << W
                                      , ve = C[W];
                                    ve === -1 ? ((oe & y) === 0 || (oe & A) !== 0) && (C[W] = F(oe, u)) : ve <= u && (c.expiredLanes |= oe),
                                    N &= ~oe
                                }
                                if (u = On,
                                y = pn,
                                y = B(c, c === u ? y : 0),
                                A = c.callbackNode,
                                y === 0 || c === u && zn === 2 || c.cancelPendingCommit !== null)
                                    return A !== null && A !== null && pg(A),
                                    c.callbackNode = null,
                                    c.callbackPriority = 0;
                                if ((y & 3) === 0 || I(c, y)) {
                                    if (u = y & -y,
                                    u === c.callbackPriority)
                                        return u;
                                    switch (A !== null && pg(A),
                                    G(y)) {
                                    case 2:
                                    case 8:
                                        y = hy;
                                        break;
                                    case 32:
                                        y = zd;
                                        break;
                                    case 268435456:
                                        y = PS;
                                        break;
                                    default:
                                        y = zd
                                    }
                                    return A = pe.bind(null, c),
                                    y = Pd(y, A),
                                    c.callbackPriority = u,
                                    c.callbackNode = y,
                                    u
                                }
                                return A !== null && A !== null && pg(A),
                                c.callbackPriority = 2,
                                c.callbackNode = null,
                                2
                            }
                            function pe(c, u) {
                                var y = c.callbackNode;
                                if (pr() && c.callbackNode !== y)
                                    return null;
                                var A = pn;
                                return A = B(c, c === On ? A : 0),
                                A === 0 ? null : (ul(c, A, u),
                                k(c, ja()),
                                c.callbackNode != null && c.callbackNode === y ? pe.bind(null, c) : null)
                            }
                            function Ge(c, u) {
                                if (pr())
                                    return null;
                                ul(c, u, !0)
                            }
                            function Qe(c) {
                                eg ? Ro(function() {
                                    (Sn & 6) !== 0 ? Pd(Ld, c) : c()
                                }) : Pd(Ld, c)
                            }
                            function Be() {
                                return mu === 0 && (mu = P()),
                                mu
                            }
                            function ct(c, u) {
                                if (gu === null) {
                                    var y = gu = [];
                                    uc = 0,
                                    Ma = Be(),
                                    hc = {
                                        status: "pending",
                                        value: void 0,
                                        then: function(A) {
                                            y.push(A)
                                        }
                                    }
                                }
                                return uc++,
                                u.then(Ke, Ke),
                                u
                            }
                            function Ke() {
                                if (--uc === 0 && gu !== null) {
                                    hc !== null && (hc.status = "fulfilled");
                                    var c = gu;
                                    gu = null,
                                    Ma = 0,
                                    hc = null;
                                    for (var u = 0; u < c.length; u++)
                                        (0,
                                        c[u])()
                                }
                            }
                            function _t(c, u) {
                                var y = []
                                  , A = {
                                    status: "pending",
                                    value: null,
                                    reason: null,
                                    then: function(C) {
                                        y.push(C)
                                    }
                                };
                                return c.then(function() {
                                    A.status = "fulfilled",
                                    A.value = u;
                                    for (var C = 0; C < y.length; C++)
                                        (0,
                                        y[C])(u)
                                }, function(C) {
                                    for (A.status = "rejected",
                                    A.reason = C,
                                    C = 0; C < y.length; C++)
                                        (0,
                                        y[C])(void 0)
                                }),
                                A
                            }
                            function Ct(c) {
                                c.updateQueue = {
                                    baseState: c.memoizedState,
                                    firstBaseUpdate: null,
                                    lastBaseUpdate: null,
                                    shared: {
                                        pending: null,
                                        lanes: 0,
                                        hiddenCallbacks: null
                                    },
                                    callbacks: null
                                }
                            }
                            function et(c, u) {
                                c = c.updateQueue,
                                u.updateQueue === c && (u.updateQueue = {
                                    baseState: c.baseState,
                                    firstBaseUpdate: c.firstBaseUpdate,
                                    lastBaseUpdate: c.lastBaseUpdate,
                                    shared: c.shared,
                                    callbacks: null
                                })
                            }
                            function st(c) {
                                return {
                                    lane: c,
                                    tag: 0,
                                    payload: null,
                                    callback: null,
                                    next: null
                                }
                            }
                            function ie(c, u, y) {
                                var A = c.updateQueue;
                                if (A === null)
                                    return null;
                                if (A = A.shared,
                                (Sn & 2) !== 0) {
                                    var C = A.pending;
                                    return C === null ? u.next = u : (u.next = C.next,
                                    C.next = u),
                                    A.pending = u,
                                    u = xt(c),
                                    Fe(c, null, y),
                                    u
                                }
                                return Pe(c, A, u, y),
                                xt(c)
                            }
                            function Re(c, u, y) {
                                if (u = u.updateQueue,
                                u !== null && (u = u.shared,
                                (y & 4194176) !== 0)) {
                                    var A = u.lanes;
                                    A &= c.pendingLanes,
                                    y |= A,
                                    u.lanes = y,
                                    ce(c, y)
                                }
                            }
                            function He(c, u) {
                                var y = c.updateQueue
                                  , A = c.alternate;
                                if (A !== null && (A = A.updateQueue,
                                y === A)) {
                                    var C = null
                                      , N = null;
                                    if (y = y.firstBaseUpdate,
                                    y !== null) {
                                        do {
                                            var W = {
                                                lane: y.lane,
                                                tag: y.tag,
                                                payload: y.payload,
                                                callback: null,
                                                next: null
                                            };
                                            N === null ? C = N = W : N = N.next = W,
                                            y = y.next
                                        } while (y !== null);
                                        N === null ? C = N = u : N = N.next = u
                                    } else
                                        C = N = u;
                                    y = {
                                        baseState: A.baseState,
                                        firstBaseUpdate: C,
                                        lastBaseUpdate: N,
                                        shared: A.shared,
                                        callbacks: A.callbacks
                                    },
                                    c.updateQueue = y;
                                    return
                                }
                                c = y.lastBaseUpdate,
                                c === null ? y.firstBaseUpdate = u : c.next = u,
                                y.lastBaseUpdate = u
                            }
                            function lt() {
                                if (fc) {
                                    var c = hc;
                                    if (c !== null)
                                        throw c
                                }
                            }
                            function ae(c, u, y, A) {
                                fc = !1;
                                var C = c.updateQueue;
                                No = !1;
                                var N = C.firstBaseUpdate
                                  , W = C.lastBaseUpdate
                                  , oe = C.shared.pending;
                                if (oe !== null) {
                                    C.shared.pending = null;
                                    var ve = oe
                                      , Xe = ve.next;
                                    ve.next = null,
                                    W === null ? N = Xe : W.next = Xe,
                                    W = ve;
                                    var it = c.alternate;
                                    it !== null && (it = it.updateQueue,
                                    oe = it.lastBaseUpdate,
                                    oe !== W && (oe === null ? it.firstBaseUpdate = Xe : oe.next = Xe,
                                    it.lastBaseUpdate = ve))
                                }
                                if (N !== null) {
                                    var dt = C.baseState;
                                    W = 0,
                                    it = Xe = ve = null,
                                    oe = N;
                                    do {
                                        var mt = oe.lane & -536870913
                                          , Qt = mt !== oe.lane;
                                        if (Qt ? (pn & mt) === mt : (A & mt) === mt) {
                                            mt !== 0 && mt === Ma && (fc = !0),
                                            it !== null && (it = it.next = {
                                                lane: 0,
                                                tag: oe.tag,
                                                payload: oe.payload,
                                                callback: null,
                                                next: null
                                            });
                                            e: {
                                                var Na = c
                                                  , Nl = oe;
                                                mt = u;
                                                var Ul = y;
                                                switch (Nl.tag) {
                                                case 1:
                                                    if (Na = Nl.payload,
                                                    typeof Na == "function") {
                                                        dt = Na.call(Ul, dt, mt);
                                                        break e
                                                    }
                                                    dt = Na;
                                                    break e;
                                                case 3:
                                                    Na.flags = Na.flags & -65537 | 128;
                                                case 0:
                                                    if (Na = Nl.payload,
                                                    mt = typeof Na == "function" ? Na.call(Ul, dt, mt) : Na,
                                                    mt == null)
                                                        break e;
                                                    dt = _d({}, dt, mt);
                                                    break e;
                                                case 2:
                                                    No = !0
                                                }
                                            }
                                            mt = oe.callback,
                                            mt !== null && (c.flags |= 64,
                                            Qt && (c.flags |= 8192),
                                            Qt = C.callbacks,
                                            Qt === null ? C.callbacks = [mt] : Qt.push(mt))
                                        } else
                                            Qt = {
                                                lane: mt,
                                                tag: oe.tag,
                                                payload: oe.payload,
                                                callback: oe.callback,
                                                next: null
                                            },
                                            it === null ? (Xe = it = Qt,
                                            ve = dt) : it = it.next = Qt,
                                            W |= mt;
                                        if (oe = oe.next,
                                        oe === null) {
                                            if (oe = C.shared.pending,
                                            oe === null)
                                                break;
                                            Qt = oe,
                                            oe = Qt.next,
                                            Qt.next = null,
                                            C.lastBaseUpdate = Qt,
                                            C.shared.pending = null
                                        }
                                    } while (!0);
                                    it === null && (ve = dt),
                                    C.baseState = ve,
                                    C.firstBaseUpdate = Xe,
                                    C.lastBaseUpdate = it,
                                    N === null && (C.shared.lanes = 0),
                                    Da |= W,
                                    c.lanes = W,
                                    c.memoizedState = dt
                                }
                            }
                            function ot(c, u) {
                                if (typeof c != "function")
                                    throw Error(r(191, c));
                                c.call(u)
                            }
                            function tt(c, u) {
                                var y = c.callbacks;
                                if (y !== null)
                                    for (c.callbacks = null,
                                    c = 0; c < y.length; c++)
                                        ot(y[c], u)
                            }
                            function gt(c, u) {
                                if (ia(c, u))
                                    return !0;
                                if (typeof c != "object" || c === null || typeof u != "object" || u === null)
                                    return !1;
                                var y = Object.keys(c)
                                  , A = Object.keys(u);
                                if (y.length !== A.length)
                                    return !1;
                                for (A = 0; A < y.length; A++) {
                                    var C = y[A];
                                    if (!Yr.call(u, C) || !ia(c[C], u[C]))
                                        return !1
                                }
                                return !0
                            }
                            function Je(c) {
                                return c = c.status,
                                c === "fulfilled" || c === "rejected"
                            }
                            function ke() {}
                            function ht(c, u, y) {
                                switch (y = c[y],
                                y === void 0 ? c.push(u) : y !== u && (u.then(ke, ke),
                                u = y),
                                u.status) {
                                case "fulfilled":
                                    return u.value;
                                case "rejected":
                                    throw c = u.reason,
                                    c === vu ? Error(r(483)) : c;
                                default:
                                    if (typeof u.status == "string")
                                        u.then(ke, ke);
                                    else {
                                        if (c = On,
                                        c !== null && 100 < c.shellSuspendCounter)
                                            throw Error(r(482));
                                        c = u,
                                        c.status = "pending",
                                        c.then(function(A) {
                                            if (u.status === "pending") {
                                                var C = u;
                                                C.status = "fulfilled",
                                                C.value = A
                                            }
                                        }, function(A) {
                                            if (u.status === "pending") {
                                                var C = u;
                                                C.status = "rejected",
                                                C.reason = A
                                            }
                                        })
                                    }
                                    switch (u.status) {
                                    case "fulfilled":
                                        return u.value;
                                    case "rejected":
                                        throw c = u.reason,
                                        c === vu ? Error(r(483)) : c
                                    }
                                    throw Ml = u,
                                    vu
                                }
                            }
                            function Mt() {
                                if (Ml === null)
                                    throw Error(r(459));
                                var c = Ml;
                                return Ml = null,
                                c
                            }
                            function Tn(c) {
                                var u = El;
                                return El += 1,
                                bl === null && (bl = []),
                                ht(bl, c, u)
                            }
                            function Zt(c, u) {
                                u = u.props.ref,
                                c.ref = u !== void 0 ? u : null
                            }
                            function Ai(c, u) {
                                throw u.$$typeof === wS ? Error(r(525)) : (c = Object.prototype.toString.call(u),
                                Error(r(31, c === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : c)))
                            }
                            function pa(c) {
                                var u = c._init;
                                return u(c._payload)
                            }
                            function os(c) {
                                function u(Me, ue) {
                                    if (c) {
                                        var Oe = Me.deletions;
                                        Oe === null ? (Me.deletions = [ue],
                                        Me.flags |= 16) : Oe.push(ue)
                                    }
                                }
                                function y(Me, ue) {
                                    if (!c)
                                        return null;
                                    for (; ue !== null; )
                                        u(Me, ue),
                                        ue = ue.sibling;
                                    return null
                                }
                                function A(Me) {
                                    for (var ue = new Map; Me !== null; )
                                        Me.key !== null ? ue.set(Me.key, Me) : ue.set(Me.index, Me),
                                        Me = Me.sibling;
                                    return ue
                                }
                                function C(Me, ue) {
                                    return Me = Xa(Me, ue),
                                    Me.index = 0,
                                    Me.sibling = null,
                                    Me
                                }
                                function N(Me, ue, Oe) {
                                    return Me.index = Oe,
                                    c ? (Oe = Me.alternate,
                                    Oe !== null ? (Oe = Oe.index,
                                    Oe < ue ? (Me.flags |= 33554434,
                                    ue) : Oe) : (Me.flags |= 33554434,
                                    ue)) : (Me.flags |= 1048576,
                                    ue)
                                }
                                function W(Me) {
                                    return c && Me.alternate === null && (Me.flags |= 33554434),
                                    Me
                                }
                                function oe(Me, ue, Oe, nt) {
                                    return ue === null || ue.tag !== 6 ? (ue = vd(Oe, Me.mode, nt),
                                    ue.return = Me,
                                    ue) : (ue = C(ue, Oe),
                                    ue.return = Me,
                                    ue)
                                }
                                function ve(Me, ue, Oe, nt) {
                                    var Rt = Oe.type;
                                    return Rt === ml ? it(Me, ue, Oe.props.children, nt, Oe.key) : ue !== null && (ue.elementType === Rt || typeof Rt == "object" && Rt !== null && Rt.$$typeof === Ya && pa(Rt) === ue.type) ? (ue = C(ue, Oe.props),
                                    Zt(ue, Oe),
                                    ue.return = Me,
                                    ue) : (ue = Gr(Oe.type, Oe.key, Oe.props, null, Me.mode, nt),
                                    Zt(ue, Oe),
                                    ue.return = Me,
                                    ue)
                                }
                                function Xe(Me, ue, Oe, nt) {
                                    return ue === null || ue.tag !== 4 || ue.stateNode.containerInfo !== Oe.containerInfo || ue.stateNode.implementation !== Oe.implementation ? (ue = Ym(Oe, Me.mode, nt),
                                    ue.return = Me,
                                    ue) : (ue = C(ue, Oe.children || []),
                                    ue.return = Me,
                                    ue)
                                }
                                function it(Me, ue, Oe, nt, Rt) {
                                    return ue === null || ue.tag !== 7 ? (ue = vi(Oe, Me.mode, nt, Rt),
                                    ue.return = Me,
                                    ue) : (ue = C(ue, Oe),
                                    ue.return = Me,
                                    ue)
                                }
                                function dt(Me, ue, Oe) {
                                    if (typeof ue == "string" && ue !== "" || typeof ue == "number" || typeof ue == "bigint")
                                        return ue = vd("" + ue, Me.mode, Oe),
                                        ue.return = Me,
                                        ue;
                                    if (typeof ue == "object" && ue !== null) {
                                        switch (ue.$$typeof) {
                                        case Uh:
                                            return Oe = Gr(ue.type, ue.key, ue.props, null, Me.mode, Oe),
                                            Zt(Oe, ue),
                                            Oe.return = Me,
                                            Oe;
                                        case qa:
                                            return ue = Ym(ue, Me.mode, Oe),
                                            ue.return = Me,
                                            ue;
                                        case Ya:
                                            var nt = ue._init;
                                            return ue = nt(ue._payload),
                                            dt(Me, ue, Oe)
                                        }
                                        if (au(ue) || l(ue))
                                            return ue = vi(ue, Me.mode, Oe, null),
                                            ue.return = Me,
                                            ue;
                                        if (typeof ue.then == "function")
                                            return dt(Me, Tn(ue), Oe);
                                        if (ue.$$typeof === mr)
                                            return dt(Me, yh(Me, ue), Oe);
                                        Ai(Me, ue)
                                    }
                                    return null
                                }
                                function mt(Me, ue, Oe, nt) {
                                    var Rt = ue !== null ? ue.key : null;
                                    if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number" || typeof Oe == "bigint")
                                        return Rt !== null ? null : oe(Me, ue, "" + Oe, nt);
                                    if (typeof Oe == "object" && Oe !== null) {
                                        switch (Oe.$$typeof) {
                                        case Uh:
                                            return Oe.key === Rt ? ve(Me, ue, Oe, nt) : null;
                                        case qa:
                                            return Oe.key === Rt ? Xe(Me, ue, Oe, nt) : null;
                                        case Ya:
                                            return Rt = Oe._init,
                                            Oe = Rt(Oe._payload),
                                            mt(Me, ue, Oe, nt)
                                        }
                                        if (au(Oe) || l(Oe))
                                            return Rt !== null ? null : it(Me, ue, Oe, nt, null);
                                        if (typeof Oe.then == "function")
                                            return mt(Me, ue, Tn(Oe), nt);
                                        if (Oe.$$typeof === mr)
                                            return mt(Me, ue, yh(Me, Oe), nt);
                                        Ai(Me, Oe)
                                    }
                                    return null
                                }
                                function Qt(Me, ue, Oe, nt, Rt) {
                                    if (typeof nt == "string" && nt !== "" || typeof nt == "number" || typeof nt == "bigint")
                                        return Me = Me.get(Oe) || null,
                                        oe(ue, Me, "" + nt, Rt);
                                    if (typeof nt == "object" && nt !== null) {
                                        switch (nt.$$typeof) {
                                        case Uh:
                                            return Me = Me.get(nt.key === null ? Oe : nt.key) || null,
                                            ve(ue, Me, nt, Rt);
                                        case qa:
                                            return Me = Me.get(nt.key === null ? Oe : nt.key) || null,
                                            Xe(ue, Me, nt, Rt);
                                        case Ya:
                                            var ri = nt._init;
                                            return nt = ri(nt._payload),
                                            Qt(Me, ue, Oe, nt, Rt)
                                        }
                                        if (au(nt) || l(nt))
                                            return Me = Me.get(Oe) || null,
                                            it(ue, Me, nt, Rt, null);
                                        if (typeof nt.then == "function")
                                            return Qt(Me, ue, Oe, Tn(nt), Rt);
                                        if (nt.$$typeof === mr)
                                            return Qt(Me, ue, Oe, yh(ue, nt), Rt);
                                        Ai(ue, nt)
                                    }
                                    return null
                                }
                                function Na(Me, ue, Oe, nt) {
                                    for (var Rt = null, ri = null, Gt = ue, En = ue = 0, Di = null; Gt !== null && En < Oe.length; En++) {
                                        Gt.index > En ? (Di = Gt,
                                        Gt = null) : Di = Gt.sibling;
                                        var hn = mt(Me, Gt, Oe[En], nt);
                                        if (hn === null) {
                                            Gt === null && (Gt = Di);
                                            break
                                        }
                                        c && Gt && hn.alternate === null && u(Me, Gt),
                                        ue = N(hn, ue, En),
                                        ri === null ? Rt = hn : ri.sibling = hn,
                                        ri = hn,
                                        Gt = Di
                                    }
                                    if (En === Oe.length)
                                        return y(Me, Gt),
                                        _n && X(Me, En),
                                        Rt;
                                    if (Gt === null) {
                                        for (; En < Oe.length; En++)
                                            Gt = dt(Me, Oe[En], nt),
                                            Gt !== null && (ue = N(Gt, ue, En),
                                            ri === null ? Rt = Gt : ri.sibling = Gt,
                                            ri = Gt);
                                        return _n && X(Me, En),
                                        Rt
                                    }
                                    for (Gt = A(Gt); En < Oe.length; En++)
                                        Di = Qt(Gt, Me, En, Oe[En], nt),
                                        Di !== null && (c && Di.alternate !== null && Gt.delete(Di.key === null ? En : Di.key),
                                        ue = N(Di, ue, En),
                                        ri === null ? Rt = Di : ri.sibling = Di,
                                        ri = Di);
                                    return c && Gt.forEach(function(eo) {
                                        return u(Me, eo)
                                    }),
                                    _n && X(Me, En),
                                    Rt
                                }
                                function Nl(Me, ue, Oe, nt) {
                                    if (Oe == null)
                                        throw Error(r(151));
                                    for (var Rt = null, ri = null, Gt = ue, En = ue = 0, Di = null, hn = Oe.next(); Gt !== null && !hn.done; En++,
                                    hn = Oe.next()) {
                                        Gt.index > En ? (Di = Gt,
                                        Gt = null) : Di = Gt.sibling;
                                        var eo = mt(Me, Gt, hn.value, nt);
                                        if (eo === null) {
                                            Gt === null && (Gt = Di);
                                            break
                                        }
                                        c && Gt && eo.alternate === null && u(Me, Gt),
                                        ue = N(eo, ue, En),
                                        ri === null ? Rt = eo : ri.sibling = eo,
                                        ri = eo,
                                        Gt = Di
                                    }
                                    if (hn.done)
                                        return y(Me, Gt),
                                        _n && X(Me, En),
                                        Rt;
                                    if (Gt === null) {
                                        for (; !hn.done; En++,
                                        hn = Oe.next())
                                            hn = dt(Me, hn.value, nt),
                                            hn !== null && (ue = N(hn, ue, En),
                                            ri === null ? Rt = hn : ri.sibling = hn,
                                            ri = hn);
                                        return _n && X(Me, En),
                                        Rt
                                    }
                                    for (Gt = A(Gt); !hn.done; En++,
                                    hn = Oe.next())
                                        hn = Qt(Gt, Me, En, hn.value, nt),
                                        hn !== null && (c && hn.alternate !== null && Gt.delete(hn.key === null ? En : hn.key),
                                        ue = N(hn, ue, En),
                                        ri === null ? Rt = hn : ri.sibling = hn,
                                        ri = hn);
                                    return c && Gt.forEach(function(Wd) {
                                        return u(Me, Wd)
                                    }),
                                    _n && X(Me, En),
                                    Rt
                                }
                                function Ul(Me, ue, Oe, nt) {
                                    if (typeof Oe == "object" && Oe !== null && Oe.type === ml && Oe.key === null && (Oe = Oe.props.children),
                                    typeof Oe == "object" && Oe !== null) {
                                        switch (Oe.$$typeof) {
                                        case Uh:
                                            e: {
                                                for (var Rt = Oe.key; ue !== null; ) {
                                                    if (ue.key === Rt) {
                                                        if (Rt = Oe.type,
                                                        Rt === ml) {
                                                            if (ue.tag === 7) {
                                                                y(Me, ue.sibling),
                                                                nt = C(ue, Oe.props.children),
                                                                nt.return = Me,
                                                                Me = nt;
                                                                break e
                                                            }
                                                        } else if (ue.elementType === Rt || typeof Rt == "object" && Rt !== null && Rt.$$typeof === Ya && pa(Rt) === ue.type) {
                                                            y(Me, ue.sibling),
                                                            nt = C(ue, Oe.props),
                                                            Zt(nt, Oe),
                                                            nt.return = Me,
                                                            Me = nt;
                                                            break e
                                                        }
                                                        y(Me, ue);
                                                        break
                                                    } else
                                                        u(Me, ue);
                                                    ue = ue.sibling
                                                }
                                                Oe.type === ml ? (nt = vi(Oe.props.children, Me.mode, nt, Oe.key),
                                                nt.return = Me,
                                                Me = nt) : (nt = Gr(Oe.type, Oe.key, Oe.props, null, Me.mode, nt),
                                                Zt(nt, Oe),
                                                nt.return = Me,
                                                Me = nt)
                                            }
                                            return W(Me);
                                        case qa:
                                            e: {
                                                for (Rt = Oe.key; ue !== null; ) {
                                                    if (ue.key === Rt)
                                                        if (ue.tag === 4 && ue.stateNode.containerInfo === Oe.containerInfo && ue.stateNode.implementation === Oe.implementation) {
                                                            y(Me, ue.sibling),
                                                            nt = C(ue, Oe.children || []),
                                                            nt.return = Me,
                                                            Me = nt;
                                                            break e
                                                        } else {
                                                            y(Me, ue);
                                                            break
                                                        }
                                                    else
                                                        u(Me, ue);
                                                    ue = ue.sibling
                                                }
                                                nt = Ym(Oe, Me.mode, nt),
                                                nt.return = Me,
                                                Me = nt
                                            }
                                            return W(Me);
                                        case Ya:
                                            return Rt = Oe._init,
                                            Oe = Rt(Oe._payload),
                                            Ul(Me, ue, Oe, nt)
                                        }
                                        if (au(Oe))
                                            return Na(Me, ue, Oe, nt);
                                        if (l(Oe)) {
                                            if (Rt = l(Oe),
                                            typeof Rt != "function")
                                                throw Error(r(150));
                                            return Oe = Rt.call(Oe),
                                            Nl(Me, ue, Oe, nt)
                                        }
                                        if (typeof Oe.then == "function")
                                            return Ul(Me, ue, Tn(Oe), nt);
                                        if (Oe.$$typeof === mr)
                                            return Ul(Me, ue, yh(Me, Oe), nt);
                                        Ai(Me, Oe)
                                    }
                                    return typeof Oe == "string" && Oe !== "" || typeof Oe == "number" || typeof Oe == "bigint" ? (Oe = "" + Oe,
                                    ue !== null && ue.tag === 6 ? (y(Me, ue.sibling),
                                    nt = C(ue, Oe),
                                    nt.return = Me,
                                    Me = nt) : (y(Me, ue),
                                    nt = vd(Oe, Me.mode, nt),
                                    nt.return = Me,
                                    Me = nt),
                                    W(Me)) : y(Me, ue)
                                }
                                return function(Me, ue, Oe, nt) {
                                    try {
                                        El = 0;
                                        var Rt = Ul(Me, ue, Oe, nt);
                                        return bl = null,
                                        Rt
                                    } catch (Gt) {
                                        if (Gt === vu)
                                            throw Gt;
                                        var ri = i(29, Gt, null, Me.mode);
                                        return ri.lanes = nt,
                                        ri.return = Me,
                                        ri
                                    }
                                }
                            }
                            function Ti(c, u) {
                                c = Rs,
                                R(yu, c),
                                R(Kn, u),
                                Rs = c | u.baseLanes
                            }
                            function ki() {
                                R(yu, Rs),
                                R(Kn, Kn.current)
                            }
                            function Pr() {
                                Rs = yu.current,
                                D(Kn),
                                D(yu)
                            }
                            function Bs(c) {
                                var u = c.alternate;
                                R(Yi, Yi.current & 1),
                                R(ba, c),
                                Xn === null && (u === null || Kn.current !== null || u.memoizedState !== null) && (Xn = c)
                            }
                            function rh(c) {
                                if (c.tag === 22) {
                                    if (R(Yi, Yi.current),
                                    R(ba, c),
                                    Xn === null) {
                                        var u = c.alternate;
                                        u !== null && u.memoizedState !== null && (Xn = c)
                                    }
                                } else
                                    ma(c)
                            }
                            function ma() {
                                R(Yi, Yi.current),
                                R(ba, ba.current)
                            }
                            function ga(c) {
                                D(ba),
                                Xn === c && (Xn = null),
                                D(Yi)
                            }
                            function cr(c) {
                                for (var u = c; u !== null; ) {
                                    if (u.tag === 13) {
                                        var y = u.memoizedState;
                                        if (y !== null && (y = y.dehydrated,
                                        y === null || Cd(y) || Rd(y)))
                                            return u
                                    } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                                        if ((u.flags & 128) !== 0)
                                            return u
                                    } else if (u.child !== null) {
                                        u.child.return = u,
                                        u = u.child;
                                        continue
                                    }
                                    if (u === c)
                                        break;
                                    for (; u.sibling === null; ) {
                                        if (u.return === null || u.return === c)
                                            return null;
                                        u = u.return
                                    }
                                    u.sibling.return = u.return,
                                    u = u.sibling
                                }
                                return null
                            }
                            function si() {
                                throw Error(r(321))
                            }
                            function Ir(c, u) {
                                if (u === null)
                                    return !1;
                                for (var y = 0; y < u.length && y < c.length; y++)
                                    if (!ia(c[y], u[y]))
                                        return !1;
                                return !0
                            }
                            function Lr(c, u, y, A, C, N) {
                                return Uo = N,
                                nn = u,
                                u.memoizedState = null,
                                u.updateQueue = null,
                                u.lanes = 0,
                                Vt.H = c === null || c.memoizedState === null ? Rl : Vs,
                                Cl = !1,
                                N = y(A, C),
                                Cl = !1,
                                dc && (N = ho(u, y, A, C)),
                                $o(c),
                                N
                            }
                            function $o(c) {
                                Vt.H = yi;
                                var u = It !== null && It.next !== null;
                                if (Uo = 0,
                                xn = It = nn = null,
                                Ka = !1,
                                pc = 0,
                                is = null,
                                u)
                                    throw Error(r(300));
                                c === null || qn || (c = c.dependencies,
                                c !== null && vh(c) && (qn = !0))
                            }
                            function ho(c, u, y, A) {
                                nn = c;
                                var C = 0;
                                do {
                                    if (dc && (is = null),
                                    pc = 0,
                                    dc = !1,
                                    25 <= C)
                                        throw Error(r(301));
                                    if (C += 1,
                                    xn = It = null,
                                    c.updateQueue != null) {
                                        var N = c.updateQueue;
                                        N.lastEffect = null,
                                        N.events = null,
                                        N.stores = null,
                                        N.memoCache != null && (N.memoCache.index = 0)
                                    }
                                    Vt.H = Ea,
                                    N = u(y, A)
                                } while (dc);
                                return N
                            }
                            function Bi() {
                                var c = Vt.H
                                  , u = c.useState()[0];
                                return u = typeof u.then == "function" ? Ze(u) : u,
                                c = c.useState()[0],
                                (It !== null ? It.memoizedState : null) !== c && (nn.flags |= 1024),
                                u
                            }
                            function j() {
                                var c = Fd !== 0;
                                return Fd = 0,
                                c
                            }
                            function me(c, u, y) {
                                u.updateQueue = c.updateQueue,
                                u.flags &= -2053,
                                c.lanes &= ~y
                            }
                            function Ee(c) {
                                if (Ka) {
                                    for (c = c.memoizedState; c !== null; ) {
                                        var u = c.queue;
                                        u !== null && (u.pending = null),
                                        c = c.next
                                    }
                                    Ka = !1
                                }
                                Uo = 0,
                                xn = It = nn = null,
                                dc = !1,
                                pc = Fd = 0,
                                is = null
                            }
                            function Se() {
                                var c = {
                                    memoizedState: null,
                                    baseState: null,
                                    baseQueue: null,
                                    queue: null,
                                    next: null
                                };
                                return xn === null ? nn.memoizedState = xn = c : xn = xn.next = c,
                                xn
                            }
                            function he() {
                                if (It === null) {
                                    var c = nn.alternate;
                                    c = c !== null ? c.memoizedState : null
                                } else
                                    c = It.next;
                                var u = xn === null ? nn.memoizedState : xn.next;
                                if (u !== null)
                                    xn = u,
                                    It = c;
                                else {
                                    if (c === null)
                                        throw nn.alternate === null ? Error(r(467)) : Error(r(310));
                                    It = c,
                                    c = {
                                        memoizedState: It.memoizedState,
                                        baseState: It.baseState,
                                        baseQueue: It.baseQueue,
                                        queue: It.queue,
                                        next: null
                                    },
                                    xn === null ? nn.memoizedState = xn = c : xn = xn.next = c
                                }
                                return xn
                            }
                            function Ze(c) {
                                var u = pc;
                                return pc += 1,
                                is === null && (is = []),
                                c = ht(is, c, u),
                                u = nn,
                                (xn === null ? u.memoizedState : xn.next) === null && (u = u.alternate,
                                Vt.H = u === null || u.memoizedState === null ? Rl : Vs),
                                c
                            }
                            function ft(c) {
                                if (c !== null && typeof c == "object") {
                                    if (typeof c.then == "function")
                                        return Ze(c);
                                    if (c.$$typeof === mr)
                                        return hs(c)
                                }
                                throw Error(r(438, String(c)))
                            }
                            function vt(c) {
                                var u = null
                                  , y = nn.updateQueue;
                                if (y !== null && (u = y.memoCache),
                                u == null) {
                                    var A = nn.alternate;
                                    A !== null && (A = A.updateQueue,
                                    A !== null && (A = A.memoCache,
                                    A != null && (u = {
                                        data: A.data.map(function(C) {
                                            return C.slice()
                                        }),
                                        index: 0
                                    })))
                                }
                                if (u ??= {
                                    data: [],
                                    index: 0
                                },
                                y === null && (y = Hd(),
                                nn.updateQueue = y),
                                y.memoCache = u,
                                y = u.data[u.index],
                                y === void 0)
                                    for (y = u.data[u.index] = Array(c),
                                    A = 0; A < c; A++)
                                        y[A] = w0;
                                return u.index++,
                                y
                            }
                            function ut(c, u) {
                                return typeof u == "function" ? u(c) : u
                            }
                            function Dt(c) {
                                var u = he();
                                return bt(u, It, c)
                            }
                            function bt(c, u, y) {
                                var A = c.queue;
                                if (A === null)
                                    throw Error(r(311));
                                A.lastRenderedReducer = y;
                                var C = c.baseQueue
                                  , N = A.pending;
                                if (N !== null) {
                                    if (C !== null) {
                                        var W = C.next;
                                        C.next = N.next,
                                        N.next = W
                                    }
                                    u.baseQueue = C = N,
                                    A.pending = null
                                }
                                if (N = c.baseState,
                                C === null)
                                    c.memoizedState = N;
                                else {
                                    u = C.next;
                                    var oe = W = null
                                      , ve = null
                                      , Xe = u
                                      , it = !1;
                                    do {
                                        var dt = Xe.lane & -536870913;
                                        if (dt !== Xe.lane ? (pn & dt) === dt : (Uo & dt) === dt) {
                                            var mt = Xe.revertLane;
                                            if (mt === 0)
                                                ve !== null && (ve = ve.next = {
                                                    lane: 0,
                                                    revertLane: 0,
                                                    action: Xe.action,
                                                    hasEagerState: Xe.hasEagerState,
                                                    eagerState: Xe.eagerState,
                                                    next: null
                                                }),
                                                dt === Ma && (it = !0);
                                            else if ((Uo & mt) === mt) {
                                                Xe = Xe.next,
                                                mt === Ma && (it = !0);
                                                continue
                                            } else
                                                dt = {
                                                    lane: 0,
                                                    revertLane: Xe.revertLane,
                                                    action: Xe.action,
                                                    hasEagerState: Xe.hasEagerState,
                                                    eagerState: Xe.eagerState,
                                                    next: null
                                                },
                                                ve === null ? (oe = ve = dt,
                                                W = N) : ve = ve.next = dt,
                                                nn.lanes |= mt,
                                                Da |= mt;
                                            dt = Xe.action,
                                            Cl && y(N, dt),
                                            N = Xe.hasEagerState ? Xe.eagerState : y(N, dt)
                                        } else
                                            mt = {
                                                lane: dt,
                                                revertLane: Xe.revertLane,
                                                action: Xe.action,
                                                hasEagerState: Xe.hasEagerState,
                                                eagerState: Xe.eagerState,
                                                next: null
                                            },
                                            ve === null ? (oe = ve = mt,
                                            W = N) : ve = ve.next = mt,
                                            nn.lanes |= dt,
                                            Da |= dt;
                                        Xe = Xe.next
                                    } while (Xe !== null && Xe !== u);
                                    if (ve === null ? W = N : ve.next = oe,
                                    !ia(N, c.memoizedState) && (qn = !0,
                                    it && (y = hc,
                                    y !== null)))
                                        throw y;
                                    c.memoizedState = N,
                                    c.baseState = W,
                                    c.baseQueue = ve,
                                    A.lastRenderedState = N
                                }
                                return C === null && (A.lanes = 0),
                                [c.memoizedState, A.dispatch]
                            }
                            function Nt(c) {
                                var u = he()
                                  , y = u.queue;
                                if (y === null)
                                    throw Error(r(311));
                                y.lastRenderedReducer = c;
                                var A = y.dispatch
                                  , C = y.pending
                                  , N = u.memoizedState;
                                if (C !== null) {
                                    y.pending = null;
                                    var W = C = C.next;
                                    do
                                        N = c(N, W.action),
                                        W = W.next;
                                    while (W !== C);
                                    ia(N, u.memoizedState) || (qn = !0),
                                    u.memoizedState = N,
                                    u.baseQueue === null && (u.baseState = N),
                                    y.lastRenderedState = N
                                }
                                return [N, A]
                            }
                            function un(c, u, y) {
                                var A = nn
                                  , C = he()
                                  , N = _n;
                                if (N) {
                                    if (y === void 0)
                                        throw Error(r(407));
                                    y = y()
                                } else
                                    y = u();
                                var W = !ia((It || C).memoizedState, y);
                                if (W && (C.memoizedState = y,
                                qn = !0),
                                C = C.queue,
                                vm(Ln.bind(null, A, C, c), [c]),
                                C.getSnapshot !== u || W || xn !== null && xn.memoizedState.tag & 1) {
                                    if (A.flags |= 2048,
                                    fr(9, Cn.bind(null, A, C, y, u), {
                                        destroy: void 0
                                    }, null),
                                    On === null)
                                        throw Error(r(349));
                                    N || (Uo & 60) !== 0 || yn(A, u, y)
                                }
                                return y
                            }
                            function yn(c, u, y) {
                                c.flags |= 16384,
                                c = {
                                    getSnapshot: u,
                                    value: y
                                },
                                u = nn.updateQueue,
                                u === null ? (u = Hd(),
                                nn.updateQueue = u,
                                u.stores = [c]) : (y = u.stores,
                                y === null ? u.stores = [c] : y.push(c))
                            }
                            function Cn(c, u, y, A) {
                                u.value = y,
                                u.getSnapshot = A,
                                Pn(u) && Tt(c)
                            }
                            function Ln(c, u, y) {
                                return y(function() {
                                    Pn(u) && Tt(c)
                                })
                            }
                            function Pn(c) {
                                var u = c.getSnapshot;
                                c = c.value;
                                try {
                                    var y = u();
                                    return !ia(c, y)
                                } catch {
                                    return !0
                                }
                            }
                            function Tt(c) {
                                var u = Ie(c, 2);
                                u !== null && es(u, c, 2)
                            }
                            function Mn(c) {
                                var u = Se();
                                if (typeof c == "function") {
                                    var y = c;
                                    if (c = y(),
                                    Cl) {
                                        q(!0);
                                        try {
                                            y()
                                        } finally {
                                            q(!1)
                                        }
                                    }
                                }
                                return u.memoizedState = u.baseState = c,
                                u.queue = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: ut,
                                    lastRenderedState: c
                                },
                                u
                            }
                            function dn(c, u, y, A) {
                                return c.baseState = y,
                                bt(c, It, typeof A == "function" ? A : ut)
                            }
                            function va(c, u, y, A, C) {
                                if (fh(c))
                                    throw Error(r(485));
                                if (c = u.action,
                                c !== null) {
                                    var N = {
                                        payload: C,
                                        action: c,
                                        next: null,
                                        isTransition: !0,
                                        status: "pending",
                                        value: null,
                                        reason: null,
                                        listeners: [],
                                        then: function(W) {
                                            N.listeners.push(W)
                                        }
                                    };
                                    Vt.T !== null ? y(!0) : N.isTransition = !1,
                                    A(N),
                                    y = u.pending,
                                    y === null ? (N.next = u.pending = N,
                                    Va(u, N)) : (N.next = y.next,
                                    u.pending = y.next = N)
                                }
                            }
                            function Va(c, u) {
                                var y = u.action
                                  , A = u.payload
                                  , C = c.state;
                                if (u.isTransition) {
                                    var N = Vt.T
                                      , W = {};
                                    Vt.T = W;
                                    try {
                                        var oe = y(C, A)
                                          , ve = Vt.S;
                                        ve !== null && ve(W, oe),
                                        ls(c, u, oe)
                                    } catch (Xe) {
                                        Gn(c, u, Xe)
                                    } finally {
                                        Vt.T = N
                                    }
                                } else
                                    try {
                                        N = y(C, A),
                                        ls(c, u, N)
                                    } catch (Xe) {
                                        Gn(c, u, Xe)
                                    }
                            }
                            function ls(c, u, y) {
                                y !== null && typeof y == "object" && typeof y.then == "function" ? y.then(function(A) {
                                    ur(c, u, A)
                                }, function(A) {
                                    return Gn(c, u, A)
                                }) : ur(c, u, y)
                            }
                            function ur(c, u, y) {
                                u.status = "fulfilled",
                                u.value = y,
                                Qn(u),
                                c.state = y,
                                u = c.pending,
                                u !== null && (y = u.next,
                                y === u ? c.pending = null : (y = y.next,
                                u.next = y,
                                Va(c, y)))
                            }
                            function Gn(c, u, y) {
                                var A = c.pending;
                                if (c.pending = null,
                                A !== null) {
                                    A = A.next;
                                    do
                                        u.status = "rejected",
                                        u.reason = y,
                                        Qn(u),
                                        u = u.next;
                                    while (u !== A)
                                }
                                c.action = null
                            }
                            function Qn(c) {
                                c = c.listeners;
                                for (var u = 0; u < c.length; u++)
                                    (0,
                                    c[u])()
                            }
                            function cs(c, u) {
                                return u
                            }
                            function Mi(c, u) {
                                if (_n) {
                                    var y = On.formState;
                                    if (y !== null) {
                                        e: {
                                            var A = nn;
                                            if (_n) {
                                                if (vs) {
                                                    var C = cg(vs, ns);
                                                    if (C) {
                                                        vs = ug(C),
                                                        A = Q0(C);
                                                        break e
                                                    }
                                                }
                                                $e(A)
                                            }
                                            A = !1
                                        }
                                        A && (u = y[0])
                                    }
                                }
                                y = Se(),
                                y.memoizedState = y.baseState = u,
                                A = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: cs,
                                    lastRenderedState: u
                                },
                                y.queue = A,
                                y = Sm.bind(null, nn, A),
                                A.dispatch = y,
                                A = Mn(!1);
                                var N = Vc.bind(null, nn, !1, A.queue);
                                return A = Se(),
                                C = {
                                    state: u,
                                    dispatch: null,
                                    action: c,
                                    pending: null
                                },
                                A.queue = C,
                                y = va.bind(null, nn, C, N, y),
                                C.dispatch = y,
                                A.memoizedState = c,
                                [u, y, !1]
                            }
                            function bs(c) {
                                var u = he();
                                return hr(u, It, c)
                            }
                            function hr(c, u, y) {
                                u = bt(c, u, cs)[0],
                                c = Dt(ut)[0],
                                u = typeof u == "object" && u !== null && typeof u.then == "function" ? Ze(u) : u;
                                var A = he()
                                  , C = A.queue
                                  , N = C.dispatch;
                                return y !== A.memoizedState && (nn.flags |= 2048,
                                fr(9, zr.bind(null, C, y), {
                                    destroy: void 0
                                }, null)),
                                [u, N, c]
                            }
                            function zr(c, u) {
                                c.action = u
                            }
                            function gm(c) {
                                var u = he()
                                  , y = It;
                                if (y !== null)
                                    return hr(u, y, c);
                                he(),
                                u = u.memoizedState,
                                y = he();
                                var A = y.queue.dispatch;
                                return y.memoizedState = c,
                                [u, A, !1]
                            }
                            function fr(c, u, y, A) {
                                return c = {
                                    tag: c,
                                    create: u,
                                    inst: y,
                                    deps: A,
                                    next: null
                                },
                                u = nn.updateQueue,
                                u === null && (u = Hd(),
                                nn.updateQueue = u),
                                y = u.lastEffect,
                                y === null ? u.lastEffect = c.next = c : (A = y.next,
                                y.next = c,
                                c.next = A,
                                u.lastEffect = c),
                                c
                            }
                            function s0() {
                                return he().memoizedState
                            }
                            function oh(c, u, y, A) {
                                var C = Se();
                                nn.flags |= c,
                                C.memoizedState = fr(1 | u, y, {
                                    destroy: void 0
                                }, A === void 0 ? null : A)
                            }
                            function lh(c, u, y, A) {
                                var C = he();
                                A = A === void 0 ? null : A;
                                var N = C.memoizedState.inst;
                                It !== null && A !== null && Ir(A, It.memoizedState.deps) ? C.memoizedState = fr(u, y, N, A) : (nn.flags |= c,
                                C.memoizedState = fr(1 | u, y, N, A))
                            }
                            function Kf(c, u) {
                                oh(8390656, 8, c, u)
                            }
                            function vm(c, u) {
                                lh(2048, 8, c, u)
                            }
                            function a0(c, u) {
                                return lh(4, 2, c, u)
                            }
                            function ch(c, u) {
                                return lh(4, 4, c, u)
                            }
                            function Jf(c, u) {
                                if (typeof u == "function") {
                                    c = c();
                                    var y = u(c);
                                    return function() {
                                        typeof y == "function" ? y() : u(null)
                                    }
                                }
                                if (u != null)
                                    return c = c(),
                                    u.current = c,
                                    function() {
                                        u.current = null
                                    }
                            }
                            function $f(c, u, y) {
                                y = y != null ? y.concat([c]) : null,
                                lh(4, 4, Jf.bind(null, u, c), y)
                            }
                            function el() {}
                            function Zl(c, u) {
                                var y = he();
                                u = u === void 0 ? null : u;
                                var A = y.memoizedState;
                                return u !== null && Ir(u, A[1]) ? A[0] : (y.memoizedState = [c, u],
                                c)
                            }
                            function ym(c, u) {
                                var y = he();
                                u = u === void 0 ? null : u;
                                var A = y.memoizedState;
                                if (u !== null && Ir(u, A[1]))
                                    return A[0];
                                if (A = c(),
                                Cl) {
                                    q(!0);
                                    try {
                                        c()
                                    } finally {
                                        q(!1)
                                    }
                                }
                                return y.memoizedState = [A, u],
                                A
                            }
                            function uh(c, u, y) {
                                return y === void 0 || (Uo & 1073741824) !== 0 ? c.memoizedState = u : (c.memoizedState = y,
                                c = Hm(),
                                nn.lanes |= c,
                                Da |= c,
                                y)
                            }
                            function _m(c, u, y, A) {
                                return ia(y, u) ? y : Kn.current !== null ? (c = uh(c, y, A),
                                ia(c, u) || (qn = !0),
                                c) : (Uo & 42) === 0 ? (qn = !0,
                                c.memoizedState = y) : (c = Hm(),
                                nn.lanes |= c,
                                Da |= c,
                                u)
                            }
                            function Fc(c, u, y, A, C) {
                                var N = Co();
                                ws(N !== 0 && 8 > N ? N : 8);
                                var W = Vt.T
                                  , oe = {};
                                Vt.T = oe,
                                Vc(c, !1, u, y);
                                try {
                                    var ve = C()
                                      , Xe = Vt.S;
                                    if (Xe !== null && Xe(oe, ve),
                                    ve !== null && typeof ve == "object" && typeof ve.then == "function") {
                                        var it = _t(ve, A);
                                        tl(c, u, it, bi(c))
                                    } else
                                        tl(c, u, A, bi(c))
                                } catch (dt) {
                                    tl(c, u, {
                                        then: function() {},
                                        status: "rejected",
                                        reason: dt
                                    }, bi())
                                } finally {
                                    ws(N),
                                    Vt.T = W
                                }
                            }
                            function Fr(c) {
                                var u = c.memoizedState;
                                if (u !== null)
                                    return u;
                                u = {
                                    memoizedState: yl,
                                    baseState: yl,
                                    baseQueue: null,
                                    queue: {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: ut,
                                        lastRenderedState: yl
                                    },
                                    next: null
                                };
                                var y = {};
                                return u.next = {
                                    memoizedState: y,
                                    baseState: y,
                                    baseQueue: null,
                                    queue: {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: ut,
                                        lastRenderedState: y
                                    },
                                    next: null
                                },
                                c.memoizedState = u,
                                c = c.alternate,
                                c !== null && (c.memoizedState = u),
                                u
                            }
                            function hh() {
                                return hs(gr)
                            }
                            function Hc() {
                                return he().memoizedState
                            }
                            function fo() {
                                return he().memoizedState
                            }
                            function xm(c) {
                                for (var u = c.return; u !== null; ) {
                                    switch (u.tag) {
                                    case 24:
                                    case 3:
                                        var y = bi();
                                        c = st(y);
                                        var A = ie(u, c, y);
                                        A !== null && (es(A, u, y),
                                        Re(A, u, y)),
                                        u = {
                                            cache: al()
                                        },
                                        c.payload = u;
                                        return
                                    }
                                    u = u.return
                                }
                            }
                            function ed(c, u, y) {
                                var A = bi();
                                y = {
                                    lane: A,
                                    revertLane: 0,
                                    action: y,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                },
                                fh(c) ? Ps(u, y) : (y = Ye(c, u, y, A),
                                y !== null && (es(y, c, A),
                                nl(y, u, A)))
                            }
                            function Sm(c, u, y) {
                                var A = bi();
                                tl(c, u, y, A)
                            }
                            function tl(c, u, y, A) {
                                var C = {
                                    lane: A,
                                    revertLane: 0,
                                    action: y,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                };
                                if (fh(c))
                                    Ps(u, C);
                                else {
                                    var N = c.alternate;
                                    if (c.lanes === 0 && (N === null || N.lanes === 0) && (N = u.lastRenderedReducer,
                                    N !== null))
                                        try {
                                            var W = u.lastRenderedState
                                              , oe = N(W, y);
                                            if (C.hasEagerState = !0,
                                            C.eagerState = oe,
                                            ia(oe, W))
                                                return Pe(c, u, C, 0),
                                                On === null && Te(),
                                                !1
                                        } catch {}
                                    if (y = Ye(c, u, C, A),
                                    y !== null)
                                        return es(y, c, A),
                                        nl(y, u, A),
                                        !0
                                }
                                return !1
                            }
                            function Vc(c, u, y, A) {
                                if (A = {
                                    lane: 2,
                                    revertLane: Be(),
                                    action: A,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                },
                                fh(c)) {
                                    if (u)
                                        throw Error(r(479))
                                } else
                                    u = Ye(c, y, A, 2),
                                    u !== null && es(u, c, 2)
                            }
                            function fh(c) {
                                var u = c.alternate;
                                return c === nn || u !== null && u === nn
                            }
                            function Ps(c, u) {
                                dc = Ka = !0;
                                var y = c.pending;
                                y === null ? u.next = u : (u.next = y.next,
                                y.next = u),
                                c.pending = u
                            }
                            function nl(c, u, y) {
                                if ((y & 4194176) !== 0) {
                                    var A = u.lanes;
                                    A &= c.pendingLanes,
                                    y |= A,
                                    u.lanes = y,
                                    ce(c, y)
                                }
                            }
                            function Gc(c, u, y, A) {
                                u = c.memoizedState,
                                y = y(A, u),
                                y = y == null ? u : _d({}, u, y),
                                c.memoizedState = y,
                                c.lanes === 0 && (c.updateQueue.baseState = y)
                            }
                            function kc(c, u, y, A, C, N, W) {
                                return c = c.stateNode,
                                typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(A, N, W) : u.prototype && u.prototype.isPureReactComponent ? !gt(y, A) || !gt(C, N) : !0
                            }
                            function r0(c, u, y, A) {
                                c = u.state,
                                typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(y, A),
                                typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(y, A),
                                u.state !== c && jr.enqueueReplaceState(u, u.state, null)
                            }
                            function po(c, u) {
                                var y = u;
                                if ("ref"in u) {
                                    y = {};
                                    for (var A in u)
                                        A !== "ref" && (y[A] = u[A])
                                }
                                if (c = c.defaultProps) {
                                    y === u && (y = _d({}, y));
                                    for (var C in c)
                                        y[C] === void 0 && (y[C] = c[C])
                                }
                                return y
                            }
                            function Xc(c, u) {
                                try {
                                    var y = c.onUncaughtError;
                                    y(u.value, {
                                        componentStack: u.stack
                                    })
                                } catch (A) {
                                    setTimeout(function() {
                                        throw A
                                    })
                                }
                            }
                            function qc(c, u, y) {
                                try {
                                    var A = c.onCaughtError;
                                    A(y.value, {
                                        componentStack: y.stack,
                                        errorBoundary: u.tag === 1 ? u.stateNode : null
                                    })
                                } catch (C) {
                                    setTimeout(function() {
                                        throw C
                                    })
                                }
                            }
                            function Yc(c, u, y) {
                                return y = st(y),
                                y.tag = 3,
                                y.payload = {
                                    element: null
                                },
                                y.callback = function() {
                                    Xc(c, u)
                                }
                                ,
                                y
                            }
                            function Am(c) {
                                return c = st(c),
                                c.tag = 3,
                                c
                            }
                            function o0(c, u, y, A) {
                                var C = y.type.getDerivedStateFromError;
                                if (typeof C == "function") {
                                    var N = A.value;
                                    c.payload = function() {
                                        return C(N)
                                    }
                                    ,
                                    c.callback = function() {
                                        qc(u, y, A)
                                    }
                                }
                                var W = y.stateNode;
                                W !== null && typeof W.componentDidCatch == "function" && (c.callback = function() {
                                    qc(u, y, A),
                                    typeof C != "function" && (Dl === null ? Dl = new Set([this]) : Dl.add(this));
                                    var oe = A.stack;
                                    this.componentDidCatch(A.value, {
                                        componentStack: oe !== null ? oe : ""
                                    })
                                }
                                )
                            }
                            function TS(c, u, y, A, C) {
                                if (y.flags |= 32768,
                                A !== null && typeof A == "object" && typeof A.then == "function") {
                                    if (u = y.alternate,
                                    u !== null && gh(u, y, C, !0),
                                    y = ba.current,
                                    y !== null) {
                                        switch (y.tag) {
                                        case 13:
                                            return Xn === null ? Ao() : y.alternate === null && Yn === 0 && (Yn = 3),
                                            y.flags &= -257,
                                            y.flags |= 65536,
                                            y.lanes = C,
                                            A === Wh ? y.flags |= 16384 : (u = y.updateQueue,
                                            u === null ? y.updateQueue = new Set([A]) : u.add(A),
                                            $l(c, A, C)),
                                            !1;
                                        case 22:
                                            return y.flags |= 65536,
                                            A === Wh ? y.flags |= 16384 : (u = y.updateQueue,
                                            u === null ? (u = {
                                                transitions: null,
                                                markerInstances: null,
                                                retryQueue: new Set([A])
                                            },
                                            y.updateQueue = u) : (y = u.retryQueue,
                                            y === null ? u.retryQueue = new Set([A]) : y.add(A)),
                                            $l(c, A, C)),
                                            !1
                                        }
                                        throw Error(r(435, y.tag))
                                    }
                                    return $l(c, A, C),
                                    Ao(),
                                    !1
                                }
                                if (_n)
                                    return u = ba.current,
                                    u !== null ? ((u.flags & 65536) === 0 && (u.flags |= 256),
                                    u.flags |= 65536,
                                    u.lanes = C,
                                    A !== Xh && (c = Error(r(422), {
                                        cause: A
                                    }),
                                    de(se(c, y)))) : (A !== Xh && (u = Error(r(423), {
                                        cause: A
                                    }),
                                    de(se(u, y))),
                                    c = c.current.alternate,
                                    c.flags |= 65536,
                                    C &= -C,
                                    c.lanes |= C,
                                    A = se(A, y),
                                    C = Yc(c.stateNode, A, C),
                                    He(c, C),
                                    Yn !== 4 && (Yn = 2)),
                                    !1;
                                var N = Error(r(520), {
                                    cause: A
                                });
                                if (N = se(N, y),
                                gc === null ? gc = [N] : gc.push(N),
                                Yn !== 4 && (Yn = 2),
                                u === null)
                                    return !0;
                                A = se(A, y),
                                y = u;
                                do {
                                    switch (y.tag) {
                                    case 3:
                                        return y.flags |= 65536,
                                        c = C & -C,
                                        y.lanes |= c,
                                        c = Yc(y.stateNode, A, c),
                                        He(y, c),
                                        !1;
                                    case 1:
                                        if (u = y.type,
                                        N = y.stateNode,
                                        (y.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || N !== null && typeof N.componentDidCatch == "function" && (Dl === null || !Dl.has(N))))
                                            return y.flags |= 65536,
                                            C &= -C,
                                            y.lanes |= C,
                                            C = Am(C),
                                            o0(C, c, y, A),
                                            He(y, C),
                                            !1
                                    }
                                    y = y.return
                                } while (y !== null);
                                return !1
                            }
                            function us(c, u, y, A) {
                                u.child = c === null ? Wr(u, null, y, A) : wl(u, c.child, y, A)
                            }
                            function td(c, u, y, A, C) {
                                y = y.render;
                                var N = u.ref;
                                if ("ref"in A) {
                                    var W = {};
                                    for (var oe in A)
                                        oe !== "ref" && (W[oe] = A[oe])
                                } else
                                    W = A;
                                return sl(u),
                                A = Lr(c, u, y, W, N, C),
                                oe = j(),
                                c !== null && !qn ? (me(c, u, C),
                                mo(c, u, C)) : (_n && oe && ze(u),
                                u.flags |= 1,
                                us(c, u, A, C),
                                u.child)
                            }
                            function l0(c, u, y, A, C) {
                                if (c === null) {
                                    var N = y.type;
                                    return typeof N == "function" && !Rh(N) && N.defaultProps === void 0 && y.compare === null ? (u.tag = 15,
                                    u.type = N,
                                    c0(c, u, N, A, C)) : (c = Gr(y.type, null, A, u, u.mode, C),
                                    c.ref = u.ref,
                                    c.return = u,
                                    u.child = c)
                                }
                                if (N = c.child,
                                !wm(c, C)) {
                                    var W = N.memoizedProps;
                                    if (y = y.compare,
                                    y = y !== null ? y : gt,
                                    y(W, A) && c.ref === u.ref)
                                        return mo(c, u, C)
                                }
                                return u.flags |= 1,
                                c = Xa(N, A),
                                c.ref = u.ref,
                                c.return = u,
                                u.child = c
                            }
                            function c0(c, u, y, A, C) {
                                if (c !== null) {
                                    var N = c.memoizedProps;
                                    if (gt(N, A) && c.ref === u.ref)
                                        if (qn = !1,
                                        u.pendingProps = A = N,
                                        wm(c, C))
                                            (c.flags & 131072) !== 0 && (qn = !0);
                                        else
                                            return u.lanes = c.lanes,
                                            mo(c, u, C)
                                }
                                return nd(c, u, y, A, C)
                            }
                            function u0(c, u, y) {
                                var A = u.pendingProps
                                  , C = A.children
                                  , N = (u.stateNode._pendingVisibility & 2) !== 0
                                  , W = c !== null ? c.memoizedState : null;
                                if (dh(c, u),
                                A.mode === "hidden" || N) {
                                    if ((u.flags & 128) !== 0) {
                                        if (A = W !== null ? W.baseLanes | y : y,
                                        c !== null) {
                                            for (C = u.child = c.child,
                                            N = 0; C !== null; )
                                                N = N | C.lanes | C.childLanes,
                                                C = C.sibling;
                                            u.childLanes = N & ~A
                                        } else
                                            u.childLanes = 0,
                                            u.child = null;
                                        return h0(c, u, A, y)
                                    }
                                    if ((y & 536870912) !== 0)
                                        u.memoizedState = {
                                            baseLanes: 0,
                                            cachePool: null
                                        },
                                        c !== null && sd(u, W !== null ? W.cachePool : null),
                                        W !== null ? Ti(u, W) : ki(),
                                        rh(u);
                                    else
                                        return u.lanes = u.childLanes = 536870912,
                                        h0(c, u, W !== null ? W.baseLanes | y : y, y)
                                } else
                                    W !== null ? (sd(u, W.cachePool),
                                    Ti(u, W),
                                    ma(u),
                                    u.memoizedState = null) : (c !== null && sd(u, null),
                                    ki(),
                                    ma(u));
                                return us(c, u, C, y),
                                u.child
                            }
                            function h0(c, u, y, A) {
                                var C = Rm();
                                return C = C === null ? null : {
                                    parent: zs ? Jn._currentValue : Jn._currentValue2,
                                    pool: C
                                },
                                u.memoizedState = {
                                    baseLanes: y,
                                    cachePool: C
                                },
                                c !== null && sd(u, null),
                                ki(),
                                rh(u),
                                c !== null && gh(c, u, A, !0),
                                null
                            }
                            function dh(c, u) {
                                var y = u.ref;
                                if (y === null)
                                    c !== null && c.ref !== null && (u.flags |= 2097664);
                                else {
                                    if (typeof y != "function" && typeof y != "object")
                                        throw Error(r(284));
                                    (c === null || c.ref !== y) && (u.flags |= 2097664)
                                }
                            }
                            function nd(c, u, y, A, C) {
                                return sl(u),
                                y = Lr(c, u, y, A, void 0, C),
                                A = j(),
                                c !== null && !qn ? (me(c, u, C),
                                mo(c, u, C)) : (_n && A && ze(u),
                                u.flags |= 1,
                                us(c, u, y, C),
                                u.child)
                            }
                            function f0(c, u, y, A, C, N) {
                                return sl(u),
                                u.updateQueue = null,
                                y = ho(u, A, y, C),
                                $o(c),
                                A = j(),
                                c !== null && !qn ? (me(c, u, N),
                                mo(c, u, N)) : (_n && A && ze(u),
                                u.flags |= 1,
                                us(c, u, y, N),
                                u.child)
                            }
                            function d0(c, u, y, A, C) {
                                if (sl(u),
                                u.stateNode === null) {
                                    var N = Al
                                      , W = y.contextType;
                                    typeof W == "object" && W !== null && (N = hs(W)),
                                    N = new y(A,N),
                                    u.memoizedState = N.state !== null && N.state !== void 0 ? N.state : null,
                                    N.updater = jr,
                                    u.stateNode = N,
                                    N._reactInternals = u,
                                    N = u.stateNode,
                                    N.props = A,
                                    N.state = u.memoizedState,
                                    N.refs = {},
                                    Ct(u),
                                    W = y.contextType,
                                    N.context = typeof W == "object" && W !== null ? hs(W) : Al,
                                    N.state = u.memoizedState,
                                    W = y.getDerivedStateFromProps,
                                    typeof W == "function" && (Gc(u, y, W, A),
                                    N.state = u.memoizedState),
                                    typeof y.getDerivedStateFromProps == "function" || typeof N.getSnapshotBeforeUpdate == "function" || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (W = N.state,
                                    typeof N.componentWillMount == "function" && N.componentWillMount(),
                                    typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount(),
                                    W !== N.state && jr.enqueueReplaceState(N, N.state, null),
                                    ae(u, A, N, C),
                                    lt(),
                                    N.state = u.memoizedState),
                                    typeof N.componentDidMount == "function" && (u.flags |= 4194308),
                                    A = !0
                                } else if (c === null) {
                                    N = u.stateNode;
                                    var oe = u.memoizedProps
                                      , ve = po(y, oe);
                                    N.props = ve;
                                    var Xe = N.context
                                      , it = y.contextType;
                                    W = Al,
                                    typeof it == "object" && it !== null && (W = hs(it));
                                    var dt = y.getDerivedStateFromProps;
                                    it = typeof dt == "function" || typeof N.getSnapshotBeforeUpdate == "function",
                                    oe = u.pendingProps !== oe,
                                    it || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (oe || Xe !== W) && r0(u, N, A, W),
                                    No = !1;
                                    var mt = u.memoizedState;
                                    N.state = mt,
                                    ae(u, A, N, C),
                                    lt(),
                                    Xe = u.memoizedState,
                                    oe || mt !== Xe || No ? (typeof dt == "function" && (Gc(u, y, dt, A),
                                    Xe = u.memoizedState),
                                    (ve = No || kc(u, y, ve, A, mt, Xe, W)) ? (it || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (typeof N.componentWillMount == "function" && N.componentWillMount(),
                                    typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount()),
                                    typeof N.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof N.componentDidMount == "function" && (u.flags |= 4194308),
                                    u.memoizedProps = A,
                                    u.memoizedState = Xe),
                                    N.props = A,
                                    N.state = Xe,
                                    N.context = W,
                                    A = ve) : (typeof N.componentDidMount == "function" && (u.flags |= 4194308),
                                    A = !1)
                                } else {
                                    N = u.stateNode,
                                    et(c, u),
                                    W = u.memoizedProps,
                                    it = po(y, W),
                                    N.props = it,
                                    dt = u.pendingProps,
                                    mt = N.context,
                                    Xe = y.contextType,
                                    ve = Al,
                                    typeof Xe == "object" && Xe !== null && (ve = hs(Xe)),
                                    oe = y.getDerivedStateFromProps,
                                    (Xe = typeof oe == "function" || typeof N.getSnapshotBeforeUpdate == "function") || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (W !== dt || mt !== ve) && r0(u, N, A, ve),
                                    No = !1,
                                    mt = u.memoizedState,
                                    N.state = mt,
                                    ae(u, A, N, C),
                                    lt();
                                    var Qt = u.memoizedState;
                                    W !== dt || mt !== Qt || No || c !== null && c.dependencies !== null && vh(c.dependencies) ? (typeof oe == "function" && (Gc(u, y, oe, A),
                                    Qt = u.memoizedState),
                                    (it = No || kc(u, y, it, A, mt, Qt, ve) || c !== null && c.dependencies !== null && vh(c.dependencies)) ? (Xe || typeof N.UNSAFE_componentWillUpdate != "function" && typeof N.componentWillUpdate != "function" || (typeof N.componentWillUpdate == "function" && N.componentWillUpdate(A, Qt, ve),
                                    typeof N.UNSAFE_componentWillUpdate == "function" && N.UNSAFE_componentWillUpdate(A, Qt, ve)),
                                    typeof N.componentDidUpdate == "function" && (u.flags |= 4),
                                    typeof N.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof N.componentDidUpdate != "function" || W === c.memoizedProps && mt === c.memoizedState || (u.flags |= 4),
                                    typeof N.getSnapshotBeforeUpdate != "function" || W === c.memoizedProps && mt === c.memoizedState || (u.flags |= 1024),
                                    u.memoizedProps = A,
                                    u.memoizedState = Qt),
                                    N.props = A,
                                    N.state = Qt,
                                    N.context = ve,
                                    A = it) : (typeof N.componentDidUpdate != "function" || W === c.memoizedProps && mt === c.memoizedState || (u.flags |= 4),
                                    typeof N.getSnapshotBeforeUpdate != "function" || W === c.memoizedProps && mt === c.memoizedState || (u.flags |= 1024),
                                    A = !1)
                                }
                                return N = A,
                                dh(c, u),
                                A = (u.flags & 128) !== 0,
                                N || A ? (N = u.stateNode,
                                y = A && typeof y.getDerivedStateFromError != "function" ? null : N.render(),
                                u.flags |= 1,
                                c !== null && A ? (u.child = wl(u, c.child, null, C),
                                u.child = wl(u, null, y, C)) : us(c, u, y, C),
                                u.memoizedState = N.state,
                                c = u.child) : c = mo(c, u, C),
                                c
                            }
                            function p0(c, u, y, A) {
                                return Ve(),
                                u.flags |= 256,
                                us(c, u, y, A),
                                u.child
                            }
                            function Tm(c) {
                                return {
                                    baseLanes: c,
                                    cachePool: Dm()
                                }
                            }
                            function ph(c, u, y) {
                                return c = c !== null ? c.childLanes & ~y : 0,
                                u && (c |= Oa),
                                c
                            }
                            function m0(c, u, y) {
                                var A = u.pendingProps, C = !1, N = (u.flags & 128) !== 0, W;
                                if ((W = N) || (W = c !== null && c.memoizedState === null ? !1 : (Yi.current & 2) !== 0),
                                W && (C = !0,
                                u.flags &= -129),
                                W = (u.flags & 32) !== 0,
                                u.flags &= -33,
                                c === null) {
                                    if (_n) {
                                        if (C ? Bs(u) : ma(u),
                                        _n) {
                                            var oe = vs, ve;
                                            (ve = oe) && (oe = J0(oe, ns),
                                            oe !== null ? (u.memoizedState = {
                                                dehydrated: oe,
                                                treeContext: Tl !== null ? {
                                                    id: yr,
                                                    overflow: _r
                                                } : null,
                                                retryLane: 536870912
                                            },
                                            ve = i(18, null, null, 0),
                                            ve.stateNode = oe,
                                            ve.return = u,
                                            u.child = ve,
                                            gs = u,
                                            vs = null,
                                            ve = !0) : ve = !1),
                                            ve || $e(u)
                                        }
                                        if (oe = u.memoizedState,
                                        oe !== null && (oe = oe.dehydrated,
                                        oe !== null))
                                            return Rd(oe) ? u.lanes = 16 : u.lanes = 536870912,
                                            null;
                                        ga(u)
                                    }
                                    return oe = A.children,
                                    A = A.fallback,
                                    C ? (ma(u),
                                    C = u.mode,
                                    oe = bm({
                                        mode: "hidden",
                                        children: oe
                                    }, C),
                                    A = vi(A, C, y, null),
                                    oe.return = u,
                                    A.return = u,
                                    oe.sibling = A,
                                    u.child = oe,
                                    C = u.child,
                                    C.memoizedState = Tm(y),
                                    C.childLanes = ph(c, W, y),
                                    u.memoizedState = kd,
                                    A) : (Bs(u),
                                    Mm(u, oe))
                                }
                                if (ve = c.memoizedState,
                                ve !== null && (oe = ve.dehydrated,
                                oe !== null)) {
                                    if (N)
                                        u.flags & 256 ? (Bs(u),
                                        u.flags &= -257,
                                        u = id(c, u, y)) : u.memoizedState !== null ? (ma(u),
                                        u.child = c.child,
                                        u.flags |= 128,
                                        u = null) : (ma(u),
                                        C = A.fallback,
                                        oe = u.mode,
                                        A = bm({
                                            mode: "visible",
                                            children: A.children
                                        }, oe),
                                        C = vi(C, oe, y, null),
                                        C.flags |= 2,
                                        A.return = u,
                                        C.return = u,
                                        A.sibling = C,
                                        u.child = A,
                                        wl(u, c.child, null, y),
                                        A = u.child,
                                        A.memoizedState = Tm(y),
                                        A.childLanes = ph(c, W, y),
                                        u.memoizedState = kd,
                                        u = C);
                                    else if (Bs(u),
                                    Rd(oe))
                                        W = W0(oe).digest,
                                        A = Error(r(419)),
                                        A.stack = "",
                                        A.digest = W,
                                        de({
                                            value: A,
                                            source: null,
                                            stack: null
                                        }),
                                        u = id(c, u, y);
                                    else if (qn || gh(c, u, y, !1),
                                    W = (y & c.childLanes) !== 0,
                                    qn || W) {
                                        if (W = On,
                                        W !== null) {
                                            if (A = y & -y,
                                            (A & 42) !== 0)
                                                A = 1;
                                            else
                                                switch (A) {
                                                case 2:
                                                    A = 1;
                                                    break;
                                                case 8:
                                                    A = 4;
                                                    break;
                                                case 32:
                                                    A = 16;
                                                    break;
                                                case 128:
                                                case 256:
                                                case 512:
                                                case 1024:
                                                case 2048:
                                                case 4096:
                                                case 8192:
                                                case 16384:
                                                case 32768:
                                                case 65536:
                                                case 131072:
                                                case 262144:
                                                case 524288:
                                                case 1048576:
                                                case 2097152:
                                                case 4194304:
                                                case 8388608:
                                                case 16777216:
                                                case 33554432:
                                                    A = 64;
                                                    break;
                                                case 268435456:
                                                    A = 134217728;
                                                    break;
                                                default:
                                                    A = 0
                                                }
                                            if (A = (A & (W.suspendedLanes | y)) !== 0 ? 0 : A,
                                            A !== 0 && A !== ve.retryLane)
                                                throw ve.retryLane = A,
                                                Ie(c, A),
                                                es(W, c, A),
                                                Gd
                                        }
                                        Cd(oe) || Ao(),
                                        u = id(c, u, y)
                                    } else
                                        Cd(oe) ? (u.flags |= 128,
                                        u.child = c.child,
                                        u = To.bind(null, c),
                                        j0(oe, u),
                                        u = null) : (c = ve.treeContext,
                                        ms && (vs = K0(oe),
                                        gs = u,
                                        _n = !0,
                                        Qa = null,
                                        ns = !1,
                                        c !== null && (Aa[Ta++] = yr,
                                        Aa[Ta++] = _r,
                                        Aa[Ta++] = Tl,
                                        yr = c.id,
                                        _r = c.overflow,
                                        Tl = u)),
                                        u = Mm(u, A.children),
                                        u.flags |= 4096);
                                    return u
                                }
                                return C ? (ma(u),
                                C = A.fallback,
                                oe = u.mode,
                                ve = c.child,
                                N = ve.sibling,
                                A = Xa(ve, {
                                    mode: "hidden",
                                    children: A.children
                                }),
                                A.subtreeFlags = ve.subtreeFlags & 31457280,
                                N !== null ? C = Xa(N, C) : (C = vi(C, oe, y, null),
                                C.flags |= 2),
                                C.return = u,
                                A.return = u,
                                A.sibling = C,
                                u.child = A,
                                A = C,
                                C = u.child,
                                oe = c.child.memoizedState,
                                oe === null ? oe = Tm(y) : (ve = oe.cachePool,
                                ve !== null ? (N = zs ? Jn._currentValue : Jn._currentValue2,
                                ve = ve.parent !== N ? {
                                    parent: N,
                                    pool: N
                                } : ve) : ve = Dm(),
                                oe = {
                                    baseLanes: oe.baseLanes | y,
                                    cachePool: ve
                                }),
                                C.memoizedState = oe,
                                C.childLanes = ph(c, W, y),
                                u.memoizedState = kd,
                                A) : (Bs(u),
                                y = c.child,
                                c = y.sibling,
                                y = Xa(y, {
                                    mode: "visible",
                                    children: A.children
                                }),
                                y.return = u,
                                y.sibling = null,
                                c !== null && (W = u.deletions,
                                W === null ? (u.deletions = [c],
                                u.flags |= 16) : W.push(c)),
                                u.child = y,
                                u.memoizedState = null,
                                y)
                            }
                            function Mm(c, u) {
                                return u = bm({
                                    mode: "visible",
                                    children: u
                                }, c.mode),
                                u.return = c,
                                c.child = u
                            }
                            function bm(c, u) {
                                return Oh(c, u, 0, null)
                            }
                            function id(c, u, y) {
                                return wl(u, c.child, null, y),
                                c = Mm(u, u.pendingProps.children),
                                c.flags |= 2,
                                u.memoizedState = null,
                                c
                            }
                            function g0(c, u, y) {
                                c.lanes |= u;
                                var A = c.alternate;
                                A !== null && (A.lanes |= u),
                                mh(c.return, u, y)
                            }
                            function Em(c, u, y, A, C) {
                                var N = c.memoizedState;
                                N === null ? c.memoizedState = {
                                    isBackwards: u,
                                    rendering: null,
                                    renderingStartTime: 0,
                                    last: A,
                                    tail: y,
                                    tailMode: C
                                } : (N.isBackwards = u,
                                N.rendering = null,
                                N.renderingStartTime = 0,
                                N.last = A,
                                N.tail = y,
                                N.tailMode = C)
                            }
                            function v0(c, u, y) {
                                var A = u.pendingProps
                                  , C = A.revealOrder
                                  , N = A.tail;
                                if (us(c, u, A.children, y),
                                A = Yi.current,
                                (A & 2) !== 0)
                                    A = A & 1 | 2,
                                    u.flags |= 128;
                                else {
                                    if (c !== null && (c.flags & 128) !== 0)
                                        e: for (c = u.child; c !== null; ) {
                                            if (c.tag === 13)
                                                c.memoizedState !== null && g0(c, y, u);
                                            else if (c.tag === 19)
                                                g0(c, y, u);
                                            else if (c.child !== null) {
                                                c.child.return = c,
                                                c = c.child;
                                                continue
                                            }
                                            if (c === u)
                                                break e;
                                            for (; c.sibling === null; ) {
                                                if (c.return === null || c.return === u)
                                                    break e;
                                                c = c.return
                                            }
                                            c.sibling.return = c.return,
                                            c = c.sibling
                                        }
                                    A &= 1
                                }
                                switch (R(Yi, A),
                                C) {
                                case "forwards":
                                    for (y = u.child,
                                    C = null; y !== null; )
                                        c = y.alternate,
                                        c !== null && cr(c) === null && (C = y),
                                        y = y.sibling;
                                    y = C,
                                    y === null ? (C = u.child,
                                    u.child = null) : (C = y.sibling,
                                    y.sibling = null),
                                    Em(u, !1, C, y, N);
                                    break;
                                case "backwards":
                                    for (y = null,
                                    C = u.child,
                                    u.child = null; C !== null; ) {
                                        if (c = C.alternate,
                                        c !== null && cr(c) === null) {
                                            u.child = C;
                                            break
                                        }
                                        c = C.sibling,
                                        C.sibling = y,
                                        y = C,
                                        C = c
                                    }
                                    Em(u, !0, y, null, N);
                                    break;
                                case "together":
                                    Em(u, !1, null, null, void 0);
                                    break;
                                default:
                                    u.memoizedState = null
                                }
                                return u.child
                            }
                            function mo(c, u, y) {
                                if (c !== null && (u.dependencies = c.dependencies),
                                Da |= u.lanes,
                                (y & u.childLanes) === 0)
                                    if (c !== null) {
                                        if (gh(c, u, y, !1),
                                        (y & u.childLanes) === 0)
                                            return null
                                    } else
                                        return null;
                                if (c !== null && u.child !== c.child)
                                    throw Error(r(153));
                                if (u.child !== null) {
                                    for (c = u.child,
                                    y = Xa(c, c.pendingProps),
                                    u.child = y,
                                    y.return = u; c.sibling !== null; )
                                        c = c.sibling,
                                        y = y.sibling = Xa(c, c.pendingProps),
                                        y.return = u;
                                    y.sibling = null
                                }
                                return u.child
                            }
                            function wm(c, u) {
                                return (c.lanes & u) !== 0 ? !0 : (c = c.dependencies,
                                !!(c !== null && vh(c)))
                            }
                            function MS(c, u, y) {
                                switch (u.tag) {
                                case 3:
                                    le(u, u.stateNode.containerInfo),
                                    il(u, Jn, c.memoizedState.cache),
                                    Ve();
                                    break;
                                case 27:
                                case 5:
                                    be(u);
                                    break;
                                case 4:
                                    le(u, u.stateNode.containerInfo);
                                    break;
                                case 10:
                                    il(u, u.type, u.memoizedProps.value);
                                    break;
                                case 13:
                                    var A = u.memoizedState;
                                    if (A !== null)
                                        return A.dehydrated !== null ? (Bs(u),
                                        u.flags |= 128,
                                        null) : (y & u.child.childLanes) !== 0 ? m0(c, u, y) : (Bs(u),
                                        c = mo(c, u, y),
                                        c !== null ? c.sibling : null);
                                    Bs(u);
                                    break;
                                case 19:
                                    var C = (c.flags & 128) !== 0;
                                    if (A = (y & u.childLanes) !== 0,
                                    A || (gh(c, u, y, !1),
                                    A = (y & u.childLanes) !== 0),
                                    C) {
                                        if (A)
                                            return v0(c, u, y);
                                        u.flags |= 128
                                    }
                                    if (C = u.memoizedState,
                                    C !== null && (C.rendering = null,
                                    C.tail = null,
                                    C.lastEffect = null),
                                    R(Yi, Yi.current),
                                    A)
                                        break;
                                    return null;
                                case 22:
                                case 23:
                                    return u.lanes = 0,
                                    u0(c, u, y);
                                case 24:
                                    il(u, Jn, c.memoizedState.cache)
                                }
                                return mo(c, u, y)
                            }
                            function y0(c, u, y) {
                                if (c !== null)
                                    if (c.memoizedProps !== u.pendingProps)
                                        qn = !0;
                                    else {
                                        if (!wm(c, y) && (u.flags & 128) === 0)
                                            return qn = !1,
                                            MS(c, u, y);
                                        qn = (c.flags & 131072) !== 0
                                    }
                                else
                                    qn = !1,
                                    _n && (u.flags & 1048576) !== 0 && J(u, du, u.index);
                                switch (u.lanes = 0,
                                u.tag) {
                                case 16:
                                    e: {
                                        c = u.pendingProps;
                                        var A = u.elementType
                                          , C = A._init;
                                        if (A = C(A._payload),
                                        u.type = A,
                                        typeof A == "function")
                                            Rh(A) ? (c = po(A, c),
                                            u.tag = 1,
                                            u = d0(null, u, A, c, y)) : (u.tag = 0,
                                            u = nd(null, u, A, c, y));
                                        else {
                                            if (A != null) {
                                                if (C = A.$$typeof,
                                                C === Ih) {
                                                    u.tag = 11,
                                                    u = td(null, u, A, c, y);
                                                    break e
                                                } else if (C === Ad) {
                                                    u.tag = 14,
                                                    u = l0(null, u, A, c, y);
                                                    break e
                                                }
                                            }
                                            throw u = h(A) || A,
                                            Error(r(306, u, ""))
                                        }
                                    }
                                    return u;
                                case 0:
                                    return nd(c, u, u.type, u.pendingProps, y);
                                case 1:
                                    return A = u.type,
                                    C = po(A, u.pendingProps),
                                    d0(c, u, A, C, y);
                                case 3:
                                    e: {
                                        if (le(u, u.stateNode.containerInfo),
                                        c === null)
                                            throw Error(r(387));
                                        var N = u.pendingProps;
                                        C = u.memoizedState,
                                        A = C.element,
                                        et(c, u),
                                        ae(u, N, null, y);
                                        var W = u.memoizedState;
                                        if (N = W.cache,
                                        il(u, Jn, N),
                                        N !== C.cache && Kl(u, [Jn], y, !0),
                                        lt(),
                                        N = W.element,
                                        ms && C.isDehydrated)
                                            if (C = {
                                                element: N,
                                                isDehydrated: !1,
                                                cache: W.cache
                                            },
                                            u.updateQueue.baseState = C,
                                            u.memoizedState = C,
                                            u.flags & 256) {
                                                u = p0(c, u, N, y);
                                                break e
                                            } else if (N !== A) {
                                                A = se(Error(r(424)), u),
                                                de(A),
                                                u = p0(c, u, N, y);
                                                break e
                                            } else
                                                for (ms && (vs = Z0(u.stateNode.containerInfo),
                                                gs = u,
                                                _n = !0,
                                                Qa = null,
                                                ns = !0),
                                                y = Wr(u, null, N, y),
                                                u.child = y; y; )
                                                    y.flags = y.flags & -3 | 4096,
                                                    y = y.sibling;
                                        else {
                                            if (Ve(),
                                            N === A) {
                                                u = mo(c, u, y);
                                                break e
                                            }
                                            us(c, u, N, y)
                                        }
                                        u = u.child
                                    }
                                    return u;
                                case 26:
                                    if (Sa)
                                        return dh(c, u),
                                        c === null ? (y = dg(u.type, null, u.pendingProps, null)) ? u.memoizedState = y : _n || (u.stateNode = Bd(u.type, u.pendingProps, qr.current, u)) : u.memoizedState = dg(u.type, c.memoizedProps, u.pendingProps, c.memoizedState),
                                        null;
                                case 27:
                                    if (kn)
                                        return be(u),
                                        c === null && kn && _n && (A = u.stateNode = vr(u.type, u.pendingProps, qr.current, qi.current, !1),
                                        gs = u,
                                        ns = !0,
                                        vs = Dd(A)),
                                        A = u.pendingProps.children,
                                        c !== null || _n ? us(c, u, A, y) : u.child = wl(u, null, A, y),
                                        dh(c, u),
                                        u.child;
                                case 5:
                                    return c === null && _n && (Nd(u.type, u.pendingProps, qi.current),
                                    (C = A = vs) && (A = OS(A, u.type, u.pendingProps, ns),
                                    A !== null ? (u.stateNode = A,
                                    gs = u,
                                    vs = Dd(A),
                                    ns = !1,
                                    C = !0) : C = !1),
                                    C || $e(u)),
                                    be(u),
                                    C = u.type,
                                    N = u.pendingProps,
                                    W = c !== null ? c.memoizedProps : null,
                                    A = N.children,
                                    Jt(C, N) ? A = null : W !== null && Jt(C, W) && (u.flags |= 32),
                                    u.memoizedState !== null && (C = Lr(c, u, Bi, null, null, y),
                                    zs ? gr._currentValue = C : gr._currentValue2 = C),
                                    dh(c, u),
                                    us(c, u, A, y),
                                    u.child;
                                case 6:
                                    return c === null && _n && (iy(u.pendingProps, qi.current),
                                    (c = y = vs) && (y = hg(y, u.pendingProps, ns),
                                    y !== null ? (u.stateNode = y,
                                    gs = u,
                                    vs = null,
                                    c = !0) : c = !1),
                                    c || $e(u)),
                                    null;
                                case 13:
                                    return m0(c, u, y);
                                case 4:
                                    return le(u, u.stateNode.containerInfo),
                                    A = u.pendingProps,
                                    c === null ? u.child = wl(u, null, A, y) : us(c, u, A, y),
                                    u.child;
                                case 11:
                                    return td(c, u, u.type, u.pendingProps, y);
                                case 7:
                                    return us(c, u, u.pendingProps, y),
                                    u.child;
                                case 8:
                                    return us(c, u, u.pendingProps.children, y),
                                    u.child;
                                case 12:
                                    return us(c, u, u.pendingProps.children, y),
                                    u.child;
                                case 10:
                                    return A = u.pendingProps,
                                    il(u, u.type, A.value),
                                    us(c, u, A.children, y),
                                    u.child;
                                case 9:
                                    return C = u.type._context,
                                    A = u.pendingProps.children,
                                    sl(u),
                                    C = hs(C),
                                    A = A(C),
                                    u.flags |= 1,
                                    us(c, u, A, y),
                                    u.child;
                                case 14:
                                    return l0(c, u, u.type, u.pendingProps, y);
                                case 15:
                                    return c0(c, u, u.type, u.pendingProps, y);
                                case 19:
                                    return v0(c, u, y);
                                case 22:
                                    return u0(c, u, y);
                                case 24:
                                    return sl(u),
                                    A = hs(Jn),
                                    c === null ? (C = Rm(),
                                    C === null && (C = On,
                                    N = al(),
                                    C.pooledCache = N,
                                    N.refCount++,
                                    N !== null && (C.pooledCacheLanes |= y),
                                    C = N),
                                    u.memoizedState = {
                                        parent: A,
                                        cache: C
                                    },
                                    Ct(u),
                                    il(u, Jn, C)) : ((c.lanes & y) !== 0 && (et(c, u),
                                    ae(u, null, null, y),
                                    lt()),
                                    C = c.memoizedState,
                                    N = u.memoizedState,
                                    C.parent !== A ? (C = {
                                        parent: A,
                                        cache: A
                                    },
                                    u.memoizedState = C,
                                    u.lanes === 0 && (u.memoizedState = u.updateQueue.baseState = C),
                                    il(u, Jn, A)) : (A = N.cache,
                                    il(u, Jn, A),
                                    A !== C.cache && Kl(u, [Jn], y, !0))),
                                    us(c, u, u.pendingProps.children, y),
                                    u.child;
                                case 29:
                                    throw u.pendingProps
                                }
                                throw Error(r(156, u.tag))
                            }
                            function il(c, u, y) {
                                zs ? (R(Bo, u._currentValue),
                                u._currentValue = y) : (R(Bo, u._currentValue2),
                                u._currentValue2 = y)
                            }
                            function go(c) {
                                var u = Bo.current;
                                zs ? c._currentValue = u : c._currentValue2 = u,
                                D(Bo)
                            }
                            function mh(c, u, y) {
                                for (; c !== null; ) {
                                    var A = c.alternate;
                                    if ((c.childLanes & u) !== u ? (c.childLanes |= u,
                                    A !== null && (A.childLanes |= u)) : A !== null && (A.childLanes & u) !== u && (A.childLanes |= u),
                                    c === y)
                                        break;
                                    c = c.return
                                }
                            }
                            function Kl(c, u, y, A) {
                                var C = c.child;
                                for (C !== null && (C.return = c); C !== null; ) {
                                    var N = C.dependencies;
                                    if (N !== null) {
                                        var W = C.child;
                                        N = N.firstContext;
                                        e: for (; N !== null; ) {
                                            var oe = N;
                                            N = C;
                                            for (var ve = 0; ve < u.length; ve++)
                                                if (oe.context === u[ve]) {
                                                    N.lanes |= y,
                                                    oe = N.alternate,
                                                    oe !== null && (oe.lanes |= y),
                                                    mh(N.return, y, c),
                                                    A || (W = null);
                                                    break e
                                                }
                                            N = oe.next
                                        }
                                    } else if (C.tag === 18) {
                                        if (W = C.return,
                                        W === null)
                                            throw Error(r(341));
                                        W.lanes |= y,
                                        N = W.alternate,
                                        N !== null && (N.lanes |= y),
                                        mh(W, y, c),
                                        W = null
                                    } else
                                        W = C.child;
                                    if (W !== null)
                                        W.return = C;
                                    else
                                        for (W = C; W !== null; ) {
                                            if (W === c) {
                                                W = null;
                                                break
                                            }
                                            if (C = W.sibling,
                                            C !== null) {
                                                C.return = W.return,
                                                W = C;
                                                break
                                            }
                                            W = W.return
                                        }
                                    C = W
                                }
                            }
                            function gh(c, u, y, A) {
                                c = null;
                                for (var C = u, N = !1; C !== null; ) {
                                    if (!N) {
                                        if ((C.flags & 524288) !== 0)
                                            N = !0;
                                        else if ((C.flags & 262144) !== 0)
                                            break
                                    }
                                    if (C.tag === 10) {
                                        var W = C.alternate;
                                        if (W === null)
                                            throw Error(r(387));
                                        if (W = W.memoizedProps,
                                        W !== null) {
                                            var oe = C.type;
                                            ia(C.pendingProps.value, W.value) || (c !== null ? c.push(oe) : c = [oe])
                                        }
                                    } else if (C === oc.current) {
                                        if (W = C.alternate,
                                        W === null)
                                            throw Error(r(387));
                                        W.memoizedState.memoizedState !== C.memoizedState.memoizedState && (c !== null ? c.push(gr) : c = [gr])
                                    }
                                    C = C.return
                                }
                                c !== null && Kl(u, c, y, A),
                                u.flags |= 262144
                            }
                            function vh(c) {
                                for (c = c.firstContext; c !== null; ) {
                                    var u = c.context;
                                    if (!ia(zs ? u._currentValue : u._currentValue2, c.memoizedValue))
                                        return !0;
                                    c = c.next
                                }
                                return !1
                            }
                            function sl(c) {
                                Ar = c,
                                wa = null,
                                c = c.dependencies,
                                c !== null && (c.firstContext = null)
                            }
                            function hs(c) {
                                return Cm(Ar, c)
                            }
                            function yh(c, u) {
                                return Ar === null && sl(c),
                                Cm(c, u)
                            }
                            function Cm(c, u) {
                                var y = zs ? u._currentValue : u._currentValue2;
                                if (u = {
                                    context: u,
                                    memoizedValue: y,
                                    next: null
                                },
                                wa === null) {
                                    if (c === null)
                                        throw Error(r(308));
                                    wa = u,
                                    c.dependencies = {
                                        lanes: 0,
                                        firstContext: u
                                    },
                                    c.flags |= 524288
                                } else
                                    wa = wa.next = u;
                                return y
                            }
                            function al() {
                                return {
                                    controller: new _u,
                                    data: new Map,
                                    refCount: 0
                                }
                            }
                            function _h(c) {
                                c.refCount--,
                                c.refCount === 0 && dy(py, function() {
                                    c.controller.abort()
                                })
                            }
                            function Rm() {
                                var c = Qr.current;
                                return c !== null ? c : On.pooledCache
                            }
                            function sd(c, u) {
                                u === null ? R(Qr, Qr.current) : R(Qr, u.pool)
                            }
                            function Dm() {
                                var c = Rm();
                                return c === null ? null : {
                                    parent: zs ? Jn._currentValue : Jn._currentValue2,
                                    pool: c
                                }
                            }
                            function Zs(c) {
                                c.flags |= 4
                            }
                            function Wc(c, u) {
                                if (c !== null && c.child === u.child)
                                    return !1;
                                if ((u.flags & 16) !== 0)
                                    return !0;
                                for (c = u.child; c !== null; ) {
                                    if ((c.flags & 13878) !== 0 || (c.subtreeFlags & 13878) !== 0)
                                        return !0;
                                    c = c.sibling
                                }
                                return !1
                            }
                            function Jl(c, u, y, A) {
                                if (Xi)
                                    for (y = u.child; y !== null; ) {
                                        if (y.tag === 5 || y.tag === 6)
                                            zh(c, y.stateNode);
                                        else if (!(y.tag === 4 || kn && y.tag === 27) && y.child !== null) {
                                            y.child.return = y,
                                            y = y.child;
                                            continue
                                        }
                                        if (y === u)
                                            break;
                                        for (; y.sibling === null; ) {
                                            if (y.return === null || y.return === u)
                                                return;
                                            y = y.return
                                        }
                                        y.sibling.return = y.return,
                                        y = y.sibling
                                    }
                                else if (Wa)
                                    for (var C = u.child; C !== null; ) {
                                        if (C.tag === 5) {
                                            var N = C.stateNode;
                                            y && A && (N = og(N, C.type, C.memoizedProps)),
                                            zh(c, N)
                                        } else if (C.tag === 6)
                                            N = C.stateNode,
                                            y && A && (N = lg(N, C.memoizedProps)),
                                            zh(c, N);
                                        else if (C.tag !== 4) {
                                            if (C.tag === 22 && C.memoizedState !== null)
                                                N = C.child,
                                                N !== null && (N.return = C),
                                                Jl(c, C, !0, !0);
                                            else if (C.child !== null) {
                                                C.child.return = C,
                                                C = C.child;
                                                continue
                                            }
                                        }
                                        if (C === u)
                                            break;
                                        for (; C.sibling === null; ) {
                                            if (C.return === null || C.return === u)
                                                return;
                                            C = C.return
                                        }
                                        C.sibling.return = C.return,
                                        C = C.sibling
                                    }
                            }
                            function _0(c, u, y, A) {
                                if (Wa)
                                    for (var C = u.child; C !== null; ) {
                                        if (C.tag === 5) {
                                            var N = C.stateNode;
                                            y && A && (N = og(N, C.type, C.memoizedProps)),
                                            rg(c, N)
                                        } else if (C.tag === 6)
                                            N = C.stateNode,
                                            y && A && (N = lg(N, C.memoizedProps)),
                                            rg(c, N);
                                        else if (C.tag !== 4) {
                                            if (C.tag === 22 && C.memoizedState !== null)
                                                N = C.child,
                                                N !== null && (N.return = C),
                                                _0(c, C, !(C.memoizedProps !== null && C.memoizedProps.mode === "manual"), !0);
                                            else if (C.child !== null) {
                                                C.child.return = C,
                                                C = C.child;
                                                continue
                                            }
                                        }
                                        if (C === u)
                                            break;
                                        for (; C.sibling === null; ) {
                                            if (C.return === null || C.return === u)
                                                return;
                                            C = C.return
                                        }
                                        C.sibling.return = C.return,
                                        C = C.sibling
                                    }
                            }
                            function xh(c, u) {
                                if (Wa && Wc(c, u)) {
                                    c = u.stateNode;
                                    var y = c.containerInfo
                                      , A = Fh();
                                    _0(A, u, !1, !1),
                                    c.pendingChildren = A,
                                    Zs(u),
                                    wd(y, A)
                                }
                            }
                            function ad(c, u, y, A) {
                                if (Xi)
                                    c.memoizedProps !== A && Zs(u);
                                else if (Wa) {
                                    var C = c.stateNode
                                      , N = c.memoizedProps;
                                    if ((c = Wc(c, u)) || N !== A) {
                                        var W = qi.current;
                                        N = uu(C, y, N, A, !c, null),
                                        N === C ? u.stateNode = C : (wo(N, y, A, W) && Zs(u),
                                        u.stateNode = N,
                                        c ? Jl(N, u, !1, !1) : Zs(u))
                                    } else
                                        u.stateNode = C
                                }
                            }
                            function rd(c, u, y) {
                                if (Jm(u, y)) {
                                    if (c.flags |= 16777216,
                                    !bd(u, y))
                                        if (hl())
                                            c.flags |= 8192;
                                        else
                                            throw Ml = Wh,
                                            Yh
                                } else
                                    c.flags &= -16777217
                            }
                            function od(c, u) {
                                if (ry(u)) {
                                    if (c.flags |= 16777216,
                                    !nc(u))
                                        if (hl())
                                            c.flags |= 8192;
                                        else
                                            throw Ml = Wh,
                                            Yh
                                } else
                                    c.flags &= -16777217
                            }
                            function jc(c, u) {
                                u !== null && (c.flags |= 4),
                                c.flags & 16384 && (u = c.tag !== 22 ? L() : 536870912,
                                c.lanes |= u,
                                Jr |= u)
                            }
                            function Qc(c, u) {
                                if (!_n)
                                    switch (c.tailMode) {
                                    case "hidden":
                                        u = c.tail;
                                        for (var y = null; u !== null; )
                                            u.alternate !== null && (y = u),
                                            u = u.sibling;
                                        y === null ? c.tail = null : y.sibling = null;
                                        break;
                                    case "collapsed":
                                        y = c.tail;
                                        for (var A = null; y !== null; )
                                            y.alternate !== null && (A = y),
                                            y = y.sibling;
                                        A === null ? u || c.tail === null ? c.tail = null : c.tail.sibling = null : A.sibling = null
                                    }
                            }
                            function ci(c) {
                                var u = c.alternate !== null && c.alternate.child === c.child
                                  , y = 0
                                  , A = 0;
                                if (u)
                                    for (var C = c.child; C !== null; )
                                        y |= C.lanes | C.childLanes,
                                        A |= C.subtreeFlags & 31457280,
                                        A |= C.flags & 31457280,
                                        C.return = c,
                                        C = C.sibling;
                                else
                                    for (C = c.child; C !== null; )
                                        y |= C.lanes | C.childLanes,
                                        A |= C.subtreeFlags,
                                        A |= C.flags,
                                        C.return = c,
                                        C = C.sibling;
                                return c.subtreeFlags |= A,
                                c.childLanes = y,
                                u
                            }
                            function x0(c, u, y) {
                                var A = u.pendingProps;
                                switch (xe(u),
                                u.tag) {
                                case 16:
                                case 15:
                                case 0:
                                case 11:
                                case 7:
                                case 8:
                                case 12:
                                case 9:
                                case 14:
                                    return ci(u),
                                    null;
                                case 1:
                                    return ci(u),
                                    null;
                                case 3:
                                    return y = u.stateNode,
                                    A = null,
                                    c !== null && (A = c.memoizedState.cache),
                                    u.memoizedState.cache !== A && (u.flags |= 2048),
                                    go(Jn),
                                    Ne(),
                                    y.pendingContext && (y.context = y.pendingContext,
                                    y.pendingContext = null),
                                    (c === null || c.child === null) && (ne(u) ? Zs(u) : c === null || c.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024,
                                    Qa !== null && (wh(Qa),
                                    Qa = null))),
                                    xh(c, u),
                                    ci(u),
                                    null;
                                case 26:
                                    if (Sa) {
                                        y = u.type;
                                        var C = u.memoizedState;
                                        return c === null ? (Zs(u),
                                        C !== null ? (ci(u),
                                        od(u, C)) : (ci(u),
                                        rd(u, y, A))) : C ? C !== c.memoizedState ? (Zs(u),
                                        ci(u),
                                        od(u, C)) : (ci(u),
                                        u.flags &= -16777217) : (Xi ? c.memoizedProps !== A && Zs(u) : ad(c, u, y, A),
                                        ci(u),
                                        rd(u, y, A)),
                                        null
                                    }
                                case 27:
                                    if (kn) {
                                        if (Ue(u),
                                        y = qr.current,
                                        C = u.type,
                                        c !== null && u.stateNode != null)
                                            Xi ? c.memoizedProps !== A && Zs(u) : ad(c, u, C, A);
                                        else {
                                            if (!A) {
                                                if (u.stateNode === null)
                                                    throw Error(r(166));
                                                return ci(u),
                                                null
                                            }
                                            c = qi.current,
                                            ne(u) ? rt(u, c) : (c = vr(C, A, y, c, !0),
                                            u.stateNode = c,
                                            Zs(u))
                                        }
                                        return ci(u),
                                        null
                                    }
                                case 5:
                                    if (Ue(u),
                                    y = u.type,
                                    c !== null && u.stateNode != null)
                                        ad(c, u, y, A);
                                    else {
                                        if (!A) {
                                            if (u.stateNode === null)
                                                throw Error(r(166));
                                            return ci(u),
                                            null
                                        }
                                        c = qi.current,
                                        ne(u) ? rt(u, c) : (C = Km(y, A, qr.current, c, u),
                                        Jl(C, u, !1, !1),
                                        u.stateNode = C,
                                        wo(C, y, A, c) && Zs(u))
                                    }
                                    return ci(u),
                                    rd(u, u.type, u.pendingProps),
                                    null;
                                case 6:
                                    if (c && u.stateNode != null)
                                        y = c.memoizedProps,
                                        Xi ? y !== A && Zs(u) : Wa && (y !== A ? (u.stateNode = In(A, qr.current, qi.current, u),
                                        Zs(u)) : u.stateNode = c.stateNode);
                                    else {
                                        if (typeof A != "string" && u.stateNode === null)
                                            throw Error(r(166));
                                        if (c = qr.current,
                                        y = qi.current,
                                        ne(u)) {
                                            if (!ms)
                                                throw Error(r(176));
                                            if (c = u.stateNode,
                                            y = u.memoizedProps,
                                            A = null,
                                            C = gs,
                                            C !== null)
                                                switch (C.tag) {
                                                case 27:
                                                case 5:
                                                    A = C.memoizedProps
                                                }
                                            fg(c, y, u, A) || $e(u)
                                        } else
                                            u.stateNode = In(A, c, y, u)
                                    }
                                    return ci(u),
                                    null;
                                case 13:
                                    if (A = u.memoizedState,
                                    c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
                                        if (C = ne(u),
                                        A !== null && A.dehydrated !== null) {
                                            if (c === null) {
                                                if (!C)
                                                    throw Error(r(318));
                                                if (!ms)
                                                    throw Error(r(344));
                                                if (C = u.memoizedState,
                                                C = C !== null ? C.dehydrated : null,
                                                !C)
                                                    throw Error(r(317));
                                                ey(C, u)
                                            } else
                                                Ve(),
                                                (u.flags & 128) === 0 && (u.memoizedState = null),
                                                u.flags |= 4;
                                            ci(u),
                                            C = !1
                                        } else
                                            Qa !== null && (wh(Qa),
                                            Qa = null),
                                            C = !0;
                                        if (!C)
                                            return u.flags & 256 ? (ga(u),
                                            u) : (ga(u),
                                            null)
                                    }
                                    if (ga(u),
                                    (u.flags & 128) !== 0)
                                        return u.lanes = y,
                                        u;
                                    if (y = A !== null,
                                    c = c !== null && c.memoizedState !== null,
                                    y) {
                                        A = u.child,
                                        C = null,
                                        A.alternate !== null && A.alternate.memoizedState !== null && A.alternate.memoizedState.cachePool !== null && (C = A.alternate.memoizedState.cachePool.pool);
                                        var N = null;
                                        A.memoizedState !== null && A.memoizedState.cachePool !== null && (N = A.memoizedState.cachePool.pool),
                                        N !== C && (A.flags |= 2048)
                                    }
                                    return y !== c && y && (u.child.flags |= 8192),
                                    jc(u, u.updateQueue),
                                    ci(u),
                                    null;
                                case 4:
                                    return Ne(),
                                    xh(c, u),
                                    c === null && Ei(u.stateNode.containerInfo),
                                    ci(u),
                                    null;
                                case 10:
                                    return go(u.type),
                                    ci(u),
                                    null;
                                case 19:
                                    if (D(Yi),
                                    C = u.memoizedState,
                                    C === null)
                                        return ci(u),
                                        null;
                                    if (A = (u.flags & 128) !== 0,
                                    N = C.rendering,
                                    N === null)
                                        if (A)
                                            Qc(C, !1);
                                        else {
                                            if (Yn !== 0 || c !== null && (c.flags & 128) !== 0)
                                                for (c = u.child; c !== null; ) {
                                                    if (N = cr(c),
                                                    N !== null) {
                                                        for (u.flags |= 128,
                                                        Qc(C, !1),
                                                        c = N.updateQueue,
                                                        u.updateQueue = c,
                                                        jc(u, c),
                                                        u.subtreeFlags = 0,
                                                        c = y,
                                                        y = u.child; y !== null; )
                                                            Dh(y, c),
                                                            y = y.sibling;
                                                        return R(Yi, Yi.current & 1 | 2),
                                                        u.child
                                                    }
                                                    c = c.sibling
                                                }
                                            C.tail !== null && ja() > Au && (u.flags |= 128,
                                            A = !0,
                                            Qc(C, !1),
                                            u.lanes = 4194304)
                                        }
                                    else {
                                        if (!A)
                                            if (c = cr(N),
                                            c !== null) {
                                                if (u.flags |= 128,
                                                A = !0,
                                                c = c.updateQueue,
                                                u.updateQueue = c,
                                                jc(u, c),
                                                Qc(C, !0),
                                                C.tail === null && C.tailMode === "hidden" && !N.alternate && !_n)
                                                    return ci(u),
                                                    null
                                            } else
                                                2 * ja() - C.renderingStartTime > Au && y !== 536870912 && (u.flags |= 128,
                                                A = !0,
                                                Qc(C, !1),
                                                u.lanes = 4194304);
                                        C.isBackwards ? (N.sibling = u.child,
                                        u.child = N) : (c = C.last,
                                        c !== null ? c.sibling = N : u.child = N,
                                        C.last = N)
                                    }
                                    return C.tail !== null ? (u = C.tail,
                                    C.rendering = u,
                                    C.tail = u.sibling,
                                    C.renderingStartTime = ja(),
                                    u.sibling = null,
                                    c = Yi.current,
                                    R(Yi, A ? c & 1 | 2 : c & 1),
                                    u) : (ci(u),
                                    null);
                                case 22:
                                case 23:
                                    return ga(u),
                                    Pr(),
                                    A = u.memoizedState !== null,
                                    c !== null ? c.memoizedState !== null !== A && (u.flags |= 8192) : A && (u.flags |= 8192),
                                    A ? (y & 536870912) !== 0 && (u.flags & 128) === 0 && (ci(u),
                                    u.subtreeFlags & 6 && (u.flags |= 8192)) : ci(u),
                                    y = u.updateQueue,
                                    y !== null && jc(u, y.retryQueue),
                                    y = null,
                                    c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (y = c.memoizedState.cachePool.pool),
                                    A = null,
                                    u.memoizedState !== null && u.memoizedState.cachePool !== null && (A = u.memoizedState.cachePool.pool),
                                    A !== y && (u.flags |= 2048),
                                    c !== null && D(Qr),
                                    null;
                                case 24:
                                    return y = null,
                                    c !== null && (y = c.memoizedState.cache),
                                    u.memoizedState.cache !== y && (u.flags |= 2048),
                                    go(Jn),
                                    ci(u),
                                    null;
                                case 25:
                                    return null
                                }
                                throw Error(r(156, u.tag))
                            }
                            function bS(c, u) {
                                switch (xe(u),
                                u.tag) {
                                case 1:
                                    return c = u.flags,
                                    c & 65536 ? (u.flags = c & -65537 | 128,
                                    u) : null;
                                case 3:
                                    return go(Jn),
                                    Ne(),
                                    c = u.flags,
                                    (c & 65536) !== 0 && (c & 128) === 0 ? (u.flags = c & -65537 | 128,
                                    u) : null;
                                case 26:
                                case 27:
                                case 5:
                                    return Ue(u),
                                    null;
                                case 13:
                                    if (ga(u),
                                    c = u.memoizedState,
                                    c !== null && c.dehydrated !== null) {
                                        if (u.alternate === null)
                                            throw Error(r(340));
                                        Ve()
                                    }
                                    return c = u.flags,
                                    c & 65536 ? (u.flags = c & -65537 | 128,
                                    u) : null;
                                case 19:
                                    return D(Yi),
                                    null;
                                case 4:
                                    return Ne(),
                                    null;
                                case 10:
                                    return go(u.type),
                                    null;
                                case 22:
                                case 23:
                                    return ga(u),
                                    Pr(),
                                    c !== null && D(Qr),
                                    c = u.flags,
                                    c & 65536 ? (u.flags = c & -65537 | 128,
                                    u) : null;
                                case 24:
                                    return go(Jn),
                                    null;
                                case 25:
                                    return null;
                                default:
                                    return null
                                }
                            }
                            function S0(c, u) {
                                switch (xe(u),
                                u.tag) {
                                case 3:
                                    go(Jn),
                                    Ne();
                                    break;
                                case 26:
                                case 27:
                                case 5:
                                    Ue(u);
                                    break;
                                case 4:
                                    Ne();
                                    break;
                                case 13:
                                    ga(u);
                                    break;
                                case 19:
                                    D(Yi);
                                    break;
                                case 10:
                                    go(u.type);
                                    break;
                                case 22:
                                case 23:
                                    ga(u),
                                    Pr(),
                                    c !== null && D(Qr);
                                    break;
                                case 24:
                                    go(Jn)
                                }
                            }
                            function Sh(c, u) {
                                try {
                                    var y = u.updateQueue
                                      , A = y !== null ? y.lastEffect : null;
                                    if (A !== null) {
                                        var C = A.next;
                                        y = C;
                                        do {
                                            if ((y.tag & c) === c) {
                                                A = void 0;
                                                var N = y.create
                                                  , W = y.inst;
                                                A = N(),
                                                W.destroy = A
                                            }
                                            y = y.next
                                        } while (y !== C)
                                    }
                                } catch (oe) {
                                    Rn(u, u.return, oe)
                                }
                            }
                            function rl(c, u, y) {
                                try {
                                    var A = u.updateQueue
                                      , C = A !== null ? A.lastEffect : null;
                                    if (C !== null) {
                                        var N = C.next;
                                        A = N;
                                        do {
                                            if ((A.tag & c) === c) {
                                                var W = A.inst
                                                  , oe = W.destroy;
                                                if (oe !== void 0) {
                                                    W.destroy = void 0,
                                                    C = u;
                                                    var ve = y;
                                                    try {
                                                        oe()
                                                    } catch (Xe) {
                                                        Rn(C, ve, Xe)
                                                    }
                                                }
                                            }
                                            A = A.next
                                        } while (A !== N)
                                    }
                                } catch (Xe) {
                                    Rn(u, u.return, Xe)
                                }
                            }
                            function A0(c) {
                                var u = c.updateQueue;
                                if (u !== null) {
                                    var y = c.stateNode;
                                    try {
                                        tt(u, y)
                                    } catch (A) {
                                        Rn(c, c.return, A)
                                    }
                                }
                            }
                            function Ks(c, u, y) {
                                y.props = po(c.type, c.memoizedProps),
                                y.state = c.memoizedState;
                                try {
                                    y.componentWillUnmount()
                                } catch (A) {
                                    Rn(c, u, A)
                                }
                            }
                            function dr(c, u) {
                                try {
                                    var y = c.ref;
                                    if (y !== null) {
                                        var A = c.stateNode;
                                        switch (c.tag) {
                                        case 26:
                                        case 27:
                                        case 5:
                                            var C = ou(A);
                                            break;
                                        default:
                                            C = A
                                        }
                                        typeof y == "function" ? c.refCleanup = y(C) : y.current = C
                                    }
                                } catch (N) {
                                    Rn(c, u, N)
                                }
                            }
                            function Js(c, u) {
                                var y = c.ref
                                  , A = c.refCleanup;
                                if (y !== null)
                                    if (typeof A == "function")
                                        try {
                                            A()
                                        } catch (C) {
                                            Rn(c, u, C)
                                        } finally {
                                            c.refCleanup = null,
                                            c = c.alternate,
                                            c != null && (c.refCleanup = null)
                                        }
                                    else if (typeof y == "function")
                                        try {
                                            y(null)
                                        } catch (C) {
                                            Rn(c, u, C)
                                        }
                                    else
                                        y.current = null
                            }
                            function Om(c) {
                                var u = c.type
                                  , y = c.memoizedProps
                                  , A = c.stateNode;
                                try {
                                    RS(A, u, y, c)
                                } catch (C) {
                                    Rn(c, c.return, C)
                                }
                            }
                            function Nm(c, u, y) {
                                try {
                                    F0(c.stateNode, c.type, y, u, c)
                                } catch (A) {
                                    Rn(c, c.return, A)
                                }
                            }
                            function Um(c) {
                                return c.tag === 5 || c.tag === 3 || (Sa ? c.tag === 26 : !1) || (kn ? c.tag === 27 : !1) || c.tag === 4
                            }
                            function Ah(c) {
                                e: for (; ; ) {
                                    for (; c.sibling === null; ) {
                                        if (c.return === null || Um(c.return))
                                            return null;
                                        c = c.return
                                    }
                                    for (c.sibling.return = c.return,
                                    c = c.sibling; c.tag !== 5 && c.tag !== 6 && (!kn || c.tag !== 27) && c.tag !== 18; ) {
                                        if (c.flags & 2 || c.child === null || c.tag === 4)
                                            continue e;
                                        c.child.return = c,
                                        c = c.child
                                    }
                                    if (!(c.flags & 2))
                                        return c.stateNode
                                }
                            }
                            function Bm(c, u, y) {
                                var A = c.tag;
                                if (A === 5 || A === 6)
                                    c = c.stateNode,
                                    u ? V0(y, c, u) : ig(y, c);
                                else if (!(A === 4 || kn && A === 27) && (c = c.child,
                                c !== null))
                                    for (Bm(c, u, y),
                                    c = c.sibling; c !== null; )
                                        Bm(c, u, y),
                                        c = c.sibling
                            }
                            function vo(c, u, y) {
                                var A = c.tag;
                                if (A === 5 || A === 6)
                                    c = c.stateNode,
                                    u ? H0(y, c, u) : L0(y, c);
                                else if (!(A === 4 || kn && A === 27) && (c = c.child,
                                c !== null))
                                    for (vo(c, u, y),
                                    c = c.sibling; c !== null; )
                                        vo(c, u, y),
                                        c = c.sibling
                            }
                            function ld(c, u, y) {
                                c = c.containerInfo;
                                try {
                                    hu(c, y)
                                } catch (A) {
                                    Rn(u, u.return, A)
                                }
                            }
                            function Th(c, u) {
                                for (Td(c.containerInfo),
                                jt = u; jt !== null; )
                                    if (c = jt,
                                    u = c.child,
                                    (c.subtreeFlags & 1028) !== 0 && u !== null)
                                        u.return = c,
                                        jt = u;
                                    else
                                        for (; jt !== null; ) {
                                            c = jt;
                                            var y = c.alternate;
                                            switch (u = c.flags,
                                            c.tag) {
                                            case 0:
                                                break;
                                            case 11:
                                            case 15:
                                                break;
                                            case 1:
                                                if ((u & 1024) !== 0 && y !== null) {
                                                    u = void 0;
                                                    var A = c
                                                      , C = y.memoizedProps;
                                                    y = y.memoizedState;
                                                    var N = A.stateNode;
                                                    try {
                                                        var W = po(A.type, C, A.elementType === A.type);
                                                        u = N.getSnapshotBeforeUpdate(W, y),
                                                        N.__reactInternalSnapshotBeforeUpdate = u
                                                    } catch (oe) {
                                                        Rn(A, A.return, oe)
                                                    }
                                                }
                                                break;
                                            case 3:
                                                (u & 1024) !== 0 && Xi && Y0(c.stateNode.containerInfo);
                                                break;
                                            case 5:
                                            case 26:
                                            case 27:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            default:
                                                if ((u & 1024) !== 0)
                                                    throw Error(r(163))
                                            }
                                            if (u = c.sibling,
                                            u !== null) {
                                                u.return = c.return,
                                                jt = u;
                                                break
                                            }
                                            jt = c.return
                                        }
                                return W = ln,
                                ln = !1,
                                W
                            }
                            function cd(c, u, y) {
                                var A = y.flags;
                                switch (y.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    _o(c, y),
                                    A & 4 && Sh(5, y);
                                    break;
                                case 1:
                                    if (_o(c, y),
                                    A & 4)
                                        if (c = y.stateNode,
                                        u === null)
                                            try {
                                                c.componentDidMount()
                                            } catch (oe) {
                                                Rn(y, y.return, oe)
                                            }
                                        else {
                                            var C = po(y.type, u.memoizedProps);
                                            u = u.memoizedState;
                                            try {
                                                c.componentDidUpdate(C, u, c.__reactInternalSnapshotBeforeUpdate)
                                            } catch (oe) {
                                                Rn(y, y.return, oe)
                                            }
                                        }
                                    A & 64 && A0(y),
                                    A & 512 && dr(y, y.return);
                                    break;
                                case 3:
                                    if (_o(c, y),
                                    A & 64 && (A = y.updateQueue,
                                    A !== null)) {
                                        if (c = null,
                                        y.child !== null)
                                            switch (y.child.tag) {
                                            case 27:
                                            case 5:
                                                c = ou(y.child.stateNode);
                                                break;
                                            case 1:
                                                c = y.child.stateNode
                                            }
                                        try {
                                            tt(A, c)
                                        } catch (oe) {
                                            Rn(y, y.return, oe)
                                        }
                                    }
                                    break;
                                case 26:
                                    if (Sa) {
                                        _o(c, y),
                                        A & 512 && dr(y, y.return);
                                        break
                                    }
                                case 27:
                                case 5:
                                    _o(c, y),
                                    u === null && A & 4 && Om(y),
                                    A & 512 && dr(y, y.return);
                                    break;
                                case 12:
                                    _o(c, y);
                                    break;
                                case 13:
                                    _o(c, y),
                                    A & 4 && ud(c, y);
                                    break;
                                case 22:
                                    if (C = y.memoizedState !== null || Zr,
                                    !C) {
                                        u = u !== null && u.memoizedState !== null || _i;
                                        var N = Zr
                                          , W = _i;
                                        Zr = C,
                                        (_i = u) && !W ? xo(c, y, (y.subtreeFlags & 8772) !== 0) : _o(c, y),
                                        Zr = N,
                                        _i = W
                                    }
                                    A & 512 && (y.memoizedProps.mode === "manual" ? dr(y, y.return) : Js(y, y.return));
                                    break;
                                default:
                                    _o(c, y)
                                }
                            }
                            function Pm(c) {
                                var u = c.alternate;
                                u !== null && (c.alternate = null,
                                Pm(u)),
                                c.child = null,
                                c.deletions = null,
                                c.sibling = null,
                                c.tag === 5 && (u = c.stateNode,
                                u !== null && CS(u)),
                                c.stateNode = null,
                                c.return = null,
                                c.dependencies = null,
                                c.memoizedProps = null,
                                c.memoizedState = null,
                                c.pendingProps = null,
                                c.stateNode = null,
                                c.updateQueue = null
                            }
                            function fs(c, u, y) {
                                for (y = y.child; y !== null; )
                                    ol(c, u, y),
                                    y = y.sibling
                            }
                            function ol(c, u, y) {
                                if (na && typeof na.onCommitFiberUnmount == "function")
                                    try {
                                        na.onCommitFiberUnmount(Ci, y)
                                    } catch {}
                                switch (y.tag) {
                                case 26:
                                    if (Sa) {
                                        _i || Js(y, u),
                                        fs(c, u, y),
                                        y.memoizedState ? tc(y.memoizedState) : y.stateNode && fu(y.stateNode);
                                        break
                                    }
                                case 27:
                                    if (kn) {
                                        _i || Js(y, u);
                                        var A = Bt
                                          , C = en;
                                        Bt = y.stateNode,
                                        fs(c, u, y),
                                        Sl(y.stateNode),
                                        Bt = A,
                                        en = C;
                                        break
                                    }
                                case 5:
                                    _i || Js(y, u);
                                case 6:
                                    if (Xi) {
                                        if (A = Bt,
                                        C = en,
                                        Bt = null,
                                        fs(c, u, y),
                                        Bt = A,
                                        en = C,
                                        Bt !== null)
                                            if (en)
                                                try {
                                                    G0(Bt, y.stateNode)
                                                } catch (N) {
                                                    Rn(y, u, N)
                                                }
                                            else
                                                try {
                                                    sg(Bt, y.stateNode)
                                                } catch (N) {
                                                    Rn(y, u, N)
                                                }
                                    } else
                                        fs(c, u, y);
                                    break;
                                case 18:
                                    Xi && Bt !== null && (en ? Hh(Bt, y.stateNode) : ny(Bt, y.stateNode));
                                    break;
                                case 4:
                                    Xi ? (A = Bt,
                                    C = en,
                                    Bt = y.stateNode.containerInfo,
                                    en = !0,
                                    fs(c, u, y),
                                    Bt = A,
                                    en = C) : (Wa && ld(y.stateNode, y, Fh()),
                                    fs(c, u, y));
                                    break;
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    _i || rl(2, y, u),
                                    _i || rl(4, y, u),
                                    fs(c, u, y);
                                    break;
                                case 1:
                                    _i || (Js(y, u),
                                    A = y.stateNode,
                                    typeof A.componentWillUnmount == "function" && Ks(y, u, A)),
                                    fs(c, u, y);
                                    break;
                                case 21:
                                    fs(c, u, y);
                                    break;
                                case 22:
                                    _i || Js(y, u),
                                    _i = (A = _i) || y.memoizedState !== null,
                                    fs(c, u, y),
                                    _i = A;
                                    break;
                                default:
                                    fs(c, u, y)
                                }
                            }
                            function ud(c, u) {
                                if (ms && u.memoizedState === null && (c = u.alternate,
                                c !== null && (c = c.memoizedState,
                                c !== null && (c = c.dehydrated,
                                c !== null))))
                                    try {
                                        US(c)
                                    } catch (y) {
                                        Rn(u, u.return, y)
                                    }
                            }
                            function T0(c) {
                                switch (c.tag) {
                                case 13:
                                case 19:
                                    var u = c.stateNode;
                                    return u === null && (u = c.stateNode = new Dn),
                                    u;
                                case 22:
                                    return c = c.stateNode,
                                    u = c._retryCache,
                                    u === null && (u = c._retryCache = new Dn),
                                    u;
                                default:
                                    throw Error(r(435, c.tag))
                                }
                            }
                            function yo(c, u) {
                                var y = T0(c);
                                u.forEach(function(A) {
                                    var C = pl.bind(null, c, A);
                                    y.has(A) || (y.add(A),
                                    A.then(C, C))
                                })
                            }
                            function Is(c, u) {
                                var y = u.deletions;
                                if (y !== null)
                                    for (var A = 0; A < y.length; A++) {
                                        var C = y[A]
                                          , N = c
                                          , W = u;
                                        if (Xi) {
                                            var oe = W;
                                            e: for (; oe !== null; ) {
                                                switch (oe.tag) {
                                                case 27:
                                                case 5:
                                                    Bt = oe.stateNode,
                                                    en = !1;
                                                    break e;
                                                case 3:
                                                    Bt = oe.stateNode.containerInfo,
                                                    en = !0;
                                                    break e;
                                                case 4:
                                                    Bt = oe.stateNode.containerInfo,
                                                    en = !0;
                                                    break e
                                                }
                                                oe = oe.return
                                            }
                                            if (Bt === null)
                                                throw Error(r(160));
                                            ol(N, W, C),
                                            Bt = null,
                                            en = !1
                                        } else
                                            ol(N, W, C);
                                        N = C.alternate,
                                        N !== null && (N.return = null),
                                        C.return = null
                                    }
                                if (u.subtreeFlags & 13878)
                                    for (u = u.child; u !== null; )
                                        Im(u, c),
                                        u = u.sibling
                            }
                            function Im(c, u) {
                                var y = c.alternate
                                  , A = c.flags;
                                switch (c.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Is(u, c),
                                    $s(c),
                                    A & 4 && (rl(3, c, c.return),
                                    Sh(3, c),
                                    rl(5, c, c.return));
                                    break;
                                case 1:
                                    Is(u, c),
                                    $s(c),
                                    A & 512 && (_i || y === null || Js(y, y.return)),
                                    A & 64 && Zr && (c = c.updateQueue,
                                    c !== null && (A = c.callbacks,
                                    A !== null && (y = c.shared.hiddenCallbacks,
                                    c.shared.hiddenCallbacks = y === null ? A : y.concat(A))));
                                    break;
                                case 26:
                                    if (Sa) {
                                        var C = pi;
                                        Is(u, c),
                                        $s(c),
                                        A & 512 && (_i || y === null || Js(y, y.return)),
                                        A & 4 && (A = y !== null ? y.memoizedState : null,
                                        u = c.memoizedState,
                                        y === null ? u === null ? c.stateNode === null ? c.stateNode = Gh(C, c.type, c.memoizedProps, c) : kh(C, c.type, c.stateNode) : c.stateNode = sy(C, u, c.memoizedProps) : A !== u ? (A === null ? y.stateNode !== null && fu(y.stateNode) : tc(A),
                                        u === null ? kh(C, c.type, c.stateNode) : sy(C, u, c.memoizedProps)) : u === null && c.stateNode !== null && Nm(c, c.memoizedProps, y.memoizedProps));
                                        break
                                    }
                                case 27:
                                    if (kn && A & 4 && c.alternate === null) {
                                        C = c.stateNode;
                                        var N = c.memoizedProps;
                                        try {
                                            xl(C),
                                            ly(c.type, N, C, c)
                                        } catch (it) {
                                            Rn(c, c.return, it)
                                        }
                                    }
                                case 5:
                                    if (Is(u, c),
                                    $s(c),
                                    A & 512 && (_i || y === null || Js(y, y.return)),
                                    Xi) {
                                        if (c.flags & 32) {
                                            u = c.stateNode;
                                            try {
                                                ag(u)
                                            } catch (it) {
                                                Rn(c, c.return, it)
                                            }
                                        }
                                        A & 4 && c.stateNode != null && (u = c.memoizedProps,
                                        Nm(c, u, y !== null ? y.memoizedProps : u)),
                                        A & 1024 && (yg = !0)
                                    }
                                    break;
                                case 6:
                                    if (Is(u, c),
                                    $s(c),
                                    A & 4 && Xi) {
                                        if (c.stateNode === null)
                                            throw Error(r(162));
                                        A = c.memoizedProps,
                                        y = y !== null ? y.memoizedProps : A,
                                        u = c.stateNode;
                                        try {
                                            z0(u, y, A)
                                        } catch (it) {
                                            Rn(c, c.return, it)
                                        }
                                    }
                                    break;
                                case 3:
                                    if (Sa ? (ay(),
                                    C = pi,
                                    pi = Ud(u.containerInfo),
                                    Is(u, c),
                                    pi = C) : Is(u, c),
                                    $s(c),
                                    A & 4) {
                                        if (Xi && ms && y !== null && y.memoizedState.isDehydrated)
                                            try {
                                                NS(u.containerInfo)
                                            } catch (it) {
                                                Rn(c, c.return, it)
                                            }
                                        if (Wa) {
                                            A = u.containerInfo,
                                            y = u.pendingChildren;
                                            try {
                                                hu(A, y)
                                            } catch (it) {
                                                Rn(c, c.return, it)
                                            }
                                        }
                                    }
                                    yg && (yg = !1,
                                    M0(c));
                                    break;
                                case 4:
                                    Sa ? (y = pi,
                                    pi = Ud(c.stateNode.containerInfo),
                                    Is(u, c),
                                    $s(c),
                                    pi = y) : (Is(u, c),
                                    $s(c)),
                                    A & 4 && Wa && ld(c.stateNode, c, c.stateNode.pendingChildren);
                                    break;
                                case 12:
                                    Is(u, c),
                                    $s(c);
                                    break;
                                case 13:
                                    Is(u, c),
                                    $s(c),
                                    c.child.flags & 8192 && c.memoizedState !== null != (y !== null && y.memoizedState !== null) && (Gs = ja()),
                                    A & 4 && (A = c.updateQueue,
                                    A !== null && (c.updateQueue = null,
                                    yo(c, A)));
                                    break;
                                case 22:
                                    A & 512 && (_i || y === null || Js(y, y.return)),
                                    C = c.memoizedState !== null;
                                    var W = y !== null && y.memoizedState !== null
                                      , oe = Zr
                                      , ve = _i;
                                    if (Zr = oe || C,
                                    _i = ve || W,
                                    Is(u, c),
                                    _i = ve,
                                    Zr = oe,
                                    $s(c),
                                    u = c.stateNode,
                                    u._current = c,
                                    u._visibility &= -3,
                                    u._visibility |= u._pendingVisibility & 2,
                                    A & 8192 && (u._visibility = C ? u._visibility & -2 : u._visibility | 1,
                                    C && (u = Zr || _i,
                                    y === null || W || u || Zc(c)),
                                    Xi && (c.memoizedProps === null || c.memoizedProps.mode !== "manual"))) {
                                        e: if (y = null,
                                        Xi)
                                            for (u = c; ; ) {
                                                if (u.tag === 5 || Sa && u.tag === 26 || kn && u.tag === 27) {
                                                    if (y === null) {
                                                        W = y = u;
                                                        try {
                                                            N = W.stateNode,
                                                            C ? k0(N) : q0(W.stateNode, W.memoizedProps)
                                                        } catch (it) {
                                                            Rn(W, W.return, it)
                                                        }
                                                    }
                                                } else if (u.tag === 6) {
                                                    if (y === null) {
                                                        W = u;
                                                        try {
                                                            var Xe = W.stateNode;
                                                            C ? X0(Xe) : DS(Xe, W.memoizedProps)
                                                        } catch (it) {
                                                            Rn(W, W.return, it)
                                                        }
                                                    }
                                                } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === c) && u.child !== null) {
                                                    u.child.return = u,
                                                    u = u.child;
                                                    continue
                                                }
                                                if (u === c)
                                                    break e;
                                                for (; u.sibling === null; ) {
                                                    if (u.return === null || u.return === c)
                                                        break e;
                                                    y === u && (y = null),
                                                    u = u.return
                                                }
                                                y === u && (y = null),
                                                u.sibling.return = u.return,
                                                u = u.sibling
                                            }
                                    }
                                    A & 4 && (A = c.updateQueue,
                                    A !== null && (y = A.retryQueue,
                                    y !== null && (A.retryQueue = null,
                                    yo(c, y))));
                                    break;
                                case 19:
                                    Is(u, c),
                                    $s(c),
                                    A & 4 && (A = c.updateQueue,
                                    A !== null && (c.updateQueue = null,
                                    yo(c, A)));
                                    break;
                                case 21:
                                    break;
                                default:
                                    Is(u, c),
                                    $s(c)
                                }
                            }
                            function $s(c) {
                                var u = c.flags;
                                if (u & 2) {
                                    try {
                                        if (Xi && (!kn || c.tag !== 27)) {
                                            e: {
                                                for (var y = c.return; y !== null; ) {
                                                    if (Um(y)) {
                                                        var A = y;
                                                        break e
                                                    }
                                                    y = y.return
                                                }
                                                throw Error(r(160))
                                            }
                                            switch (A.tag) {
                                            case 27:
                                                if (kn) {
                                                    var C = A.stateNode
                                                      , N = Ah(c);
                                                    vo(c, N, C);
                                                    break
                                                }
                                            case 5:
                                                var W = A.stateNode;
                                                A.flags & 32 && (ag(W),
                                                A.flags &= -33);
                                                var oe = Ah(c);
                                                vo(c, oe, W);
                                                break;
                                            case 3:
                                            case 4:
                                                var ve = A.stateNode.containerInfo
                                                  , Xe = Ah(c);
                                                Bm(c, Xe, ve);
                                                break;
                                            default:
                                                throw Error(r(161))
                                            }
                                        }
                                    } catch (it) {
                                        Rn(c, c.return, it)
                                    }
                                    c.flags &= -3
                                }
                                u & 4096 && (c.flags &= -4097)
                            }
                            function M0(c) {
                                if (c.subtreeFlags & 1024)
                                    for (c = c.child; c !== null; ) {
                                        var u = c;
                                        M0(u),
                                        u.tag === 5 && u.flags & 1024 && Ed(u.stateNode),
                                        c = c.sibling
                                    }
                            }
                            function _o(c, u) {
                                if (u.subtreeFlags & 8772)
                                    for (u = u.child; u !== null; )
                                        cd(c, u.alternate, u),
                                        u = u.sibling
                            }
                            function Zc(c) {
                                for (c = c.child; c !== null; ) {
                                    var u = c;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        rl(4, u, u.return),
                                        Zc(u);
                                        break;
                                    case 1:
                                        Js(u, u.return);
                                        var y = u.stateNode;
                                        typeof y.componentWillUnmount == "function" && Ks(u, u.return, y),
                                        Zc(u);
                                        break;
                                    case 26:
                                    case 27:
                                    case 5:
                                        Js(u, u.return),
                                        Zc(u);
                                        break;
                                    case 22:
                                        Js(u, u.return),
                                        u.memoizedState === null && Zc(u);
                                        break;
                                    default:
                                        Zc(u)
                                    }
                                    c = c.sibling
                                }
                            }
                            function xo(c, u, y) {
                                for (y = y && (u.subtreeFlags & 8772) !== 0,
                                u = u.child; u !== null; ) {
                                    var A = u.alternate
                                      , C = c
                                      , N = u
                                      , W = N.flags;
                                    switch (N.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        xo(C, N, y),
                                        Sh(4, N);
                                        break;
                                    case 1:
                                        if (xo(C, N, y),
                                        A = N,
                                        C = A.stateNode,
                                        typeof C.componentDidMount == "function")
                                            try {
                                                C.componentDidMount()
                                            } catch (Xe) {
                                                Rn(A, A.return, Xe)
                                            }
                                        if (A = N,
                                        C = A.updateQueue,
                                        C !== null) {
                                            var oe = A.stateNode;
                                            try {
                                                var ve = C.shared.hiddenCallbacks;
                                                if (ve !== null)
                                                    for (C.shared.hiddenCallbacks = null,
                                                    C = 0; C < ve.length; C++)
                                                        ot(ve[C], oe)
                                            } catch (Xe) {
                                                Rn(A, A.return, Xe)
                                            }
                                        }
                                        y && W & 64 && A0(N),
                                        dr(N, N.return);
                                        break;
                                    case 26:
                                    case 27:
                                    case 5:
                                        xo(C, N, y),
                                        y && A === null && W & 4 && Om(N),
                                        dr(N, N.return);
                                        break;
                                    case 12:
                                        xo(C, N, y);
                                        break;
                                    case 13:
                                        xo(C, N, y),
                                        y && W & 4 && ud(C, N);
                                        break;
                                    case 22:
                                        N.memoizedState === null && xo(C, N, y),
                                        dr(N, N.return);
                                        break;
                                    default:
                                        xo(C, N, y)
                                    }
                                    u = u.sibling
                                }
                            }
                            function hd(c, u) {
                                var y = null;
                                c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (y = c.memoizedState.cachePool.pool),
                                c = null,
                                u.memoizedState !== null && u.memoizedState.cachePool !== null && (c = u.memoizedState.cachePool.pool),
                                c !== y && (c != null && c.refCount++,
                                y != null && _h(y))
                            }
                            function Mh(c, u) {
                                c = null,
                                u.alternate !== null && (c = u.alternate.memoizedState.cache),
                                u = u.memoizedState.cache,
                                u !== c && (u.refCount++,
                                c != null && _h(c))
                            }
                            function $i(c, u, y, A) {
                                if (u.subtreeFlags & 10256)
                                    for (u = u.child; u !== null; )
                                        Lm(c, u, y, A),
                                        u = u.sibling
                            }
                            function Lm(c, u, y, A) {
                                var C = u.flags;
                                switch (u.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    $i(c, u, y, A),
                                    C & 2048 && Sh(9, u);
                                    break;
                                case 3:
                                    $i(c, u, y, A),
                                    C & 2048 && (c = null,
                                    u.alternate !== null && (c = u.alternate.memoizedState.cache),
                                    u = u.memoizedState.cache,
                                    u !== c && (u.refCount++,
                                    c != null && _h(c)));
                                    break;
                                case 12:
                                    if (C & 2048) {
                                        $i(c, u, y, A),
                                        c = u.stateNode;
                                        try {
                                            var N = u.memoizedProps
                                              , W = N.id
                                              , oe = N.onPostCommit;
                                            typeof oe == "function" && oe(W, u.alternate === null ? "mount" : "update", c.passiveEffectDuration, -0)
                                        } catch (ve) {
                                            Rn(u, u.return, ve)
                                        }
                                    } else
                                        $i(c, u, y, A);
                                    break;
                                case 23:
                                    break;
                                case 22:
                                    N = u.stateNode,
                                    u.memoizedState !== null ? N._visibility & 4 ? $i(c, u, y, A) : Es(c, u) : N._visibility & 4 ? $i(c, u, y, A) : (N._visibility |= 4,
                                    ds(c, u, y, A, (u.subtreeFlags & 10256) !== 0)),
                                    C & 2048 && hd(u.alternate, u);
                                    break;
                                case 24:
                                    $i(c, u, y, A),
                                    C & 2048 && Mh(u.alternate, u);
                                    break;
                                default:
                                    $i(c, u, y, A)
                                }
                            }
                            function ds(c, u, y, A, C) {
                                for (C = C && (u.subtreeFlags & 10256) !== 0,
                                u = u.child; u !== null; ) {
                                    var N = c
                                      , W = u
                                      , oe = y
                                      , ve = A
                                      , Xe = W.flags;
                                    switch (W.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ds(N, W, oe, ve, C),
                                        Sh(8, W);
                                        break;
                                    case 23:
                                        break;
                                    case 22:
                                        var it = W.stateNode;
                                        W.memoizedState !== null ? it._visibility & 4 ? ds(N, W, oe, ve, C) : Es(N, W) : (it._visibility |= 4,
                                        ds(N, W, oe, ve, C)),
                                        C && Xe & 2048 && hd(W.alternate, W);
                                        break;
                                    case 24:
                                        ds(N, W, oe, ve, C),
                                        C && Xe & 2048 && Mh(W.alternate, W);
                                        break;
                                    default:
                                        ds(N, W, oe, ve, C)
                                    }
                                    u = u.sibling
                                }
                            }
                            function Es(c, u) {
                                if (u.subtreeFlags & 10256)
                                    for (u = u.child; u !== null; ) {
                                        var y = c
                                          , A = u
                                          , C = A.flags;
                                        switch (A.tag) {
                                        case 22:
                                            Es(y, A),
                                            C & 2048 && hd(A.alternate, A);
                                            break;
                                        case 24:
                                            Es(y, A),
                                            C & 2048 && Mh(A.alternate, A);
                                            break;
                                        default:
                                            Es(y, A)
                                        }
                                        u = u.sibling
                                    }
                            }
                            function Ga(c) {
                                if (c.subtreeFlags & Ca)
                                    for (c = c.child; c !== null; )
                                        fd(c),
                                        c = c.sibling
                            }
                            function fd(c) {
                                switch (c.tag) {
                                case 26:
                                    Ga(c),
                                    c.flags & Ca && (c.memoizedState !== null ? oy(pi, c.memoizedState, c.memoizedProps) : Fs(c.type, c.memoizedProps));
                                    break;
                                case 5:
                                    Ga(c),
                                    c.flags & Ca && Fs(c.type, c.memoizedProps);
                                    break;
                                case 3:
                                case 4:
                                    if (Sa) {
                                        var u = pi;
                                        pi = Ud(c.stateNode.containerInfo),
                                        Ga(c),
                                        pi = u
                                    } else
                                        Ga(c);
                                    break;
                                case 22:
                                    c.memoizedState === null && (u = c.alternate,
                                    u !== null && u.memoizedState !== null ? (u = Ca,
                                    Ca = 16777216,
                                    Ga(c),
                                    Ca = u) : Ga(c));
                                    break;
                                default:
                                    Ga(c)
                                }
                            }
                            function bh(c) {
                                var u = c.alternate;
                                if (u !== null && (c = u.child,
                                c !== null)) {
                                    u.child = null;
                                    do
                                        u = c.sibling,
                                        c.sibling = null,
                                        c = u;
                                    while (c !== null)
                                }
                            }
                            function ll(c) {
                                var u = c.deletions;
                                if ((c.flags & 16) !== 0) {
                                    if (u !== null)
                                        for (var y = 0; y < u.length; y++) {
                                            var A = u[y];
                                            jt = A,
                                            zm(A, c)
                                        }
                                    bh(c)
                                }
                                if (c.subtreeFlags & 10256)
                                    for (c = c.child; c !== null; )
                                        dd(c),
                                        c = c.sibling
                            }
                            function dd(c) {
                                switch (c.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ll(c),
                                    c.flags & 2048 && rl(9, c, c.return);
                                    break;
                                case 3:
                                    ll(c);
                                    break;
                                case 12:
                                    ll(c);
                                    break;
                                case 22:
                                    var u = c.stateNode;
                                    c.memoizedState !== null && u._visibility & 4 && (c.return === null || c.return.tag !== 13) ? (u._visibility &= -5,
                                    So(c)) : ll(c);
                                    break;
                                default:
                                    ll(c)
                                }
                            }
                            function So(c) {
                                var u = c.deletions;
                                if ((c.flags & 16) !== 0) {
                                    if (u !== null)
                                        for (var y = 0; y < u.length; y++) {
                                            var A = u[y];
                                            jt = A,
                                            zm(A, c)
                                        }
                                    bh(c)
                                }
                                for (c = c.child; c !== null; ) {
                                    switch (u = c,
                                    u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        rl(8, u, u.return),
                                        So(u);
                                        break;
                                    case 22:
                                        y = u.stateNode,
                                        y._visibility & 4 && (y._visibility &= -5,
                                        So(u));
                                        break;
                                    default:
                                        So(u)
                                    }
                                    c = c.sibling
                                }
                            }
                            function zm(c, u) {
                                for (; jt !== null; ) {
                                    var y = jt;
                                    switch (y.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        rl(8, y, u);
                                        break;
                                    case 23:
                                    case 22:
                                        if (y.memoizedState !== null && y.memoizedState.cachePool !== null) {
                                            var A = y.memoizedState.cachePool.pool;
                                            A != null && A.refCount++
                                        }
                                        break;
                                    case 24:
                                        _h(y.memoizedState.cache)
                                    }
                                    if (A = y.child,
                                    A !== null)
                                        A.return = y,
                                        jt = A;
                                    else
                                        e: for (y = c; jt !== null; ) {
                                            A = jt;
                                            var C = A.sibling
                                              , N = A.return;
                                            if (Pm(A),
                                            A === y) {
                                                jt = null;
                                                break e
                                            }
                                            if (C !== null) {
                                                C.return = N,
                                                jt = C;
                                                break e
                                            }
                                            jt = N
                                        }
                                }
                            }
                            function Kc(c) {
                                var u = D0(c);
                                if (u != null) {
                                    if (typeof u.memoizedProps["data-testname"] != "string")
                                        throw Error(r(364));
                                    return u
                                }
                                if (c = tg(c),
                                c === null)
                                    throw Error(r(362));
                                return c.stateNode.current
                            }
                            function cl(c, u) {
                                var y = c.tag;
                                switch (u.$$typeof) {
                                case Su:
                                    if (c.type === u.value)
                                        return !0;
                                    break;
                                case Ja:
                                    e: {
                                        for (u = u.value,
                                        c = [c, 0],
                                        y = 0; y < c.length; ) {
                                            var A = c[y++]
                                              , C = A.tag
                                              , N = c[y++]
                                              , W = u[N];
                                            if (C !== 5 && C !== 26 && C !== 27 || !cu(A)) {
                                                for (; W != null && cl(A, W); )
                                                    N++,
                                                    W = u[N];
                                                if (N === u.length) {
                                                    u = !0;
                                                    break e
                                                } else
                                                    for (A = A.child; A !== null; )
                                                        c.push(A, N),
                                                        A = A.sibling
                                            }
                                        }
                                        u = !1
                                    }
                                    return u;
                                case ai:
                                    if ((y === 5 || y === 26 || y === 27) && B0(c.stateNode, u.value))
                                        return !0;
                                    break;
                                case Kr:
                                    if ((y === 5 || y === 6 || y === 26 || y === 27) && (c = U0(c),
                                    c !== null && 0 <= c.indexOf(u.value)))
                                        return !0;
                                    break;
                                case Tr:
                                    if ((y === 5 || y === 26 || y === 27) && (c = c.memoizedProps["data-testname"],
                                    typeof c == "string" && c.toLowerCase() === u.value.toLowerCase()))
                                        return !0;
                                    break;
                                default:
                                    throw Error(r(365))
                                }
                                return !1
                            }
                            function Fm(c) {
                                switch (c.$$typeof) {
                                case Su:
                                    return "<" + (h(c.value) || "Unknown") + ">";
                                case Ja:
                                    return ":has(" + (Fm(c) || "") + ")";
                                case ai:
                                    return '[role="' + c.value + '"]';
                                case Kr:
                                    return '"' + c.value + '"';
                                case Tr:
                                    return '[data-testname="' + c.value + '"]';
                                default:
                                    throw Error(r(365))
                                }
                            }
                            function ea(c, u) {
                                var y = [];
                                c = [c, 0];
                                for (var A = 0; A < c.length; ) {
                                    var C = c[A++]
                                      , N = C.tag
                                      , W = c[A++]
                                      , oe = u[W];
                                    if (N !== 5 && N !== 26 && N !== 27 || !cu(C)) {
                                        for (; oe != null && cl(C, oe); )
                                            W++,
                                            oe = u[W];
                                        if (W === u.length)
                                            y.push(C);
                                        else
                                            for (C = C.child; C !== null; )
                                                c.push(C, W),
                                                C = C.sibling
                                    }
                                }
                                return y
                            }
                            function Eh(c, u) {
                                if (!_l)
                                    throw Error(r(363));
                                c = Kc(c),
                                c = ea(c, u),
                                u = [],
                                c = Array.from(c);
                                for (var y = 0; y < c.length; ) {
                                    var A = c[y++]
                                      , C = A.tag;
                                    if (C === 5 || C === 26 || C === 27)
                                        cu(A) || u.push(A.stateNode);
                                    else
                                        for (A = A.child; A !== null; )
                                            c.push(A),
                                            A = A.sibling
                                }
                                return u
                            }
                            function bi() {
                                if ((Sn & 2) !== 0 && pn !== 0)
                                    return pn & -pn;
                                if (Vt.T !== null) {
                                    var c = Ma;
                                    return c !== 0 ? c : Be()
                                }
                                return O0()
                            }
                            function Hm() {
                                Oa === 0 && (Oa = (pn & 536870912) === 0 || _n ? P() : 536870912);
                                var c = ba.current;
                                return c !== null && (c.flags |= 32),
                                Oa
                            }
                            function es(c, u, y) {
                                (c === On && zn === 2 || c.cancelPendingCommit !== null) && (ps(c, 0),
                                ta(c, pn, Oa, !1)),
                                Z(c, y),
                                ((Sn & 2) === 0 || c !== On) && (c === On && ((Sn & 2) === 0 && (Po |= y),
                                Yn === 4 && ta(c, pn, Oa, !1)),
                                yt(c))
                            }
                            function ul(c, u, y) {
                                if ((Sn & 6) !== 0)
                                    throw Error(r(327));
                                var A = !y && (u & 60) === 0 && (u & c.expiredLanes) === 0 || I(c, u)
                                  , C = A ? Gm(c, u) : md(c, u, !0)
                                  , N = A;
                                do {
                                    if (C === 0) {
                                        Ra && !A && ta(c, u, 0, !1);
                                        break
                                    } else if (C === 6)
                                        ta(c, u, 0, !er);
                                    else {
                                        if (y = c.current.alternate,
                                        N && !Jc(y)) {
                                            C = md(c, u, !1),
                                            N = !1;
                                            continue
                                        }
                                        if (C === 2) {
                                            if (N = u,
                                            c.errorRecoveryDisabledLanes & N)
                                                var W = 0;
                                            else
                                                W = c.pendingLanes & -536870913,
                                                W = W !== 0 ? W : W & 536870912 ? 536870912 : 0;
                                            if (W !== 0) {
                                                u = W;
                                                e: {
                                                    var oe = c;
                                                    C = gc;
                                                    var ve = ms && oe.current.memoizedState.isDehydrated;
                                                    if (ve && (ps(oe, W).flags |= 256),
                                                    W = md(oe, W, !1),
                                                    W !== 2) {
                                                        if (Wi && !ve) {
                                                            oe.errorRecoveryDisabledLanes |= N,
                                                            Po |= N,
                                                            C = 4;
                                                            break e
                                                        }
                                                        N = Ri,
                                                        Ri = C,
                                                        N !== null && wh(N)
                                                    }
                                                    C = W
                                                }
                                                if (N = !1,
                                                C !== 2)
                                                    continue
                                            }
                                        }
                                        if (C === 1) {
                                            ps(c, 0),
                                            ta(c, u, 0, !0);
                                            break
                                        }
                                        e: {
                                            switch (A = c,
                                            C) {
                                            case 0:
                                            case 1:
                                                throw Error(r(345));
                                            case 4:
                                                if ((u & 4194176) === u) {
                                                    ta(A, u, Oa, !er);
                                                    break e
                                                }
                                                break;
                                            case 2:
                                                Ri = null;
                                                break;
                                            case 3:
                                            case 5:
                                                break;
                                            default:
                                                throw Error(r(329))
                                            }
                                            if (A.finishedWork = y,
                                            A.finishedLanes = u,
                                            (u & 62914560) === u && (N = Gs + 300 - ja(),
                                            10 < N)) {
                                                if (ta(A, u, Oa, !er),
                                                B(A, 0) !== 0)
                                                    break e;
                                                A.timeoutHandle = Ii(pd.bind(null, A, y, Ri, Qh, Xd, u, Oa, Po, Jr, er, 2, -0, 0), N);
                                                break e
                                            }
                                            pd(A, y, Ri, Qh, Xd, u, Oa, Po, Jr, er, 0, -0, 0)
                                        }
                                    }
                                    break
                                } while (!0);
                                yt(c)
                            }
                            function wh(c) {
                                Ri === null ? Ri = c : Ri.push.apply(Ri, c)
                            }
                            function pd(c, u, y, A, C, N, W, oe, ve, Xe, it, dt, mt) {
                                var Qt = u.subtreeFlags;
                                if ((Qt & 8192 || (Qt & 16785408) === 16785408) && ($m(),
                                fd(u),
                                u = Li(),
                                u !== null)) {
                                    c.cancelPendingCommit = u(fl.bind(null, c, y, A, C, W, oe, ve, 1, dt, mt)),
                                    ta(c, N, W, !Xe);
                                    return
                                }
                                fl(c, y, A, C, W, oe, ve, it, dt, mt)
                            }
                            function Jc(c) {
                                for (var u = c; ; ) {
                                    var y = u.tag;
                                    if ((y === 0 || y === 11 || y === 15) && u.flags & 16384 && (y = u.updateQueue,
                                    y !== null && (y = y.stores,
                                    y !== null)))
                                        for (var A = 0; A < y.length; A++) {
                                            var C = y[A]
                                              , N = C.getSnapshot;
                                            C = C.value;
                                            try {
                                                if (!ia(N(), C))
                                                    return !1
                                            } catch {
                                                return !1
                                            }
                                        }
                                    if (y = u.child,
                                    u.subtreeFlags & 16384 && y !== null)
                                        y.return = u,
                                        u = y;
                                    else {
                                        if (u === c)
                                            break;
                                        for (; u.sibling === null; ) {
                                            if (u.return === null || u.return === c)
                                                return !0;
                                            u = u.return
                                        }
                                        u.sibling.return = u.return,
                                        u = u.sibling
                                    }
                                }
                                return !0
                            }
                            function ta(c, u, y, A) {
                                u &= ~jh,
                                u &= ~Po,
                                c.suspendedLanes |= u,
                                c.pingedLanes &= ~u,
                                A && (c.warmLanes |= u),
                                A = c.expirationTimes;
                                for (var C = u; 0 < C; ) {
                                    var N = 31 - Hs(C)
                                      , W = 1 << N;
                                    A[N] = -1,
                                    C &= ~W
                                }
                                y !== 0 && te(c, y, u)
                            }
                            function Ch() {
                                return (Sn & 6) === 0 ? (wt(0, !1),
                                !1) : !0
                            }
                            function $c() {
                                if (Lt !== null) {
                                    if (zn === 0)
                                        var c = Lt.return;
                                    else
                                        c = Lt,
                                        wa = Ar = null,
                                        Ee(c),
                                        bl = null,
                                        El = 0,
                                        c = Lt;
                                    for (; c !== null; )
                                        S0(c.alternate, c),
                                        c = c.return;
                                    Lt = null
                                }
                            }
                            function ps(c, u) {
                                c.finishedWork = null,
                                c.finishedLanes = 0;
                                var y = c.timeoutHandle;
                                y !== vl && (c.timeoutHandle = vl,
                                Md(y)),
                                y = c.cancelPendingCommit,
                                y !== null && (c.cancelPendingCommit = null,
                                y()),
                                $c(),
                                On = c,
                                Lt = y = Xa(c.current, null),
                                pn = u,
                                zn = 0,
                                Cs = null,
                                er = !1,
                                Ra = I(c, u),
                                Wi = !1,
                                Jr = Oa = jh = Po = Da = Yn = 0,
                                Ri = gc = null,
                                Xd = !1,
                                (u & 8) !== 0 && (u |= u & 32);
                                var A = c.entangledLanes;
                                if (A !== 0)
                                    for (c = c.entanglements,
                                    A &= u; 0 < A; ) {
                                        var C = 31 - Hs(A)
                                          , N = 1 << C;
                                        u |= c[C],
                                        A &= ~N
                                    }
                                return Rs = u,
                                Te(),
                                y
                            }
                            function ya(c, u) {
                                nn = null,
                                Vt.H = yi,
                                u === vu ? (u = Mt(),
                                zn = 3) : u === Yh ? (u = Mt(),
                                zn = 4) : zn = u === Gd ? 8 : u !== null && typeof u == "object" && typeof u.then == "function" ? 6 : 1,
                                Cs = u,
                                Lt === null && (Yn = 1,
                                Xc(c, se(u, c.current)))
                            }
                            function hl() {
                                var c = ba.current;
                                return c === null ? !0 : (pn & 4194176) === pn ? Xn === null : (pn & 62914560) === pn || (pn & 536870912) !== 0 ? c === Xn : !1
                            }
                            function Hr() {
                                var c = Vt.H;
                                return Vt.H = yi,
                                c === null ? yi : c
                            }
                            function Vr() {
                                var c = Vt.A;
                                return Vt.A = xu,
                                c
                            }
                            function Ao() {
                                Yn = 4,
                                er || (pn & 4194176) !== pn && ba.current !== null || (Ra = !0),
                                (Da & 134217727) === 0 && (Po & 134217727) === 0 || On === null || ta(On, pn, Oa, !1)
                            }
                            function md(c, u, y) {
                                var A = Sn;
                                Sn |= 2;
                                var C = Hr()
                                  , N = Vr();
                                (On !== c || pn !== u) && (Qh = null,
                                ps(c, u)),
                                u = !1;
                                var W = Yn;
                                e: do
                                    try {
                                        if (zn !== 0 && Lt !== null) {
                                            var oe = Lt
                                              , ve = Cs;
                                            switch (zn) {
                                            case 8:
                                                $c(),
                                                W = 6;
                                                break e;
                                            case 3:
                                            case 2:
                                            case 6:
                                                ba.current === null && (u = !0);
                                                var Xe = zn;
                                                if (zn = 0,
                                                Cs = null,
                                                ka(c, oe, ve, Xe),
                                                y && Ra) {
                                                    W = 0;
                                                    break e
                                                }
                                                break;
                                            default:
                                                Xe = zn,
                                                zn = 0,
                                                Cs = null,
                                                ka(c, oe, ve, Xe)
                                            }
                                        }
                                        Vm(),
                                        W = Yn;
                                        break
                                    } catch (it) {
                                        ya(c, it)
                                    }
                                while (!0);
                                return u && c.shellSuspendCounter++,
                                wa = Ar = null,
                                Sn = A,
                                Vt.H = C,
                                Vt.A = N,
                                Lt === null && (On = null,
                                pn = 0,
                                Te()),
                                W
                            }
                            function Vm() {
                                for (; Lt !== null; )
                                    di(Lt)
                            }
                            function Gm(c, u) {
                                var y = Sn;
                                Sn |= 2;
                                var A = Hr()
                                  , C = Vr();
                                On !== c || pn !== u ? (Qh = null,
                                Au = ja() + 500,
                                ps(c, u)) : Ra = I(c, u);
                                e: do
                                    try {
                                        if (zn !== 0 && Lt !== null) {
                                            u = Lt;
                                            var N = Cs;
                                            t: switch (zn) {
                                            case 1:
                                                zn = 0,
                                                Cs = null,
                                                ka(c, u, N, 1);
                                                break;
                                            case 2:
                                                if (Je(N)) {
                                                    zn = 0,
                                                    Cs = null,
                                                    bn(u);
                                                    break
                                                }
                                                u = function() {
                                                    zn === 2 && On === c && (zn = 7),
                                                    yt(c)
                                                }
                                                ,
                                                N.then(u, u);
                                                break e;
                                            case 3:
                                                zn = 7;
                                                break e;
                                            case 4:
                                                zn = 5;
                                                break e;
                                            case 7:
                                                Je(N) ? (zn = 0,
                                                Cs = null,
                                                bn(u)) : (zn = 0,
                                                Cs = null,
                                                ka(c, u, N, 7));
                                                break;
                                            case 5:
                                                var W = null;
                                                switch (Lt.tag) {
                                                case 26:
                                                    W = Lt.memoizedState;
                                                case 5:
                                                case 27:
                                                    var oe = Lt
                                                      , ve = oe.type
                                                      , Xe = oe.pendingProps;
                                                    if (W ? nc(W) : bd(ve, Xe)) {
                                                        zn = 0,
                                                        Cs = null;
                                                        var it = oe.sibling;
                                                        if (it !== null)
                                                            Lt = it;
                                                        else {
                                                            var dt = oe.return;
                                                            dt !== null ? (Lt = dt,
                                                            _a(dt)) : Lt = null
                                                        }
                                                        break t
                                                    }
                                                }
                                                zn = 0,
                                                Cs = null,
                                                ka(c, u, N, 5);
                                                break;
                                            case 6:
                                                zn = 0,
                                                Cs = null,
                                                ka(c, u, N, 6);
                                                break;
                                            case 8:
                                                $c(),
                                                Yn = 6;
                                                break e;
                                            default:
                                                throw Error(r(462))
                                            }
                                        }
                                        Ls();
                                        break
                                    } catch (mt) {
                                        ya(c, mt)
                                    }
                                while (!0);
                                return wa = Ar = null,
                                Vt.H = A,
                                Vt.A = C,
                                Sn = y,
                                Lt !== null ? 0 : (On = null,
                                pn = 0,
                                Te(),
                                Yn)
                            }
                            function Ls() {
                                for (; Lt !== null && !BS(); )
                                    di(Lt)
                            }
                            function di(c) {
                                var u = y0(c.alternate, c, Rs);
                                c.memoizedProps = c.pendingProps,
                                u === null ? _a(c) : Lt = u
                            }
                            function bn(c) {
                                var u = c
                                  , y = u.alternate;
                                switch (u.tag) {
                                case 15:
                                case 0:
                                    u = f0(y, u, u.pendingProps, u.type, void 0, pn);
                                    break;
                                case 11:
                                    u = f0(y, u, u.pendingProps, u.type.render, u.ref, pn);
                                    break;
                                case 5:
                                    Ee(u);
                                default:
                                    S0(y, u),
                                    u = Lt = Dh(u, Rs),
                                    u = y0(y, u, Rs)
                                }
                                c.memoizedProps = c.pendingProps,
                                u === null ? _a(c) : Lt = u
                            }
                            function ka(c, u, y, A) {
                                wa = Ar = null,
                                Ee(u),
                                bl = null,
                                El = 0;
                                var C = u.return;
                                try {
                                    if (TS(c, C, u, y, pn)) {
                                        Yn = 1,
                                        Xc(c, se(y, c.current)),
                                        Lt = null;
                                        return
                                    }
                                } catch (N) {
                                    if (C !== null)
                                        throw Lt = C,
                                        N;
                                    Yn = 1,
                                    Xc(c, se(y, c.current)),
                                    Lt = null;
                                    return
                                }
                                u.flags & 32768 ? (_n || A === 1 ? c = !0 : Ra || (pn & 536870912) !== 0 ? c = !1 : (er = c = !0,
                                (A === 2 || A === 3 || A === 6) && (A = ba.current,
                                A !== null && A.tag === 13 && (A.flags |= 16384))),
                                gd(u, c)) : _a(u)
                            }
                            function _a(c) {
                                var u = c;
                                do {
                                    if ((u.flags & 32768) !== 0) {
                                        gd(u, er);
                                        return
                                    }
                                    c = u.return;
                                    var y = x0(u.alternate, u, Rs);
                                    if (y !== null) {
                                        Lt = y;
                                        return
                                    }
                                    if (u = u.sibling,
                                    u !== null) {
                                        Lt = u;
                                        return
                                    }
                                    Lt = u = c
                                } while (u !== null);
                                Yn === 0 && (Yn = 5)
                            }
                            function gd(c, u) {
                                do {
                                    var y = bS(c.alternate, c);
                                    if (y !== null) {
                                        y.flags &= 32767,
                                        Lt = y;
                                        return
                                    }
                                    if (y = c.return,
                                    y !== null && (y.flags |= 32768,
                                    y.subtreeFlags = 0,
                                    y.deletions = null),
                                    !u && (c = c.sibling,
                                    c !== null)) {
                                        Lt = c;
                                        return
                                    }
                                    Lt = c = y
                                } while (c !== null);
                                Yn = 6,
                                Lt = null
                            }
                            function fl(c, u, y, A, C, N, W, oe, ve, Xe) {
                                var it = Vt.T
                                  , dt = Co();
                                try {
                                    ws(2),
                                    Vt.T = null,
                                    b0(c, u, y, A, dt, C, N, W, oe, ve, Xe)
                                } finally {
                                    Vt.T = it,
                                    ws(dt)
                                }
                            }
                            function b0(c, u, y, A, C, N, W, oe) {
                                do
                                    pr();
                                while ($r !== null);
                                if ((Sn & 6) !== 0)
                                    throw Error(r(327));
                                var ve = c.finishedWork;
                                if (A = c.finishedLanes,
                                ve === null)
                                    return null;
                                if (c.finishedWork = null,
                                c.finishedLanes = 0,
                                ve === c.current)
                                    throw Error(r(177));
                                c.callbackNode = null,
                                c.callbackPriority = 0,
                                c.cancelPendingCommit = null;
                                var Xe = ve.lanes | ve.childLanes;
                                if (Xe |= xr,
                                K(c, A, Xe, N, W, oe),
                                c === On && (Lt = On = null,
                                pn = 0),
                                (ve.subtreeFlags & 10256) === 0 && (ve.flags & 10256) === 0 || Mr || (Mr = !0,
                                Ol = Xe,
                                qd = y,
                                Mo(zd, function() {
                                    return pr(!0),
                                    null
                                })),
                                y = (ve.flags & 15990) !== 0,
                                (ve.subtreeFlags & 15990) !== 0 || y ? (y = Vt.T,
                                Vt.T = null,
                                N = Co(),
                                ws(2),
                                W = Sn,
                                Sn |= 4,
                                Th(c, ve),
                                Im(ve, c),
                                R0(c.containerInfo),
                                c.current = ve,
                                cd(c, ve.alternate, ve),
                                Id(),
                                Sn = W,
                                ws(N),
                                Vt.T = y) : c.current = ve,
                                Mr ? (Mr = !1,
                                $r = c,
                                vc = A) : km(c, Xe),
                                Xe = c.pendingLanes,
                                Xe === 0 && (Dl = null),
                                V(ve.stateNode, C),
                                yt(c),
                                u !== null)
                                    for (C = c.onRecoverableError,
                                    ve = 0; ve < u.length; ve++)
                                        Xe = u[ve],
                                        C(Xe.value, {
                                            componentStack: Xe.stack
                                        });
                                return (vc & 3) !== 0 && pr(),
                                Xe = c.pendingLanes,
                                (A & 4194218) !== 0 && (Xe & 42) !== 0 ? c === Yd ? Tu++ : (Tu = 0,
                                Yd = c) : Tu = 0,
                                wt(0, !1),
                                null
                            }
                            function km(c, u) {
                                (c.pooledCacheLanes &= u) === 0 && (u = c.pooledCache,
                                u != null && (c.pooledCache = null,
                                _h(u)))
                            }
                            function pr() {
                                if ($r !== null) {
                                    var c = $r
                                      , u = Ol;
                                    Ol = 0;
                                    var y = G(vc)
                                      , A = 32 > y ? 32 : y;
                                    y = Vt.T;
                                    var C = Co();
                                    try {
                                        if (ws(A),
                                        Vt.T = null,
                                        $r === null)
                                            var N = !1;
                                        else {
                                            A = qd,
                                            qd = null;
                                            var W = $r
                                              , oe = vc;
                                            if ($r = null,
                                            vc = 0,
                                            (Sn & 6) !== 0)
                                                throw Error(r(331));
                                            var ve = Sn;
                                            if (Sn |= 4,
                                            dd(W.current),
                                            Lm(W, W.current, oe, A),
                                            Sn = ve,
                                            wt(0, !1),
                                            na && typeof na.onPostCommitFiberRoot == "function")
                                                try {
                                                    na.onPostCommitFiberRoot(Ci, W)
                                                } catch {}
                                            N = !0
                                        }
                                        return N
                                    } finally {
                                        ws(C),
                                        Vt.T = y,
                                        km(c, u)
                                    }
                                }
                                return !1
                            }
                            function eu(c, u, y) {
                                u = se(y, u),
                                u = Yc(c.stateNode, u, 2),
                                c = ie(c, u, 2),
                                c !== null && (Z(c, 2),
                                yt(c))
                            }
                            function Rn(c, u, y) {
                                if (c.tag === 3)
                                    eu(c, c, y);
                                else
                                    for (; u !== null; ) {
                                        if (u.tag === 3) {
                                            eu(u, c, y);
                                            break
                                        } else if (u.tag === 1) {
                                            var A = u.stateNode;
                                            if (typeof u.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (Dl === null || !Dl.has(A))) {
                                                c = se(y, c),
                                                y = Am(2),
                                                A = ie(u, y, 2),
                                                A !== null && (o0(y, A, u, c),
                                                Z(A, 2),
                                                yt(A));
                                                break
                                            }
                                        }
                                        u = u.return
                                    }
                            }
                            function $l(c, u, y) {
                                var A = c.pingCache;
                                if (A === null) {
                                    A = c.pingCache = new $a;
                                    var C = new Set;
                                    A.set(u, C)
                                } else
                                    C = A.get(u),
                                    C === void 0 && (C = new Set,
                                    A.set(u, C));
                                C.has(y) || (Wi = !0,
                                C.add(y),
                                c = Xm.bind(null, c, u, y),
                                u.then(c, c))
                            }
                            function Xm(c, u, y) {
                                var A = c.pingCache;
                                A !== null && A.delete(u),
                                c.pingedLanes |= c.suspendedLanes & y,
                                c.warmLanes &= ~y,
                                On === c && (pn & y) === y && (Yn === 4 || Yn === 3 && (pn & 62914560) === pn && 300 > ja() - Gs ? (Sn & 2) === 0 && ps(c, 0) : jh |= y,
                                Jr === pn && (Jr = 0)),
                                yt(c)
                            }
                            function dl(c, u) {
                                u === 0 && (u = L()),
                                c = Ie(c, u),
                                c !== null && (Z(c, u),
                                yt(c))
                            }
                            function To(c) {
                                var u = c.memoizedState
                                  , y = 0;
                                u !== null && (y = u.retryLane),
                                dl(c, y)
                            }
                            function pl(c, u) {
                                var y = 0;
                                switch (c.tag) {
                                case 13:
                                    var A = c.stateNode
                                      , C = c.memoizedState;
                                    C !== null && (y = C.retryLane);
                                    break;
                                case 19:
                                    A = c.stateNode;
                                    break;
                                case 22:
                                    A = c.stateNode._retryCache;
                                    break;
                                default:
                                    throw Error(r(314))
                                }
                                A !== null && A.delete(u),
                                dl(c, y)
                            }
                            function Mo(c, u) {
                                return Pd(c, u)
                            }
                            function qm(c, u, y, A) {
                                this.tag = c,
                                this.key = y,
                                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                                this.index = 0,
                                this.refCleanup = this.ref = null,
                                this.pendingProps = u,
                                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                                this.mode = A,
                                this.subtreeFlags = this.flags = 0,
                                this.deletions = null,
                                this.childLanes = this.lanes = 0,
                                this.alternate = null
                            }
                            function Rh(c) {
                                return c = c.prototype,
                                !(!c || !c.isReactComponent)
                            }
                            function Xa(c, u) {
                                var y = c.alternate;
                                return y === null ? (y = i(c.tag, u, c.key, c.mode),
                                y.elementType = c.elementType,
                                y.type = c.type,
                                y.stateNode = c.stateNode,
                                y.alternate = c,
                                c.alternate = y) : (y.pendingProps = u,
                                y.type = c.type,
                                y.flags = 0,
                                y.subtreeFlags = 0,
                                y.deletions = null),
                                y.flags = c.flags & 31457280,
                                y.childLanes = c.childLanes,
                                y.lanes = c.lanes,
                                y.child = c.child,
                                y.memoizedProps = c.memoizedProps,
                                y.memoizedState = c.memoizedState,
                                y.updateQueue = c.updateQueue,
                                u = c.dependencies,
                                y.dependencies = u === null ? null : {
                                    lanes: u.lanes,
                                    firstContext: u.firstContext
                                },
                                y.sibling = c.sibling,
                                y.index = c.index,
                                y.ref = c.ref,
                                y.refCleanup = c.refCleanup,
                                y
                            }
                            function Dh(c, u) {
                                c.flags &= 31457282;
                                var y = c.alternate;
                                return y === null ? (c.childLanes = 0,
                                c.lanes = u,
                                c.child = null,
                                c.subtreeFlags = 0,
                                c.memoizedProps = null,
                                c.memoizedState = null,
                                c.updateQueue = null,
                                c.dependencies = null,
                                c.stateNode = null) : (c.childLanes = y.childLanes,
                                c.lanes = y.lanes,
                                c.child = y.child,
                                c.subtreeFlags = 0,
                                c.deletions = null,
                                c.memoizedProps = y.memoizedProps,
                                c.memoizedState = y.memoizedState,
                                c.updateQueue = y.updateQueue,
                                c.type = y.type,
                                u = y.dependencies,
                                c.dependencies = u === null ? null : {
                                    lanes: u.lanes,
                                    firstContext: u.firstContext
                                }),
                                c
                            }
                            function Gr(c, u, y, A, C, N) {
                                var W = 0;
                                if (A = c,
                                typeof c == "function")
                                    Rh(c) && (W = 1);
                                else if (typeof c == "string")
                                    W = Sa && kn ? Vh(c, y, qi.current) ? 26 : kr(c) ? 27 : 5 : Sa ? Vh(c, y, qi.current) ? 26 : 5 : kn && kr(c) ? 27 : 5;
                                else
                                    e: switch (c) {
                                    case ml:
                                        return vi(y.children, C, N, u);
                                    case Bh:
                                        W = 8,
                                        C |= 24;
                                        break;
                                    case xd:
                                        return c = i(12, y, u, C | 2),
                                        c.elementType = xd,
                                        c.lanes = N,
                                        c;
                                    case Sd:
                                        return c = i(13, y, u, C),
                                        c.elementType = Sd,
                                        c.lanes = N,
                                        c;
                                    case su:
                                        return c = i(19, y, u, C),
                                        c.elementType = su,
                                        c.lanes = N,
                                        c;
                                    case jm:
                                        return Oh(y, C, N, u);
                                    default:
                                        if (typeof c == "object" && c !== null)
                                            switch (c.$$typeof) {
                                            case Ph:
                                            case mr:
                                                W = 10;
                                                break e;
                                            case Wm:
                                                W = 9;
                                                break e;
                                            case Ih:
                                                W = 11;
                                                break e;
                                            case Ad:
                                                W = 14;
                                                break e;
                                            case Ya:
                                                W = 16,
                                                A = null;
                                                break e
                                            }
                                        W = 29,
                                        y = Error(r(130, c === null ? "null" : typeof c, "")),
                                        A = null
                                    }
                                return u = i(W, y, u, C),
                                u.elementType = c,
                                u.type = A,
                                u.lanes = N,
                                u
                            }
                            function vi(c, u, y, A) {
                                return c = i(7, c, A, u),
                                c.lanes = y,
                                c
                            }
                            function Oh(c, u, y, A) {
                                c = i(22, c, A, u),
                                c.elementType = jm,
                                c.lanes = y;
                                var C = {
                                    _visibility: 1,
                                    _pendingVisibility: 1,
                                    _pendingMarkers: null,
                                    _retryCache: null,
                                    _transitions: null,
                                    _current: null,
                                    detach: function() {
                                        var N = C._current;
                                        if (N === null)
                                            throw Error(r(456));
                                        if ((C._pendingVisibility & 2) === 0) {
                                            var W = Ie(N, 2);
                                            W !== null && (C._pendingVisibility |= 2,
                                            es(W, N, 2))
                                        }
                                    },
                                    attach: function() {
                                        var N = C._current;
                                        if (N === null)
                                            throw Error(r(456));
                                        if ((C._pendingVisibility & 2) !== 0) {
                                            var W = Ie(N, 2);
                                            W !== null && (C._pendingVisibility &= -3,
                                            es(W, N, 2))
                                        }
                                    }
                                };
                                return c.stateNode = C,
                                c
                            }
                            function vd(c, u, y) {
                                return c = i(6, c, null, u),
                                c.lanes = y,
                                c
                            }
                            function Ym(c, u, y) {
                                return u = i(4, c.children !== null ? c.children : [], c.key, u),
                                u.lanes = y,
                                u.stateNode = {
                                    containerInfo: c.containerInfo,
                                    pendingChildren: null,
                                    implementation: c.implementation
                                },
                                u
                            }
                            function ES(c, u, y, A, C, N, W, oe) {
                                this.tag = 1,
                                this.containerInfo = c,
                                this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
                                this.timeoutHandle = vl,
                                this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                                this.callbackPriority = 0,
                                this.expirationTimes = H(-1),
                                this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                                this.entanglements = H(0),
                                this.hiddenUpdates = H(null),
                                this.identifierPrefix = A,
                                this.onUncaughtError = C,
                                this.onCaughtError = N,
                                this.onRecoverableError = W,
                                this.pooledCache = null,
                                this.pooledCacheLanes = 0,
                                this.formState = oe,
                                this.incompleteTransitions = new Map
                            }
                            function E0(c, u, y, A, C, N, W, oe, ve, Xe, it, dt) {
                                return c = new ES(c,u,y,W,oe,ve,Xe,dt),
                                u = 1,
                                N === !0 && (u |= 24),
                                N = i(3, null, null, u),
                                c.current = N,
                                N.stateNode = c,
                                u = al(),
                                u.refCount++,
                                c.pooledCache = u,
                                u.refCount++,
                                N.memoizedState = {
                                    element: A,
                                    isDehydrated: y,
                                    cache: u
                                },
                                Ct(N),
                                c
                            }
                            function Pi(c) {
                                return c ? (c = Al,
                                c) : Al
                            }
                            function yd(c) {
                                var u = c._reactInternals;
                                if (u === void 0)
                                    throw typeof c.render == "function" ? Error(r(188)) : (c = Object.keys(c).join(","),
                                    Error(r(268, c)));
                                return c = b(u),
                                c = c !== null ? E(c) : null,
                                c === null ? null : ou(c.stateNode)
                            }
                            function tu(c, u, y, A, C, N) {
                                C = Pi(C),
                                A.context === null ? A.context = C : A.pendingContext = C,
                                A = st(u),
                                A.payload = {
                                    element: y
                                },
                                N = N === void 0 ? null : N,
                                N !== null && (A.callback = N),
                                y = ie(c, A, u),
                                y !== null && (es(y, c, u),
                                Re(y, c, u))
                            }
                            function nu(c, u) {
                                if (c = c.memoizedState,
                                c !== null && c.dehydrated !== null) {
                                    var y = c.retryLane;
                                    c.retryLane = y !== 0 && y < u ? y : u
                                }
                            }
                            function Nh(c, u) {
                                nu(c, u),
                                (c = c.alternate) && nu(c, u)
                            }
                            var Kt = {}, iu = Jd(), xa = eM(), _d = Object.assign, wS = Symbol.for("react.element"), Uh = Symbol.for("react.transitional.element"), qa = Symbol.for("react.portal"), ml = Symbol.for("react.fragment"), Bh = Symbol.for("react.strict_mode"), xd = Symbol.for("react.profiler"), Ph = Symbol.for("react.provider"), Wm = Symbol.for("react.consumer"), mr = Symbol.for("react.context"), Ih = Symbol.for("react.forward_ref"), Sd = Symbol.for("react.suspense"), su = Symbol.for("react.suspense_list"), Ad = Symbol.for("react.memo"), Ya = Symbol.for("react.lazy"), jm = Symbol.for("react.offscreen"), w0 = Symbol.for("react.memo_cache_sentinel"), bo = Symbol.iterator, Qm = Symbol.for("react.client.reference"), Vt = iu.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Eo, gl, ec = !1, au = Array.isArray, Zm = n.rendererVersion, Lh = n.rendererPackageName, ru = n.extraDevToolsConfig, ou = n.getPublicInstance, C0 = n.getRootHostContext, lu = n.getChildHostContext, Td = n.prepareForCommit, R0 = n.resetAfterCommit, Km = n.createInstance, zh = n.appendInitialChild, wo = n.finalizeInitialChildren, Jt = n.shouldSetTextContent, In = n.createTextInstance, Ii = n.scheduleTimeout, Md = n.cancelTimeout, vl = n.noTimeout, zs = n.isPrimaryRenderer;
                            n.warnsIfNotActing;
                            var Xi = n.supportsMutation
                              , Wa = n.supportsPersistence
                              , ms = n.supportsHydration
                              , D0 = n.getInstanceFromNode;
                            n.beforeActiveInstanceBlur,
                            n.afterActiveInstanceBlur;
                            var Ei = n.preparePortalMount;
                            n.prepareScopeUpdate,
                            n.getInstanceFromScope;
                            var ws = n.setCurrentUpdatePriority
                              , Co = n.getCurrentUpdatePriority
                              , O0 = n.resolveUpdatePriority;
                            n.resolveEventType,
                            n.resolveEventTimeStamp;
                            var N0 = n.shouldAttemptEagerTransition
                              , CS = n.detachDeletedInstance;
                            n.requestPostPaintCallback;
                            var Jm = n.maySuspendCommit
                              , bd = n.preloadInstance
                              , $m = n.startSuspendingCommit
                              , Fs = n.suspendInstance
                              , Li = n.waitForCommitToBeReady
                              , yl = n.NotPendingTransition
                              , gr = n.HostTransitionContext
                              , Ed = n.resetFormInstance;
                            n.bindToConsole;
                            var eg = n.supportsMicrotasks
                              , Ro = n.scheduleMicrotask
                              , _l = n.supportsTestSelectors
                              , tg = n.findFiberRoot
                              , ng = n.getBoundingRect
                              , U0 = n.getTextContent
                              , cu = n.isHiddenSubtree
                              , B0 = n.matchAccessibilityRole
                              , P0 = n.setFocusIfFocusable
                              , I0 = n.setupIntersectionObserver
                              , L0 = n.appendChild
                              , ig = n.appendChildToContainer
                              , z0 = n.commitTextUpdate
                              , RS = n.commitMount
                              , F0 = n.commitUpdate
                              , H0 = n.insertBefore
                              , V0 = n.insertInContainerBefore
                              , sg = n.removeChild
                              , G0 = n.removeChildFromContainer
                              , ag = n.resetTextContent
                              , k0 = n.hideInstance
                              , X0 = n.hideTextInstance
                              , q0 = n.unhideInstance
                              , DS = n.unhideTextInstance
                              , Y0 = n.clearContainer
                              , uu = n.cloneInstance
                              , Fh = n.createContainerChildSet
                              , rg = n.appendChildToContainerChildSet
                              , wd = n.finalizeContainerChildren
                              , hu = n.replaceContainerChildren
                              , og = n.cloneHiddenInstance
                              , lg = n.cloneHiddenTextInstance
                              , Cd = n.isSuspenseInstancePending
                              , Rd = n.isSuspenseInstanceFallback
                              , W0 = n.getSuspenseInstanceFallbackErrorDetails
                              , j0 = n.registerSuspenseInstanceRetry
                              , cg = n.canHydrateFormStateMarker
                              , Q0 = n.isFormStateMarkerMatching
                              , ug = n.getNextHydratableSibling
                              , Dd = n.getFirstHydratableChild
                              , Z0 = n.getFirstHydratableChildWithinContainer
                              , K0 = n.getFirstHydratableChildWithinSuspenseInstance
                              , OS = n.canHydrateInstance
                              , hg = n.canHydrateTextInstance
                              , J0 = n.canHydrateSuspenseInstance
                              , $0 = n.hydrateInstance
                              , fg = n.hydrateTextInstance
                              , ey = n.hydrateSuspenseInstance
                              , ty = n.getNextHydratableInstanceAfterSuspenseInstance
                              , NS = n.commitHydratedContainer
                              , US = n.commitHydratedSuspenseInstance
                              , ny = n.clearSuspenseBoundary
                              , Hh = n.clearSuspenseBoundaryFromContainer
                              , Od = n.shouldDeleteUnhydratedTailInstances;
                            n.diffHydratedPropsForDevWarnings,
                            n.diffHydratedTextForDevWarnings,
                            n.describeHydratableInstanceForDevWarnings;
                            var Nd = n.validateHydratableInstance
                              , iy = n.validateHydratableTextInstance
                              , Sa = n.supportsResources
                              , Vh = n.isHostHoistableType
                              , Ud = n.getHoistableRoot
                              , dg = n.getResource
                              , sy = n.acquireResource
                              , tc = n.releaseResource
                              , Gh = n.hydrateHoistable
                              , kh = n.mountHoistable
                              , fu = n.unmountHoistable
                              , Bd = n.createHoistableInstance
                              , ay = n.prepareToCommitHoistables
                              , ry = n.mayResourceSuspendCommit
                              , nc = n.preloadResource
                              , oy = n.suspendResource
                              , kn = n.supportsSingletons
                              , vr = n.resolveSingletonInstance
                              , xl = n.clearSingleton
                              , ly = n.acquireSingletonInstance
                              , Sl = n.releaseSingletonInstance
                              , kr = n.isHostSingletonType
                              , wi = []
                              , Do = -1
                              , Al = {}
                              , Hs = Math.clz32 ? Math.clz32 : O
                              , cy = Math.log
                              , uy = Math.LN2
                              , Xr = 128
                              , ic = 4194304
                              , Pd = xa.unstable_scheduleCallback
                              , pg = xa.unstable_cancelCallback
                              , BS = xa.unstable_shouldYield
                              , Id = xa.unstable_requestPaint
                              , ja = xa.unstable_now
                              , Ld = xa.unstable_ImmediatePriority
                              , hy = xa.unstable_UserBlockingPriority
                              , zd = xa.unstable_NormalPriority
                              , PS = xa.unstable_IdlePriority
                              , fy = xa.log
                              , ts = xa.unstable_setDisableYieldValue
                              , Ci = null
                              , na = null
                              , ia = typeof Object.is == "function" ? Object.is : ee
                              , mg = new WeakMap
                              , sc = []
                              , ac = 0
                              , rc = null
                              , du = 0
                              , Aa = []
                              , Ta = 0
                              , Tl = null
                              , yr = 1
                              , _r = ""
                              , qi = M(null)
                              , pu = M(null)
                              , qr = M(null)
                              , oc = M(null)
                              , gs = null
                              , vs = null
                              , _n = !1
                              , Qa = null
                              , ns = !1
                              , Xh = Error(r(519))
                              , Za = []
                              , lc = 0
                              , xr = 0
                              , qh = null
                              , Oo = null
                              , cc = !1
                              , Zn = !1
                              , gg = !1
                              , mu = 0
                              , gu = null
                              , uc = 0
                              , Ma = 0
                              , hc = null
                              , No = !1
                              , fc = !1
                              , Yr = Object.prototype.hasOwnProperty
                              , vu = Error(r(460))
                              , Yh = Error(r(474))
                              , Wh = {
                                then: function() {}
                            }
                              , Ml = null
                              , bl = null
                              , El = 0
                              , wl = os(!0)
                              , Wr = os(!1)
                              , Kn = M(null)
                              , yu = M(0)
                              , ba = M(null)
                              , Xn = null
                              , Yi = M(0)
                              , Uo = 0
                              , nn = null
                              , It = null
                              , xn = null
                              , Ka = !1
                              , dc = !1
                              , Cl = !1
                              , Fd = 0
                              , pc = 0
                              , is = null
                              , Sr = 0
                              , Hd = function() {
                                return {
                                    lastEffect: null,
                                    events: null,
                                    stores: null,
                                    memoCache: null
                                }
                            }
                              , yi = {
                                readContext: hs,
                                use: ft,
                                useCallback: si,
                                useContext: si,
                                useEffect: si,
                                useImperativeHandle: si,
                                useLayoutEffect: si,
                                useInsertionEffect: si,
                                useMemo: si,
                                useReducer: si,
                                useRef: si,
                                useState: si,
                                useDebugValue: si,
                                useDeferredValue: si,
                                useTransition: si,
                                useSyncExternalStore: si,
                                useId: si
                            };
                            yi.useCacheRefresh = si,
                            yi.useMemoCache = si,
                            yi.useHostTransitionStatus = si,
                            yi.useFormState = si,
                            yi.useActionState = si,
                            yi.useOptimistic = si;
                            var Rl = {
                                readContext: hs,
                                use: ft,
                                useCallback: function(c, u) {
                                    return Se().memoizedState = [c, u === void 0 ? null : u],
                                    c
                                },
                                useContext: hs,
                                useEffect: Kf,
                                useImperativeHandle: function(c, u, y) {
                                    y = y != null ? y.concat([c]) : null,
                                    oh(4194308, 4, Jf.bind(null, u, c), y)
                                },
                                useLayoutEffect: function(c, u) {
                                    return oh(4194308, 4, c, u)
                                },
                                useInsertionEffect: function(c, u) {
                                    oh(4, 2, c, u)
                                },
                                useMemo: function(c, u) {
                                    var y = Se();
                                    u = u === void 0 ? null : u;
                                    var A = c();
                                    if (Cl) {
                                        q(!0);
                                        try {
                                            c()
                                        } finally {
                                            q(!1)
                                        }
                                    }
                                    return y.memoizedState = [A, u],
                                    A
                                },
                                useReducer: function(c, u, y) {
                                    var A = Se();
                                    if (y !== void 0) {
                                        var C = y(u);
                                        if (Cl) {
                                            q(!0);
                                            try {
                                                y(u)
                                            } finally {
                                                q(!1)
                                            }
                                        }
                                    } else
                                        C = u;
                                    return A.memoizedState = A.baseState = C,
                                    c = {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: c,
                                        lastRenderedState: C
                                    },
                                    A.queue = c,
                                    c = c.dispatch = ed.bind(null, nn, c),
                                    [A.memoizedState, c]
                                },
                                useRef: function(c) {
                                    var u = Se();
                                    return c = {
                                        current: c
                                    },
                                    u.memoizedState = c
                                },
                                useState: function(c) {
                                    c = Mn(c);
                                    var u = c.queue
                                      , y = Sm.bind(null, nn, u);
                                    return u.dispatch = y,
                                    [c.memoizedState, y]
                                },
                                useDebugValue: el,
                                useDeferredValue: function(c, u) {
                                    var y = Se();
                                    return uh(y, c, u)
                                },
                                useTransition: function() {
                                    var c = Mn(!1);
                                    return c = Fc.bind(null, nn, c.queue, !0, !1),
                                    Se().memoizedState = c,
                                    [!1, c]
                                },
                                useSyncExternalStore: function(c, u, y) {
                                    var A = nn
                                      , C = Se();
                                    if (_n) {
                                        if (y === void 0)
                                            throw Error(r(407));
                                        y = y()
                                    } else {
                                        if (y = u(),
                                        On === null)
                                            throw Error(r(349));
                                        (pn & 60) !== 0 || yn(A, u, y)
                                    }
                                    C.memoizedState = y;
                                    var N = {
                                        value: y,
                                        getSnapshot: u
                                    };
                                    return C.queue = N,
                                    Kf(Ln.bind(null, A, N, c), [c]),
                                    A.flags |= 2048,
                                    fr(9, Cn.bind(null, A, N, y, u), {
                                        destroy: void 0
                                    }, null),
                                    y
                                },
                                useId: function() {
                                    var c = Se()
                                      , u = On.identifierPrefix;
                                    if (_n) {
                                        var y = _r
                                          , A = yr;
                                        y = (A & ~(1 << 32 - Hs(A) - 1)).toString(32) + y,
                                        u = ":" + u + "R" + y,
                                        y = Fd++,
                                        0 < y && (u += "H" + y.toString(32)),
                                        u += ":"
                                    } else
                                        y = Sr++,
                                        u = ":" + u + "r" + y.toString(32) + ":";
                                    return c.memoizedState = u
                                },
                                useCacheRefresh: function() {
                                    return Se().memoizedState = xm.bind(null, nn)
                                }
                            };
                            Rl.useMemoCache = vt,
                            Rl.useHostTransitionStatus = hh,
                            Rl.useFormState = Mi,
                            Rl.useActionState = Mi,
                            Rl.useOptimistic = function(c) {
                                var u = Se();
                                u.memoizedState = u.baseState = c;
                                var y = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: null,
                                    lastRenderedState: null
                                };
                                return u.queue = y,
                                u = Vc.bind(null, nn, !0, y),
                                y.dispatch = u,
                                [c, u]
                            }
                            ;
                            var Vs = {
                                readContext: hs,
                                use: ft,
                                useCallback: Zl,
                                useContext: hs,
                                useEffect: vm,
                                useImperativeHandle: $f,
                                useInsertionEffect: a0,
                                useLayoutEffect: ch,
                                useMemo: ym,
                                useReducer: Dt,
                                useRef: s0,
                                useState: function() {
                                    return Dt(ut)
                                },
                                useDebugValue: el,
                                useDeferredValue: function(c, u) {
                                    var y = he();
                                    return _m(y, It.memoizedState, c, u)
                                },
                                useTransition: function() {
                                    var c = Dt(ut)[0]
                                      , u = he().memoizedState;
                                    return [typeof c == "boolean" ? c : Ze(c), u]
                                },
                                useSyncExternalStore: un,
                                useId: Hc
                            };
                            Vs.useCacheRefresh = fo,
                            Vs.useMemoCache = vt,
                            Vs.useHostTransitionStatus = hh,
                            Vs.useFormState = bs,
                            Vs.useActionState = bs,
                            Vs.useOptimistic = function(c, u) {
                                var y = he();
                                return dn(y, It, c, u)
                            }
                            ;
                            var Ea = {
                                readContext: hs,
                                use: ft,
                                useCallback: Zl,
                                useContext: hs,
                                useEffect: vm,
                                useImperativeHandle: $f,
                                useInsertionEffect: a0,
                                useLayoutEffect: ch,
                                useMemo: ym,
                                useReducer: Nt,
                                useRef: s0,
                                useState: function() {
                                    return Nt(ut)
                                },
                                useDebugValue: el,
                                useDeferredValue: function(c, u) {
                                    var y = he();
                                    return It === null ? uh(y, c, u) : _m(y, It.memoizedState, c, u)
                                },
                                useTransition: function() {
                                    var c = Nt(ut)[0]
                                      , u = he().memoizedState;
                                    return [typeof c == "boolean" ? c : Ze(c), u]
                                },
                                useSyncExternalStore: un,
                                useId: Hc
                            };
                            Ea.useCacheRefresh = fo,
                            Ea.useMemoCache = vt,
                            Ea.useHostTransitionStatus = hh,
                            Ea.useFormState = gm,
                            Ea.useActionState = gm,
                            Ea.useOptimistic = function(c, u) {
                                var y = he();
                                return It !== null ? dn(y, It, c, u) : (y.baseState = c,
                                [c, y.queue.dispatch])
                            }
                            ;
                            var jr = {
                                isMounted: function(c) {
                                    return (c = c._reactInternals) ? _(c) === c : !1
                                },
                                enqueueSetState: function(c, u, y) {
                                    c = c._reactInternals;
                                    var A = bi()
                                      , C = st(A);
                                    C.payload = u,
                                    y != null && (C.callback = y),
                                    u = ie(c, C, A),
                                    u !== null && (es(u, c, A),
                                    Re(u, c, A))
                                },
                                enqueueReplaceState: function(c, u, y) {
                                    c = c._reactInternals;
                                    var A = bi()
                                      , C = st(A);
                                    C.tag = 1,
                                    C.payload = u,
                                    y != null && (C.callback = y),
                                    u = ie(c, C, A),
                                    u !== null && (es(u, c, A),
                                    Re(u, c, A))
                                },
                                enqueueForceUpdate: function(c, u) {
                                    c = c._reactInternals;
                                    var y = bi()
                                      , A = st(y);
                                    A.tag = 2,
                                    u != null && (A.callback = u),
                                    u = ie(c, A, y),
                                    u !== null && (es(u, c, y),
                                    Re(u, c, y))
                                }
                            }
                              , Vd = typeof reportError == "function" ? reportError : function(c) {
                                if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                    var u = new window.ErrorEvent("error",{
                                        bubbles: !0,
                                        cancelable: !0,
                                        message: typeof c == "object" && c !== null && typeof c.message == "string" ? String(c.message) : String(c),
                                        error: c
                                    });
                                    if (!window.dispatchEvent(u))
                                        return
                                } else if (typeof process == "object" && typeof process.emit == "function") {
                                    process.emit("uncaughtException", c);
                                    return
                                }
                                console.error(c)
                            }
                              , Gd = Error(r(461))
                              , qn = !1
                              , kd = {
                                dehydrated: null,
                                treeContext: null,
                                retryLane: 0
                            }
                              , Bo = M(null)
                              , Ar = null
                              , wa = null
                              , _u = typeof AbortController < "u" ? AbortController : function() {
                                var c = []
                                  , u = this.signal = {
                                    aborted: !1,
                                    addEventListener: function(y, A) {
                                        c.push(A)
                                    }
                                };
                                this.abort = function() {
                                    u.aborted = !0,
                                    c.forEach(function(y) {
                                        return y()
                                    })
                                }
                            }
                              , dy = xa.unstable_scheduleCallback
                              , py = xa.unstable_NormalPriority
                              , Jn = {
                                $$typeof: mr,
                                Consumer: null,
                                Provider: null,
                                _currentValue: null,
                                _currentValue2: null,
                                _threadCount: 0
                            }
                              , vg = Vt.S;
                            Vt.S = function(c, u) {
                                typeof u == "object" && u !== null && typeof u.then == "function" && ct(c, u),
                                vg !== null && vg(c, u)
                            }
                            ;
                            var Qr = M(null)
                              , Zr = !1
                              , _i = !1
                              , yg = !1
                              , Dn = typeof WeakSet == "function" ? WeakSet : Set
                              , jt = null
                              , ln = !1
                              , Bt = null
                              , en = !1
                              , pi = null
                              , Ca = 8192
                              , xu = {
                                getCacheForType: function(c) {
                                    var u = hs(Jn)
                                      , y = u.data.get(c);
                                    return y === void 0 && (y = c(),
                                    u.data.set(c, y)),
                                    y
                                }
                            }
                              , Su = 0
                              , Ja = 1
                              , ai = 2
                              , Tr = 3
                              , Kr = 4;
                            if (typeof Symbol == "function" && Symbol.for) {
                                var mc = Symbol.for;
                                Su = mc("selector.component"),
                                Ja = mc("selector.has_pseudo_class"),
                                ai = mc("selector.role"),
                                Tr = mc("selector.test_id"),
                                Kr = mc("selector.text")
                            }
                            var $a = typeof WeakMap == "function" ? WeakMap : Map
                              , Sn = 0
                              , On = null
                              , Lt = null
                              , pn = 0
                              , zn = 0
                              , Cs = null
                              , er = !1
                              , Ra = !1
                              , Wi = !1
                              , Rs = 0
                              , Yn = 0
                              , Da = 0
                              , Po = 0
                              , jh = 0
                              , Oa = 0
                              , Jr = 0
                              , gc = null
                              , Ri = null
                              , Xd = !1
                              , Gs = 0
                              , Au = 1 / 0
                              , Qh = null
                              , Dl = null
                              , Mr = !1
                              , $r = null
                              , vc = 0
                              , Ol = 0
                              , qd = null
                              , Tu = 0
                              , Yd = null;
                            return Kt.attemptContinuousHydration = function(c) {
                                if (c.tag === 13) {
                                    var u = Ie(c, 67108864);
                                    u !== null && es(u, c, 67108864),
                                    Nh(c, 67108864)
                                }
                            }
                            ,
                            Kt.attemptHydrationAtCurrentPriority = function(c) {
                                if (c.tag === 13) {
                                    var u = bi()
                                      , y = Ie(c, u);
                                    y !== null && es(y, c, u),
                                    Nh(c, u)
                                }
                            }
                            ,
                            Kt.attemptSynchronousHydration = function(c) {
                                switch (c.tag) {
                                case 3:
                                    if (c = c.stateNode,
                                    c.current.memoizedState.isDehydrated) {
                                        var u = U(c.pendingLanes);
                                        if (u !== 0) {
                                            for (c.pendingLanes |= 2,
                                            c.entangledLanes |= 2; u; ) {
                                                var y = 1 << 31 - Hs(u);
                                                c.entanglements[1] |= y,
                                                u &= ~y
                                            }
                                            yt(c),
                                            (Sn & 6) === 0 && (Au = ja() + 500,
                                            wt(0, !1))
                                        }
                                    }
                                    break;
                                case 13:
                                    u = Ie(c, 2),
                                    u !== null && es(u, c, 2),
                                    Ch(),
                                    Nh(c, 2)
                                }
                            }
                            ,
                            Kt.batchedUpdates = function(c, u) {
                                return c(u)
                            }
                            ,
                            Kt.createComponentSelector = function(c) {
                                return {
                                    $$typeof: Su,
                                    value: c
                                }
                            }
                            ,
                            Kt.createContainer = function(c, u, y, A, C, N, W, oe, ve, Xe) {
                                return E0(c, u, !1, null, y, A, N, W, oe, ve, Xe, null)
                            }
                            ,
                            Kt.createHasPseudoClassSelector = function(c) {
                                return {
                                    $$typeof: Ja,
                                    value: c
                                }
                            }
                            ,
                            Kt.createHydrationContainer = function(c, u, y, A, C, N, W, oe, ve, Xe, it, dt, mt) {
                                return c = E0(y, A, !0, c, C, N, oe, ve, Xe, it, dt, mt),
                                c.context = Pi(null),
                                y = c.current,
                                A = bi(),
                                C = st(A),
                                C.callback = u ?? null,
                                ie(y, C, A),
                                c.current.lanes = A,
                                Z(c, A),
                                yt(c),
                                c
                            }
                            ,
                            Kt.createPortal = function(c, u, y) {
                                var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                                return {
                                    $$typeof: qa,
                                    key: A == null ? null : "" + A,
                                    children: c,
                                    containerInfo: u,
                                    implementation: y
                                }
                            }
                            ,
                            Kt.createRoleSelector = function(c) {
                                return {
                                    $$typeof: ai,
                                    value: c
                                }
                            }
                            ,
                            Kt.createTestNameSelector = function(c) {
                                return {
                                    $$typeof: Tr,
                                    value: c
                                }
                            }
                            ,
                            Kt.createTextSelector = function(c) {
                                return {
                                    $$typeof: Kr,
                                    value: c
                                }
                            }
                            ,
                            Kt.defaultOnCaughtError = function(c) {
                                console.error(c)
                            }
                            ,
                            Kt.defaultOnRecoverableError = function(c) {
                                Vd(c)
                            }
                            ,
                            Kt.defaultOnUncaughtError = function(c) {
                                Vd(c)
                            }
                            ,
                            Kt.deferredUpdates = function(c) {
                                var u = Vt.T
                                  , y = Co();
                                try {
                                    return ws(32),
                                    Vt.T = null,
                                    c()
                                } finally {
                                    ws(y),
                                    Vt.T = u
                                }
                            }
                            ,
                            Kt.discreteUpdates = function(c, u, y, A, C) {
                                var N = Vt.T
                                  , W = Co();
                                try {
                                    return ws(2),
                                    Vt.T = null,
                                    c(u, y, A, C)
                                } finally {
                                    ws(W),
                                    Vt.T = N,
                                    Sn === 0 && (Au = ja() + 500)
                                }
                            }
                            ,
                            Kt.findAllNodes = Eh,
                            Kt.findBoundingRects = function(c, u) {
                                if (!_l)
                                    throw Error(r(363));
                                u = Eh(c, u),
                                c = [];
                                for (var y = 0; y < u.length; y++)
                                    c.push(ng(u[y]));
                                for (u = c.length - 1; 0 < u; u--) {
                                    y = c[u];
                                    for (var A = y.x, C = A + y.width, N = y.y, W = N + y.height, oe = u - 1; 0 <= oe; oe--)
                                        if (u !== oe) {
                                            var ve = c[oe]
                                              , Xe = ve.x
                                              , it = Xe + ve.width
                                              , dt = ve.y
                                              , mt = dt + ve.height;
                                            if (A >= Xe && N >= dt && C <= it && W <= mt) {
                                                c.splice(u, 1);
                                                break
                                            } else if (A !== Xe || y.width !== ve.width || mt < N || dt > W) {
                                                if (!(N !== dt || y.height !== ve.height || it < A || Xe > C)) {
                                                    Xe > A && (ve.width += Xe - A,
                                                    ve.x = A),
                                                    it < C && (ve.width = C - Xe),
                                                    c.splice(u, 1);
                                                    break
                                                }
                                            } else {
                                                dt > N && (ve.height += dt - N,
                                                ve.y = N),
                                                mt < W && (ve.height = W - dt),
                                                c.splice(u, 1);
                                                break
                                            }
                                        }
                                }
                                return c
                            }
                            ,
                            Kt.findHostInstance = yd,
                            Kt.findHostInstanceWithNoPortals = function(c) {
                                return c = b(c),
                                c = c !== null ? T(c) : null,
                                c === null ? null : ou(c.stateNode)
                            }
                            ,
                            Kt.findHostInstanceWithWarning = function(c) {
                                return yd(c)
                            }
                            ,
                            Kt.flushPassiveEffects = pr,
                            Kt.flushSyncFromReconciler = function(c) {
                                var u = Sn;
                                Sn |= 1;
                                var y = Vt.T
                                  , A = Co();
                                try {
                                    if (ws(2),
                                    Vt.T = null,
                                    c)
                                        return c()
                                } finally {
                                    ws(A),
                                    Vt.T = y,
                                    Sn = u,
                                    (Sn & 6) === 0 && wt(0, !1)
                                }
                            }
                            ,
                            Kt.flushSyncWork = Ch,
                            Kt.focusWithin = function(c, u) {
                                if (!_l)
                                    throw Error(r(363));
                                for (c = Kc(c),
                                u = ea(c, u),
                                u = Array.from(u),
                                c = 0; c < u.length; ) {
                                    var y = u[c++]
                                      , A = y.tag;
                                    if (!cu(y)) {
                                        if ((A === 5 || A === 26 || A === 27) && P0(y.stateNode))
                                            return !0;
                                        for (y = y.child; y !== null; )
                                            u.push(y),
                                            y = y.sibling
                                    }
                                }
                                return !1
                            }
                            ,
                            Kt.getFindAllNodesFailureDescription = function(c, u) {
                                if (!_l)
                                    throw Error(r(363));
                                var y = 0
                                  , A = [];
                                c = [Kc(c), 0];
                                for (var C = 0; C < c.length; ) {
                                    var N = c[C++]
                                      , W = N.tag
                                      , oe = c[C++]
                                      , ve = u[oe];
                                    if ((W !== 5 && W !== 26 && W !== 27 || !cu(N)) && (cl(N, ve) && (A.push(Fm(ve)),
                                    oe++,
                                    oe > y && (y = oe)),
                                    oe < u.length))
                                        for (N = N.child; N !== null; )
                                            c.push(N, oe),
                                            N = N.sibling
                                }
                                if (y < u.length) {
                                    for (c = []; y < u.length; y++)
                                        c.push(Fm(u[y]));
                                    return `findAllNodes was able to match part of the selector:
  ` + (A.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ")
                                }
                                return null
                            }
                            ,
                            Kt.getPublicRootInstance = function(c) {
                                if (c = c.current,
                                !c.child)
                                    return null;
                                switch (c.child.tag) {
                                case 27:
                                case 5:
                                    return ou(c.child.stateNode);
                                default:
                                    return c.child.stateNode
                                }
                            }
                            ,
                            Kt.injectIntoDevTools = function() {
                                var c = {
                                    bundleType: 0,
                                    version: Zm,
                                    rendererPackageName: Lh,
                                    currentDispatcherRef: Vt,
                                    findFiberByHostInstance: D0,
                                    reconcilerVersion: "19.0.0"
                                };
                                if (ru !== null && (c.rendererConfig = ru),
                                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
                                    c = !1;
                                else {
                                    var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                                    if (u.isDisabled || !u.supportsFiber)
                                        c = !0;
                                    else {
                                        try {
                                            Ci = u.inject(c),
                                            na = u
                                        } catch {}
                                        c = !!u.checkDCE
                                    }
                                }
                                return c
                            }
                            ,
                            Kt.isAlreadyRendering = function() {
                                return !1
                            }
                            ,
                            Kt.observeVisibleRects = function(c, u, y, A) {
                                if (!_l)
                                    throw Error(r(363));
                                c = Eh(c, u);
                                var C = I0(c, y, A).disconnect;
                                return {
                                    disconnect: function() {
                                        C()
                                    }
                                }
                            }
                            ,
                            Kt.shouldError = function() {
                                return null
                            }
                            ,
                            Kt.shouldSuspend = function() {
                                return !1
                            }
                            ,
                            Kt.startHostTransition = function(c, u, y, A) {
                                if (c.tag !== 5)
                                    throw Error(r(476));
                                var C = Fr(c).queue;
                                Fc(c, C, u, yl, y === null ? s : function() {
                                    var N = Fr(c).next.queue;
                                    return tl(c, N, {}, bi()),
                                    y(A)
                                }
                                )
                            }
                            ,
                            Kt.updateContainer = function(c, u, y, A) {
                                var C = u.current
                                  , N = bi();
                                return tu(C, N, c, u, y, A),
                                N
                            }
                            ,
                            Kt.updateContainerSync = function(c, u, y, A) {
                                return u.tag === 0 && pr(),
                                tu(u.current, 2, c, u, y, A),
                                2
                            }
                            ,
                            Kt
                        }
                        ,
                        t.exports.default = t.exports,
                        Object.defineProperty(t.exports, "__esModule", {
                            value: !0
                        })
                    }
                    )
                })
                  , iR = cn({
                    "node_modules/react-reconciler/index.js": ( (e, t) => {
                        t.exports = sz()
                    }
                    )
                })
                  , az = cn({
                    "node_modules/react/cjs/react-jsx-runtime.production.js": (e => {
                        var t = Symbol.for("react.transitional.element")
                          , n = Symbol.for("react.fragment");
                        function i(s, r, l) {
                            var h = null;
                            if (l !== void 0 && (h = "" + l),
                            r.key !== void 0 && (h = "" + r.key),
                            "key"in r) {
                                l = {};
                                for (var d in r)
                                    d !== "key" && (l[d] = r[d])
                            } else
                                l = r;
                            return r = l.ref,
                            {
                                $$typeof: t,
                                type: s,
                                key: h,
                                ref: r !== void 0 ? r : null,
                                props: l
                            }
                        }
                        e.Fragment = n,
                        e.jsx = i,
                        e.jsxs = i
                    }
                    )
                })
                  , rz = cn({
                    "node_modules/react/jsx-runtime.js": ( (e, t) => {
                        t.exports = az()
                    }
                    )
                })
                  , Ut = tr(rz())
                  , oz = tr(iR())
                  , sR = tr(eM());
                const h9 = ( () => {
                    var e, t;
                    return typeof window < "u" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative")
                }
                )() ? Le.useLayoutEffect : Le.useEffect;
                function tM(e, t, n) {
                    if (!e)
                        return;
                    if (n(e) === !0)
                        return e;
                    let i = t ? e.return : e.child;
                    for (; i; ) {
                        const s = tM(i, t, n);
                        if (s)
                            return s;
                        i = t ? null : i.sibling
                    }
                }
                function aR(e) {
                    try {
                        return Object.defineProperties(e, {
                            _currentRenderer: {
                                get() {
                                    return null
                                },
                                set() {}
                            },
                            _currentRenderer2: {
                                get() {
                                    return null
                                },
                                set() {}
                            }
                        })
                    } catch {
                        return e
                    }
                }
                const nM = aR(Le.createContext(null));
                var rR = class extends Le.Component {
                    render() {
                        return Le.createElement(nM.Provider, {
                            value: this._reactInternals
                        }, this.props.children)
                    }
                }
                ;
                function oR() {
                    const e = Le.useContext(nM);
                    if (e === null)
                        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
                    const t = Le.useId();
                    return Le.useMemo( () => {
                        for (const n of [e, e?.alternate]) {
                            if (!n)
                                continue;
                            const i = tM(n, !1, s => {
                                let r = s.memoizedState;
                                for (; r; ) {
                                    if (r.memoizedState === t)
                                        return !0;
                                    r = r.next
                                }
                            }
                            );
                            if (i)
                                return i
                        }
                    }
                    , [e, t])
                }
                const lz = Symbol.for("react.context")
                  , cz = e => e !== null && typeof e == "object" && "$$typeof"in e && e.$$typeof === lz;
                function uz() {
                    const e = oR()
                      , [t] = Le.useState( () => new Map);
                    t.clear();
                    let n = e;
                    for (; n; ) {
                        const i = n.type;
                        cz(i) && i !== nM && !t.has(i) && t.set(i, Le.use(aR(i))),
                        n = n.return
                    }
                    return t
                }
                function hz() {
                    const e = uz();
                    return Le.useMemo( () => Array.from(e.keys()).reduce( (t, n) => i => Le.createElement(t, null, Le.createElement(n.Provider, {
                        ...i,
                        value: e.get(n)
                    })), t => Le.createElement(rR, {
                        ...t
                    })), [e])
                }
                function lR(e) {
                    let t = e.root;
                    for (; t.getState().previousRoot; )
                        t = t.getState().previousRoot;
                    return t
                }
                const f9 = Le.act
                  , cR = e => e && e.isOrthographicCamera
                  , fz = e => e && e.hasOwnProperty("current")
                  , dz = e => e != null && (typeof e == "string" || typeof e == "number" || e.isColor)
                  , Dv = ( (e, t) => typeof window < "u" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative"))() ? Le.useLayoutEffect : Le.useEffect;
                function iM(e) {
                    const t = Le.useRef(e);
                    return Dv( () => void (t.current = e), [e]),
                    t
                }
                function pz() {
                    const e = oR()
                      , t = hz();
                    return Le.useMemo( () => ({children: n}) => {
                        const i = tM(e, !0, s => s.type === Le.StrictMode) ? Le.StrictMode : Le.Fragment;
                        return (0,
                        Ut.jsx)(i, {
                            children: (0,
                            Ut.jsx)(t, {
                                children: n
                            })
                        })
                    }
                    , [e, t])
                }
                function mz({set: e}) {
                    return Dv( () => (e(new Promise( () => null)),
                    () => e(!1)), [e]),
                    null
                }
                const gz = (e => (e = class extends Le.Component {
                    constructor(...n) {
                        super(...n),
                        this.state = {
                            error: !1
                        }
                    }
                    componentDidCatch(n) {
                        this.props.set(n)
                    }
                    render() {
                        return this.state.error ? null : this.props.children
                    }
                }
                ,
                e.getDerivedStateFromError = () => ({
                    error: !0
                }),
                e))();
                function uR(e) {
                    var t;
                    const n = typeof window < "u" ? (t = window.devicePixelRatio) != null ? t : 2 : 1;
                    return Array.isArray(e) ? Math.min(Math.max(e[0], n), e[1]) : e
                }
                function Vp(e) {
                    var t;
                    return (t = e.__r3f) == null ? void 0 : t.root.getState()
                }
                const xi = {
                    obj: e => e === Object(e) && !xi.arr(e) && typeof e != "function",
                    fun: e => typeof e == "function",
                    str: e => typeof e == "string",
                    num: e => typeof e == "number",
                    boo: e => typeof e == "boolean",
                    und: e => e === void 0,
                    nul: e => e === null,
                    arr: e => Array.isArray(e),
                    equ(e, t, {arrays: n="shallow", objects: i="reference", strict: s=!0}={}) {
                        if (typeof e != typeof t || !!e != !!t)
                            return !1;
                        if (xi.str(e) || xi.num(e) || xi.boo(e))
                            return e === t;
                        const r = xi.obj(e);
                        if (r && i === "reference")
                            return e === t;
                        const l = xi.arr(e);
                        if (l && n === "reference")
                            return e === t;
                        if ((l || r) && e === t)
                            return !0;
                        let h;
                        for (h in e)
                            if (!(h in t))
                                return !1;
                        if (r && n === "shallow" && i === "shallow") {
                            for (h in s ? t : e)
                                if (!xi.equ(e[h], t[h], {
                                    strict: s,
                                    objects: "reference"
                                }))
                                    return !1
                        } else
                            for (h in s ? t : e)
                                if (e[h] !== t[h])
                                    return !1;
                        if (xi.und(h)) {
                            if (l && e.length === 0 && t.length === 0 || r && Object.keys(e).length === 0 && Object.keys(t).length === 0)
                                return !0;
                            if (e !== t)
                                return !1
                        }
                        return !0
                    }
                };
                function vz(e) {
                    const t = {
                        nodes: {},
                        materials: {},
                        meshes: {}
                    };
                    return e && e.traverse(n => {
                        n.name && (t.nodes[n.name] = n),
                        n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material),
                        n.isMesh && !t.meshes[n.name] && (t.meshes[n.name] = n)
                    }
                    ),
                    t
                }
                function yz(e) {
                    e.type !== "Scene" && (e.dispose == null || e.dispose());
                    for (const t in e) {
                        const n = e[t];
                        n?.type !== "Scene" && (n == null || n.dispose == null || n.dispose())
                    }
                }
                const hR = ["children", "key", "ref"];
                function _z(e) {
                    const t = {};
                    for (const n in e)
                        hR.includes(n) || (t[n] = e[n]);
                    return t
                }
                function Ex(e, t, n, i) {
                    const s = e;
                    let r = s?.__r3f;
                    return r || (r = {
                        root: t,
                        type: n,
                        parent: null,
                        children: [],
                        props: _z(i),
                        object: s,
                        eventCount: 0,
                        handlers: {},
                        isHidden: !1
                    },
                    s && (s.__r3f = r)),
                    r
                }
                function Ov(e, t) {
                    let n = e[t];
                    if (!t.includes("-"))
                        return {
                            root: e,
                            key: t,
                            target: n
                        };
                    n = e;
                    for (const s of t.split("-")) {
                        var i;
                        t = s,
                        e = n,
                        n = (i = n) == null ? void 0 : i[t]
                    }
                    return {
                        root: e,
                        key: t,
                        target: n
                    }
                }
                const fR = /-\d+$/;
                function wx(e, t) {
                    if (xi.str(t.props.attach)) {
                        if (fR.test(t.props.attach)) {
                            const s = t.props.attach.replace(fR, "")
                              , {root: r, key: l} = Ov(e.object, s);
                            Array.isArray(r[l]) || (r[l] = [])
                        }
                        const {root: n, key: i} = Ov(e.object, t.props.attach);
                        t.previousAttach = n[i],
                        n[i] = t.object
                    } else
                        xi.fun(t.props.attach) && (t.previousAttach = t.props.attach(e.object, t.object))
                }
                function Cx(e, t) {
                    if (xi.str(t.props.attach)) {
                        const {root: n, key: i} = Ov(e.object, t.props.attach)
                          , s = t.previousAttach;
                        s === void 0 ? delete n[i] : n[i] = s
                    } else
                        t.previousAttach == null || t.previousAttach(e.object, t.object);
                    delete t.previousAttach
                }
                const sM = [...hR, "args", "dispose", "attach", "object", "onUpdate", "dispose"]
                  , dR = new Map;
                function xz(e) {
                    let t = dR.get(e.constructor);
                    try {
                        t || (t = new e.constructor,
                        dR.set(e.constructor, t))
                    } catch {}
                    return t
                }
                function Sz(e, t) {
                    const n = {};
                    for (const i in t)
                        if (!sM.includes(i) && !xi.equ(t[i], e.props[i])) {
                            n[i] = t[i];
                            for (const s in t)
                                s.startsWith(`${i}-`) && (n[s] = t[s])
                        }
                    for (const i in e.props) {
                        if (sM.includes(i) || t.hasOwnProperty(i))
                            continue;
                        const {root: s, key: r} = Ov(e.object, i);
                        if (s.constructor && s.constructor.length === 0) {
                            const l = xz(s);
                            xi.und(l) || (n[r] = l[r])
                        } else
                            n[r] = 0
                    }
                    return n
                }
                const Az = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"]
                  , Tz = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
                function ju(e, t) {
                    var n;
                    const i = e.__r3f
                      , s = i && lR(i).getState()
                      , r = i?.eventCount;
                    for (const h in t) {
                        let d = t[h];
                        if (sM.includes(h))
                            continue;
                        if (i && Tz.test(h)) {
                            typeof d == "function" ? i.handlers[h] = d : delete i.handlers[h],
                            i.eventCount = Object.keys(i.handlers).length;
                            continue
                        }
                        if (d === void 0)
                            continue;
                        let {root: p, key: m, target: v} = Ov(e, h);
                        if (v instanceof mp && d instanceof mp)
                            v.mask = d.mask;
                        else if (v instanceof at && dz(d))
                            v.set(d);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && typeof v.copy == "function" && d != null && d.constructor && v.constructor === d.constructor)
                            v.copy(d);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && Array.isArray(d))
                            typeof v.fromArray == "function" ? v.fromArray(d) : v.set(...d);
                        else if (v !== null && typeof v == "object" && typeof v.set == "function" && typeof d == "number")
                            typeof v.setScalar == "function" ? v.setScalar(d) : v.set(d);
                        else {
                            var l;
                            p[m] = d,
                            s && !s.linear && Az.includes(m) && (l = p[m]) != null && l.isTexture && p[m].format === ss && p[m].type === ui && (p[m].colorSpace = $t)
                        }
                    }
                    if (i != null && i.parent && s != null && s.internal && (n = i.object) != null && n.isObject3D && r !== i.eventCount) {
                        const h = i.object
                          , d = s.internal.interaction.indexOf(h);
                        d > -1 && s.internal.interaction.splice(d, 1),
                        i.eventCount && h.raycast !== null && s.internal.interaction.push(h)
                    }
                    return i && i.props.attach === void 0 && (i.object.isBufferGeometry ? i.props.attach = "geometry" : i.object.isMaterial && (i.props.attach = "material")),
                    i && Gp(i),
                    e
                }
                function Gp(e) {
                    var t;
                    if (!e.parent)
                        return;
                    e.props.onUpdate == null || e.props.onUpdate(e.object);
                    const n = (t = e.root) == null || t.getState == null ? void 0 : t.getState();
                    n && n.internal.frames === 0 && n.invalidate()
                }
                function pR(e, t) {
                    e.manual || (cR(e) ? (e.left = t.width / -2,
                    e.right = t.width / 2,
                    e.top = t.height / 2,
                    e.bottom = t.height / -2) : e.aspect = t.width / t.height,
                    e.updateProjectionMatrix())
                }
                const La = e => e?.isObject3D;
                function Rx(e) {
                    return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId
                }
                function mR(e, t, n, i) {
                    const s = n.get(t);
                    s && (n.delete(t),
                    n.size === 0 && (e.delete(i),
                    s.target.releasePointerCapture(i)))
                }
                function Mz(e, t) {
                    const {internal: n} = e.getState();
                    n.interaction = n.interaction.filter(i => i !== t),
                    n.initialHits = n.initialHits.filter(i => i !== t),
                    n.hovered.forEach( (i, s) => {
                        (i.eventObject === t || i.object === t) && n.hovered.delete(s)
                    }
                    ),
                    n.capturedMap.forEach( (i, s) => {
                        mR(n.capturedMap, t, i, s)
                    }
                    )
                }
                function bz(e) {
                    function t(d) {
                        const {internal: p} = e.getState()
                          , m = d.offsetX - p.initialClick[0]
                          , v = d.offsetY - p.initialClick[1];
                        return Math.round(Math.sqrt(m * m + v * v))
                    }
                    function n(d) {
                        return d.filter(p => ["Move", "Over", "Enter", "Out", "Leave"].some(m => {
                            var v;
                            return (v = p.__r3f) == null ? void 0 : v.handlers["onPointer" + m]
                        }
                        ))
                    }
                    function i(d, p) {
                        const m = e.getState()
                          , v = new Set
                          , _ = []
                          , x = p ? p(m.internal.interaction) : m.internal.interaction;
                        for (let M = 0; M < x.length; M++) {
                            const D = Vp(x[M]);
                            D && (D.raycaster.camera = void 0)
                        }
                        m.previousRoot || m.events.compute == null || m.events.compute(d, m);
                        function b(M) {
                            const D = Vp(M);
                            if (!D || !D.events.enabled || D.raycaster.camera === null)
                                return [];
                            if (D.raycaster.camera === void 0) {
                                var R;
                                D.events.compute == null || D.events.compute(d, D, (R = D.previousRoot) == null ? void 0 : R.getState()),
                                D.raycaster.camera === void 0 && (D.raycaster.camera = null)
                            }
                            return D.raycaster.camera ? D.raycaster.intersectObject(M, !0) : []
                        }
                        let E = x.flatMap(b).sort( (M, D) => {
                            const R = Vp(M.object)
                              , O = Vp(D.object);
                            return !R || !O ? M.distance - D.distance : O.events.priority - R.events.priority || M.distance - D.distance
                        }
                        ).filter(M => {
                            const D = Rx(M);
                            return v.has(D) ? !1 : (v.add(D),
                            !0)
                        }
                        );
                        m.events.filter && (E = m.events.filter(E, m));
                        for (const M of E) {
                            let D = M.object;
                            for (; D; ) {
                                var T;
                                (T = D.__r3f) != null && T.eventCount && _.push({
                                    ...M,
                                    eventObject: D
                                }),
                                D = D.parent
                            }
                        }
                        if ("pointerId"in d && m.internal.capturedMap.has(d.pointerId))
                            for (let M of m.internal.capturedMap.get(d.pointerId).values())
                                v.has(Rx(M.intersection)) || _.push(M.intersection);
                        return _
                    }
                    function s(d, p, m, v) {
                        if (d.length) {
                            const _ = {
                                stopped: !1
                            };
                            for (const x of d) {
                                let b = Vp(x.object);
                                if (b || x.object.traverseAncestors(E => {
                                    const T = Vp(E);
                                    if (T)
                                        return b = T,
                                        !1
                                }
                                ),
                                b) {
                                    const {raycaster: E, pointer: T, camera: M, internal: D} = b
                                      , R = new Q(T.x,T.y,0).unproject(M)
                                      , O = P => {
                                        var L, H;
                                        return (L = (H = D.capturedMap.get(P)) == null ? void 0 : H.has(x.eventObject)) != null ? L : !1
                                    }
                                      , U = P => {
                                        const L = {
                                            intersection: x,
                                            target: p.target
                                        };
                                        D.capturedMap.has(P) ? D.capturedMap.get(P).set(x.eventObject, L) : D.capturedMap.set(P, new Map([[x.eventObject, L]])),
                                        p.target.setPointerCapture(P)
                                    }
                                      , B = P => {
                                        const L = D.capturedMap.get(P);
                                        L && mR(D.capturedMap, x.eventObject, L, P)
                                    }
                                    ;
                                    let I = {};
                                    for (let P in p) {
                                        let L = p[P];
                                        typeof L != "function" && (I[P] = L)
                                    }
                                    let F = {
                                        ...x,
                                        ...I,
                                        pointer: T,
                                        intersections: d,
                                        stopped: _.stopped,
                                        delta: m,
                                        unprojectedPoint: R,
                                        ray: E.ray,
                                        camera: M,
                                        stopPropagation() {
                                            const P = "pointerId"in p && D.capturedMap.get(p.pointerId);
                                            if ((!P || P.has(x.eventObject)) && (F.stopped = _.stopped = !0,
                                            D.hovered.size && Array.from(D.hovered.values()).find(L => L.eventObject === x.eventObject))) {
                                                const L = d.slice(0, d.indexOf(x));
                                                r([...L, x])
                                            }
                                        },
                                        target: {
                                            hasPointerCapture: O,
                                            setPointerCapture: U,
                                            releasePointerCapture: B
                                        },
                                        currentTarget: {
                                            hasPointerCapture: O,
                                            setPointerCapture: U,
                                            releasePointerCapture: B
                                        },
                                        nativeEvent: p
                                    };
                                    if (v(F),
                                    _.stopped === !0)
                                        break
                                }
                            }
                        }
                        return d
                    }
                    function r(d) {
                        const {internal: p} = e.getState();
                        for (const m of p.hovered.values())
                            if (!d.length || !d.find(v => v.object === m.object && v.index === m.index && v.instanceId === m.instanceId)) {
                                const v = m.eventObject.__r3f;
                                if (p.hovered.delete(Rx(m)),
                                v != null && v.eventCount) {
                                    const _ = v.handlers
                                      , x = {
                                        ...m,
                                        intersections: d
                                    };
                                    _.onPointerOut == null || _.onPointerOut(x),
                                    _.onPointerLeave == null || _.onPointerLeave(x)
                                }
                            }
                    }
                    function l(d, p) {
                        for (let m = 0; m < p.length; m++) {
                            const v = p[m].__r3f;
                            v == null || v.handlers.onPointerMissed == null || v.handlers.onPointerMissed(d)
                        }
                    }
                    function h(d) {
                        switch (d) {
                        case "onPointerLeave":
                        case "onPointerCancel":
                            return () => r([]);
                        case "onLostPointerCapture":
                            return p => {
                                const {internal: m} = e.getState();
                                "pointerId"in p && m.capturedMap.has(p.pointerId) && requestAnimationFrame( () => {
                                    m.capturedMap.has(p.pointerId) && (m.capturedMap.delete(p.pointerId),
                                    r([]))
                                }
                                )
                            }
                        }
                        return function(m) {
                            const {onPointerMissed: v, internal: _} = e.getState();
                            _.lastEvent.current = m;
                            const x = d === "onPointerMove"
                              , b = d === "onClick" || d === "onContextMenu" || d === "onDoubleClick"
                              , E = i(m, x ? n : void 0)
                              , T = b ? t(m) : 0;
                            d === "onPointerDown" && (_.initialClick = [m.offsetX, m.offsetY],
                            _.initialHits = E.map(D => D.eventObject)),
                            b && !E.length && T <= 2 && (l(m, _.interaction),
                            v && v(m)),
                            x && r(E);
                            function M(D) {
                                const R = D.eventObject
                                  , O = R.__r3f;
                                if (!(O != null && O.eventCount))
                                    return;
                                const U = O.handlers;
                                if (x) {
                                    if (U.onPointerOver || U.onPointerEnter || U.onPointerOut || U.onPointerLeave) {
                                        const B = Rx(D)
                                          , I = _.hovered.get(B);
                                        I ? I.stopped && D.stopPropagation() : (_.hovered.set(B, D),
                                        U.onPointerOver == null || U.onPointerOver(D),
                                        U.onPointerEnter == null || U.onPointerEnter(D))
                                    }
                                    U.onPointerMove == null || U.onPointerMove(D)
                                } else {
                                    const B = U[d];
                                    B ? (!b || _.initialHits.includes(R)) && (l(m, _.interaction.filter(I => !_.initialHits.includes(I))),
                                    B(D)) : b && _.initialHits.includes(R) && l(m, _.interaction.filter(I => !_.initialHits.includes(I)))
                                }
                            }
                            s(E, m, T, M)
                        }
                    }
                    return {
                        handlePointer: h
                    }
                }
                const gR = e => !!(e != null && e.render)
                  , aM = Le.createContext(null)
                  , Ez = (e, t) => {
                    const n = eR( (h, d) => {
                        const p = new Q
                          , m = new Q
                          , v = new Q;
                        function _(T=d().camera, M=m, D=d().size) {
                            const {width: R, height: O, top: U, left: B} = D
                              , I = R / O;
                            M.isVector3 ? v.copy(M) : v.set(...M);
                            const F = T.getWorldPosition(p).distanceTo(v);
                            if (cR(T))
                                return {
                                    width: R / T.zoom,
                                    height: O / T.zoom,
                                    top: U,
                                    left: B,
                                    factor: 1,
                                    distance: F,
                                    aspect: I
                                };
                            {
                                const P = T.fov * Math.PI / 180
                                  , L = 2 * Math.tan(P / 2) * F
                                  , H = L * (R / O);
                                return {
                                    width: H,
                                    height: L,
                                    top: U,
                                    left: B,
                                    factor: R / H,
                                    distance: F,
                                    aspect: I
                                }
                            }
                        }
                        let x;
                        const b = T => h(M => ({
                            performance: {
                                ...M.performance,
                                current: T
                            }
                        }))
                          , E = new ye;
                        return {
                            set: h,
                            get: d,
                            gl: null,
                            camera: null,
                            raycaster: null,
                            events: {
                                priority: 1,
                                enabled: !0,
                                connected: !1
                            },
                            scene: null,
                            xr: null,
                            invalidate: (T=1) => e(d(), T),
                            advance: (T, M) => t(T, M, d()),
                            legacy: !1,
                            linear: !1,
                            flat: !1,
                            controls: null,
                            clock: new PT,
                            pointer: E,
                            mouse: E,
                            frameloop: "always",
                            onPointerMissed: void 0,
                            performance: {
                                current: 1,
                                min: .5,
                                max: 1,
                                debounce: 200,
                                regress: () => {
                                    const T = d();
                                    x && clearTimeout(x),
                                    T.performance.current !== T.performance.min && b(T.performance.min),
                                    x = setTimeout( () => b(d().performance.max), T.performance.debounce)
                                }
                            },
                            size: {
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0
                            },
                            viewport: {
                                initialDpr: 0,
                                dpr: 0,
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0,
                                aspect: 0,
                                distance: 0,
                                factor: 0,
                                getCurrentViewport: _
                            },
                            setEvents: T => h(M => ({
                                ...M,
                                events: {
                                    ...M.events,
                                    ...T
                                }
                            })),
                            setSize: (T, M, D=0, R=0) => {
                                const O = d().camera
                                  , U = {
                                    width: T,
                                    height: M,
                                    top: D,
                                    left: R
                                };
                                h(B => ({
                                    size: U,
                                    viewport: {
                                        ...B.viewport,
                                        ..._(O, m, U)
                                    }
                                }))
                            }
                            ,
                            setDpr: T => h(M => {
                                const D = uR(T);
                                return {
                                    viewport: {
                                        ...M.viewport,
                                        dpr: D,
                                        initialDpr: M.viewport.initialDpr || D
                                    }
                                }
                            }
                            ),
                            setFrameloop: (T="always") => {
                                const M = d().clock;
                                M.stop(),
                                M.elapsedTime = 0,
                                T !== "never" && (M.start(),
                                M.elapsedTime = 0),
                                h( () => ({
                                    frameloop: T
                                }))
                            }
                            ,
                            previousRoot: void 0,
                            internal: {
                                interaction: [],
                                hovered: new Map,
                                subscribers: [],
                                initialClick: [0, 0],
                                initialHits: [],
                                capturedMap: new Map,
                                lastEvent: Le.createRef(),
                                active: !1,
                                frames: 0,
                                priority: 0,
                                subscribe: (T, M, D) => {
                                    const R = d().internal;
                                    return R.priority = R.priority + (M > 0 ? 1 : 0),
                                    R.subscribers.push({
                                        ref: T,
                                        priority: M,
                                        store: D
                                    }),
                                    R.subscribers = R.subscribers.sort( (O, U) => O.priority - U.priority),
                                    () => {
                                        const O = d().internal;
                                        O != null && O.subscribers && (O.priority = O.priority - (M > 0 ? 1 : 0),
                                        O.subscribers = O.subscribers.filter(U => U.ref !== T))
                                    }
                                }
                            }
                        }
                    }
                    )
                      , i = n.getState();
                    let s = i.size
                      , r = i.viewport.dpr
                      , l = i.camera;
                    return n.subscribe( () => {
                        const {camera: h, size: d, viewport: p, gl: m, set: v} = n.getState();
                        if (d.width !== s.width || d.height !== s.height || p.dpr !== r) {
                            s = d,
                            r = p.dpr,
                            pR(h, d),
                            p.dpr > 0 && m.setPixelRatio(p.dpr);
                            const _ = typeof HTMLCanvasElement < "u" && m.domElement instanceof HTMLCanvasElement;
                            m.setSize(d.width, d.height, _)
                        }
                        h !== l && (l = h,
                        v(_ => ({
                            viewport: {
                                ..._.viewport,
                                ..._.viewport.getCurrentViewport(h)
                            }
                        })))
                    }
                    ),
                    n.subscribe(h => e(h)),
                    n
                }
                ;
                function rM() {
                    const e = Le.useContext(aM);
                    if (!e)
                        throw new Error("R3F: Hooks can only be used within the Canvas component!");
                    return e
                }
                function Us(e=n => n, t) {
                    return rM()(e, t)
                }
                function Nv(e, t=0) {
                    const n = rM()
                      , i = n.getState().internal.subscribe
                      , s = iM(e);
                    return Dv( () => i(s, t, n), [t, i, n]),
                    null
                }
                const vR = new WeakMap
                  , wz = e => {
                    var t;
                    return typeof e == "function" && (e == null || (t = e.prototype) == null ? void 0 : t.constructor) === e
                }
                ;
                function yR(e, t) {
                    return function(n, ...i) {
                        let s;
                        return wz(n) ? (s = vR.get(n),
                        s || (s = new n,
                        vR.set(n, s))) : s = n,
                        e && e(s),
                        Promise.all(i.map(r => new Promise( (l, h) => s.load(r, d => {
                            La(d?.scene) && Object.assign(d, vz(d.scene)),
                            l(d)
                        }
                        , t, d => h(new Error(`Could not load ${r}: ${d?.message}`))))))
                    }
                }
                function _R(e, t, n, i) {
                    const s = Array.isArray(t) ? t : [t]
                      , r = ez(yR(n, i), [e, ...s], {
                        equal: xi.equ
                    });
                    return Array.isArray(t) ? r : r[0]
                }
                _R.preload = function(e, t, n) {
                    const i = Array.isArray(t) ? t : [t];
                    return tz(yR(n), [e, ...i])
                }
                ,
                _R.clear = function(e, t) {
                    return nz([e, ...Array.isArray(t) ? t : [t]])
                }
                ;
                function Cz(e) {
                    const t = (0,
                    oz.default)(e);
                    return t.injectIntoDevTools({
                        bundleType: 0,
                        rendererPackageName: "@react-three/fiber",
                        version: Le.version
                    }),
                    t
                }
                const xR = 0
                  , kp = {}
                  , Rz = /^three(?=[A-Z])/
                  , Dx = e => `${e[0].toUpperCase()}${e.slice(1)}`;
                let Dz = 0;
                const Oz = e => typeof e == "function";
                function SR(e) {
                    if (Oz(e)) {
                        const t = `${Dz++}`;
                        return kp[t] = e,
                        t
                    } else
                        Object.assign(kp, e)
                }
                function AR(e, t) {
                    const n = Dx(e)
                      , i = kp[n];
                    if (e !== "primitive" && !i)
                        throw new Error(`R3F: ${n} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
                    if (e === "primitive" && !t.object)
                        throw new Error("R3F: Primitives without 'object' are invalid!");
                    if (t.args !== void 0 && !Array.isArray(t.args))
                        throw new Error("R3F: The args prop must be an array!")
                }
                function Nz(e, t, n) {
                    var i;
                    return e = Dx(e)in kp ? e : e.replace(Rz, ""),
                    AR(e, t),
                    e === "primitive" && (i = t.object) != null && i.__r3f && delete t.object.__r3f,
                    Ex(t.object, n, e, t)
                }
                function Uz(e) {
                    if (!e.isHidden) {
                        var t;
                        e.props.attach && (t = e.parent) != null && t.object ? Cx(e.parent, e) : La(e.object) && (e.object.visible = !1),
                        e.isHidden = !0,
                        Gp(e)
                    }
                }
                function TR(e) {
                    if (e.isHidden) {
                        var t;
                        e.props.attach && (t = e.parent) != null && t.object ? wx(e.parent, e) : La(e.object) && e.props.visible !== !1 && (e.object.visible = !0),
                        e.isHidden = !1,
                        Gp(e)
                    }
                }
                function oM(e, t, n) {
                    const i = t.root.getState();
                    if (!(!e.parent && e.object !== i.scene)) {
                        if (!t.object) {
                            var s, r;
                            const l = kp[Dx(t.type)];
                            t.object = (s = t.props.object) != null ? s : new l(...(r = t.props.args) != null ? r : []),
                            t.object.__r3f = t
                        }
                        if (ju(t.object, t.props),
                        t.props.attach)
                            wx(e, t);
                        else if (La(t.object) && La(e.object)) {
                            const l = e.object.children.indexOf(n?.object);
                            if (n && l !== -1) {
                                const h = e.object.children.indexOf(t.object);
                                if (h !== -1) {
                                    e.object.children.splice(h, 1);
                                    const d = h < l ? l - 1 : l;
                                    e.object.children.splice(d, 0, t.object)
                                } else
                                    t.object.parent = e.object,
                                    e.object.children.splice(l, 0, t.object),
                                    t.object.dispatchEvent({
                                        type: "added"
                                    }),
                                    e.object.dispatchEvent({
                                        type: "childadded",
                                        child: t.object
                                    })
                            } else
                                e.object.add(t.object)
                        }
                        for (const l of t.children)
                            oM(t, l);
                        Gp(t)
                    }
                }
                function lM(e, t) {
                    t && (t.parent = e,
                    e.children.push(t),
                    oM(e, t))
                }
                function MR(e, t, n) {
                    if (!t || !n)
                        return;
                    t.parent = e;
                    const i = e.children.indexOf(n);
                    i !== -1 ? e.children.splice(i, 0, t) : e.children.push(t),
                    oM(e, t, n)
                }
                function bR(e) {
                    if (typeof e.dispose == "function") {
                        const t = () => {
                            try {
                                e.dispose()
                            } catch {}
                        }
                        ;
                        typeof IS_REACT_ACT_ENVIRONMENT < "u" ? t() : (0,
                        sR.unstable_scheduleCallback)(sR.unstable_IdlePriority, t)
                    }
                }
                function cM(e, t, n) {
                    if (!t)
                        return;
                    t.parent = null;
                    const i = e.children.indexOf(t);
                    i !== -1 && e.children.splice(i, 1),
                    t.props.attach ? Cx(e, t) : La(t.object) && La(e.object) && (e.object.remove(t.object),
                    Mz(lR(t), t.object));
                    const s = t.props.dispose !== null && n !== !1;
                    for (let r = t.children.length - 1; r >= 0; r--) {
                        const l = t.children[r];
                        cM(t, l, s)
                    }
                    t.children.length = 0,
                    delete t.object.__r3f,
                    s && t.type !== "primitive" && t.object.type !== "Scene" && bR(t.object),
                    n === void 0 && Gp(t)
                }
                function Bz(e, t) {
                    for (const n of [e, e.alternate])
                        if (n !== null)
                            if (typeof n.ref == "function") {
                                n.refCleanup == null || n.refCleanup();
                                const i = n.ref(t);
                                typeof i == "function" && (n.refCleanup = i)
                            } else
                                n.ref && (n.ref.current = t)
                }
                const Ox = [];
                function Pz() {
                    for (const [n] of Ox) {
                        const i = n.parent;
                        if (i) {
                            n.props.attach ? Cx(i, n) : La(n.object) && La(i.object) && i.object.remove(n.object);
                            for (const s of n.children)
                                s.props.attach ? Cx(n, s) : La(s.object) && La(n.object) && n.object.remove(s.object)
                        }
                        n.isHidden && TR(n),
                        n.object.__r3f && delete n.object.__r3f,
                        n.type !== "primitive" && bR(n.object)
                    }
                    for (const [n,i,s] of Ox) {
                        n.props = i;
                        const r = n.parent;
                        if (r) {
                            var e, t;
                            const l = kp[Dx(n.type)];
                            n.object = (e = n.props.object) != null ? e : new l(...(t = n.props.args) != null ? t : []),
                            n.object.__r3f = n,
                            Bz(s, n.object),
                            ju(n.object, n.props),
                            n.props.attach ? wx(r, n) : La(n.object) && La(r.object) && r.object.add(n.object);
                            for (const h of n.children)
                                h.props.attach ? wx(n, h) : La(h.object) && La(n.object) && n.object.add(h.object);
                            Gp(n)
                        }
                    }
                    Ox.length = 0
                }
                const uM = () => {}
                  , ER = {};
                let Nx = xR;
                const Iz = 0
                  , Lz = 4
                  , Ux = Cz({
                    isPrimaryRenderer: !1,
                    warnsIfNotActing: !1,
                    supportsMutation: !0,
                    supportsPersistence: !1,
                    supportsHydration: !1,
                    createInstance: Nz,
                    removeChild: cM,
                    appendChild: lM,
                    appendInitialChild: lM,
                    insertBefore: MR,
                    appendChildToContainer(e, t) {
                        const n = e.getState().scene.__r3f;
                        !t || !n || lM(n, t)
                    },
                    removeChildFromContainer(e, t) {
                        const n = e.getState().scene.__r3f;
                        !t || !n || cM(n, t)
                    },
                    insertInContainerBefore(e, t, n) {
                        const i = e.getState().scene.__r3f;
                        !t || !n || !i || MR(i, t, n)
                    },
                    getRootHostContext: () => ER,
                    getChildHostContext: () => ER,
                    commitUpdate(e, t, n, i, s) {
                        var r, l, h;
                        AR(t, i);
                        let d = !1;
                        if ((e.type === "primitive" && n.object !== i.object || ((r = i.args) == null ? void 0 : r.length) !== ((l = n.args) == null ? void 0 : l.length) || (h = i.args) != null && h.some( (p, m) => {
                            var v;
                            return p !== ((v = n.args) == null ? void 0 : v[m])
                        }
                        )) && (d = !0),
                        d)
                            Ox.push([e, {
                                ...i
                            }, s]);
                        else {
                            const p = Sz(e, i);
                            Object.keys(p).length && (Object.assign(e.props, p),
                            ju(e.object, p))
                        }
                        (s.sibling === null || (s.flags & Lz) === Iz) && Pz()
                    },
                    finalizeInitialChildren: () => !1,
                    commitMount() {},
                    getPublicInstance: e => e?.object,
                    prepareForCommit: () => null,
                    preparePortalMount: e => Ex(e.getState().scene, e, "", {}),
                    resetAfterCommit: () => {}
                    ,
                    shouldSetTextContent: () => !1,
                    clearContainer: () => !1,
                    hideInstance: Uz,
                    unhideInstance: TR,
                    createTextInstance: uM,
                    hideTextInstance: uM,
                    unhideTextInstance: uM,
                    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
                    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
                    noTimeout: -1,
                    getInstanceFromNode: () => null,
                    beforeActiveInstanceBlur() {},
                    afterActiveInstanceBlur() {},
                    detachDeletedInstance() {},
                    prepareScopeUpdate() {},
                    getInstanceFromScope: () => null,
                    shouldAttemptEagerTransition: () => !1,
                    trackSchedulerEvent: () => {}
                    ,
                    resolveEventType: () => null,
                    resolveEventTimeStamp: () => -1.1,
                    requestPostPaintCallback() {},
                    maySuspendCommit: () => !1,
                    preloadInstance: () => !0,
                    startSuspendingCommit() {},
                    suspendInstance() {},
                    waitForCommitToBeReady: () => null,
                    NotPendingTransition: null,
                    HostTransitionContext: Le.createContext(null),
                    setCurrentUpdatePriority(e) {
                        Nx = e
                    },
                    getCurrentUpdatePriority() {
                        return Nx
                    },
                    resolveUpdatePriority() {
                        var e;
                        if (Nx !== xR)
                            return Nx;
                        switch (typeof window < "u" && ((e = window.event) == null ? void 0 : e.type)) {
                        case "click":
                        case "contextmenu":
                        case "dblclick":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                            return Dy.DiscreteEventPriority;
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerenter":
                        case "pointerleave":
                        case "wheel":
                            return Dy.ContinuousEventPriority;
                        default:
                            return Dy.DefaultEventPriority
                        }
                    },
                    resetFormInstance() {}
                })
                  , Nf = new Map
                  , Xp = {
                    objects: "shallow",
                    strict: !1
                };
                function zz(e, t) {
                    if (!t && typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && e.parentElement) {
                        const {width: n, height: i, top: s, left: r} = e.parentElement.getBoundingClientRect();
                        return {
                            width: n,
                            height: i,
                            top: s,
                            left: r
                        }
                    } else if (!t && typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)
                        return {
                            width: e.width,
                            height: e.height,
                            top: 0,
                            left: 0
                        };
                    return {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        ...t
                    }
                }
                function Fz(e) {
                    const t = Nf.get(e)
                      , n = t?.fiber
                      , i = t?.store;
                    t && console.warn("R3F.createRoot should only be called once!");
                    const s = typeof reportError == "function" ? reportError : console.error
                      , r = i || Ez(vM, DR)
                      , l = n || Ux.createContainer(r, Dy.ConcurrentRoot, null, !1, null, "", s, s, s, null);
                    t || Nf.set(e, {
                        fiber: l,
                        store: r
                    });
                    let h, d, p = !1, m = null;
                    return {
                        async configure(v={}) {
                            let _;
                            m = new Promise(X => _ = X);
                            let {gl: x, size: b, scene: E, events: T, onCreated: M, shadows: D=!1, linear: R=!1, flat: O=!1, legacy: U=!1, orthographic: B=!1, frameloop: I="always", dpr: F=[1, 2], performance: P, raycaster: L, camera: H, onPointerMissed: Z} = v
                              , K = r.getState()
                              , te = K.gl;
                            if (!K.gl) {
                                const X = {
                                    canvas: e,
                                    powerPreference: "high-performance",
                                    antialias: !0,
                                    alpha: !0
                                }
                                  , J = typeof x == "function" ? await x(X) : x;
                                gR(J) ? te = J : te = new K1({
                                    ...X,
                                    ...x
                                }),
                                K.set({
                                    gl: te
                                })
                            }
                            let ce = K.raycaster;
                            ce || K.set({
                                raycaster: ce = new FT
                            });
                            const {params: G, ...V} = L || {};
                            if (xi.equ(V, ce, Xp) || ju(ce, {
                                ...V
                            }),
                            xi.equ(G, ce.params, Xp) || ju(ce, {
                                params: {
                                    ...ce.params,
                                    ...G
                                }
                            }),
                            !K.camera || K.camera === d && !xi.equ(d, H, Xp)) {
                                d = H;
                                const X = H?.isCamera
                                  , J = X ? H : B ? new Yu(0,0,0,0,.1,1e3) : new hi(75,0,.1,1e3);
                                X || (J.position.z = 5,
                                H && (ju(J, H),
                                J.manual || ("aspect"in H || "left"in H || "right"in H || "bottom"in H || "top"in H) && (J.manual = !0,
                                J.updateProjectionMatrix())),
                                !K.camera && !(H != null && H.rotation) && J.lookAt(0, 0, 0)),
                                K.set({
                                    camera: J
                                }),
                                ce.camera = J
                            }
                            if (!K.scene) {
                                let X;
                                E != null && E.isScene ? (X = E,
                                Ex(X, r, "", {})) : (X = new bp,
                                Ex(X, r, "", {}),
                                E && ju(X, E)),
                                K.set({
                                    scene: X
                                })
                            }
                            T && !K.events.handlers && K.set({
                                events: T(r)
                            });
                            const q = zz(e, b);
                            if (xi.equ(q, K.size, Xp) || K.setSize(q.width, q.height, q.top, q.left),
                            F && K.viewport.dpr !== uR(F) && K.setDpr(F),
                            K.frameloop !== I && K.setFrameloop(I),
                            K.onPointerMissed || K.set({
                                onPointerMissed: Z
                            }),
                            P && !xi.equ(P, K.performance, Xp) && K.set(X => ({
                                performance: {
                                    ...X.performance,
                                    ...P
                                }
                            })),
                            !K.xr) {
                                var ee;
                                const X = (xe, le) => {
                                    const Ne = r.getState();
                                    Ne.frameloop !== "never" && DR(xe, !0, Ne, le)
                                }
                                  , J = () => {
                                    const xe = r.getState();
                                    xe.gl.xr.enabled = xe.gl.xr.isPresenting,
                                    xe.gl.xr.setAnimationLoop(xe.gl.xr.isPresenting ? X : null),
                                    xe.gl.xr.isPresenting || vM(xe)
                                }
                                  , ze = {
                                    connect() {
                                        const xe = r.getState().gl;
                                        xe.xr.addEventListener("sessionstart", J),
                                        xe.xr.addEventListener("sessionend", J)
                                    },
                                    disconnect() {
                                        const xe = r.getState().gl;
                                        xe.xr.removeEventListener("sessionstart", J),
                                        xe.xr.removeEventListener("sessionend", J)
                                    }
                                };
                                typeof ((ee = te.xr) == null ? void 0 : ee.addEventListener) == "function" && ze.connect(),
                                K.set({
                                    xr: ze
                                })
                            }
                            if (te.shadowMap) {
                                const X = te.shadowMap.enabled
                                  , J = te.shadowMap.type;
                                if (te.shadowMap.enabled = !!D,
                                xi.boo(D))
                                    te.shadowMap.type = Og;
                                else if (xi.str(D)) {
                                    var se;
                                    const ze = {
                                        basic: uE,
                                        percentage: Oy,
                                        soft: Og,
                                        variance: Lo
                                    };
                                    te.shadowMap.type = (se = ze[D]) != null ? se : Og
                                } else
                                    xi.obj(D) && Object.assign(te.shadowMap, D);
                                (X !== te.shadowMap.enabled || J !== te.shadowMap.type) && (te.shadowMap.needsUpdate = !0)
                            }
                            return An.enabled = !U,
                            p || (te.outputColorSpace = R ? Ll : $t,
                            te.toneMapping = O ? zo : hA),
                            K.legacy !== U && K.set( () => ({
                                legacy: U
                            })),
                            K.linear !== R && K.set( () => ({
                                linear: R
                            })),
                            K.flat !== O && K.set( () => ({
                                flat: O
                            })),
                            x && !xi.fun(x) && !gR(x) && !xi.equ(x, te, Xp) && ju(te, x),
                            h = M,
                            p = !0,
                            _(),
                            this
                        },
                        render(v) {
                            return !p && !m && this.configure(),
                            m.then( () => {
                                Ux.updateContainer((0,
                                Ut.jsx)(Hz, {
                                    store: r,
                                    children: v,
                                    onCreated: h,
                                    rootElement: e
                                }), l, null, () => {}
                                )
                            }
                            ),
                            r
                        },
                        unmount() {
                            wR(e)
                        }
                    }
                }
                function Hz({store: e, children: t, onCreated: n, rootElement: i}) {
                    return Dv( () => {
                        const s = e.getState();
                        s.set(r => ({
                            internal: {
                                ...r.internal,
                                active: !0
                            }
                        })),
                        n && n(s),
                        e.getState().events.connected || s.events.connect == null || s.events.connect(i)
                    }
                    , []),
                    (0,
                    Ut.jsx)(aM.Provider, {
                        value: e,
                        children: t
                    })
                }
                function wR(e, t) {
                    const n = Nf.get(e)
                      , i = n?.fiber;
                    if (i) {
                        const s = n?.store.getState();
                        s && (s.internal.active = !1),
                        Ux.updateContainer(null, i, null, () => {
                            s && setTimeout( () => {
                                try {
                                    var r, l, h, d;
                                    s.events.disconnect == null || s.events.disconnect(),
                                    (r = s.gl) == null || (l = r.renderLists) == null || l.dispose == null || l.dispose(),
                                    (h = s.gl) == null || h.forceContextLoss == null || h.forceContextLoss(),
                                    (d = s.gl) != null && d.xr && s.xr.disconnect(),
                                    yz(s.scene),
                                    Nf.delete(e),
                                    t && t(e)
                                } catch {}
                            }
                            , 500)
                        }
                        )
                    }
                }
                function Vz(e, t, n) {
                    return (0,
                    Ut.jsx)(Gz, {
                        children: e,
                        container: t,
                        state: n
                    })
                }
                function Gz({state: e={}, children: t, container: n}) {
                    const {events: i, size: s, ...r} = e
                      , l = rM()
                      , [h] = Le.useState( () => new FT)
                      , [d] = Le.useState( () => new ye)
                      , p = iM( (v, _) => {
                        let x;
                        if (_.camera && s) {
                            const b = _.camera;
                            x = v.viewport.getCurrentViewport(b, new Q, s),
                            b !== v.camera && pR(b, s)
                        }
                        return {
                            ...v,
                            ..._,
                            scene: n,
                            raycaster: h,
                            pointer: d,
                            mouse: d,
                            previousRoot: l,
                            events: {
                                ...v.events,
                                ..._.events,
                                ...i
                            },
                            size: {
                                ...v.size,
                                ...s
                            },
                            viewport: {
                                ...v.viewport,
                                ...x
                            },
                            setEvents: b => _.set(E => ({
                                ...E,
                                events: {
                                    ...E.events,
                                    ...b
                                }
                            }))
                        }
                    }
                    )
                      , m = Le.useMemo( () => {
                        const v = eR( (x, b) => ({
                            ...r,
                            set: x,
                            get: b
                        }))
                          , _ = x => v.setState(b => p.current(x, b));
                        return _(l.getState()),
                        l.subscribe(_),
                        v
                    }
                    , [l, n]);
                    return (0,
                    Ut.jsx)(Ut.Fragment, {
                        children: Ux.createPortal((0,
                        Ut.jsx)(aM.Provider, {
                            value: m,
                            children: t
                        }), m, null)
                    })
                }
                const kz = new Set
                  , Xz = new Set
                  , qz = new Set;
                function hM(e, t) {
                    if (e.size)
                        for (const {callback: n} of e.values())
                            n(t)
                }
                function Uv(e, t) {
                    switch (e) {
                    case "before":
                        return hM(kz, t);
                    case "after":
                        return hM(Xz, t);
                    case "tail":
                        return hM(qz, t)
                    }
                }
                let fM, dM;
                function pM(e, t, n) {
                    let i = t.clock.getDelta();
                    t.frameloop === "never" && typeof e == "number" && (i = e - t.clock.elapsedTime,
                    t.clock.oldTime = t.clock.elapsedTime,
                    t.clock.elapsedTime = e),
                    fM = t.internal.subscribers;
                    for (let s = 0; s < fM.length; s++)
                        dM = fM[s],
                        dM.ref.current(dM.store.getState(), i, n);
                    return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera),
                    t.internal.frames = Math.max(0, t.internal.frames - 1),
                    t.frameloop === "always" ? 1 : t.internal.frames
                }
                let Bx = !1, mM = !1, gM, CR, qp;
                function RR(e) {
                    CR = requestAnimationFrame(RR),
                    Bx = !0,
                    gM = 0,
                    Uv("before", e),
                    mM = !0;
                    for (const n of Nf.values()) {
                        var t;
                        qp = n.store.getState(),
                        qp.internal.active && (qp.frameloop === "always" || qp.internal.frames > 0) && !((t = qp.gl.xr) != null && t.isPresenting) && (gM += pM(e, qp))
                    }
                    if (mM = !1,
                    Uv("after", e),
                    gM === 0)
                        return Uv("tail", e),
                        Bx = !1,
                        cancelAnimationFrame(CR)
                }
                function vM(e, t=1) {
                    var n;
                    if (!e)
                        return Nf.forEach(i => vM(i.store.getState(), t));
                    (n = e.gl.xr) != null && n.isPresenting || !e.internal.active || e.frameloop === "never" || (t > 1 ? e.internal.frames = Math.min(60, e.internal.frames + t) : mM ? e.internal.frames = 2 : e.internal.frames = 1,
                    Bx || (Bx = !0,
                    requestAnimationFrame(RR)))
                }
                function DR(e, t=!0, n, i) {
                    if (t && Uv("before", e),
                    n)
                        pM(e, n, i);
                    else
                        for (const s of Nf.values())
                            pM(e, s.store.getState());
                    t && Uv("after", e)
                }
                const yM = {
                    onClick: ["click", !1],
                    onContextMenu: ["contextmenu", !1],
                    onDoubleClick: ["dblclick", !1],
                    onWheel: ["wheel", !0],
                    onPointerDown: ["pointerdown", !0],
                    onPointerUp: ["pointerup", !0],
                    onPointerLeave: ["pointerleave", !0],
                    onPointerMove: ["pointermove", !0],
                    onPointerCancel: ["pointercancel", !0],
                    onLostPointerCapture: ["lostpointercapture", !0]
                };
                function Yz(e) {
                    const {handlePointer: t} = bz(e);
                    return {
                        priority: 1,
                        enabled: !0,
                        compute(n, i, s) {
                            i.pointer.set(n.offsetX / i.size.width * 2 - 1, -(n.offsetY / i.size.height) * 2 + 1),
                            i.raycaster.setFromCamera(i.pointer, i.camera)
                        },
                        connected: void 0,
                        handlers: Object.keys(yM).reduce( (n, i) => ({
                            ...n,
                            [i]: t(i)
                        }), {}),
                        update: () => {
                            var n;
                            const {events: i, internal: s} = e.getState();
                            (n = s.lastEvent) != null && n.current && i.handlers && i.handlers.onPointerMove(s.lastEvent.current)
                        }
                        ,
                        connect: n => {
                            const {set: i, events: s} = e.getState();
                            if (s.disconnect == null || s.disconnect(),
                            i(r => ({
                                events: {
                                    ...r.events,
                                    connected: n
                                }
                            })),
                            s.handlers)
                                for (const r in s.handlers) {
                                    const l = s.handlers[r]
                                      , [h,d] = yM[r];
                                    n.addEventListener(h, l, {
                                        passive: d
                                    })
                                }
                        }
                        ,
                        disconnect: () => {
                            const {set: n, events: i} = e.getState();
                            if (i.connected) {
                                if (i.handlers)
                                    for (const s in i.handlers) {
                                        const r = i.handlers[s]
                                          , [l] = yM[s];
                                        i.connected.removeEventListener(l, r)
                                    }
                                n(s => ({
                                    events: {
                                        ...s.events,
                                        connected: void 0
                                    }
                                }))
                            }
                        }
                    }
                }
                function OR(e, t) {
                    let n;
                    return (...i) => {
                        window.clearTimeout(n),
                        n = window.setTimeout( () => e(...i), t)
                    }
                }
                function Wz({debounce: e, scroll: t, polyfill: n, offsetSize: i}={
                    debounce: 0,
                    scroll: !1,
                    offsetSize: !1
                }) {
                    const s = n || (typeof window > "u" ? class {
                    }
                    : window.ResizeObserver);
                    if (!s)
                        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
                    const [r,l] = (0,
                    Le.useState)({
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0,
                        bottom: 0,
                        right: 0,
                        x: 0,
                        y: 0
                    })
                      , h = (0,
                    Le.useRef)({
                        element: null,
                        scrollContainers: null,
                        resizeObserver: null,
                        lastBounds: r,
                        orientationHandler: null
                    })
                      , d = e ? typeof e == "number" ? e : e.scroll : null
                      , p = e ? typeof e == "number" ? e : e.resize : null
                      , m = (0,
                    Le.useRef)(!1);
                    (0,
                    Le.useEffect)( () => (m.current = !0,
                    () => void (m.current = !1)));
                    const [v,_,x] = (0,
                    Le.useMemo)( () => {
                        const M = () => {
                            if (!h.current.element)
                                return;
                            const {left: D, top: R, width: O, height: U, bottom: B, right: I, x: F, y: P} = h.current.element.getBoundingClientRect()
                              , L = {
                                left: D,
                                top: R,
                                width: O,
                                height: U,
                                bottom: B,
                                right: I,
                                x: F,
                                y: P
                            };
                            h.current.element instanceof HTMLElement && i && (L.height = h.current.element.offsetHeight,
                            L.width = h.current.element.offsetWidth),
                            Object.freeze(L),
                            m.current && !Kz(h.current.lastBounds, L) && l(h.current.lastBounds = L)
                        }
                        ;
                        return [M, p ? OR(M, p) : M, d ? OR(M, d) : M]
                    }
                    , [l, i, d, p]);
                    function b() {
                        h.current.scrollContainers && (h.current.scrollContainers.forEach(M => M.removeEventListener("scroll", x, !0)),
                        h.current.scrollContainers = null),
                        h.current.resizeObserver && (h.current.resizeObserver.disconnect(),
                        h.current.resizeObserver = null),
                        h.current.orientationHandler && ("orientation"in screen && "removeEventListener"in screen.orientation ? screen.orientation.removeEventListener("change", h.current.orientationHandler) : "onorientationchange"in window && window.removeEventListener("orientationchange", h.current.orientationHandler))
                    }
                    function E() {
                        h.current.element && (h.current.resizeObserver = new s(x),
                        h.current.resizeObserver.observe(h.current.element),
                        t && h.current.scrollContainers && h.current.scrollContainers.forEach(M => M.addEventListener("scroll", x, {
                            capture: !0,
                            passive: !0
                        })),
                        h.current.orientationHandler = () => {
                            x()
                        }
                        ,
                        "orientation"in screen && "addEventListener"in screen.orientation ? screen.orientation.addEventListener("change", h.current.orientationHandler) : "onorientationchange"in window && window.addEventListener("orientationchange", h.current.orientationHandler))
                    }
                    const T = M => {
                        !M || M === h.current.element || (b(),
                        h.current.element = M,
                        h.current.scrollContainers = NR(M),
                        E())
                    }
                    ;
                    return Qz(x, !!t),
                    jz(_),
                    (0,
                    Le.useEffect)( () => {
                        b(),
                        E()
                    }
                    , [t, x, _]),
                    (0,
                    Le.useEffect)( () => b, []),
                    [T, r, v]
                }
                function jz(e) {
                    (0,
                    Le.useEffect)( () => {
                        const t = e;
                        return window.addEventListener("resize", t),
                        () => void window.removeEventListener("resize", t)
                    }
                    , [e])
                }
                function Qz(e, t) {
                    (0,
                    Le.useEffect)( () => {
                        if (t) {
                            const n = e;
                            return window.addEventListener("scroll", n, {
                                capture: !0,
                                passive: !0
                            }),
                            () => void window.removeEventListener("scroll", n, !0)
                        }
                    }
                    , [e, t])
                }
                function NR(e) {
                    const t = [];
                    if (!e || e === document.body)
                        return t;
                    const {overflow: n, overflowX: i, overflowY: s} = window.getComputedStyle(e);
                    return [n, i, s].some(r => r === "auto" || r === "scroll") && t.push(e),
                    [...t, ...NR(e.parentElement)]
                }
                const Zz = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
                  , Kz = (e, t) => Zz.every(n => e[n] === t[n]);
                var p9 = tr(rE())
                  , m9 = tr(iR())
                  , g9 = tr(eM());
                function Jz({ref: e, children: t, fallback: n, resize: i, style: s, gl: r, events: l=Yz, eventSource: h, eventPrefix: d, shadows: p, linear: m, flat: v, legacy: _, orthographic: x, frameloop: b, dpr: E, performance: T, raycaster: M, camera: D, scene: R, onPointerMissed: O, onCreated: U, ...B}) {
                    Le.useMemo( () => SR(GI), []);
                    const I = pz()
                      , [F,P] = Wz({
                        scroll: !0,
                        debounce: {
                            scroll: 50,
                            resize: 0
                        },
                        ...i
                    })
                      , L = Le.useRef(null)
                      , H = Le.useRef(null);
                    Le.useImperativeHandle(e, () => L.current);
                    const Z = iM(O)
                      , [K,te] = Le.useState(!1)
                      , [ce,G] = Le.useState(!1);
                    if (K)
                        throw K;
                    if (ce)
                        throw ce;
                    const V = Le.useRef(null);
                    return Dv( () => {
                        const q = L.current;
                        if (P.width > 0 && P.height > 0 && q) {
                            V.current || (V.current = Fz(q));
                            async function ee() {
                                await V.current.configure({
                                    gl: r,
                                    scene: R,
                                    events: l,
                                    shadows: p,
                                    linear: m,
                                    flat: v,
                                    legacy: _,
                                    orthographic: x,
                                    frameloop: b,
                                    dpr: E,
                                    performance: T,
                                    raycaster: M,
                                    camera: D,
                                    size: P,
                                    onPointerMissed: (...se) => Z.current == null ? void 0 : Z.current(...se),
                                    onCreated: se => {
                                        se.events.connect == null || se.events.connect(h ? fz(h) ? h.current : h : H.current),
                                        d && se.setEvents({
                                            compute: (X, J) => {
                                                const ze = X[d + "X"]
                                                  , xe = X[d + "Y"];
                                                J.pointer.set(ze / J.size.width * 2 - 1, -(xe / J.size.height) * 2 + 1),
                                                J.raycaster.setFromCamera(J.pointer, J.camera)
                                            }
                                        }),
                                        U?.(se)
                                    }
                                }),
                                V.current.render((0,
                                Ut.jsx)(I, {
                                    children: (0,
                                    Ut.jsx)(gz, {
                                        set: G,
                                        children: (0,
                                        Ut.jsx)(Le.Suspense, {
                                            fallback: (0,
                                            Ut.jsx)(mz, {
                                                set: te
                                            }),
                                            children: t ?? null
                                        })
                                    })
                                }))
                            }
                            ee()
                        }
                    }
                    ),
                    Le.useEffect( () => {
                        const q = L.current;
                        if (q)
                            return () => wR(q)
                    }
                    , []),
                    (0,
                    Ut.jsx)("div", {
                        ref: H,
                        style: {
                            position: "relative",
                            width: "100%",
                            height: "100%",
                            overflow: "hidden",
                            pointerEvents: h ? "none" : "auto",
                            ...s
                        },
                        ...B,
                        children: (0,
                        Ut.jsx)("div", {
                            ref: F,
                            style: {
                                width: "100%",
                                height: "100%"
                            },
                            children: (0,
                            Ut.jsx)("canvas", {
                                ref: L,
                                style: {
                                    display: "block"
                                },
                                children: n
                            })
                        })
                    })
                }
                function $z(e) {
                    return (0,
                    Ut.jsx)(rR, {
                        children: (0,
                        Ut.jsx)(Jz, {
                            ...e
                        })
                    })
                }
                function _M() {
                    return _M = Object.assign ? Object.assign.bind() : function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = arguments[t];
                            for (var i in n)
                                ({}).hasOwnProperty.call(n, i) && (e[i] = n[i])
                        }
                        return e
                    }
                    ,
                    _M.apply(null, arguments)
                }
                var eF = Object.defineProperty
                  , tF = (e, t, n) => t in e ? eF(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : e[t] = n
                  , nF = (e, t, n) => (tF(e, typeof t != "symbol" ? t + "" : t, n),
                n)
                  , iF = class {
                    constructor() {
                        nF(this, "_listeners")
                    }
                    addEventListener(e, t) {
                        this._listeners === void 0 && (this._listeners = {});
                        const n = this._listeners;
                        n[e] === void 0 && (n[e] = []),
                        n[e].indexOf(t) === -1 && n[e].push(t)
                    }
                    hasEventListener(e, t) {
                        if (this._listeners === void 0)
                            return !1;
                        const n = this._listeners;
                        return n[e] !== void 0 && n[e].indexOf(t) !== -1
                    }
                    removeEventListener(e, t) {
                        if (this._listeners === void 0)
                            return;
                        const n = this._listeners[e];
                        if (n !== void 0) {
                            const i = n.indexOf(t);
                            i !== -1 && n.splice(i, 1)
                        }
                    }
                    dispatchEvent(e) {
                        if (this._listeners === void 0)
                            return;
                        const t = this._listeners[e.type];
                        if (t !== void 0) {
                            e.target = this;
                            const n = t.slice(0);
                            for (let i = 0, s = n.length; i < s; i++)
                                n[i].call(this, e);
                            e.target = null
                        }
                    }
                }
                  , sF = Object.defineProperty
                  , aF = (e, t, n) => t in e ? sF(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : e[t] = n
                  , zt = (e, t, n) => (aF(e, typeof t != "symbol" ? t + "" : t, n),
                n);
                const Px = new hf
                  , UR = new Rc
                  , rF = Math.cos(70 * (Math.PI / 180))
                  , BR = (e, t) => (e % t + t) % t;
                var oF = class extends iF {
                    constructor(e, t) {
                        super(),
                        zt(this, "object"),
                        zt(this, "domElement"),
                        zt(this, "enabled", !0),
                        zt(this, "target", new Q),
                        zt(this, "minDistance", 0),
                        zt(this, "maxDistance", 1 / 0),
                        zt(this, "minZoom", 0),
                        zt(this, "maxZoom", 1 / 0),
                        zt(this, "minPolarAngle", 0),
                        zt(this, "maxPolarAngle", Math.PI),
                        zt(this, "minAzimuthAngle", -1 / 0),
                        zt(this, "maxAzimuthAngle", 1 / 0),
                        zt(this, "enableDamping", !1),
                        zt(this, "dampingFactor", .05),
                        zt(this, "enableZoom", !0),
                        zt(this, "zoomSpeed", 1),
                        zt(this, "enableRotate", !0),
                        zt(this, "rotateSpeed", 1),
                        zt(this, "enablePan", !0),
                        zt(this, "panSpeed", 1),
                        zt(this, "screenSpacePanning", !0),
                        zt(this, "keyPanSpeed", 7),
                        zt(this, "zoomToCursor", !1),
                        zt(this, "autoRotate", !1),
                        zt(this, "autoRotateSpeed", 2),
                        zt(this, "reverseOrbit", !1),
                        zt(this, "reverseHorizontalOrbit", !1),
                        zt(this, "reverseVerticalOrbit", !1),
                        zt(this, "keys", {
                            LEFT: "ArrowLeft",
                            UP: "ArrowUp",
                            RIGHT: "ArrowRight",
                            BOTTOM: "ArrowDown"
                        }),
                        zt(this, "mouseButtons", {
                            LEFT: Kh.ROTATE,
                            MIDDLE: Kh.DOLLY,
                            RIGHT: Kh.PAN
                        }),
                        zt(this, "touches", {
                            ONE: Jh.ROTATE,
                            TWO: Jh.DOLLY_PAN
                        }),
                        zt(this, "target0"),
                        zt(this, "position0"),
                        zt(this, "zoom0"),
                        zt(this, "_domElementKeyEvents", null),
                        zt(this, "getPolarAngle"),
                        zt(this, "getAzimuthalAngle"),
                        zt(this, "setPolarAngle"),
                        zt(this, "setAzimuthalAngle"),
                        zt(this, "getDistance"),
                        zt(this, "getZoomScale"),
                        zt(this, "listenToKeyEvents"),
                        zt(this, "stopListenToKeyEvents"),
                        zt(this, "saveState"),
                        zt(this, "reset"),
                        zt(this, "update"),
                        zt(this, "connect"),
                        zt(this, "dispose"),
                        zt(this, "dollyIn"),
                        zt(this, "dollyOut"),
                        zt(this, "getScale"),
                        zt(this, "setScale"),
                        this.object = e,
                        this.domElement = t,
                        this.target0 = this.target.clone(),
                        this.position0 = this.object.position.clone(),
                        this.zoom0 = this.object.zoom,
                        this.getPolarAngle = () => p.phi,
                        this.getAzimuthalAngle = () => p.theta,
                        this.setPolarAngle = ie => {
                            let Re = BR(ie, 2 * Math.PI)
                              , He = p.phi;
                            He < 0 && (He += 2 * Math.PI),
                            Re < 0 && (Re += 2 * Math.PI);
                            let lt = Math.abs(Re - He);
                            2 * Math.PI - lt < lt && (Re < He ? Re += 2 * Math.PI : He += 2 * Math.PI),
                            m.phi = Re - He,
                            n.update()
                        }
                        ,
                        this.setAzimuthalAngle = ie => {
                            let Re = BR(ie, 2 * Math.PI)
                              , He = p.theta;
                            He < 0 && (He += 2 * Math.PI),
                            Re < 0 && (Re += 2 * Math.PI);
                            let lt = Math.abs(Re - He);
                            2 * Math.PI - lt < lt && (Re < He ? Re += 2 * Math.PI : He += 2 * Math.PI),
                            m.theta = Re - He,
                            n.update()
                        }
                        ,
                        this.getDistance = () => n.object.position.distanceTo(n.target),
                        this.listenToKeyEvents = ie => {
                            ie.addEventListener("keydown", Qe),
                            this._domElementKeyEvents = ie
                        }
                        ,
                        this.stopListenToKeyEvents = () => {
                            this._domElementKeyEvents.removeEventListener("keydown", Qe),
                            this._domElementKeyEvents = null
                        }
                        ,
                        this.saveState = () => {
                            n.target0.copy(n.target),
                            n.position0.copy(n.object.position),
                            n.zoom0 = n.object.zoom
                        }
                        ,
                        this.reset = () => {
                            n.target.copy(n.target0),
                            n.object.position.copy(n.position0),
                            n.object.zoom = n.zoom0,
                            n.object.updateProjectionMatrix(),
                            n.dispatchEvent(i),
                            n.update(),
                            h = l.NONE
                        }
                        ,
                        this.update = ( () => {
                            const ie = new Q
                              , Re = new Q(0,1,0)
                              , He = new _s().setFromUnitVectors(e.up, Re)
                              , lt = He.clone().invert()
                              , ae = new Q
                              , ot = new _s
                              , tt = 2 * Math.PI;
                            return function() {
                                const Je = n.object.position;
                                He.setFromUnitVectors(e.up, Re),
                                lt.copy(He).invert(),
                                ie.copy(Je).sub(n.target),
                                ie.applyQuaternion(He),
                                p.setFromVector3(ie),
                                n.autoRotate && h === l.NONE && K(H()),
                                n.enableDamping ? (p.theta += m.theta * n.dampingFactor,
                                p.phi += m.phi * n.dampingFactor) : (p.theta += m.theta,
                                p.phi += m.phi);
                                let ke = n.minAzimuthAngle
                                  , ht = n.maxAzimuthAngle;
                                isFinite(ke) && isFinite(ht) && (ke < -Math.PI ? ke += tt : ke > Math.PI && (ke -= tt),
                                ht < -Math.PI ? ht += tt : ht > Math.PI && (ht -= tt),
                                ke <= ht ? p.theta = Math.max(ke, Math.min(ht, p.theta)) : p.theta = p.theta > (ke + ht) / 2 ? Math.max(ke, p.theta) : Math.min(ht, p.theta)),
                                p.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, p.phi)),
                                p.makeSafe(),
                                n.enableDamping === !0 ? n.target.addScaledVector(_, n.dampingFactor) : n.target.add(_),
                                n.zoomToCursor && F || n.object.isOrthographicCamera ? p.radius = J(p.radius) : p.radius = J(p.radius * v),
                                ie.setFromSpherical(p),
                                ie.applyQuaternion(lt),
                                Je.copy(n.target).add(ie),
                                n.object.matrixAutoUpdate || n.object.updateMatrix(),
                                n.object.lookAt(n.target),
                                n.enableDamping === !0 ? (m.theta *= 1 - n.dampingFactor,
                                m.phi *= 1 - n.dampingFactor,
                                _.multiplyScalar(1 - n.dampingFactor)) : (m.set(0, 0, 0),
                                _.set(0, 0, 0));
                                let Mt = !1;
                                if (n.zoomToCursor && F) {
                                    let Tn = null;
                                    if (n.object instanceof hi && n.object.isPerspectiveCamera) {
                                        const Zt = ie.length();
                                        Tn = J(Zt * v);
                                        const Ai = Zt - Tn;
                                        n.object.position.addScaledVector(B, Ai),
                                        n.object.updateMatrixWorld()
                                    } else if (n.object.isOrthographicCamera) {
                                        const Zt = new Q(I.x,I.y,0);
                                        Zt.unproject(n.object),
                                        n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / v)),
                                        n.object.updateProjectionMatrix(),
                                        Mt = !0;
                                        const Ai = new Q(I.x,I.y,0);
                                        Ai.unproject(n.object),
                                        n.object.position.sub(Ai).add(Zt),
                                        n.object.updateMatrixWorld(),
                                        Tn = ie.length()
                                    } else
                                        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                                        n.zoomToCursor = !1;
                                    Tn !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Tn).add(n.object.position) : (Px.origin.copy(n.object.position),
                                    Px.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                                    Math.abs(n.object.up.dot(Px.direction)) < rF ? e.lookAt(n.target) : (UR.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                                    Px.intersectPlane(UR, n.target))))
                                } else
                                    n.object instanceof Yu && n.object.isOrthographicCamera && (Mt = v !== 1,
                                    Mt && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / v)),
                                    n.object.updateProjectionMatrix()));
                                return v = 1,
                                F = !1,
                                Mt || ae.distanceToSquared(n.object.position) > d || 8 * (1 - ot.dot(n.object.quaternion)) > d ? (n.dispatchEvent(i),
                                ae.copy(n.object.position),
                                ot.copy(n.object.quaternion),
                                Mt = !1,
                                !0) : !1
                            }
                        }
                        )(),
                        this.connect = ie => {
                            n.domElement = ie,
                            n.domElement.style.touchAction = "none",
                            n.domElement.addEventListener("contextmenu", Ke),
                            n.domElement.addEventListener("pointerdown", yt),
                            n.domElement.addEventListener("pointercancel", $),
                            n.domElement.addEventListener("wheel", Ge)
                        }
                        ,
                        this.dispose = () => {
                            var ie, Re, He, lt, ae, ot;
                            n.domElement && (n.domElement.style.touchAction = "auto"),
                            (ie = n.domElement) == null || ie.removeEventListener("contextmenu", Ke),
                            (Re = n.domElement) == null || Re.removeEventListener("pointerdown", yt),
                            (He = n.domElement) == null || He.removeEventListener("pointercancel", $),
                            (lt = n.domElement) == null || lt.removeEventListener("wheel", Ge),
                            (ae = n.domElement) == null || ae.ownerDocument.removeEventListener("pointermove", wt),
                            (ot = n.domElement) == null || ot.ownerDocument.removeEventListener("pointerup", $),
                            n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", Qe)
                        }
                        ;
                        const n = this
                          , i = {
                            type: "change"
                        }
                          , s = {
                            type: "start"
                        }
                          , r = {
                            type: "end"
                        }
                          , l = {
                            NONE: -1,
                            ROTATE: 0,
                            DOLLY: 1,
                            PAN: 2,
                            TOUCH_ROTATE: 3,
                            TOUCH_PAN: 4,
                            TOUCH_DOLLY_PAN: 5,
                            TOUCH_DOLLY_ROTATE: 6
                        };
                        let h = l.NONE;
                        const d = 1e-6
                          , p = new px
                          , m = new px;
                        let v = 1;
                        const _ = new Q
                          , x = new ye
                          , b = new ye
                          , E = new ye
                          , T = new ye
                          , M = new ye
                          , D = new ye
                          , R = new ye
                          , O = new ye
                          , U = new ye
                          , B = new Q
                          , I = new ye;
                        let F = !1;
                        const P = []
                          , L = {};
                        function H() {
                            return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
                        }
                        function Z() {
                            return Math.pow(.95, n.zoomSpeed)
                        }
                        function K(ie) {
                            n.reverseOrbit || n.reverseHorizontalOrbit ? m.theta += ie : m.theta -= ie
                        }
                        function te(ie) {
                            n.reverseOrbit || n.reverseVerticalOrbit ? m.phi += ie : m.phi -= ie
                        }
                        const ce = ( () => {
                            const ie = new Q;
                            return function(He, lt) {
                                ie.setFromMatrixColumn(lt, 0),
                                ie.multiplyScalar(-He),
                                _.add(ie)
                            }
                        }
                        )()
                          , G = ( () => {
                            const ie = new Q;
                            return function(He, lt) {
                                n.screenSpacePanning === !0 ? ie.setFromMatrixColumn(lt, 1) : (ie.setFromMatrixColumn(lt, 0),
                                ie.crossVectors(n.object.up, ie)),
                                ie.multiplyScalar(He),
                                _.add(ie)
                            }
                        }
                        )()
                          , V = ( () => {
                            const ie = new Q;
                            return function(He, lt) {
                                const ae = n.domElement;
                                if (ae && n.object instanceof hi && n.object.isPerspectiveCamera) {
                                    const ot = n.object.position;
                                    ie.copy(ot).sub(n.target);
                                    let tt = ie.length();
                                    tt *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                                    ce(2 * He * tt / ae.clientHeight, n.object.matrix),
                                    G(2 * lt * tt / ae.clientHeight, n.object.matrix)
                                } else
                                    ae && n.object instanceof Yu && n.object.isOrthographicCamera ? (ce(He * (n.object.right - n.object.left) / n.object.zoom / ae.clientWidth, n.object.matrix),
                                    G(lt * (n.object.top - n.object.bottom) / n.object.zoom / ae.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                                    n.enablePan = !1)
                            }
                        }
                        )();
                        function q(ie) {
                            n.object instanceof hi && n.object.isPerspectiveCamera || n.object instanceof Yu && n.object.isOrthographicCamera ? v = ie : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                            n.enableZoom = !1)
                        }
                        function ee(ie) {
                            q(v / ie)
                        }
                        function se(ie) {
                            q(v * ie)
                        }
                        function X(ie) {
                            if (!n.zoomToCursor || !n.domElement)
                                return;
                            F = !0;
                            const Re = n.domElement.getBoundingClientRect()
                              , He = ie.clientX - Re.left
                              , lt = ie.clientY - Re.top
                              , ae = Re.width
                              , ot = Re.height;
                            I.x = He / ae * 2 - 1,
                            I.y = -(lt / ot) * 2 + 1,
                            B.set(I.x, I.y, 1).unproject(n.object).sub(n.object.position).normalize()
                        }
                        function J(ie) {
                            return Math.max(n.minDistance, Math.min(n.maxDistance, ie))
                        }
                        function ze(ie) {
                            x.set(ie.clientX, ie.clientY)
                        }
                        function xe(ie) {
                            X(ie),
                            R.set(ie.clientX, ie.clientY)
                        }
                        function le(ie) {
                            T.set(ie.clientX, ie.clientY)
                        }
                        function Ne(ie) {
                            b.set(ie.clientX, ie.clientY),
                            E.subVectors(b, x).multiplyScalar(n.rotateSpeed);
                            const Re = n.domElement;
                            Re && (K(2 * Math.PI * E.x / Re.clientHeight),
                            te(2 * Math.PI * E.y / Re.clientHeight)),
                            x.copy(b),
                            n.update()
                        }
                        function be(ie) {
                            O.set(ie.clientX, ie.clientY),
                            U.subVectors(O, R),
                            U.y > 0 ? ee(Z()) : U.y < 0 && se(Z()),
                            R.copy(O),
                            n.update()
                        }
                        function Ue(ie) {
                            M.set(ie.clientX, ie.clientY),
                            D.subVectors(M, T).multiplyScalar(n.panSpeed),
                            V(D.x, D.y),
                            T.copy(M),
                            n.update()
                        }
                        function $e(ie) {
                            X(ie),
                            ie.deltaY < 0 ? se(Z()) : ie.deltaY > 0 && ee(Z()),
                            n.update()
                        }
                        function rt(ie) {
                            let Re = !1;
                            switch (ie.code) {
                            case n.keys.UP:
                                V(0, n.keyPanSpeed),
                                Re = !0;
                                break;
                            case n.keys.BOTTOM:
                                V(0, -n.keyPanSpeed),
                                Re = !0;
                                break;
                            case n.keys.LEFT:
                                V(n.keyPanSpeed, 0),
                                Re = !0;
                                break;
                            case n.keys.RIGHT:
                                V(-n.keyPanSpeed, 0),
                                Re = !0;
                                break
                            }
                            Re && (ie.preventDefault(),
                            n.update())
                        }
                        function Et() {
                            if (P.length == 1)
                                x.set(P[0].pageX, P[0].pageY);
                            else {
                                const ie = .5 * (P[0].pageX + P[1].pageX)
                                  , Re = .5 * (P[0].pageY + P[1].pageY);
                                x.set(ie, Re)
                            }
                        }
                        function ne() {
                            if (P.length == 1)
                                T.set(P[0].pageX, P[0].pageY);
                            else {
                                const ie = .5 * (P[0].pageX + P[1].pageX)
                                  , Re = .5 * (P[0].pageY + P[1].pageY);
                                T.set(ie, Re)
                            }
                        }
                        function Ve() {
                            const ie = P[0].pageX - P[1].pageX
                              , Re = P[0].pageY - P[1].pageY
                              , He = Math.sqrt(ie * ie + Re * Re);
                            R.set(0, He)
                        }
                        function de() {
                            n.enableZoom && Ve(),
                            n.enablePan && ne()
                        }
                        function Te() {
                            n.enableZoom && Ve(),
                            n.enableRotate && Et()
                        }
                        function Pe(ie) {
                            if (P.length == 1)
                                b.set(ie.pageX, ie.pageY);
                            else {
                                const He = st(ie)
                                  , lt = .5 * (ie.pageX + He.x)
                                  , ae = .5 * (ie.pageY + He.y);
                                b.set(lt, ae)
                            }
                            E.subVectors(b, x).multiplyScalar(n.rotateSpeed);
                            const Re = n.domElement;
                            Re && (K(2 * Math.PI * E.x / Re.clientHeight),
                            te(2 * Math.PI * E.y / Re.clientHeight)),
                            x.copy(b)
                        }
                        function Ye(ie) {
                            if (P.length == 1)
                                M.set(ie.pageX, ie.pageY);
                            else {
                                const Re = st(ie)
                                  , He = .5 * (ie.pageX + Re.x)
                                  , lt = .5 * (ie.pageY + Re.y);
                                M.set(He, lt)
                            }
                            D.subVectors(M, T).multiplyScalar(n.panSpeed),
                            V(D.x, D.y),
                            T.copy(M)
                        }
                        function Ie(ie) {
                            const Re = st(ie)
                              , He = ie.pageX - Re.x
                              , lt = ie.pageY - Re.y
                              , ae = Math.sqrt(He * He + lt * lt);
                            O.set(0, ae),
                            U.set(0, Math.pow(O.y / R.y, n.zoomSpeed)),
                            ee(U.y),
                            R.copy(O)
                        }
                        function Fe(ie) {
                            n.enableZoom && Ie(ie),
                            n.enablePan && Ye(ie)
                        }
                        function xt(ie) {
                            n.enableZoom && Ie(ie),
                            n.enableRotate && Pe(ie)
                        }
                        function yt(ie) {
                            var Re, He;
                            n.enabled !== !1 && (P.length === 0 && ((Re = n.domElement) == null || Re.ownerDocument.addEventListener("pointermove", wt),
                            (He = n.domElement) == null || He.ownerDocument.addEventListener("pointerup", $)),
                            _t(ie),
                            ie.pointerType === "touch" ? Be(ie) : k(ie))
                        }
                        function wt(ie) {
                            n.enabled !== !1 && (ie.pointerType === "touch" ? ct(ie) : pe(ie))
                        }
                        function $(ie) {
                            var Re, He, lt;
                            Ct(ie),
                            P.length === 0 && ((Re = n.domElement) == null || Re.releasePointerCapture(ie.pointerId),
                            (He = n.domElement) == null || He.ownerDocument.removeEventListener("pointermove", wt),
                            (lt = n.domElement) == null || lt.ownerDocument.removeEventListener("pointerup", $)),
                            n.dispatchEvent(r),
                            h = l.NONE
                        }
                        function k(ie) {
                            let Re;
                            switch (ie.button) {
                            case 0:
                                Re = n.mouseButtons.LEFT;
                                break;
                            case 1:
                                Re = n.mouseButtons.MIDDLE;
                                break;
                            case 2:
                                Re = n.mouseButtons.RIGHT;
                                break;
                            default:
                                Re = -1
                            }
                            switch (Re) {
                            case Kh.DOLLY:
                                if (n.enableZoom === !1)
                                    return;
                                xe(ie),
                                h = l.DOLLY;
                                break;
                            case Kh.ROTATE:
                                if (ie.ctrlKey || ie.metaKey || ie.shiftKey) {
                                    if (n.enablePan === !1)
                                        return;
                                    le(ie),
                                    h = l.PAN
                                } else {
                                    if (n.enableRotate === !1)
                                        return;
                                    ze(ie),
                                    h = l.ROTATE
                                }
                                break;
                            case Kh.PAN:
                                if (ie.ctrlKey || ie.metaKey || ie.shiftKey) {
                                    if (n.enableRotate === !1)
                                        return;
                                    ze(ie),
                                    h = l.ROTATE
                                } else {
                                    if (n.enablePan === !1)
                                        return;
                                    le(ie),
                                    h = l.PAN
                                }
                                break;
                            default:
                                h = l.NONE
                            }
                            h !== l.NONE && n.dispatchEvent(s)
                        }
                        function pe(ie) {
                            if (n.enabled !== !1)
                                switch (h) {
                                case l.ROTATE:
                                    if (n.enableRotate === !1)
                                        return;
                                    Ne(ie);
                                    break;
                                case l.DOLLY:
                                    if (n.enableZoom === !1)
                                        return;
                                    be(ie);
                                    break;
                                case l.PAN:
                                    if (n.enablePan === !1)
                                        return;
                                    Ue(ie);
                                    break
                                }
                        }
                        function Ge(ie) {
                            n.enabled === !1 || n.enableZoom === !1 || h !== l.NONE && h !== l.ROTATE || (ie.preventDefault(),
                            n.dispatchEvent(s),
                            $e(ie),
                            n.dispatchEvent(r))
                        }
                        function Qe(ie) {
                            n.enabled === !1 || n.enablePan === !1 || rt(ie)
                        }
                        function Be(ie) {
                            switch (et(ie),
                            P.length) {
                            case 1:
                                switch (n.touches.ONE) {
                                case Jh.ROTATE:
                                    if (n.enableRotate === !1)
                                        return;
                                    Et(),
                                    h = l.TOUCH_ROTATE;
                                    break;
                                case Jh.PAN:
                                    if (n.enablePan === !1)
                                        return;
                                    ne(),
                                    h = l.TOUCH_PAN;
                                    break;
                                default:
                                    h = l.NONE
                                }
                                break;
                            case 2:
                                switch (n.touches.TWO) {
                                case Jh.DOLLY_PAN:
                                    if (n.enableZoom === !1 && n.enablePan === !1)
                                        return;
                                    de(),
                                    h = l.TOUCH_DOLLY_PAN;
                                    break;
                                case Jh.DOLLY_ROTATE:
                                    if (n.enableZoom === !1 && n.enableRotate === !1)
                                        return;
                                    Te(),
                                    h = l.TOUCH_DOLLY_ROTATE;
                                    break;
                                default:
                                    h = l.NONE
                                }
                                break;
                            default:
                                h = l.NONE
                            }
                            h !== l.NONE && n.dispatchEvent(s)
                        }
                        function ct(ie) {
                            switch (et(ie),
                            h) {
                            case l.TOUCH_ROTATE:
                                if (n.enableRotate === !1)
                                    return;
                                Pe(ie),
                                n.update();
                                break;
                            case l.TOUCH_PAN:
                                if (n.enablePan === !1)
                                    return;
                                Ye(ie),
                                n.update();
                                break;
                            case l.TOUCH_DOLLY_PAN:
                                if (n.enableZoom === !1 && n.enablePan === !1)
                                    return;
                                Fe(ie),
                                n.update();
                                break;
                            case l.TOUCH_DOLLY_ROTATE:
                                if (n.enableZoom === !1 && n.enableRotate === !1)
                                    return;
                                xt(ie),
                                n.update();
                                break;
                            default:
                                h = l.NONE
                            }
                        }
                        function Ke(ie) {
                            n.enabled !== !1 && ie.preventDefault()
                        }
                        function _t(ie) {
                            P.push(ie)
                        }
                        function Ct(ie) {
                            delete L[ie.pointerId];
                            for (let Re = 0; Re < P.length; Re++)
                                if (P[Re].pointerId == ie.pointerId) {
                                    P.splice(Re, 1);
                                    return
                                }
                        }
                        function et(ie) {
                            let Re = L[ie.pointerId];
                            Re === void 0 && (Re = new ye,
                            L[ie.pointerId] = Re),
                            Re.set(ie.pageX, ie.pageY)
                        }
                        function st(ie) {
                            const Re = ie.pointerId === P[0].pointerId ? P[1] : P[0];
                            return L[Re.pointerId]
                        }
                        this.dollyIn = (ie=Z()) => {
                            se(ie),
                            n.update()
                        }
                        ,
                        this.dollyOut = (ie=Z()) => {
                            ee(ie),
                            n.update()
                        }
                        ,
                        this.getScale = () => v,
                        this.setScale = ie => {
                            q(ie),
                            n.update()
                        }
                        ,
                        this.getZoomScale = () => Z(),
                        t !== void 0 && this.connect(t),
                        this.update()
                    }
                }
                ;
                const lF = Le.forwardRef( ({makeDefault: e, camera: t, regress: n, domElement: i, enableDamping: s=!0, keyEvents: r=!1, onChange: l, onStart: h, onEnd: d, ...p}, m) => {
                    const v = Us(B => B.invalidate)
                      , _ = Us(B => B.camera)
                      , x = Us(B => B.gl)
                      , b = Us(B => B.events)
                      , E = Us(B => B.setEvents)
                      , T = Us(B => B.set)
                      , M = Us(B => B.get)
                      , D = Us(B => B.performance)
                      , R = t || _
                      , O = i || b.connected || x.domElement
                      , U = Le.useMemo( () => new oF(R), [R]);
                    return Nv( () => {
                        U.enabled && U.update()
                    }
                    , -1),
                    Le.useEffect( () => (r && U.connect(r === !0 ? O : r),
                    U.connect(O),
                    () => void U.dispose()), [r, O, n, U, v]),
                    Le.useEffect( () => {
                        const B = P => {
                            v(),
                            n && D.regress(),
                            l && l(P)
                        }
                          , I = P => {
                            h && h(P)
                        }
                          , F = P => {
                            d && d(P)
                        }
                        ;
                        return U.addEventListener("change", B),
                        U.addEventListener("start", I),
                        U.addEventListener("end", F),
                        () => {
                            U.removeEventListener("start", I),
                            U.removeEventListener("end", F),
                            U.removeEventListener("change", B)
                        }
                    }
                    , [l, h, d, U, v, E]),
                    Le.useEffect( () => {
                        if (e) {
                            const B = M().controls;
                            return T({
                                controls: U
                            }),
                            () => T({
                                controls: B
                            })
                        }
                    }
                    , [e, U]),
                    Le.createElement("primitive", _M({
                        ref: m,
                        object: U,
                        enableDamping: s
                    }, p))
                }
                );
                var xM = 1 / 1e3
                  , cF = 1e3
                  , uF = class {
                    constructor() {
                        this.startTime = performance.now(),
                        this.previousTime = 0,
                        this.currentTime = 0,
                        this._delta = 0,
                        this._elapsed = 0,
                        this._fixedDelta = 1e3 / 60,
                        this.timescale = 1,
                        this.useFixedDelta = !1,
                        this._autoReset = !1
                    }
                    get autoReset() {
                        return this._autoReset
                    }
                    set autoReset(e) {
                        typeof document < "u" && document.hidden !== void 0 && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
                        this._autoReset = e)
                    }
                    get delta() {
                        return this._delta * xM
                    }
                    get fixedDelta() {
                        return this._fixedDelta * xM
                    }
                    set fixedDelta(e) {
                        this._fixedDelta = e * cF
                    }
                    get elapsed() {
                        return this._elapsed * xM
                    }
                    update(e) {
                        this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime,
                        this.currentTime = (e !== void 0 ? e : performance.now()) - this.startTime,
                        this._delta = this.currentTime - this.previousTime),
                        this._delta *= this.timescale,
                        this._elapsed += this._delta
                    }
                    reset() {
                        this._delta = 0,
                        this._elapsed = 0,
                        this.currentTime = performance.now() - this.startTime
                    }
                    getDelta() {
                        return this.delta
                    }
                    getElapsed() {
                        return this.elapsed
                    }
                    handleEvent(e) {
                        document.hidden || (this.currentTime = performance.now() - this.startTime)
                    }
                    dispose() {
                        this.autoReset = !1
                    }
                }
                  , hF = ( () => {
                    const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
                      , t = new Float32Array([0, 0, 2, 0, 0, 2])
                      , n = new an;
                    return n.setAttribute("position", new wn(e,3)),
                    n.setAttribute("uv", new wn(t,2)),
                    n
                }
                )()
                  , Ys = class mb {
                    static get fullscreenGeometry() {
                        return hF
                    }
                    constructor(t="Pass", n=new bp, i=new av) {
                        this.name = t,
                        this.renderer = null,
                        this.scene = n,
                        this.camera = i,
                        this.screen = null,
                        this.rtt = !0,
                        this.needsSwap = !0,
                        this.needsDepthTexture = !1,
                        this.enabled = !0
                    }
                    get renderToScreen() {
                        return !this.rtt
                    }
                    set renderToScreen(t) {
                        if (this.rtt === t) {
                            const n = this.fullscreenMaterial;
                            n !== null && (n.needsUpdate = !0),
                            this.rtt = !t
                        }
                    }
                    set mainScene(t) {}
                    set mainCamera(t) {}
                    setRenderer(t) {
                        this.renderer = t
                    }
                    isEnabled() {
                        return this.enabled
                    }
                    setEnabled(t) {
                        this.enabled = t
                    }
                    get fullscreenMaterial() {
                        return this.screen !== null ? this.screen.material : null
                    }
                    set fullscreenMaterial(t) {
                        let n = this.screen;
                        n !== null ? n.material = t : (n = new Fi(mb.fullscreenGeometry,t),
                        n.frustumCulled = !1,
                        this.scene === null && (this.scene = new bp),
                        this.scene.add(n),
                        this.screen = n)
                    }
                    getFullscreenMaterial() {
                        return this.fullscreenMaterial
                    }
                    setFullscreenMaterial(t) {
                        this.fullscreenMaterial = t
                    }
                    getDepthTexture() {
                        return null
                    }
                    setDepthTexture(t, n=ji) {}
                    render(t, n, i, s, r) {
                        throw new Error("Render method not implemented!")
                    }
                    setSize(t, n) {}
                    initialize(t, n, i) {}
                    dispose() {
                        for (const t of Object.keys(this)) {
                            const n = this[t];
                            (n instanceof Un || n instanceof Os || n instanceof zi || n instanceof mb) && this[t].dispose()
                        }
                        this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose()
                    }
                }
                  , fF = class extends Ys {
                    constructor() {
                        super("ClearMaskPass", null, null),
                        this.needsSwap = !1
                    }
                    render(e, t, n, i, s) {
                        const r = e.state.buffers.stencil;
                        r.setLocked(!1),
                        r.setTest(!1)
                    }
                }
                  , dF = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`
                  , Uf = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , PR = class extends Fn {
                    constructor() {
                        super({
                            name: "CopyMaterial",
                            uniforms: {
                                inputBuffer: new Ce(null),
                                opacity: new Ce(1)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: dF,
                            vertexShader: Uf
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    getOpacity(e) {
                        return this.uniforms.opacity.value
                    }
                    setOpacity(e) {
                        this.uniforms.opacity.value = e
                    }
                }
                  , IR = class extends Ys {
                    constructor(e, t=!0) {
                        super("CopyPass"),
                        this.fullscreenMaterial = new PR,
                        this.needsSwap = !1,
                        this.renderTarget = e,
                        e === void 0 && (this.renderTarget = new Un(1,1,{
                            minFilter: mi,
                            magFilter: mi,
                            stencilBuffer: !1,
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "CopyPass.Target"),
                        this.autoResize = t
                    }
                    get resize() {
                        return this.autoResize
                    }
                    set resize(e) {
                        this.autoResize = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    setAutoResizeEnabled(e) {
                        this.autoResize = e
                    }
                    render(e, t, n, i, s) {
                        this.fullscreenMaterial.inputBuffer = t.texture,
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        this.autoResize && this.renderTarget.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && (this.renderTarget.texture.type = n,
                        n !== ui ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : e !== null && e.outputColorSpace === $t && (this.renderTarget.texture.colorSpace = $t))
                    }
                }
                  , LR = new at
                  , Yp = class extends Ys {
                    constructor(e=!0, t=!0, n=!1) {
                        super("ClearPass", null, null),
                        this.needsSwap = !1,
                        this.color = e,
                        this.depth = t,
                        this.stencil = n,
                        this.overrideClearColor = null,
                        this.overrideClearAlpha = -1
                    }
                    setClearFlags(e, t, n) {
                        this.color = e,
                        this.depth = t,
                        this.stencil = n
                    }
                    getOverrideClearColor() {
                        return this.overrideClearColor
                    }
                    setOverrideClearColor(e) {
                        this.overrideClearColor = e
                    }
                    getOverrideClearAlpha() {
                        return this.overrideClearAlpha
                    }
                    setOverrideClearAlpha(e) {
                        this.overrideClearAlpha = e
                    }
                    render(e, t, n, i, s) {
                        const r = this.overrideClearColor
                          , l = this.overrideClearAlpha
                          , h = e.getClearAlpha()
                          , d = r !== null
                          , p = l >= 0;
                        d ? (e.getClearColor(LR),
                        e.setClearColor(r, p ? l : h)) : p && e.setClearAlpha(l),
                        e.setRenderTarget(this.renderToScreen ? null : t),
                        e.clear(this.color, this.depth, this.stencil),
                        d ? e.setClearColor(LR, h) : p && e.setClearAlpha(h)
                    }
                }
                  , pF = class extends Ys {
                    constructor(e, t) {
                        super("MaskPass", e, t),
                        this.needsSwap = !1,
                        this.clearPass = new Yp(!1,!1,!0),
                        this.inverse = !1
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get inverted() {
                        return this.inverse
                    }
                    set inverted(e) {
                        this.inverse = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    render(e, t, n, i, s) {
                        const r = e.getContext()
                          , l = e.state.buffers
                          , h = this.scene
                          , d = this.camera
                          , p = this.clearPass
                          , m = this.inverted ? 0 : 1
                          , v = 1 - m;
                        l.color.setMask(!1),
                        l.depth.setMask(!1),
                        l.color.setLocked(!0),
                        l.depth.setLocked(!0),
                        l.stencil.setTest(!0),
                        l.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE),
                        l.stencil.setFunc(r.ALWAYS, m, 4294967295),
                        l.stencil.setClear(v),
                        l.stencil.setLocked(!0),
                        this.clearPass.enabled && (this.renderToScreen ? p.render(e, null) : (p.render(e, t),
                        p.render(e, n))),
                        this.renderToScreen ? (e.setRenderTarget(null),
                        e.render(h, d)) : (e.setRenderTarget(t),
                        e.render(h, d),
                        e.setRenderTarget(n),
                        e.render(h, d)),
                        l.color.setLocked(!1),
                        l.depth.setLocked(!1),
                        l.stencil.setLocked(!1),
                        l.stencil.setFunc(r.EQUAL, 1, 4294967295),
                        l.stencil.setOp(r.KEEP, r.KEEP, r.KEEP),
                        l.stencil.setLocked(!0)
                    }
                }
                  , mF = class {
                    constructor(e=null, {depthBuffer: t=!0, stencilBuffer: n=!1, multisampling: i=0, frameBufferType: s}={}) {
                        this.renderer = null,
                        this.inputBuffer = this.createBuffer(t, n, s, i),
                        this.outputBuffer = this.inputBuffer.clone(),
                        this.copyPass = new IR,
                        this.depthTexture = null,
                        this.passes = [],
                        this.timer = new uF,
                        this.autoRenderToScreen = !0,
                        this.setRenderer(e)
                    }
                    get multisampling() {
                        return this.inputBuffer.samples || 0
                    }
                    set multisampling(e) {
                        const t = this.inputBuffer
                          , n = this.multisampling;
                        n > 0 && e > 0 ? (this.inputBuffer.samples = e,
                        this.outputBuffer.samples = e,
                        this.inputBuffer.dispose(),
                        this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(),
                        this.outputBuffer.dispose(),
                        this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e),
                        this.inputBuffer.depthTexture = this.depthTexture,
                        this.outputBuffer = this.inputBuffer.clone())
                    }
                    getTimer() {
                        return this.timer
                    }
                    getRenderer() {
                        return this.renderer
                    }
                    setRenderer(e) {
                        if (this.renderer = e,
                        e !== null) {
                            const t = e.getSize(new ye)
                              , n = e.getContext().getContextAttributes().alpha
                              , i = this.inputBuffer.texture.type;
                            i === ui && e.outputColorSpace === $t && (this.inputBuffer.texture.colorSpace = $t,
                            this.outputBuffer.texture.colorSpace = $t,
                            this.inputBuffer.dispose(),
                            this.outputBuffer.dispose()),
                            e.autoClear = !1,
                            this.setSize(t.width, t.height);
                            for (const s of this.passes)
                                s.initialize(e, n, i)
                        }
                    }
                    replaceRenderer(e, t=!0) {
                        const n = this.renderer
                          , i = n.domElement.parentNode;
                        return this.setRenderer(e),
                        t && i !== null && (i.removeChild(n.domElement),
                        i.appendChild(e.domElement)),
                        n
                    }
                    createDepthTexture() {
                        const e = this.depthTexture = new mv;
                        return this.inputBuffer.depthTexture = e,
                        this.inputBuffer.dispose(),
                        this.inputBuffer.stencilBuffer ? (e.format = sf,
                        e.type = nf) : e.type = Il,
                        e
                    }
                    deleteDepthTexture() {
                        if (this.depthTexture !== null) {
                            this.depthTexture.dispose(),
                            this.depthTexture = null,
                            this.inputBuffer.depthTexture = null,
                            this.inputBuffer.dispose();
                            for (const e of this.passes)
                                e.setDepthTexture(null)
                        }
                    }
                    createBuffer(e, t, n, i) {
                        const s = this.renderer
                          , r = s === null ? new ye : s.getDrawingBufferSize(new ye)
                          , l = {
                            minFilter: mi,
                            magFilter: mi,
                            stencilBuffer: t,
                            depthBuffer: e,
                            type: n
                        }
                          , h = new Un(r.width,r.height,l);
                        return i > 0 && (h.ignoreDepthForMultisampleCopy = !1,
                        h.samples = i),
                        n === ui && s !== null && s.outputColorSpace === $t && (h.texture.colorSpace = $t),
                        h.texture.name = "EffectComposer.Buffer",
                        h.texture.generateMipmaps = !1,
                        h
                    }
                    setMainScene(e) {
                        for (const t of this.passes)
                            t.mainScene = e
                    }
                    setMainCamera(e) {
                        for (const t of this.passes)
                            t.mainCamera = e
                    }
                    addPass(e, t) {
                        const n = this.passes
                          , i = this.renderer
                          , s = i.getDrawingBufferSize(new ye)
                          , r = i.getContext().getContextAttributes().alpha
                          , l = this.inputBuffer.texture.type;
                        if (e.setRenderer(i),
                        e.setSize(s.width, s.height),
                        e.initialize(i, r, l),
                        this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1),
                        e.renderToScreen && (this.autoRenderToScreen = !1)),
                        t !== void 0 ? n.splice(t, 0, e) : n.push(e),
                        this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0),
                        e.needsDepthTexture || this.depthTexture !== null)
                            if (this.depthTexture === null) {
                                const h = this.createDepthTexture();
                                for (e of n)
                                    e.setDepthTexture(h)
                            } else
                                e.setDepthTexture(this.depthTexture)
                    }
                    removePass(e) {
                        const t = this.passes
                          , n = t.indexOf(e);
                        if (n !== -1 && t.splice(n, 1).length > 0) {
                            if (this.depthTexture !== null) {
                                const i = (s, r) => s || r.needsDepthTexture;
                                t.reduce(i, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null),
                                this.deleteDepthTexture())
                            }
                            this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1,
                            t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                        }
                    }
                    removeAllPasses() {
                        const e = this.passes;
                        this.deleteDepthTexture(),
                        e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1),
                        this.passes = [])
                    }
                    render(e) {
                        const t = this.renderer
                          , n = this.copyPass;
                        let i = this.inputBuffer, s = this.outputBuffer, r = !1, l, h, d;
                        e === void 0 && (this.timer.update(),
                        e = this.timer.getDelta());
                        for (const p of this.passes)
                            p.enabled && (p.render(t, i, s, e, r),
                            p.needsSwap && (r && (n.renderToScreen = p.renderToScreen,
                            l = t.getContext(),
                            h = t.state.buffers.stencil,
                            h.setFunc(l.NOTEQUAL, 1, 4294967295),
                            n.render(t, i, s, e, r),
                            h.setFunc(l.EQUAL, 1, 4294967295)),
                            d = i,
                            i = s,
                            s = d),
                            p instanceof pF ? r = !0 : p instanceof fF && (r = !1))
                    }
                    setSize(e, t, n) {
                        const i = this.renderer
                          , s = i.getSize(new ye);
                        (e === void 0 || t === void 0) && (e = s.width,
                        t = s.height),
                        (s.width !== e || s.height !== t) && i.setSize(e, t, n);
                        const r = i.getDrawingBufferSize(new ye);
                        this.inputBuffer.setSize(r.width, r.height),
                        this.outputBuffer.setSize(r.width, r.height);
                        for (const l of this.passes)
                            l.setSize(r.width, r.height)
                    }
                    reset() {
                        this.dispose(),
                        this.autoRenderToScreen = !0
                    }
                    dispose() {
                        for (const e of this.passes)
                            e.dispose();
                        this.passes = [],
                        this.inputBuffer !== null && this.inputBuffer.dispose(),
                        this.outputBuffer !== null && this.outputBuffer.dispose(),
                        this.deleteDepthTexture(),
                        this.copyPass.dispose(),
                        this.timer.dispose(),
                        Ys.fullscreenGeometry.dispose()
                    }
                }
                  , za = {
                    NONE: 0,
                    DEPTH: 1,
                    CONVOLUTION: 2
                }
                  , Bn = {
                    FRAGMENT_HEAD: "FRAGMENT_HEAD",
                    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                    VERTEX_HEAD: "VERTEX_HEAD",
                    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
                }
                  , gF = class {
                    constructor() {
                        this.shaderParts = new Map([[Bn.FRAGMENT_HEAD, null], [Bn.FRAGMENT_MAIN_UV, null], [Bn.FRAGMENT_MAIN_IMAGE, null], [Bn.VERTEX_HEAD, null], [Bn.VERTEX_MAIN_SUPPORT, null]]),
                        this.defines = new Map,
                        this.uniforms = new Map,
                        this.blendModes = new Map,
                        this.extensions = new Set,
                        this.attributes = za.NONE,
                        this.varyings = new Set,
                        this.uvTransformation = !1,
                        this.readDepth = !1,
                        this.colorSpace = Ll
                    }
                }
                  , SM = !1
                  , zR = class {
                    constructor(e=null) {
                        this.originalMaterials = new Map,
                        this.material = null,
                        this.materials = null,
                        this.materialsBackSide = null,
                        this.materialsDoubleSide = null,
                        this.materialsFlatShaded = null,
                        this.materialsFlatShadedBackSide = null,
                        this.materialsFlatShadedDoubleSide = null,
                        this.setMaterial(e),
                        this.meshCount = 0,
                        this.replaceMaterial = t => {
                            if (t.isMesh) {
                                let n;
                                if (t.material.flatShading)
                                    switch (t.material.side) {
                                    case nr:
                                        n = this.materialsFlatShadedDoubleSide;
                                        break;
                                    case ys:
                                        n = this.materialsFlatShadedBackSide;
                                        break;
                                    default:
                                        n = this.materialsFlatShaded;
                                        break
                                    }
                                else
                                    switch (t.material.side) {
                                    case nr:
                                        n = this.materialsDoubleSide;
                                        break;
                                    case ys:
                                        n = this.materialsBackSide;
                                        break;
                                    default:
                                        n = this.materials;
                                        break
                                    }
                                this.originalMaterials.set(t, t.material),
                                t.isSkinnedMesh ? t.material = n[2] : t.isInstancedMesh ? t.material = n[1] : t.material = n[0],
                                ++this.meshCount
                            }
                        }
                    }
                    cloneMaterial(e) {
                        if (!(e instanceof Fn))
                            return e.clone();
                        const t = e.uniforms
                          , n = new Map;
                        for (const s in t) {
                            const r = t[s].value;
                            r.isRenderTargetTexture && (t[s].value = null,
                            n.set(s, r))
                        }
                        const i = e.clone();
                        for (const s of n)
                            t[s[0]].value = s[1],
                            i.uniforms[s[0]].value = s[1];
                        return i
                    }
                    setMaterial(e) {
                        if (this.disposeMaterials(),
                        this.material = e,
                        e !== null) {
                            const t = this.materials = [this.cloneMaterial(e), this.cloneMaterial(e), this.cloneMaterial(e)];
                            for (const n of t)
                                n.uniforms = Object.assign({}, e.uniforms),
                                n.side = Bl;
                            t[2].skinning = !0,
                            this.materialsBackSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.side = ys,
                                i
                            }
                            ),
                            this.materialsDoubleSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.side = nr,
                                i
                            }
                            ),
                            this.materialsFlatShaded = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.flatShading = !0,
                                i
                            }
                            ),
                            this.materialsFlatShadedBackSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.flatShading = !0,
                                i.side = ys,
                                i
                            }
                            ),
                            this.materialsFlatShadedDoubleSide = t.map(n => {
                                const i = this.cloneMaterial(n);
                                return i.uniforms = Object.assign({}, e.uniforms),
                                i.flatShading = !0,
                                i.side = nr,
                                i
                            }
                            )
                        }
                    }
                    render(e, t, n) {
                        const i = e.shadowMap.enabled;
                        if (e.shadowMap.enabled = !1,
                        SM) {
                            const s = this.originalMaterials;
                            this.meshCount = 0,
                            t.traverse(this.replaceMaterial),
                            e.render(t, n);
                            for (const r of s)
                                r[0].material = r[1];
                            this.meshCount !== s.size && s.clear()
                        } else {
                            const s = t.overrideMaterial;
                            t.overrideMaterial = this.material,
                            e.render(t, n),
                            t.overrideMaterial = s
                        }
                        e.shadowMap.enabled = i
                    }
                    disposeMaterials() {
                        if (this.material !== null) {
                            const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                            for (const t of e)
                                t.dispose()
                        }
                    }
                    dispose() {
                        this.originalMaterials.clear(),
                        this.disposeMaterials()
                    }
                    static get workaroundEnabled() {
                        return SM
                    }
                    static set workaroundEnabled(e) {
                        SM = e
                    }
                }
                  , Qu = -1
                  , Hn = class extends Er {
                    constructor(e, t=Qu, n=Qu, i=1) {
                        super(),
                        this.resizable = e,
                        this.baseSize = new ye(1,1),
                        this.preferredSize = new ye(t,n),
                        this.target = this.preferredSize,
                        this.s = i,
                        this.effectiveSize = new ye,
                        this.addEventListener("change", () => this.updateEffectiveSize()),
                        this.updateEffectiveSize()
                    }
                    updateEffectiveSize() {
                        const e = this.baseSize
                          , t = this.preferredSize
                          , n = this.effectiveSize
                          , i = this.scale;
                        t.width !== Qu ? n.width = t.width : t.height !== Qu ? n.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : n.width = Math.round(e.width * i),
                        t.height !== Qu ? n.height = t.height : t.width !== Qu ? n.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : n.height = Math.round(e.height * i)
                    }
                    get width() {
                        return this.effectiveSize.width
                    }
                    set width(e) {
                        this.preferredWidth = e
                    }
                    get height() {
                        return this.effectiveSize.height
                    }
                    set height(e) {
                        this.preferredHeight = e
                    }
                    getWidth() {
                        return this.width
                    }
                    getHeight() {
                        return this.height
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(e) {
                        this.s !== e && (this.s = e,
                        this.preferredSize.setScalar(Qu),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    get baseWidth() {
                        return this.baseSize.width
                    }
                    set baseWidth(e) {
                        this.baseSize.width !== e && (this.baseSize.width = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseWidth() {
                        return this.baseWidth
                    }
                    setBaseWidth(e) {
                        this.baseWidth = e
                    }
                    get baseHeight() {
                        return this.baseSize.height
                    }
                    set baseHeight(e) {
                        this.baseSize.height !== e && (this.baseSize.height = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getBaseHeight() {
                        return this.baseHeight
                    }
                    setBaseHeight(e) {
                        this.baseHeight = e
                    }
                    setBaseSize(e, t) {
                        (this.baseSize.width !== e || this.baseSize.height !== t) && (this.baseSize.set(e, t),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    get preferredWidth() {
                        return this.preferredSize.width
                    }
                    set preferredWidth(e) {
                        this.preferredSize.width !== e && (this.preferredSize.width = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredWidth() {
                        return this.preferredWidth
                    }
                    setPreferredWidth(e) {
                        this.preferredWidth = e
                    }
                    get preferredHeight() {
                        return this.preferredSize.height
                    }
                    set preferredHeight(e) {
                        this.preferredSize.height !== e && (this.preferredSize.height = e,
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    getPreferredHeight() {
                        return this.preferredHeight
                    }
                    setPreferredHeight(e) {
                        this.preferredHeight = e
                    }
                    setPreferredSize(e, t) {
                        (this.preferredSize.width !== e || this.preferredSize.height !== t) && (this.preferredSize.set(e, t),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                    }
                    copy(e) {
                        this.s = e.scale,
                        this.baseSize.set(e.baseWidth, e.baseHeight),
                        this.preferredSize.set(e.preferredWidth, e.preferredHeight),
                        this.dispatchEvent({
                            type: "change"
                        }),
                        this.resizable.setSize(this.baseSize.width, this.baseSize.height)
                    }
                    static get AUTO_SIZE() {
                        return Qu
                    }
                }
                  , vF = class {
                    constructor(e=0) {
                        this.nextId = e
                    }
                    getNextId() {
                        return this.nextId++
                    }
                    reset(e=0) {
                        return this.nextId = e,
                        this
                    }
                }
                  , AM = new vF(2)
                  , FR = class extends Set {
                    constructor(e, t=AM.getNextId()) {
                        super(),
                        this.exclusive = !1,
                        this._layer = t,
                        (this._layer < 1 || this._layer > 31) && (console.warn("Layer out of range, resetting to 2"),
                        AM.reset(2),
                        this._layer = AM.getNextId()),
                        e !== void 0 && this.set(e)
                    }
                    get layer() {
                        return this._layer
                    }
                    set layer(e) {
                        const t = this._layer;
                        for (const n of this)
                            n.layers.disable(t),
                            n.layers.enable(e);
                        this._layer = e
                    }
                    getLayer() {
                        return this.layer
                    }
                    setLayer(e) {
                        this.layer = e
                    }
                    isExclusive() {
                        return this.exclusive
                    }
                    setExclusive(e) {
                        this.exclusive = e
                    }
                    clear() {
                        const e = this.layer;
                        for (const t of this)
                            t.layers.disable(e);
                        return super.clear()
                    }
                    set(e) {
                        this.clear();
                        for (const t of e)
                            this.add(t);
                        return this
                    }
                    indexOf(e) {
                        return this.has(e) ? 0 : -1
                    }
                    add(e) {
                        return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer),
                        super.add(e)
                    }
                    delete(e) {
                        return this.has(e) && e.layers.disable(this.layer),
                        super.delete(e)
                    }
                    toggle(e) {
                        let t;
                        return this.has(e) ? (this.delete(e),
                        t = !1) : (this.add(e),
                        t = !0),
                        t
                    }
                    setVisible(e) {
                        for (const t of this)
                            e ? t.layers.enable(0) : t.layers.disable(0);
                        return this
                    }
                }
                  , Yt = {
                    SKIP: 9,
                    SET: 30,
                    ADD: 0,
                    ALPHA: 1,
                    AVERAGE: 2,
                    COLOR: 3,
                    COLOR_BURN: 4,
                    COLOR_DODGE: 5,
                    DARKEN: 6,
                    DIFFERENCE: 7,
                    DIVIDE: 8,
                    DST: 9,
                    EXCLUSION: 10,
                    HARD_LIGHT: 11,
                    HARD_MIX: 12,
                    HUE: 13,
                    INVERT: 14,
                    INVERT_RGB: 15,
                    LIGHTEN: 16,
                    LINEAR_BURN: 17,
                    LINEAR_DODGE: 18,
                    LINEAR_LIGHT: 19,
                    LUMINOSITY: 20,
                    MULTIPLY: 21,
                    NEGATION: 22,
                    NORMAL: 23,
                    OVERLAY: 24,
                    PIN_LIGHT: 25,
                    REFLECT: 26,
                    SATURATION: 27,
                    SCREEN: 28,
                    SOFT_LIGHT: 29,
                    SRC: 30,
                    SUBTRACT: 31,
                    VIVID_LIGHT: 32
                }
                  , yF = new Map([[Yt.ADD, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}"], [Yt.ALPHA, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}"], [Yt.AVERAGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}"], [Yt.COLOR, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}"], [Yt.COLOR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}"], [Yt.COLOR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}"], [Yt.DARKEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}"], [Yt.DIFFERENCE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}"], [Yt.DIVIDE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}"], [Yt.DST, null], [Yt.EXCLUSION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}"], [Yt.HARD_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}"], [Yt.HARD_MIX, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}"], [Yt.HUE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}"], [Yt.INVERT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}"], [Yt.INVERT_RGB, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}"], [Yt.LIGHTEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}"], [Yt.LINEAR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}"], [Yt.LINEAR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}"], [Yt.LINEAR_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}"], [Yt.LUMINOSITY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}"], [Yt.MULTIPLY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}"], [Yt.NEGATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}"], [Yt.NORMAL, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"], [Yt.OVERLAY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}"], [Yt.PIN_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}"], [Yt.REFLECT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}"], [Yt.SATURATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}"], [Yt.SCREEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}"], [Yt.SOFT_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}"], [Yt.SRC, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"], [Yt.SUBTRACT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}"], [Yt.VIVID_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}"]])
                  , _F = class extends Er {
                    constructor(e, t=1) {
                        super(),
                        this._blendFunction = e,
                        this.opacity = new Ce(t)
                    }
                    getOpacity() {
                        return this.opacity.value
                    }
                    setOpacity(e) {
                        this.opacity.value = e
                    }
                    get blendFunction() {
                        return this._blendFunction
                    }
                    set blendFunction(e) {
                        this._blendFunction = e,
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    getBlendFunction() {
                        return this.blendFunction
                    }
                    setBlendFunction(e) {
                        this.blendFunction = e
                    }
                    getShaderCode() {
                        return yF.get(this.blendFunction)
                    }
                }
                  , Ni = class extends Er {
                    constructor(e, t, {attributes: n=za.NONE, blendFunction: i=Yt.NORMAL, defines: s=new Map, uniforms: r=new Map, extensions: l=null, vertexShader: h=null}={}) {
                        super(),
                        this.name = e,
                        this.renderer = null,
                        this.attributes = n,
                        this.fragmentShader = t,
                        this.vertexShader = h,
                        this.defines = s,
                        this.uniforms = r,
                        this.extensions = l,
                        this.blendMode = new _F(i),
                        this.blendMode.addEventListener("change", d => this.setChanged()),
                        this._inputColorSpace = Ll,
                        this._outputColorSpace = Ho
                    }
                    get inputColorSpace() {
                        return this._inputColorSpace
                    }
                    set inputColorSpace(e) {
                        this._inputColorSpace = e,
                        this.setChanged()
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e,
                        this.setChanged()
                    }
                    set mainScene(e) {}
                    set mainCamera(e) {}
                    getName() {
                        return this.name
                    }
                    setRenderer(e) {
                        this.renderer = e
                    }
                    getDefines() {
                        return this.defines
                    }
                    getUniforms() {
                        return this.uniforms
                    }
                    getExtensions() {
                        return this.extensions
                    }
                    getBlendMode() {
                        return this.blendMode
                    }
                    getAttributes() {
                        return this.attributes
                    }
                    setAttributes(e) {
                        this.attributes = e,
                        this.setChanged()
                    }
                    getFragmentShader() {
                        return this.fragmentShader
                    }
                    setFragmentShader(e) {
                        this.fragmentShader = e,
                        this.setChanged()
                    }
                    getVertexShader() {
                        return this.vertexShader
                    }
                    setVertexShader(e) {
                        this.vertexShader = e,
                        this.setChanged()
                    }
                    setChanged() {
                        this.dispatchEvent({
                            type: "change"
                        })
                    }
                    setDepthTexture(e, t=ji) {}
                    update(e, t, n) {}
                    setSize(e, t) {}
                    initialize(e, t, n) {}
                    dispose() {
                        for (const e of Object.keys(this)) {
                            const t = this[e];
                            (t instanceof Un || t instanceof Os || t instanceof zi || t instanceof Ys) && this[e].dispose()
                        }
                    }
                }
                  , Wp = {
                    VERY_SMALL: 0,
                    SMALL: 1,
                    MEDIUM: 2,
                    LARGE: 3,
                    VERY_LARGE: 4,
                    HUGE: 5
                }
                  , xF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`
                  , SF = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , AF = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]
                  , TF = class extends Fn {
                    constructor(e=new gn) {
                        super({
                            name: "KawaseBlurMaterial",
                            uniforms: {
                                inputBuffer: new Ce(null),
                                texelSize: new Ce(new gn),
                                scale: new Ce(1),
                                kernel: new Ce(0)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: xF,
                            vertexShader: SF
                        }),
                        this.setTexelSize(e.x, e.y),
                        this.kernelSize = Wp.MEDIUM
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.inputBuffer = e
                    }
                    get kernelSequence() {
                        return AF[this.kernelSize]
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(e) {
                        this.uniforms.scale.value = e
                    }
                    getScale() {
                        return this.uniforms.scale.value
                    }
                    setScale(e) {
                        this.uniforms.scale.value = e
                    }
                    getKernel() {
                        return null
                    }
                    get kernel() {
                        return this.uniforms.kernel.value
                    }
                    set kernel(e) {
                        this.uniforms.kernel.value = e
                    }
                    setKernel(e) {
                        this.kernel = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t, e * .5, t * .5)
                    }
                    setSize(e, t) {
                        const n = 1 / e
                          , i = 1 / t;
                        this.uniforms.texelSize.value.set(n, i, n * .5, i * .5)
                    }
                }
                  , Ix = class extends Ys {
                    constructor({kernelSize: e=Wp.MEDIUM, resolutionScale: t=.5, width: n=Hn.AUTO_SIZE, height: i=Hn.AUTO_SIZE, resolutionX: s=n, resolutionY: r=i}={}) {
                        super("KawaseBlurPass"),
                        this.renderTargetA = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetA.texture.name = "Blur.Target.A",
                        this.renderTargetB = this.renderTargetA.clone(),
                        this.renderTargetB.texture.name = "Blur.Target.B";
                        const l = this.resolution = new Hn(this,s,r,t);
                        l.addEventListener("change", h => this.setSize(l.baseWidth, l.baseHeight)),
                        this._blurMaterial = new TF,
                        this._blurMaterial.kernelSize = e,
                        this.copyMaterial = new PR
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get blurMaterial() {
                        return this._blurMaterial
                    }
                    set blurMaterial(e) {
                        this._blurMaterial = e
                    }
                    get dithering() {
                        return this.copyMaterial.dithering
                    }
                    set dithering(e) {
                        this.copyMaterial.dithering = e
                    }
                    get kernelSize() {
                        return this.blurMaterial.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurMaterial.kernelSize = e
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get scale() {
                        return this.blurMaterial.scale
                    }
                    set scale(e) {
                        this.blurMaterial.scale = e
                    }
                    getScale() {
                        return this.blurMaterial.scale
                    }
                    setScale(e) {
                        this.blurMaterial.scale = e
                    }
                    getKernelSize() {
                        return this.kernelSize
                    }
                    setKernelSize(e) {
                        this.kernelSize = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, s) {
                        const r = this.scene
                          , l = this.camera
                          , h = this.renderTargetA
                          , d = this.renderTargetB
                          , p = this.blurMaterial
                          , m = p.kernelSequence;
                        let v = t;
                        this.fullscreenMaterial = p;
                        for (let _ = 0, x = m.length; _ < x; ++_) {
                            const b = (_ & 1) === 0 ? h : d;
                            p.kernel = m[_],
                            p.inputBuffer = v.texture,
                            e.setRenderTarget(b),
                            e.render(r, l),
                            v = b
                        }
                        this.fullscreenMaterial = this.copyMaterial,
                        this.copyMaterial.inputBuffer = v.texture,
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        e.render(r, l)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.renderTargetA.setSize(i, s),
                        this.renderTargetB.setSize(i, s),
                        this.blurMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && (this.renderTargetA.texture.type = n,
                        this.renderTargetB.texture.type = n,
                        n !== ui ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : e !== null && e.outputColorSpace === $t && (this.renderTargetA.texture.colorSpace = $t,
                        this.renderTargetB.texture.colorSpace = $t))
                    }
                    static get AUTO_SIZE() {
                        return Hn.AUTO_SIZE
                    }
                }
                  , MF = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`
                  , bF = class extends Fn {
                    constructor(e=!1, t=null) {
                        super({
                            name: "LuminanceMaterial",
                            defines: {
                                THREE_REVISION: xc.replace(/\D+/g, "")
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                threshold: new Ce(0),
                                smoothing: new Ce(1),
                                range: new Ce(null)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: MF,
                            vertexShader: Uf
                        }),
                        this.colorOutput = e,
                        this.luminanceRange = t
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get threshold() {
                        return this.uniforms.threshold.value
                    }
                    set threshold(e) {
                        this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
                        this.uniforms.threshold.value = e
                    }
                    getThreshold() {
                        return this.threshold
                    }
                    setThreshold(e) {
                        this.threshold = e
                    }
                    get smoothing() {
                        return this.uniforms.smoothing.value
                    }
                    set smoothing(e) {
                        this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
                        this.uniforms.smoothing.value = e
                    }
                    getSmoothingFactor() {
                        return this.smoothing
                    }
                    setSmoothingFactor(e) {
                        this.smoothing = e
                    }
                    get useThreshold() {
                        return this.threshold > 0 || this.smoothing > 0
                    }
                    set useThreshold(e) {}
                    get colorOutput() {
                        return this.defines.COLOR !== void 0
                    }
                    set colorOutput(e) {
                        e ? this.defines.COLOR = "1" : delete this.defines.COLOR,
                        this.needsUpdate = !0
                    }
                    isColorOutputEnabled(e) {
                        return this.colorOutput
                    }
                    setColorOutputEnabled(e) {
                        this.colorOutput = e
                    }
                    get useRange() {
                        return this.luminanceRange !== null
                    }
                    set useRange(e) {
                        this.luminanceRange = null
                    }
                    get luminanceRange() {
                        return this.uniforms.range.value
                    }
                    set luminanceRange(e) {
                        e !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE,
                        this.uniforms.range.value = e,
                        this.needsUpdate = !0
                    }
                    getLuminanceRange() {
                        return this.luminanceRange
                    }
                    setLuminanceRange(e) {
                        this.luminanceRange = e
                    }
                }
                  , EF = class extends Ys {
                    constructor({renderTarget: e, luminanceRange: t, colorOutput: n, resolutionScale: i=1, width: s=Hn.AUTO_SIZE, height: r=Hn.AUTO_SIZE, resolutionX: l=s, resolutionY: h=r}={}) {
                        super("LuminancePass"),
                        this.fullscreenMaterial = new bF(n,t),
                        this.needsSwap = !1,
                        this.renderTarget = e,
                        this.renderTarget === void 0 && (this.renderTarget = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "LuminancePass.Target");
                        const d = this.resolution = new Hn(this,l,h,i);
                        d.addEventListener("change", p => this.setSize(d.baseWidth, d.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    render(e, t, n, i, s) {
                        const r = this.fullscreenMaterial;
                        r.inputBuffer = t.texture,
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && n !== ui && (this.renderTarget.texture.type = n,
                        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                }
                  , wF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`
                  , CF = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , RF = class extends Fn {
                    constructor() {
                        super({
                            name: "DownsamplingMaterial",
                            uniforms: {
                                inputBuffer: new Ce(null),
                                texelSize: new Ce(new ye)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: wF,
                            vertexShader: CF
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , DF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`
                  , OF = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , NF = class extends Fn {
                    constructor() {
                        super({
                            name: "UpsamplingMaterial",
                            uniforms: {
                                inputBuffer: new Ce(null),
                                supportBuffer: new Ce(null),
                                texelSize: new Ce(new ye),
                                radius: new Ce(.85)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: DF,
                            vertexShader: OF
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set supportBuffer(e) {
                        this.uniforms.supportBuffer.value = e
                    }
                    get radius() {
                        return this.uniforms.radius.value
                    }
                    set radius(e) {
                        this.uniforms.radius.value = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , UF = class extends Ys {
                    constructor() {
                        super("MipmapBlurPass"),
                        this.needsSwap = !1,
                        this.renderTarget = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "Upsampling.Mipmap0",
                        this.downsamplingMipmaps = [],
                        this.upsamplingMipmaps = [],
                        this.downsamplingMaterial = new RF,
                        this.upsamplingMaterial = new NF,
                        this.resolution = new ye
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    get levels() {
                        return this.downsamplingMipmaps.length
                    }
                    set levels(e) {
                        if (this.levels !== e) {
                            const t = this.renderTarget;
                            this.dispose(),
                            this.downsamplingMipmaps = [],
                            this.upsamplingMipmaps = [];
                            for (let n = 0; n < e; ++n) {
                                const i = t.clone();
                                i.texture.name = "Downsampling.Mipmap" + n,
                                this.downsamplingMipmaps.push(i)
                            }
                            this.upsamplingMipmaps.push(t);
                            for (let n = 1, i = e - 1; n < i; ++n) {
                                const s = t.clone();
                                s.texture.name = "Upsampling.Mipmap" + n,
                                this.upsamplingMipmaps.push(s)
                            }
                            this.setSize(this.resolution.x, this.resolution.y)
                        }
                    }
                    get radius() {
                        return this.upsamplingMaterial.radius
                    }
                    set radius(e) {
                        this.upsamplingMaterial.radius = e
                    }
                    render(e, t, n, i, s) {
                        const {scene: r, camera: l} = this
                          , {downsamplingMaterial: h, upsamplingMaterial: d} = this
                          , {downsamplingMipmaps: p, upsamplingMipmaps: m} = this;
                        let v = t;
                        this.fullscreenMaterial = h;
                        for (let _ = 0, x = p.length; _ < x; ++_) {
                            const b = p[_];
                            h.setSize(v.width, v.height),
                            h.inputBuffer = v.texture,
                            e.setRenderTarget(b),
                            e.render(r, l),
                            v = b
                        }
                        this.fullscreenMaterial = d;
                        for (let _ = m.length - 1; _ >= 0; --_) {
                            const x = m[_];
                            d.setSize(v.width, v.height),
                            d.inputBuffer = v.texture,
                            d.supportBuffer = p[_].texture,
                            e.setRenderTarget(x),
                            e.render(r, l),
                            v = x
                        }
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.set(e, t);
                        let i = n.width
                          , s = n.height;
                        for (let r = 0, l = this.downsamplingMipmaps.length; r < l; ++r)
                            i = Math.round(i * .5),
                            s = Math.round(s * .5),
                            this.downsamplingMipmaps[r].setSize(i, s),
                            r < this.upsamplingMipmaps.length && this.upsamplingMipmaps[r].setSize(i, s)
                    }
                    initialize(e, t, n) {
                        if (n !== void 0) {
                            const i = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                            for (const s of i)
                                s.texture.type = n;
                            if (n !== ui)
                                this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                                this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                            else if (e !== null && e.outputColorSpace === $t)
                                for (const s of i)
                                    s.texture.colorSpace = $t
                        }
                    }
                    dispose() {
                        super.dispose();
                        for (const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
                            e.dispose()
                    }
                }
                  , BF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`
                  , HR = class extends Ni {
                    constructor({blendFunction: e=Yt.SCREEN, luminanceThreshold: t=1, luminanceSmoothing: n=.03, mipmapBlur: i=!0, intensity: s=1, radius: r=.85, levels: l=8, kernelSize: h=Wp.LARGE, resolutionScale: d=.5, width: p=Hn.AUTO_SIZE, height: m=Hn.AUTO_SIZE, resolutionX: v=p, resolutionY: _=m}={}) {
                        super("BloomEffect", BF, {
                            blendFunction: e,
                            uniforms: new Map([["map", new Ce(null)], ["intensity", new Ce(s)]])
                        }),
                        this.renderTarget = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "Bloom.Target",
                        this.blurPass = new Ix({
                            kernelSize: h
                        }),
                        this.luminancePass = new EF({
                            colorOutput: !0
                        }),
                        this.luminanceMaterial.threshold = t,
                        this.luminanceMaterial.smoothing = n,
                        this.mipmapBlurPass = new UF,
                        this.mipmapBlurPass.enabled = i,
                        this.mipmapBlurPass.radius = r,
                        this.mipmapBlurPass.levels = l,
                        this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
                        const x = this.resolution = new Hn(this,v,_,d);
                        x.addEventListener("change", b => this.setSize(x.baseWidth, x.baseHeight))
                    }
                    get texture() {
                        return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
                    }
                    getTexture() {
                        return this.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getLuminancePass() {
                        return this.luminancePass
                    }
                    get luminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    getLuminanceMaterial() {
                        return this.luminancePass.fullscreenMaterial
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get dithering() {
                        return this.blurPass.dithering
                    }
                    set dithering(e) {
                        this.blurPass.dithering = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    get distinction() {
                        return console.warn(this.name, "distinction was removed"),
                        1
                    }
                    set distinction(e) {
                        console.warn(this.name, "distinction was removed")
                    }
                    get intensity() {
                        return this.uniforms.get("intensity").value
                    }
                    set intensity(e) {
                        this.uniforms.get("intensity").value = e
                    }
                    getIntensity() {
                        return this.intensity
                    }
                    setIntensity(e) {
                        this.intensity = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    update(e, t, n) {
                        const i = this.renderTarget
                          , s = this.luminancePass;
                        s.enabled ? (s.render(e, t),
                        this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, s.renderTarget) : this.blurPass.render(e, s.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, t) : this.blurPass.render(e, t, i)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height),
                        this.blurPass.resolution.copy(n),
                        this.luminancePass.setSize(e, t),
                        this.mipmapBlurPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, n),
                        this.luminancePass.initialize(e, t, n),
                        this.mipmapBlurPass.initialize(e, t, n),
                        n !== void 0 && (this.renderTarget.texture.type = n,
                        e !== null && e.outputColorSpace === $t && (this.renderTarget.texture.colorSpace = $t))
                    }
                }
                  , PF = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}"
                  , IF = class extends Ni {
                    constructor({blendFunction: e=Yt.SRC, brightness: t=0, contrast: n=0}={}) {
                        super("BrightnessContrastEffect", PF, {
                            blendFunction: e,
                            uniforms: new Map([["brightness", new Ce(t)], ["contrast", new Ce(n)]])
                        }),
                        this.inputColorSpace = $t
                    }
                    get brightness() {
                        return this.uniforms.get("brightness").value
                    }
                    set brightness(e) {
                        this.uniforms.get("brightness").value = e
                    }
                    getBrightness() {
                        return this.brightness
                    }
                    setBrightness(e) {
                        this.brightness = e
                    }
                    get contrast() {
                        return this.uniforms.get("contrast").value
                    }
                    set contrast(e) {
                        this.uniforms.get("contrast").value = e
                    }
                    getContrast() {
                        return this.contrast
                    }
                    setContrast(e) {
                        this.contrast = e
                    }
                }
                  , LF = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}"
                  , zF = class extends Ni {
                    constructor(e) {
                        super("ColorAverageEffect", LF, {
                            blendFunction: e
                        })
                    }
                }
                  , FF = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}"
                  , HF = class extends Ni {
                    constructor({blendFunction: e, bits: t=16}={}) {
                        super("ColorDepthEffect", FF, {
                            blendFunction: e,
                            uniforms: new Map([["factor", new Ce(1)]])
                        }),
                        this.bits = 0,
                        this.bitDepth = t
                    }
                    get bitDepth() {
                        return this.bits
                    }
                    set bitDepth(e) {
                        this.bits = e,
                        this.uniforms.get("factor").value = Math.pow(2, e / 3)
                    }
                    getBitDepth() {
                        return this.bitDepth
                    }
                    setBitDepth(e) {
                        this.bitDepth = e
                    }
                }
                  , VF = `#ifdef RADIAL_MODULATION
uniform float modulationOffset;
#endif
varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;
#ifdef RADIAL_MODULATION
const vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}
#else
if(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}
#endif
outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}`
                  , GF = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}"
                  , kF = class extends Ni {
                    constructor({offset: e=new ye(.001,5e-4), radialModulation: t=!1, modulationOffset: n=.15}={}) {
                        super("ChromaticAberrationEffect", VF, {
                            vertexShader: GF,
                            attributes: za.CONVOLUTION,
                            uniforms: new Map([["offset", new Ce(e)], ["modulationOffset", new Ce(n)]])
                        }),
                        this.radialModulation = t
                    }
                    get offset() {
                        return this.uniforms.get("offset").value
                    }
                    set offset(e) {
                        this.uniforms.get("offset").value = e
                    }
                    get radialModulation() {
                        return this.defines.has("RADIAL_MODULATION")
                    }
                    set radialModulation(e) {
                        e ? this.defines.set("RADIAL_MODULATION", "1") : this.defines.delete("RADIAL_MODULATION"),
                        this.setChanged()
                    }
                    get modulationOffset() {
                        return this.uniforms.get("modulationOffset").value
                    }
                    set modulationOffset(e) {
                        this.uniforms.get("modulationOffset").value = e
                    }
                    getOffset() {
                        return this.offset
                    }
                    setOffset(e) {
                        this.offset = e
                    }
                }
                  , XF = `void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){
#ifdef INVERTED
vec3 color=vec3(1.0-depth);
#else
vec3 color=vec3(depth);
#endif
outputColor=vec4(color,inputColor.a);}`
                  , qF = class extends Ni {
                    constructor({blendFunction: e=Yt.SRC, inverted: t=!1}={}) {
                        super("DepthEffect", XF, {
                            blendFunction: e,
                            attributes: za.DEPTH
                        }),
                        this.inverted = t
                    }
                    get inverted() {
                        return this.defines.has("INVERTED")
                    }
                    set inverted(e) {
                        this.inverted !== e && (e ? this.defines.set("INVERTED", "1") : this.defines.delete("INVERTED"),
                        this.setChanged())
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                }
                  , VR = {
                    RED: 0,
                    GREEN: 1,
                    BLUE: 2,
                    ALPHA: 3
                }
                  , TM = {
                    DISCARD: 0,
                    MULTIPLY: 1,
                    MULTIPLY_RGB_SET_ALPHA: 2,
                    MULTIPLY_RGB: 3
                }
                  , YF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;
#else
float coc=texture2D(cocBuffer,vUv).g*scale;
#endif
if(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);
#else
vec2 step=texelSize*coc;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`
                  , Lx = class extends Fn {
                    constructor(e=!1, t=!1) {
                        super({
                            name: "BokehMaterial",
                            defines: {
                                PASS: e ? "2" : "1"
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                cocBuffer: new Ce(null),
                                texelSize: new Ce(new ye),
                                kernel64: new Ce(null),
                                kernel16: new Ce(null),
                                scale: new Ce(1)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: YF,
                            vertexShader: Uf
                        }),
                        t && (this.defines.FOREGROUND = "1"),
                        this.generateKernel()
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set cocBuffer(e) {
                        this.uniforms.cocBuffer.value = e
                    }
                    setCoCBuffer(e) {
                        this.uniforms.cocBuffer.value = e
                    }
                    get scale() {
                        return this.uniforms.scale.value
                    }
                    set scale(e) {
                        this.uniforms.scale.value = e
                    }
                    getScale(e) {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    generateKernel() {
                        const e = 2.39996323
                          , t = new Float64Array(128)
                          , n = new Float64Array(32);
                        let i = 0
                          , s = 0;
                        for (let r = 0, l = Math.sqrt(80); r < 80; ++r) {
                            const h = r * e
                              , d = Math.sqrt(r) / l
                              , p = d * Math.cos(h)
                              , m = d * Math.sin(h);
                            r % 5 === 0 ? (n[s++] = p,
                            n[s++] = m) : (t[i++] = p,
                            t[i++] = m)
                        }
                        this.uniforms.kernel64.value = t,
                        this.uniforms.kernel16.value = n
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                ;
                function jp(e, t, n) {
                    return e * (t - n) - t
                }
                function Bf(e, t, n) {
                    return Math.min(Math.max((e + t) / (t - n), 0), 1)
                }
                var WF = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#ifdef LOG_DEPTH
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#endif
return depth;}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`
                  , jF = class extends Fn {
                    constructor(e) {
                        super({
                            name: "CircleOfConfusionMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new Ce(null),
                                focusDistance: new Ce(0),
                                focusRange: new Ce(0),
                                cameraNear: new Ce(.3),
                                cameraFar: new Ce(1e3)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: WF,
                            vertexShader: Uf
                        }),
                        this.uniforms.focalLength = this.uniforms.focusRange,
                        this.copyCameraSettings(e)
                    }
                    get near() {
                        return this.uniforms.cameraNear.value
                    }
                    get far() {
                        return this.uniforms.cameraFar.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=ji) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    get focusDistance() {
                        return this.uniforms.focusDistance.value
                    }
                    set focusDistance(e) {
                        this.uniforms.focusDistance.value = e
                    }
                    get worldFocusDistance() {
                        return -jp(this.focusDistance, this.near, this.far)
                    }
                    set worldFocusDistance(e) {
                        this.focusDistance = Bf(-e, this.near, this.far)
                    }
                    getFocusDistance(e) {
                        this.uniforms.focusDistance.value = e
                    }
                    setFocusDistance(e) {
                        this.uniforms.focusDistance.value = e
                    }
                    get focalLength() {
                        return this.focusRange
                    }
                    set focalLength(e) {
                        this.focusRange = e
                    }
                    get focusRange() {
                        return this.uniforms.focusRange.value
                    }
                    set focusRange(e) {
                        this.uniforms.focusRange.value = e
                    }
                    get worldFocusRange() {
                        return -jp(this.focusRange, this.near, this.far)
                    }
                    set worldFocusRange(e) {
                        this.focusRange = Bf(-e, this.near, this.far)
                    }
                    getFocalLength(e) {
                        return this.focusRange
                    }
                    setFocalLength(e) {
                        this.focusRange = e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near,
                        this.uniforms.cameraFar.value = e.far,
                        e instanceof hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                }
                  , QF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 3
vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);
#elif MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`
                  , ZF = class extends Fn {
                    constructor(e=null) {
                        super({
                            name: "MaskMaterial",
                            uniforms: {
                                maskTexture: new Ce(e),
                                inputBuffer: new Ce(null),
                                strength: new Ce(1)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: QF,
                            vertexShader: Uf
                        }),
                        this.colorChannel = VR.RED,
                        this.maskFunction = TM.DISCARD
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    set maskTexture(e) {
                        this.uniforms.maskTexture.value = e,
                        delete this.defines.MASK_PRECISION_HIGH,
                        e.type !== ui && (this.defines.MASK_PRECISION_HIGH = "1"),
                        this.needsUpdate = !0
                    }
                    setMaskTexture(e) {
                        this.maskTexture = e
                    }
                    set colorChannel(e) {
                        this.defines.COLOR_CHANNEL = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setColorChannel(e) {
                        this.colorChannel = e
                    }
                    set maskFunction(e) {
                        this.defines.MASK_FUNCTION = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setMaskFunction(e) {
                        this.maskFunction = e
                    }
                    get inverted() {
                        return this.defines.INVERTED !== void 0
                    }
                    set inverted(e) {
                        this.inverted && !e ? delete this.defines.INVERTED : e && (this.defines.INVERTED = "1"),
                        this.needsUpdate = !0
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    get strength() {
                        return this.uniforms.strength.value
                    }
                    set strength(e) {
                        this.uniforms.strength.value = e
                    }
                    getStrength() {
                        return this.strength
                    }
                    setStrength(e) {
                        this.strength = e
                    }
                }
                  , Dr = class extends Ys {
                    constructor(e, t="inputBuffer") {
                        super("ShaderPass"),
                        this.fullscreenMaterial = e,
                        this.input = t
                    }
                    setInput(e) {
                        this.input = e
                    }
                    render(e, t, n, i, s) {
                        const r = this.fullscreenMaterial.uniforms;
                        t !== null && r !== void 0 && r[this.input] !== void 0 && (r[this.input].value = t.texture),
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        e.render(this.scene, this.camera)
                    }
                    initialize(e, t, n) {
                        n !== void 0 && n !== ui && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                }
                  , KF = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);
#if MASK_FUNCTION == 1
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);
#else
vec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);
#endif
vec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}`
                  , JF = class extends Ni {
                    constructor(e, {blendFunction: t, worldFocusDistance: n, worldFocusRange: i, focusDistance: s=0, focalLength: r=.1, focusRange: l=r, bokehScale: h=1, resolutionScale: d=1, width: p=Hn.AUTO_SIZE, height: m=Hn.AUTO_SIZE, resolutionX: v=p, resolutionY: _=m}={}) {
                        super("DepthOfFieldEffect", KF, {
                            blendFunction: t,
                            attributes: za.DEPTH,
                            uniforms: new Map([["nearColorBuffer", new Ce(null)], ["farColorBuffer", new Ce(null)], ["nearCoCBuffer", new Ce(null)], ["farCoCBuffer", new Ce(null)], ["scale", new Ce(1)]])
                        }),
                        this.camera = e,
                        this.renderTarget = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "DoF.Intermediate",
                        this.renderTargetMasked = this.renderTarget.clone(),
                        this.renderTargetMasked.texture.name = "DoF.Masked.Far",
                        this.renderTargetNear = this.renderTarget.clone(),
                        this.renderTargetNear.texture.name = "DoF.Bokeh.Near",
                        this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture,
                        this.renderTargetFar = this.renderTarget.clone(),
                        this.renderTargetFar.texture.name = "DoF.Bokeh.Far",
                        this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture,
                        this.renderTargetCoC = this.renderTarget.clone(),
                        this.renderTargetCoC.texture.name = "DoF.CoC",
                        this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture,
                        this.renderTargetCoCBlurred = this.renderTargetCoC.clone(),
                        this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred",
                        this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture,
                        this.cocPass = new Dr(new jF(e));
                        const x = this.cocMaterial;
                        x.focusDistance = s,
                        x.focusRange = l,
                        n !== void 0 && (x.worldFocusDistance = n),
                        i !== void 0 && (x.worldFocusRange = i),
                        this.blurPass = new Ix({
                            resolutionScale: d,
                            resolutionX: v,
                            resolutionY: _,
                            kernelSize: Wp.MEDIUM
                        }),
                        this.maskPass = new Dr(new ZF(this.renderTargetCoC.texture));
                        const b = this.maskPass.fullscreenMaterial;
                        b.colorChannel = VR.GREEN,
                        this.maskFunction = TM.MULTIPLY_RGB,
                        this.bokehNearBasePass = new Dr(new Lx(!1,!0)),
                        this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture,
                        this.bokehNearFillPass = new Dr(new Lx(!0,!0)),
                        this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture,
                        this.bokehFarBasePass = new Dr(new Lx(!1,!1)),
                        this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture,
                        this.bokehFarFillPass = new Dr(new Lx(!0,!1)),
                        this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture,
                        this.target = null;
                        const E = this.resolution = new Hn(this,v,_,d);
                        E.addEventListener("change", T => this.setSize(E.baseWidth, E.baseHeight)),
                        this.bokehScale = h
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.cocMaterial.copyCameraSettings(e)
                    }
                    get cocTexture() {
                        return this.renderTargetCoC.texture
                    }
                    get maskFunction() {
                        return this.maskPass.fullscreenMaterial.maskFunction
                    }
                    set maskFunction(e) {
                        this.maskFunction !== e && (this.defines.set("MASK_FUNCTION", e.toFixed(0)),
                        this.maskPass.fullscreenMaterial.maskFunction = e,
                        this.setChanged())
                    }
                    get cocMaterial() {
                        return this.cocPass.fullscreenMaterial
                    }
                    get circleOfConfusionMaterial() {
                        return this.cocMaterial
                    }
                    getCircleOfConfusionMaterial() {
                        return this.cocMaterial
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get bokehScale() {
                        return this.uniforms.get("scale").value
                    }
                    set bokehScale(e) {
                        this.bokehNearBasePass.fullscreenMaterial.scale = e,
                        this.bokehNearFillPass.fullscreenMaterial.scale = e,
                        this.bokehFarBasePass.fullscreenMaterial.scale = e,
                        this.bokehFarFillPass.fullscreenMaterial.scale = e,
                        this.maskPass.fullscreenMaterial.strength = e,
                        this.uniforms.get("scale").value = e
                    }
                    getBokehScale() {
                        return this.bokehScale
                    }
                    setBokehScale(e) {
                        this.bokehScale = e
                    }
                    getTarget() {
                        return this.target
                    }
                    setTarget(e) {
                        this.target = e
                    }
                    calculateFocusDistance(e) {
                        const t = this.camera
                          , n = t.position.distanceTo(e);
                        return Bf(-n, t.near, t.far)
                    }
                    setDepthTexture(e, t=ji) {
                        this.cocMaterial.depthBuffer = e,
                        this.cocMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        const i = this.renderTarget
                          , s = this.renderTargetCoC
                          , r = this.renderTargetCoCBlurred
                          , l = this.renderTargetMasked;
                        if (this.target !== null) {
                            const h = this.calculateFocusDistance(this.target);
                            this.cocMaterial.focusDistance = h
                        }
                        this.cocPass.render(e, null, s),
                        this.blurPass.render(e, s, r),
                        this.maskPass.render(e, t, l),
                        this.bokehFarBasePass.render(e, l, i),
                        this.bokehFarFillPass.render(e, i, this.renderTargetFar),
                        this.bokehNearBasePass.render(e, t, i),
                        this.bokehNearFillPass.render(e, i, this.renderTargetNear)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.cocPass.setSize(e, t),
                        this.blurPass.setSize(e, t),
                        this.maskPass.setSize(e, t),
                        this.renderTargetFar.setSize(e, t),
                        this.renderTargetCoC.setSize(e, t),
                        this.renderTargetMasked.setSize(e, t),
                        this.renderTarget.setSize(i, s),
                        this.renderTargetNear.setSize(i, s),
                        this.renderTargetCoCBlurred.setSize(i, s),
                        this.bokehNearBasePass.fullscreenMaterial.setSize(e, t),
                        this.bokehNearFillPass.fullscreenMaterial.setSize(e, t),
                        this.bokehFarBasePass.fullscreenMaterial.setSize(e, t),
                        this.bokehFarFillPass.fullscreenMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.cocPass.initialize(e, t, n),
                        this.maskPass.initialize(e, t, n),
                        this.bokehNearBasePass.initialize(e, t, n),
                        this.bokehNearFillPass.initialize(e, t, n),
                        this.bokehFarBasePass.initialize(e, t, n),
                        this.bokehFarFillPass.initialize(e, t, n),
                        this.blurPass.initialize(e, t, ui),
                        e.capabilities.logarithmicDepthBuffer && (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
                        n !== void 0 && (this.renderTarget.texture.type = n,
                        this.renderTargetNear.texture.type = n,
                        this.renderTargetFar.texture.type = n,
                        this.renderTargetMasked.texture.type = n,
                        e !== null && e.outputColorSpace === $t && (this.renderTarget.texture.colorSpace = $t,
                        this.renderTargetNear.texture.colorSpace = $t,
                        this.renderTargetFar.texture.colorSpace = $t,
                        this.renderTargetMasked.texture.colorSpace = $t))
                    }
                }
                  , $F = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}"
                  , eH = class extends Ni {
                    constructor({blendFunction: e, angle: t=Math.PI * .5, scale: n=1}={}) {
                        super("DotScreenEffect", $F, {
                            blendFunction: e,
                            uniforms: new Map([["angle", new Ce(new ye)], ["scale", new Ce(n)]])
                        }),
                        this.angle = t
                    }
                    get angle() {
                        return Math.acos(this.uniforms.get("angle").value.y)
                    }
                    set angle(e) {
                        this.uniforms.get("angle").value.set(Math.sin(e), Math.cos(e))
                    }
                    getAngle() {
                        return this.angle
                    }
                    setAngle(e) {
                        this.angle = e
                    }
                    get scale() {
                        return this.uniforms.get("scale").value
                    }
                    set scale(e) {
                        this.uniforms.get("scale").value = e
                    }
                }
                  , tH = `#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))
#define ONE_OVER_TWELVE 0.08333333333333333
varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}`
                  , nH = "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}"
                  , iH = class extends Ni {
                    constructor({blendFunction: e=Yt.SRC}={}) {
                        super("FXAAEffect", tH, {
                            vertexShader: nH,
                            blendFunction: e,
                            defines: new Map([["EDGE_THRESHOLD_MIN", "0.0312"], ["EDGE_THRESHOLD_MAX", "0.125"], ["SUBPIXEL_QUALITY", "0.75"], ["SAMPLES", "12"]])
                        })
                    }
                    get minEdgeThreshold() {
                        return Number(this.defines.get("EDGE_THRESHOLD_MIN"))
                    }
                    set minEdgeThreshold(e) {
                        this.defines.set("EDGE_THRESHOLD_MIN", e.toFixed(12)),
                        this.setChanged()
                    }
                    get maxEdgeThreshold() {
                        return Number(this.defines.get("EDGE_THRESHOLD_MAX"))
                    }
                    set maxEdgeThreshold(e) {
                        this.defines.set("EDGE_THRESHOLD_MAX", e.toFixed(12)),
                        this.setChanged()
                    }
                    get subpixelQuality() {
                        return Number(this.defines.get("SUBPIXEL_QUALITY"))
                    }
                    set subpixelQuality(e) {
                        this.defines.set("SUBPIXEL_QUALITY", e.toFixed(12)),
                        this.setChanged()
                    }
                    get samples() {
                        return Number(this.defines.get("SAMPLES"))
                    }
                    set samples(e) {
                        this.defines.set("SAMPLES", e.toFixed(0)),
                        this.setChanged()
                    }
                }
                  , Pf = {
                    DISABLED: 0,
                    SPORADIC: 1,
                    CONSTANT_MILD: 2,
                    CONSTANT_WILD: 3
                };
                function sH(e, t, n) {
                    const i = new Map([[ap, 1], [Fy, 2], [ss, 4]]);
                    let s;
                    if (i.has(t) || console.error("Invalid noise texture format"),
                    n === ui) {
                        s = new Uint8Array(e * i.get(t));
                        for (let r = 0, l = s.length; r < l; ++r)
                            s[r] = Math.random() * 255 + .5
                    } else {
                        s = new Float32Array(e * i.get(t));
                        for (let r = 0, l = s.length; r < l; ++r)
                            s[r] = Math.random()
                    }
                    return s
                }
                var MM = class extends Xo {
                    constructor(e, t, n=ap, i=ui) {
                        super(sH(e * t, n, i), e, t, n, i),
                        this.needsUpdate = !0
                    }
                }
                  , aH = "uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}"
                  , zx = "Glitch.Generated";
                function rr(e, t) {
                    return e + Math.random() * (t - e)
                }
                var rH = class extends Ni {
                    constructor({chromaticAberrationOffset: e=null, delay: t=new ye(1.5,3.5), duration: n=new ye(.6,1), strength: i=new ye(.3,1), columns: s=.05, ratio: r=.85, perturbationMap: l=null, dtSize: h=64}={}) {
                        if (super("GlitchEffect", aH, {
                            uniforms: new Map([["perturbationMap", new Ce(null)], ["columns", new Ce(s)], ["active", new Ce(!1)], ["random", new Ce(1)], ["seeds", new Ce(new ye)], ["distortion", new Ce(new ye)]])
                        }),
                        l === null) {
                            const d = new MM(h,h,ss);
                            d.name = zx,
                            this.perturbationMap = d
                        } else
                            this.perturbationMap = l;
                        this.time = 0,
                        this.distortion = this.uniforms.get("distortion").value,
                        this.delay = t,
                        this.duration = n,
                        this.breakPoint = new ye(rr(this.delay.x, this.delay.y),rr(this.duration.x, this.duration.y)),
                        this.strength = i,
                        this.mode = Pf.SPORADIC,
                        this.ratio = r,
                        this.chromaticAberrationOffset = e
                    }
                    get seeds() {
                        return this.uniforms.get("seeds").value
                    }
                    get active() {
                        return this.uniforms.get("active").value
                    }
                    isActive() {
                        return this.active
                    }
                    get minDelay() {
                        return this.delay.x
                    }
                    set minDelay(e) {
                        this.delay.x = e
                    }
                    getMinDelay() {
                        return this.delay.x
                    }
                    setMinDelay(e) {
                        this.delay.x = e
                    }
                    get maxDelay() {
                        return this.delay.y
                    }
                    set maxDelay(e) {
                        this.delay.y = e
                    }
                    getMaxDelay() {
                        return this.delay.y
                    }
                    setMaxDelay(e) {
                        this.delay.y = e
                    }
                    get minDuration() {
                        return this.duration.x
                    }
                    set minDuration(e) {
                        this.duration.x = e
                    }
                    getMinDuration() {
                        return this.duration.x
                    }
                    setMinDuration(e) {
                        this.duration.x = e
                    }
                    get maxDuration() {
                        return this.duration.y
                    }
                    set maxDuration(e) {
                        this.duration.y = e
                    }
                    getMaxDuration() {
                        return this.duration.y
                    }
                    setMaxDuration(e) {
                        this.duration.y = e
                    }
                    get minStrength() {
                        return this.strength.x
                    }
                    set minStrength(e) {
                        this.strength.x = e
                    }
                    getMinStrength() {
                        return this.strength.x
                    }
                    setMinStrength(e) {
                        this.strength.x = e
                    }
                    get maxStrength() {
                        return this.strength.y
                    }
                    set maxStrength(e) {
                        this.strength.y = e
                    }
                    getMaxStrength() {
                        return this.strength.y
                    }
                    setMaxStrength(e) {
                        this.strength.y = e
                    }
                    getMode() {
                        return this.mode
                    }
                    setMode(e) {
                        this.mode = e
                    }
                    getGlitchRatio() {
                        return 1 - this.ratio
                    }
                    setGlitchRatio(e) {
                        this.ratio = Math.min(Math.max(1 - e, 0), 1)
                    }
                    get columns() {
                        return this.uniforms.get("columns").value
                    }
                    set columns(e) {
                        this.uniforms.get("columns").value = e
                    }
                    getGlitchColumns() {
                        return this.columns
                    }
                    setGlitchColumns(e) {
                        this.columns = e
                    }
                    getChromaticAberrationOffset() {
                        return this.chromaticAberrationOffset
                    }
                    setChromaticAberrationOffset(e) {
                        this.chromaticAberrationOffset = e
                    }
                    get perturbationMap() {
                        return this.uniforms.get("perturbationMap").value
                    }
                    set perturbationMap(e) {
                        const t = this.perturbationMap;
                        t !== null && t.name === zx && t.dispose(),
                        e.minFilter = e.magFilter = ti,
                        e.wrapS = e.wrapT = Uu,
                        e.generateMipmaps = !1,
                        this.uniforms.get("perturbationMap").value = e
                    }
                    getPerturbationMap() {
                        return this.perturbationMap
                    }
                    setPerturbationMap(e) {
                        this.perturbationMap = e
                    }
                    generatePerturbationMap(e=64) {
                        const t = new MM(e,e,ss);
                        return t.name = zx,
                        t
                    }
                    update(e, t, n) {
                        const i = this.mode
                          , s = this.breakPoint
                          , r = this.chromaticAberrationOffset
                          , l = this.strength;
                        let h = this.time, d = !1, p = 0, m = 0, v;
                        i !== Pf.DISABLED && (i === Pf.SPORADIC && (h += n,
                        v = h > s.x,
                        h >= s.x + s.y && (s.set(rr(this.delay.x, this.delay.y), rr(this.duration.x, this.duration.y)),
                        h = 0)),
                        p = Math.random(),
                        this.uniforms.get("random").value = p,
                        v && p > this.ratio || i === Pf.CONSTANT_WILD ? (d = !0,
                        p *= l.y * .03,
                        m = rr(-Math.PI, Math.PI),
                        this.seeds.set(rr(-l.y, l.y), rr(-l.y, l.y)),
                        this.distortion.set(rr(0, 1), rr(0, 1))) : (v || i === Pf.CONSTANT_MILD) && (d = !0,
                        p *= l.x * .03,
                        m = rr(-Math.PI, Math.PI),
                        this.seeds.set(rr(-l.x, l.x), rr(-l.x, l.x)),
                        this.distortion.set(rr(0, 1), rr(0, 1))),
                        this.time = h),
                        r !== null && (d ? r.set(Math.cos(m), Math.sin(m)).multiplyScalar(p) : r.set(0, 0)),
                        this.uniforms.get("active").value = d
                    }
                    dispose() {
                        const e = this.perturbationMap;
                        e !== null && e.name === zx && e.dispose()
                    }
                }
                  , Bv = {
                    DEFAULT: 0,
                    KEEP_MAX_DEPTH: 1,
                    DISCARD_MAX_DEPTH: 2
                }
                  , oH = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;
#endif
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;
#endif
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`
                  , GR = class extends Fn {
                    constructor() {
                        super({
                            name: "DepthMaskMaterial",
                            defines: {
                                DEPTH_EPSILON: "0.0001",
                                DEPTH_PACKING_0: "0",
                                DEPTH_PACKING_1: "0",
                                DEPTH_TEST_STRATEGY: Bv.KEEP_MAX_DEPTH
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                depthBuffer0: new Ce(null),
                                depthBuffer1: new Ce(null),
                                cameraNearFar: new Ce(new ye(1,1))
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: oH,
                            vertexShader: Uf
                        }),
                        this.depthMode = $d
                    }
                    set depthBuffer0(e) {
                        this.uniforms.depthBuffer0.value = e
                    }
                    set depthPacking0(e) {
                        this.defines.DEPTH_PACKING_0 = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer0(e, t=ji) {
                        this.depthBuffer0 = e,
                        this.depthPacking0 = t
                    }
                    set depthBuffer1(e) {
                        this.uniforms.depthBuffer1.value = e
                    }
                    set depthPacking1(e) {
                        this.defines.DEPTH_PACKING_1 = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer1(e, t=ji) {
                        this.depthBuffer1 = e,
                        this.depthPacking1 = t
                    }
                    get maxDepthStrategy() {
                        return Number(this.defines.DEPTH_TEST_STRATEGY)
                    }
                    set maxDepthStrategy(e) {
                        this.defines.DEPTH_TEST_STRATEGY = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    get keepFar() {
                        return this.maxDepthStrategy
                    }
                    set keepFar(e) {
                        this.maxDepthStrategy = e ? Bv.KEEP_MAX_DEPTH : Bv.DISCARD_MAX_DEPTH
                    }
                    getMaxDepthStrategy() {
                        return this.maxDepthStrategy
                    }
                    setMaxDepthStrategy(e) {
                        this.maxDepthStrategy = e
                    }
                    get epsilon() {
                        return Number(this.defines.DEPTH_EPSILON)
                    }
                    set epsilon(e) {
                        this.defines.DEPTH_EPSILON = e.toFixed(16),
                        this.needsUpdate = !0
                    }
                    getEpsilon() {
                        return this.epsilon
                    }
                    setEpsilon(e) {
                        this.epsilon = e
                    }
                    get depthMode() {
                        return Number(this.defines.DEPTH_MODE)
                    }
                    set depthMode(e) {
                        let t;
                        switch (e) {
                        case Ng:
                            t = "false";
                            break;
                        case Ug:
                            t = "true";
                            break;
                        case ef:
                            t = "abs(d1 - d0) <= DEPTH_EPSILON";
                            break;
                        case ep:
                            t = "abs(d1 - d0) > DEPTH_EPSILON";
                            break;
                        case $d:
                            t = "d0 > d1";
                            break;
                        case Ou:
                            t = "d0 >= d1";
                            break;
                        case Bg:
                            t = "d0 <= d1";
                            break;
                        case Pg:
                        default:
                            t = "d0 < d1";
                            break
                        }
                        this.defines.DEPTH_MODE = e.toFixed(0),
                        this.defines["depthTest(d0, d1)"] = t,
                        this.needsUpdate = !0
                    }
                    getDepthMode() {
                        return this.depthMode
                    }
                    setDepthMode(e) {
                        this.depthMode = e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNearFar.value.set(e.near, e.far),
                        e instanceof hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                }
                  , lH = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);
#include <dithering_fragment>
}`
                  , cH = class extends Fn {
                    constructor(e) {
                        super({
                            name: "GodRaysMaterial",
                            defines: {
                                SAMPLES_INT: "60",
                                SAMPLES_FLOAT: "60.0"
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                lightPosition: new Ce(e),
                                density: new Ce(1),
                                decay: new Ce(1),
                                weight: new Ce(1),
                                exposure: new Ce(1),
                                clampMax: new Ce(1)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: lH,
                            vertexShader: Uf
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get lightPosition() {
                        return this.uniforms.lightPosition.value
                    }
                    getLightPosition() {
                        return this.uniforms.lightPosition.value
                    }
                    setLightPosition(e) {
                        this.uniforms.lightPosition.value = e
                    }
                    get density() {
                        return this.uniforms.density.value
                    }
                    set density(e) {
                        this.uniforms.density.value = e
                    }
                    getDensity() {
                        return this.uniforms.density.value
                    }
                    setDensity(e) {
                        this.uniforms.density.value = e
                    }
                    get decay() {
                        return this.uniforms.decay.value
                    }
                    set decay(e) {
                        this.uniforms.decay.value = e
                    }
                    getDecay() {
                        return this.uniforms.decay.value
                    }
                    setDecay(e) {
                        this.uniforms.decay.value = e
                    }
                    get weight() {
                        return this.uniforms.weight.value
                    }
                    set weight(e) {
                        this.uniforms.weight.value = e
                    }
                    getWeight() {
                        return this.uniforms.weight.value
                    }
                    setWeight(e) {
                        this.uniforms.weight.value = e
                    }
                    get exposure() {
                        return this.uniforms.exposure.value
                    }
                    set exposure(e) {
                        this.uniforms.exposure.value = e
                    }
                    getExposure() {
                        return this.uniforms.exposure.value
                    }
                    setExposure(e) {
                        this.uniforms.exposure.value = e
                    }
                    get maxIntensity() {
                        return this.uniforms.clampMax.value
                    }
                    set maxIntensity(e) {
                        this.uniforms.clampMax.value = e
                    }
                    getMaxIntensity() {
                        return this.uniforms.clampMax.value
                    }
                    setMaxIntensity(e) {
                        this.uniforms.clampMax.value = e
                    }
                    get samples() {
                        return Number(this.defines.SAMPLES_INT)
                    }
                    set samples(e) {
                        const t = Math.floor(e);
                        this.defines.SAMPLES_INT = t.toFixed(0),
                        this.defines.SAMPLES_FLOAT = t.toFixed(1),
                        this.needsUpdate = !0
                    }
                    getSamples() {
                        return this.samples
                    }
                    setSamples(e) {
                        this.samples = e
                    }
                }
                  , Pv = class extends Ys {
                    constructor(e, t, n=null) {
                        super("RenderPass", e, t),
                        this.needsSwap = !1,
                        this.clearPass = new Yp,
                        this.overrideMaterialManager = n === null ? null : new zR(n),
                        this.ignoreBackground = !1,
                        this.skipShadowMapUpdate = !1,
                        this.selection = null
                    }
                    set mainScene(e) {
                        this.scene = e
                    }
                    set mainCamera(e) {
                        this.camera = e
                    }
                    get renderToScreen() {
                        return super.renderToScreen
                    }
                    set renderToScreen(e) {
                        super.renderToScreen = e,
                        this.clearPass.renderToScreen = e
                    }
                    get overrideMaterial() {
                        const e = this.overrideMaterialManager;
                        return e !== null ? e.material : null
                    }
                    set overrideMaterial(e) {
                        const t = this.overrideMaterialManager;
                        e !== null ? t !== null ? t.setMaterial(e) : this.overrideMaterialManager = new zR(e) : t !== null && (t.dispose(),
                        this.overrideMaterialManager = null)
                    }
                    getOverrideMaterial() {
                        return this.overrideMaterial
                    }
                    setOverrideMaterial(e) {
                        this.overrideMaterial = e
                    }
                    get clear() {
                        return this.clearPass.enabled
                    }
                    set clear(e) {
                        this.clearPass.enabled = e
                    }
                    getSelection() {
                        return this.selection
                    }
                    setSelection(e) {
                        this.selection = e
                    }
                    isBackgroundDisabled() {
                        return this.ignoreBackground
                    }
                    setBackgroundDisabled(e) {
                        this.ignoreBackground = e
                    }
                    isShadowMapDisabled() {
                        return this.skipShadowMapUpdate
                    }
                    setShadowMapDisabled(e) {
                        this.skipShadowMapUpdate = e
                    }
                    getClearPass() {
                        return this.clearPass
                    }
                    render(e, t, n, i, s) {
                        const r = this.scene
                          , l = this.camera
                          , h = this.selection
                          , d = l.layers.mask
                          , p = r.background
                          , m = e.shadowMap.autoUpdate
                          , v = this.renderToScreen ? null : t;
                        h !== null && l.layers.set(h.getLayer()),
                        this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
                        (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (r.background = null),
                        this.clearPass.enabled && this.clearPass.render(e, t),
                        e.setRenderTarget(v),
                        this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(e, r, l) : e.render(r, l),
                        l.layers.mask = d,
                        r.background = p,
                        e.shadowMap.autoUpdate = m
                    }
                }
                  , uH = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}`
                  , bM = new Q
                  , kR = new Xt
                  , hH = class extends Ni {
                    constructor(e, t, {blendFunction: n=Yt.SCREEN, samples: i=60, density: s=.96, decay: r=.9, weight: l=.4, exposure: h=.6, clampMax: d=1, blur: p=!0, kernelSize: m=Wp.SMALL, resolutionScale: v=.5, width: _=Hn.AUTO_SIZE, height: x=Hn.AUTO_SIZE, resolutionX: b=_, resolutionY: E=x}={}) {
                        super("GodRaysEffect", uH, {
                            blendFunction: n,
                            attributes: za.DEPTH,
                            uniforms: new Map([["map", new Ce(null)]])
                        }),
                        this.camera = e,
                        this._lightSource = t,
                        this.lightSource = t,
                        this.lightScene = new bp,
                        this.screenPosition = new ye,
                        this.renderTargetA = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetA.texture.name = "GodRays.Target.A",
                        this.renderTargetB = this.renderTargetA.clone(),
                        this.renderTargetB.texture.name = "GodRays.Target.B",
                        this.uniforms.get("map").value = this.renderTargetB.texture,
                        this.renderTargetLight = new Un(1,1),
                        this.renderTargetLight.texture.name = "GodRays.Light",
                        this.renderTargetLight.depthTexture = new mv,
                        this.renderPassLight = new Pv(this.lightScene,e),
                        this.renderPassLight.clearPass.overrideClearColor = new at(0),
                        this.clearPass = new Yp(!0,!1,!1),
                        this.clearPass.overrideClearColor = new at(0),
                        this.blurPass = new Ix({
                            kernelSize: m
                        }),
                        this.blurPass.enabled = p,
                        this.depthMaskPass = new Dr(new GR);
                        const T = this.depthMaskMaterial;
                        T.depthBuffer1 = this.renderTargetLight.depthTexture,
                        T.copyCameraSettings(e),
                        this.godRaysPass = new Dr(new cH(this.screenPosition));
                        const M = this.godRaysMaterial;
                        M.density = s,
                        M.decay = r,
                        M.weight = l,
                        M.exposure = h,
                        M.maxIntensity = d,
                        M.samples = i;
                        const D = this.resolution = new Hn(this,b,E,v);
                        D.addEventListener("change", R => this.setSize(D.baseWidth, D.baseHeight))
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.renderPassLight.mainCamera = e,
                        this.depthMaskMaterial.copyCameraSettings(e)
                    }
                    get lightSource() {
                        return this._lightSource
                    }
                    set lightSource(e) {
                        this._lightSource = e,
                        e !== null && (e.material.depthWrite = !1,
                        e.material.transparent = !0)
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    get texture() {
                        return this.renderTargetB.texture
                    }
                    getTexture() {
                        return this.texture
                    }
                    get depthMaskMaterial() {
                        return this.depthMaskPass.fullscreenMaterial
                    }
                    get godRaysMaterial() {
                        return this.godRaysPass.fullscreenMaterial
                    }
                    getGodRaysMaterial() {
                        return this.godRaysMaterial
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get dithering() {
                        return this.godRaysMaterial.dithering
                    }
                    set dithering(e) {
                        const t = this.godRaysMaterial;
                        t.dithering = e,
                        t.needsUpdate = !0
                    }
                    get blur() {
                        return this.blurPass.enabled
                    }
                    set blur(e) {
                        this.blurPass.enabled = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    get samples() {
                        return this.godRaysMaterial.samples
                    }
                    set samples(e) {
                        this.godRaysMaterial.samples = e
                    }
                    setDepthTexture(e, t=ji) {
                        this.depthMaskPass.fullscreenMaterial.depthBuffer0 = e,
                        this.depthMaskPass.fullscreenMaterial.depthPacking0 = t
                    }
                    update(e, t, n) {
                        const i = this.lightSource
                          , s = i.parent
                          , r = i.matrixAutoUpdate
                          , l = this.renderTargetA
                          , h = this.renderTargetLight;
                        i.material.depthWrite = !0,
                        i.matrixAutoUpdate = !1,
                        i.updateWorldMatrix(!0, !1),
                        s !== null && (r || kR.copy(i.matrix),
                        i.matrix.copy(i.matrixWorld)),
                        this.lightScene.add(i),
                        this.renderPassLight.render(e, h),
                        this.clearPass.render(e, l),
                        this.depthMaskPass.render(e, h, l),
                        i.material.depthWrite = !1,
                        i.matrixAutoUpdate = r,
                        s !== null && (r || i.matrix.copy(kR),
                        s.add(i)),
                        bM.setFromMatrixPosition(i.matrixWorld).project(this.camera),
                        this.screenPosition.set(Math.min(Math.max((bM.x + 1) * .5, -1), 2), Math.min(Math.max((bM.y + 1) * .5, -1), 2)),
                        this.blurPass.enabled && this.blurPass.render(e, l, l),
                        this.godRaysPass.render(e, l, this.renderTargetB)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.renderTargetA.setSize(i, s),
                        this.renderTargetB.setSize(i, s),
                        this.renderTargetLight.setSize(i, s),
                        this.blurPass.resolution.copy(n)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, n),
                        this.renderPassLight.initialize(e, t, n),
                        this.depthMaskPass.initialize(e, t, n),
                        this.godRaysPass.initialize(e, t, n),
                        n !== void 0 && (this.renderTargetA.texture.type = n,
                        this.renderTargetB.texture.type = n,
                        this.renderTargetLight.texture.type = n,
                        e !== null && e.outputColorSpace === $t && (this.renderTargetA.texture.colorSpace = $t,
                        this.renderTargetB.texture.colorSpace = $t,
                        this.renderTargetLight.texture.colorSpace = $t))
                    }
                }
                  , fH = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}"
                  , dH = class extends Ni {
                    constructor({blendFunction: e=Yt.OVERLAY, scale: t=1, lineWidth: n=0}={}) {
                        super("GridEffect", fH, {
                            blendFunction: e,
                            uniforms: new Map([["scale", new Ce(new ye)], ["lineWidth", new Ce(n)]])
                        }),
                        this.resolution = new ye,
                        this.s = 0,
                        this.scale = t,
                        this.l = 0,
                        this.lineWidth = n
                    }
                    get scale() {
                        return this.s
                    }
                    set scale(e) {
                        this.s = Math.max(e, 1e-6),
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getScale() {
                        return this.scale
                    }
                    setScale(e) {
                        this.scale = e
                    }
                    get lineWidth() {
                        return this.l
                    }
                    set lineWidth(e) {
                        this.l = e,
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getLineWidth() {
                        return this.lineWidth
                    }
                    setLineWidth(e) {
                        this.lineWidth = e
                    }
                    setSize(e, t) {
                        this.resolution.set(e, t);
                        const n = e / t
                          , i = this.scale * (t * .125);
                        this.uniforms.get("scale").value.set(n * i, i),
                        this.uniforms.get("lineWidth").value = i / t + this.lineWidth
                    }
                }
                  , pH = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}"
                  , mH = class extends Ni {
                    constructor({blendFunction: e=Yt.SRC, hue: t=0, saturation: n=0}={}) {
                        super("HueSaturationEffect", pH, {
                            blendFunction: e,
                            uniforms: new Map([["hue", new Ce(new Q)], ["saturation", new Ce(n)]])
                        }),
                        this.hue = t
                    }
                    get saturation() {
                        return this.uniforms.get("saturation").value
                    }
                    set saturation(e) {
                        this.uniforms.get("saturation").value = e
                    }
                    getSaturation() {
                        return this.saturation
                    }
                    setSaturation(e) {
                        this.saturation = e
                    }
                    get hue() {
                        const e = this.uniforms.get("hue").value;
                        return Math.acos((e.x * 3 - 1) / 2)
                    }
                    set hue(e) {
                        const t = Math.sin(e)
                          , n = Math.cos(e);
                        this.uniforms.get("hue").value.set((2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3)
                    }
                    getHue() {
                        return this.hue
                    }
                    setHue(e) {
                        this.hue = e
                    }
                }
                  , Iv = {
                    FULL: 0,
                    SINGLE: 1
                }
                  , XR = {
                    DEPTH: 0,
                    LUMA: 1,
                    COLOR: 2
                }
                  , gH = {
                    DISABLED: 0,
                    DEPTH: 1,
                    CUSTOM: 2
                }
                  , Lv = {
                    LOW: 0,
                    MEDIUM: 1,
                    HIGH: 2,
                    ULTRA: 3
                }
                  , vH = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`
                  , yH = class extends Ni {
                    constructor({blendFunction: e=Yt.SCREEN, premultiply: t=!1}={}) {
                        super("NoiseEffect", vH, {
                            blendFunction: e
                        }),
                        this.premultiply = t
                    }
                    get premultiply() {
                        return this.defines.has("PREMULTIPLY")
                    }
                    set premultiply(e) {
                        this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"),
                        this.setChanged())
                    }
                    isPremultiplied() {
                        return this.premultiply
                    }
                    setPremultiplied(e) {
                        this.premultiply = e
                    }
                }
                  , _H = `#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`
                  , xH = `#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`
                  , SH = class extends Fn {
                    constructor(e=null, t) {
                        super({
                            name: "DepthComparisonMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new Ce(null),
                                cameraNear: new Ce(.3),
                                cameraFar: new Ce(1e3)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: _H,
                            vertexShader: xH
                        }),
                        this.depthBuffer = e,
                        this.depthPacking = Fo,
                        this.copyCameraSettings(t)
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=Fo) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near,
                        this.uniforms.cameraFar.value = e.far,
                        e instanceof hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                }
                  , AH = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}"
                  , TH = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                  , MH = class extends Fn {
                    constructor(e=new ye) {
                        super({
                            name: "OutlineMaterial",
                            uniforms: {
                                inputBuffer: new Ce(null),
                                texelSize: new Ce(new ye)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: AH,
                            vertexShader: TH
                        }),
                        this.uniforms.texelSize.value.set(e.x, e.y),
                        this.uniforms.maskTexture = this.uniforms.inputBuffer
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , qR = class extends Ys {
                    constructor(e, t, {renderTarget: n, resolutionScale: i=1, width: s=Hn.AUTO_SIZE, height: r=Hn.AUTO_SIZE, resolutionX: l=s, resolutionY: h=r}={}) {
                        super("DepthPass"),
                        this.needsSwap = !1,
                        this.renderPass = new Pv(e,t,new hx({
                            depthPacking: Fo
                        }));
                        const d = this.renderPass;
                        d.skipShadowMapUpdate = !0,
                        d.ignoreBackground = !0;
                        const p = d.clearPass;
                        p.overrideClearColor = new at(16777215),
                        p.overrideClearAlpha = 1,
                        this.renderTarget = n,
                        this.renderTarget === void 0 && (this.renderTarget = new Un(1,1,{
                            minFilter: ti,
                            magFilter: ti
                        }),
                        this.renderTarget.texture.name = "DepthPass.Target");
                        const m = this.resolution = new Hn(this,l,h,i);
                        m.addEventListener("change", v => this.setSize(m.baseWidth, m.baseHeight))
                    }
                    set mainScene(e) {
                        this.renderPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.renderPass.mainCamera = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, s) {
                        const r = this.renderToScreen ? null : this.renderTarget;
                        this.renderPass.render(e, r)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height)
                    }
                }
                  , bH = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texture2D(patternTexture,vUvPattern);
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`
                  , EH = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}"
                  , wH = class extends Ni {
                    constructor(e, t, {blendFunction: n=Yt.SCREEN, patternTexture: i=null, patternScale: s=1, edgeStrength: r=1, pulseSpeed: l=0, visibleEdgeColor: h=16777215, hiddenEdgeColor: d=2230538, kernelSize: p=Wp.VERY_SMALL, blur: m=!1, xRay: v=!0, multisampling: _=0, resolutionScale: x=.5, width: b=Hn.AUTO_SIZE, height: E=Hn.AUTO_SIZE, resolutionX: T=b, resolutionY: M=E}={}) {
                        super("OutlineEffect", bH, {
                            uniforms: new Map([["maskTexture", new Ce(null)], ["edgeTexture", new Ce(null)], ["edgeStrength", new Ce(r)], ["visibleEdgeColor", new Ce(new at(h))], ["hiddenEdgeColor", new Ce(new at(d))], ["pulse", new Ce(1)], ["patternScale", new Ce(s)], ["patternTexture", new Ce(null)]])
                        }),
                        this.blendMode.addEventListener("change", U => {
                            this.blendMode.blendFunction === Yt.ALPHA ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"),
                            this.setChanged()
                        }
                        ),
                        this.blendMode.blendFunction = n,
                        this.patternTexture = i,
                        this.xRay = v,
                        this.scene = e,
                        this.camera = t,
                        this.renderTargetMask = new Un(1,1),
                        this.renderTargetMask.samples = _,
                        this.renderTargetMask.texture.name = "Outline.Mask",
                        this.uniforms.get("maskTexture").value = this.renderTargetMask.texture,
                        this.renderTargetOutline = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetOutline.texture.name = "Outline.Edges",
                        this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture,
                        this.clearPass = new Yp,
                        this.clearPass.overrideClearColor = new at(0),
                        this.clearPass.overrideClearAlpha = 1,
                        this.depthPass = new qR(e,t),
                        this.maskPass = new Pv(e,t,new SH(this.depthPass.texture,t));
                        const D = this.maskPass.clearPass;
                        D.overrideClearColor = new at(16777215),
                        D.overrideClearAlpha = 1,
                        this.blurPass = new Ix({
                            resolutionScale: x,
                            resolutionX: T,
                            resolutionY: M,
                            kernelSize: p
                        }),
                        this.blurPass.enabled = m;
                        const R = this.blurPass.resolution;
                        R.addEventListener("change", U => this.setSize(R.baseWidth, R.baseHeight)),
                        this.outlinePass = new Dr(new MH);
                        const O = this.outlinePass.fullscreenMaterial;
                        O.inputBuffer = this.renderTargetMask.texture,
                        this.time = 0,
                        this.forceUpdate = !0,
                        this.selection = new FR,
                        this.pulseSpeed = l
                    }
                    set mainScene(e) {
                        this.scene = e,
                        this.depthPass.mainScene = e,
                        this.maskPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.depthPass.mainCamera = e,
                        this.maskPass.mainCamera = e,
                        this.maskPass.overrideMaterial.copyCameraSettings(e)
                    }
                    get resolution() {
                        return this.blurPass.resolution
                    }
                    getResolution() {
                        return this.blurPass.getResolution()
                    }
                    get multisampling() {
                        return this.renderTargetMask.samples
                    }
                    set multisampling(e) {
                        this.renderTargetMask.samples = e,
                        this.renderTargetMask.dispose()
                    }
                    get patternScale() {
                        return this.uniforms.get("patternScale").value
                    }
                    set patternScale(e) {
                        this.uniforms.get("patternScale").value = e
                    }
                    get edgeStrength() {
                        return this.uniforms.get("edgeStrength").value
                    }
                    set edgeStrength(e) {
                        this.uniforms.get("edgeStrength").value = e
                    }
                    get visibleEdgeColor() {
                        return this.uniforms.get("visibleEdgeColor").value
                    }
                    set visibleEdgeColor(e) {
                        this.uniforms.get("visibleEdgeColor").value = e
                    }
                    get hiddenEdgeColor() {
                        return this.uniforms.get("hiddenEdgeColor").value
                    }
                    set hiddenEdgeColor(e) {
                        this.uniforms.get("hiddenEdgeColor").value = e
                    }
                    getBlurPass() {
                        return this.blurPass
                    }
                    getSelection() {
                        return this.selection
                    }
                    getPulseSpeed() {
                        return this.pulseSpeed
                    }
                    setPulseSpeed(e) {
                        this.pulseSpeed = e
                    }
                    get width() {
                        return this.resolution.width
                    }
                    set width(e) {
                        this.resolution.preferredWidth = e
                    }
                    get height() {
                        return this.resolution.height
                    }
                    set height(e) {
                        this.resolution.preferredHeight = e
                    }
                    get selectionLayer() {
                        return this.selection.layer
                    }
                    set selectionLayer(e) {
                        this.selection.layer = e
                    }
                    get dithering() {
                        return this.blurPass.dithering
                    }
                    set dithering(e) {
                        this.blurPass.dithering = e
                    }
                    get kernelSize() {
                        return this.blurPass.kernelSize
                    }
                    set kernelSize(e) {
                        this.blurPass.kernelSize = e
                    }
                    get blur() {
                        return this.blurPass.enabled
                    }
                    set blur(e) {
                        this.blurPass.enabled = e
                    }
                    get xRay() {
                        return this.defines.has("X_RAY")
                    }
                    set xRay(e) {
                        this.xRay !== e && (e ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"),
                        this.setChanged())
                    }
                    isXRayEnabled() {
                        return this.xRay
                    }
                    setXRayEnabled(e) {
                        this.xRay = e
                    }
                    get patternTexture() {
                        return this.uniforms.get("patternTexture").value
                    }
                    set patternTexture(e) {
                        e !== null ? (e.wrapS = e.wrapT = Uu,
                        this.defines.set("USE_PATTERN", "1"),
                        this.setVertexShader(EH)) : (this.defines.delete("USE_PATTERN"),
                        this.setVertexShader(null)),
                        this.uniforms.get("patternTexture").value = e,
                        this.setChanged()
                    }
                    setPatternTexture(e) {
                        this.patternTexture = e
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    setSelection(e) {
                        return this.selection.set(e),
                        this
                    }
                    clearSelection() {
                        return this.selection.clear(),
                        this
                    }
                    selectObject(e) {
                        return this.selection.add(e),
                        this
                    }
                    deselectObject(e) {
                        return this.selection.delete(e),
                        this
                    }
                    update(e, t, n) {
                        const i = this.scene
                          , s = this.camera
                          , r = this.selection
                          , l = this.uniforms.get("pulse")
                          , h = i.background
                          , d = s.layers.mask;
                        (this.forceUpdate || r.size > 0) && (i.background = null,
                        l.value = 1,
                        this.pulseSpeed > 0 && (l.value = Math.cos(this.time * this.pulseSpeed * 10) * .375 + .625),
                        this.time += n,
                        r.setVisible(!1),
                        this.depthPass.render(e),
                        r.setVisible(!0),
                        s.layers.set(r.layer),
                        this.maskPass.render(e, this.renderTargetMask),
                        s.layers.mask = d,
                        i.background = h,
                        this.outlinePass.render(e, null, this.renderTargetOutline),
                        this.blurPass.enabled && this.blurPass.render(e, this.renderTargetOutline, this.renderTargetOutline)),
                        this.forceUpdate = r.size > 0
                    }
                    setSize(e, t) {
                        this.blurPass.setSize(e, t),
                        this.renderTargetMask.setSize(e, t);
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.depthPass.setSize(i, s),
                        this.renderTargetOutline.setSize(i, s),
                        this.outlinePass.fullscreenMaterial.setSize(i, s)
                    }
                    initialize(e, t, n) {
                        this.blurPass.initialize(e, t, ui),
                        n !== void 0 && (this.depthPass.initialize(e, t, n),
                        this.maskPass.initialize(e, t, n),
                        this.outlinePass.initialize(e, t, n))
                    }
                }
                  , CH = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}"
                  , RH = class extends Ni {
                    constructor(e=30) {
                        super("PixelationEffect", CH, {
                            uniforms: new Map([["active", new Ce(!1)], ["d", new Ce(new gn)]])
                        }),
                        this.resolution = new ye,
                        this._granularity = 0,
                        this.granularity = e
                    }
                    get granularity() {
                        return this._granularity
                    }
                    set granularity(e) {
                        let t = Math.floor(e);
                        t % 2 > 0 && (t += 1),
                        this._granularity = t,
                        this.uniforms.get("active").value = t > 0,
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getGranularity() {
                        return this.granularity
                    }
                    setGranularity(e) {
                        this.granularity = e
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.set(e, t);
                        const i = this.granularity
                          , s = i / n.x
                          , r = i / n.y;
                        this.uniforms.get("d").value.set(s, r, 1 / s, 1 / r)
                    }
                }
                  , DH = `uniform float count;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;
#ifdef SCROLL
y+=time*scrollSpeed;
#endif
vec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`
                  , OH = class extends Ni {
                    constructor({blendFunction: e=Yt.OVERLAY, density: t=1.25, scrollSpeed: n=0}={}) {
                        super("ScanlineEffect", DH, {
                            blendFunction: e,
                            uniforms: new Map([["count", new Ce(0)], ["scrollSpeed", new Ce(0)]])
                        }),
                        this.resolution = new ye,
                        this.d = t,
                        this.scrollSpeed = n
                    }
                    get density() {
                        return this.d
                    }
                    set density(e) {
                        this.d = e,
                        this.setSize(this.resolution.width, this.resolution.height)
                    }
                    getDensity() {
                        return this.density
                    }
                    setDensity(e) {
                        this.density = e
                    }
                    get scrollSpeed() {
                        return this.uniforms.get("scrollSpeed").value
                    }
                    set scrollSpeed(e) {
                        this.uniforms.get("scrollSpeed").value = e,
                        e === 0 ? this.defines.delete("SCROLL") && this.setChanged() : this.defines.has("SCROLL") || (this.defines.set("SCROLL", "1"),
                        this.setChanged())
                    }
                    setSize(e, t) {
                        this.resolution.set(e, t),
                        this.uniforms.get("count").value = Math.round(t * this.density)
                    }
                }
                  , v9 = Math.PI * .5
                  , NH = class extends HR {
                    constructor(e, t, n) {
                        super(n),
                        this.setAttributes(this.getAttributes() | za.DEPTH),
                        this.camera = t,
                        this.depthPass = new qR(e,t),
                        this.clearPass = new Yp(!0,!1,!1),
                        this.clearPass.overrideClearColor = new at(0),
                        this.depthMaskPass = new Dr(new GR);
                        const i = this.depthMaskMaterial;
                        i.copyCameraSettings(t),
                        i.depthBuffer1 = this.depthPass.texture,
                        i.depthPacking1 = Fo,
                        i.depthMode = ef,
                        this.renderTargetMasked = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetMasked.texture.name = "Bloom.Masked",
                        this.selection = new FR,
                        this._inverted = !1,
                        this._ignoreBackground = !1
                    }
                    set mainScene(e) {
                        this.depthPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.depthPass.mainCamera = e,
                        this.depthMaskMaterial.copyCameraSettings(e)
                    }
                    getSelection() {
                        return this.selection
                    }
                    get depthMaskMaterial() {
                        return this.depthMaskPass.fullscreenMaterial
                    }
                    get inverted() {
                        return this._inverted
                    }
                    set inverted(e) {
                        this._inverted = e,
                        this.depthMaskMaterial.depthMode = e ? ep : ef
                    }
                    isInverted() {
                        return this.inverted
                    }
                    setInverted(e) {
                        this.inverted = e
                    }
                    get ignoreBackground() {
                        return this._ignoreBackground
                    }
                    set ignoreBackground(e) {
                        this._ignoreBackground = e,
                        this.depthMaskMaterial.maxDepthStrategy = e ? Bv.DISCARD_MAX_DEPTH : Bv.KEEP_MAX_DEPTH
                    }
                    isBackgroundDisabled() {
                        return this.ignoreBackground
                    }
                    setBackgroundDisabled(e) {
                        this.ignoreBackground = e
                    }
                    setDepthTexture(e, t=ji) {
                        this.depthMaskMaterial.depthBuffer0 = e,
                        this.depthMaskMaterial.depthPacking0 = t
                    }
                    update(e, t, n) {
                        const i = this.camera
                          , s = this.selection
                          , r = this.inverted;
                        let l = t;
                        if (this.ignoreBackground || !r || s.size > 0) {
                            const h = i.layers.mask;
                            i.layers.set(s.layer),
                            this.depthPass.render(e),
                            i.layers.mask = h,
                            l = this.renderTargetMasked,
                            this.clearPass.render(e, l),
                            this.depthMaskPass.render(e, t, l)
                        }
                        super.update(e, l, n)
                    }
                    setSize(e, t) {
                        super.setSize(e, t),
                        this.renderTargetMasked.setSize(e, t),
                        this.depthPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        super.initialize(e, t, n),
                        this.clearPass.initialize(e, t, n),
                        this.depthPass.initialize(e, t, n),
                        this.depthMaskPass.initialize(e, t, n),
                        e !== null && e.capabilities.logarithmicDepthBuffer && (this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
                        n !== void 0 && (this.renderTargetMasked.texture.type = n,
                        e !== null && e.outputColorSpace === $t && (this.renderTargetMasked.texture.colorSpace = $t))
                    }
                }
                  , UH = "uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}"
                  , BH = class extends Ni {
                    constructor({blendFunction: e, intensity: t=1}={}) {
                        super("SepiaEffect", UH, {
                            blendFunction: e,
                            uniforms: new Map([["weightsR", new Ce(new Q(.393,.769,.189))], ["weightsG", new Ce(new Q(.349,.686,.168))], ["weightsB", new Ce(new Q(.272,.534,.131))]])
                        })
                    }
                    get intensity() {
                        return this.blendMode.opacity.value
                    }
                    set intensity(e) {
                        this.blendMode.opacity.value = e
                    }
                    getIntensity() {
                        return this.intensity
                    }
                    setIntensity(e) {
                        this.intensity = e
                    }
                    get weightsR() {
                        return this.uniforms.get("weightsR").value
                    }
                    get weightsG() {
                        return this.uniforms.get("weightsG").value
                    }
                    get weightsB() {
                        return this.uniforms.get("weightsB").value
                    }
                }
                  , PH = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`
                  , IH = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`
                  , LH = class extends Fn {
                    constructor(e=new ye, t=XR.COLOR) {
                        super({
                            name: "EdgeDetectionMaterial",
                            defines: {
                                THREE_REVISION: xc.replace(/\D+/g, ""),
                                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                                EDGE_THRESHOLD: "0.1",
                                DEPTH_THRESHOLD: "0.01",
                                PREDICATION_MODE: "0",
                                PREDICATION_THRESHOLD: "0.01",
                                PREDICATION_SCALE: "2.0",
                                PREDICATION_STRENGTH: "1.0",
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                depthBuffer: new Ce(null),
                                predicationBuffer: new Ce(null),
                                texelSize: new Ce(e)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: PH,
                            vertexShader: IH
                        }),
                        this.edgeDetectionMode = t
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=ji) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    get edgeDetectionMode() {
                        return Number(this.defines.EDGE_DETECTION_MODE)
                    }
                    set edgeDetectionMode(e) {
                        this.defines.EDGE_DETECTION_MODE = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getEdgeDetectionMode() {
                        return this.edgeDetectionMode
                    }
                    setEdgeDetectionMode(e) {
                        this.edgeDetectionMode = e
                    }
                    get localContrastAdaptationFactor() {
                        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
                    }
                    set localContrastAdaptationFactor(e) {
                        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getLocalContrastAdaptationFactor() {
                        return this.localContrastAdaptationFactor
                    }
                    setLocalContrastAdaptationFactor(e) {
                        this.localContrastAdaptationFactor = e
                    }
                    get edgeDetectionThreshold() {
                        return Number(this.defines.EDGE_THRESHOLD)
                    }
                    set edgeDetectionThreshold(e) {
                        this.defines.EDGE_THRESHOLD = e.toFixed("6"),
                        this.defines.DEPTH_THRESHOLD = (e * .1).toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getEdgeDetectionThreshold() {
                        return this.edgeDetectionThreshold
                    }
                    setEdgeDetectionThreshold(e) {
                        this.edgeDetectionThreshold = e
                    }
                    get predicationMode() {
                        return Number(this.defines.PREDICATION_MODE)
                    }
                    set predicationMode(e) {
                        this.defines.PREDICATION_MODE = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getPredicationMode() {
                        return this.predicationMode
                    }
                    setPredicationMode(e) {
                        this.predicationMode = e
                    }
                    set predicationBuffer(e) {
                        this.uniforms.predicationBuffer.value = e
                    }
                    setPredicationBuffer(e) {
                        this.uniforms.predicationBuffer.value = e
                    }
                    get predicationThreshold() {
                        return Number(this.defines.PREDICATION_THRESHOLD)
                    }
                    set predicationThreshold(e) {
                        this.defines.PREDICATION_THRESHOLD = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getPredicationThreshold() {
                        return this.predicationThreshold
                    }
                    setPredicationThreshold(e) {
                        this.predicationThreshold = e
                    }
                    get predicationScale() {
                        return Number(this.defines.PREDICATION_SCALE)
                    }
                    set predicationScale(e) {
                        this.defines.PREDICATION_SCALE = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getPredicationScale() {
                        return this.predicationScale
                    }
                    setPredicationScale(e) {
                        this.predicationScale = e
                    }
                    get predicationStrength() {
                        return Number(this.defines.PREDICATION_STRENGTH)
                    }
                    set predicationStrength(e) {
                        this.defines.PREDICATION_STRENGTH = e.toFixed("6"),
                        this.needsUpdate = !0
                    }
                    getPredicationStrength() {
                        return this.predicationStrength
                    }
                    setPredicationStrength(e) {
                        this.predicationStrength = e
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , zH = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`
                  , FH = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , HH = class extends Fn {
                    constructor(e=new ye, t=new ye) {
                        super({
                            name: "SMAAWeightsMaterial",
                            defines: {
                                MAX_SEARCH_STEPS_INT: "16",
                                MAX_SEARCH_STEPS_FLOAT: "16.0",
                                MAX_SEARCH_STEPS_DIAG_INT: "8",
                                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                                CORNER_ROUNDING: "25",
                                CORNER_ROUNDING_NORM: "0.25",
                                AREATEX_MAX_DISTANCE: "16.0",
                                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                searchTexture: new Ce(null),
                                areaTexture: new Ce(null),
                                resolution: new Ce(t),
                                texelSize: new Ce(e)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: zH,
                            vertexShader: FH
                        })
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get searchTexture() {
                        return this.uniforms.searchTexture.value
                    }
                    set searchTexture(e) {
                        this.uniforms.searchTexture.value = e
                    }
                    get areaTexture() {
                        return this.uniforms.areaTexture.value
                    }
                    set areaTexture(e) {
                        this.uniforms.areaTexture.value = e
                    }
                    setLookupTextures(e, t) {
                        this.searchTexture = e,
                        this.areaTexture = t
                    }
                    get orthogonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_INT)
                    }
                    set orthogonalSearchSteps(e) {
                        const t = Math.min(Math.max(e, 0), 112);
                        this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"),
                        this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"),
                        this.needsUpdate = !0
                    }
                    setOrthogonalSearchSteps(e) {
                        this.orthogonalSearchSteps = e
                    }
                    get diagonalSearchSteps() {
                        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
                    }
                    set diagonalSearchSteps(e) {
                        const t = Math.min(Math.max(e, 0), 20);
                        this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"),
                        this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"),
                        this.needsUpdate = !0
                    }
                    setDiagonalSearchSteps(e) {
                        this.diagonalSearchSteps = e
                    }
                    get diagonalDetection() {
                        return this.defines.DISABLE_DIAG_DETECTION === void 0
                    }
                    set diagonalDetection(e) {
                        e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1",
                        this.needsUpdate = !0
                    }
                    isDiagonalDetectionEnabled() {
                        return this.diagonalDetection
                    }
                    setDiagonalDetectionEnabled(e) {
                        this.diagonalDetection = e
                    }
                    get cornerRounding() {
                        return Number(this.defines.CORNER_ROUNDING)
                    }
                    set cornerRounding(e) {
                        const t = Math.min(Math.max(e, 0), 100);
                        this.defines.CORNER_ROUNDING = t.toFixed("4"),
                        this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"),
                        this.needsUpdate = !0
                    }
                    setCornerRounding(e) {
                        this.cornerRounding = e
                    }
                    get cornerDetection() {
                        return this.defines.DISABLE_CORNER_DETECTION === void 0
                    }
                    set cornerDetection(e) {
                        e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1",
                        this.needsUpdate = !0
                    }
                    isCornerRoundingEnabled() {
                        return this.cornerDetection
                    }
                    setCornerRoundingEnabled(e) {
                        this.cornerDetection = e
                    }
                    setSize(e, t) {
                        const n = this.uniforms;
                        n.texelSize.value.set(1 / e, 1 / t),
                        n.resolution.value.set(e, t)
                    }
                }
                  , YR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"
                  , WR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC"
                  , VH = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}"
                  , GH = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}"
                  , kH = class extends Ni {
                    constructor({blendFunction: e=Yt.SRC, preset: t=Lv.MEDIUM, edgeDetectionMode: n=XR.COLOR, predicationMode: i=gH.DISABLED}={}) {
                        super("SMAAEffect", VH, {
                            vertexShader: GH,
                            blendFunction: e,
                            attributes: za.CONVOLUTION | za.DEPTH,
                            uniforms: new Map([["weightMap", new Ce(null)]])
                        });
                        let s, r;
                        arguments.length > 1 && (s = arguments[0],
                        r = arguments[1],
                        arguments.length > 2 && (t = arguments[2]),
                        arguments.length > 3 && (n = arguments[3])),
                        this.renderTargetEdges = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTargetEdges.texture.name = "SMAA.Edges",
                        this.renderTargetWeights = this.renderTargetEdges.clone(),
                        this.renderTargetWeights.texture.name = "SMAA.Weights",
                        this.uniforms.get("weightMap").value = this.renderTargetWeights.texture,
                        this.clearPass = new Yp(!0,!1,!1),
                        this.clearPass.overrideClearColor = new at(0),
                        this.clearPass.overrideClearAlpha = 1,
                        this.edgeDetectionPass = new Dr(new LH),
                        this.edgeDetectionMaterial.edgeDetectionMode = n,
                        this.edgeDetectionMaterial.predicationMode = i,
                        this.weightsPass = new Dr(new HH);
                        const l = new fx;
                        l.onLoad = () => {
                            const h = new zi(s);
                            h.name = "SMAA.Search",
                            h.magFilter = ti,
                            h.minFilter = ti,
                            h.generateMipmaps = !1,
                            h.needsUpdate = !0,
                            h.flipY = !0,
                            this.weightsMaterial.searchTexture = h;
                            const d = new zi(r);
                            d.name = "SMAA.Area",
                            d.magFilter = mi,
                            d.minFilter = mi,
                            d.generateMipmaps = !1,
                            d.needsUpdate = !0,
                            d.flipY = !1,
                            this.weightsMaterial.areaTexture = d,
                            this.dispatchEvent({
                                type: "load"
                            })
                        }
                        ,
                        l.itemStart("search"),
                        l.itemStart("area"),
                        s !== void 0 && r !== void 0 ? (l.itemEnd("search"),
                        l.itemEnd("area")) : typeof Image < "u" && (s = new Image,
                        r = new Image,
                        s.addEventListener("load", () => l.itemEnd("search")),
                        r.addEventListener("load", () => l.itemEnd("area")),
                        s.src = YR,
                        r.src = WR),
                        this.applyPreset(t)
                    }
                    get edgesTexture() {
                        return this.renderTargetEdges.texture
                    }
                    getEdgesTexture() {
                        return this.edgesTexture
                    }
                    get weightsTexture() {
                        return this.renderTargetWeights.texture
                    }
                    getWeightsTexture() {
                        return this.weightsTexture
                    }
                    get edgeDetectionMaterial() {
                        return this.edgeDetectionPass.fullscreenMaterial
                    }
                    get colorEdgesMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    getEdgeDetectionMaterial() {
                        return this.edgeDetectionMaterial
                    }
                    get weightsMaterial() {
                        return this.weightsPass.fullscreenMaterial
                    }
                    getWeightsMaterial() {
                        return this.weightsMaterial
                    }
                    setEdgeDetectionThreshold(e) {
                        this.edgeDetectionMaterial.edgeDetectionThreshold = e
                    }
                    setOrthogonalSearchSteps(e) {
                        this.weightsMaterial.orthogonalSearchSteps = e
                    }
                    applyPreset(e) {
                        const t = this.edgeDetectionMaterial
                          , n = this.weightsMaterial;
                        switch (e) {
                        case Lv.LOW:
                            t.edgeDetectionThreshold = .15,
                            n.orthogonalSearchSteps = 4,
                            n.diagonalDetection = !1,
                            n.cornerDetection = !1;
                            break;
                        case Lv.MEDIUM:
                            t.edgeDetectionThreshold = .1,
                            n.orthogonalSearchSteps = 8,
                            n.diagonalDetection = !1,
                            n.cornerDetection = !1;
                            break;
                        case Lv.HIGH:
                            t.edgeDetectionThreshold = .1,
                            n.orthogonalSearchSteps = 16,
                            n.diagonalSearchSteps = 8,
                            n.cornerRounding = 25,
                            n.diagonalDetection = !0,
                            n.cornerDetection = !0;
                            break;
                        case Lv.ULTRA:
                            t.edgeDetectionThreshold = .05,
                            n.orthogonalSearchSteps = 32,
                            n.diagonalSearchSteps = 16,
                            n.cornerRounding = 25,
                            n.diagonalDetection = !0,
                            n.cornerDetection = !0;
                            break
                        }
                    }
                    setDepthTexture(e, t=ji) {
                        this.edgeDetectionMaterial.depthBuffer = e,
                        this.edgeDetectionMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        this.clearPass.render(e, this.renderTargetEdges),
                        this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
                        this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
                    }
                    setSize(e, t) {
                        this.edgeDetectionMaterial.setSize(e, t),
                        this.weightsMaterial.setSize(e, t),
                        this.renderTargetEdges.setSize(e, t),
                        this.renderTargetWeights.setSize(e, t)
                    }
                    dispose() {
                        const {searchTexture: e, areaTexture: t} = this.weightsMaterial;
                        e !== null && t !== null && (e.dispose(),
                        t.dispose()),
                        super.dispose()
                    }
                    static get searchImageDataURL() {
                        return YR
                    }
                    static get areaImageDataURL() {
                        return WR
                    }
                }
                  , XH = `#include <common>
#include <packing>
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
float readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}
#else
uniform lowp sampler2D normalBuffer;
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
uniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);
#ifdef PERSPECTIVE_CAMERA
float linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearSampleDepth=sampleDepth;
#endif
float proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){
#ifdef NORMAL_DEPTH
vec4 normalDepth=texture2D(normalDepthBuffer,vUv);
#else
vec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));
#endif
float ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);
#ifdef PERSPECTIVE_CAMERA
float linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearDepth=depth;
#endif
if(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);
#ifdef LEGACY_INTENSITY
ao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);
#endif
}gl_FragColor.r=ao;}`
                  , qH = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , YH = class extends Fn {
                    constructor(e) {
                        super({
                            name: "SSAOMaterial",
                            defines: {
                                SAMPLES_INT: "0",
                                INV_SAMPLES_FLOAT: "0.0",
                                SPIRAL_TURNS: "0.0",
                                RADIUS: "1.0",
                                RADIUS_SQ: "1.0",
                                DISTANCE_SCALING: "1",
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new Ce(null),
                                normalBuffer: new Ce(null),
                                normalDepthBuffer: new Ce(null),
                                noiseTexture: new Ce(null),
                                inverseProjectionMatrix: new Ce(new Xt),
                                projectionMatrix: new Ce(new Xt),
                                texelSize: new Ce(new ye),
                                cameraNearFar: new Ce(new ye),
                                distanceCutoff: new Ce(new ye),
                                proximityCutoff: new Ce(new ye),
                                noiseScale: new Ce(new ye),
                                minRadiusScale: new Ce(.33),
                                intensity: new Ce(1),
                                fade: new Ce(.01),
                                bias: new Ce(0)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: XH,
                            vertexShader: qH
                        }),
                        this.copyCameraSettings(e),
                        this.resolution = new ye,
                        this.r = 1
                    }
                    get near() {
                        return this.uniforms.cameraNearFar.value.x
                    }
                    get far() {
                        return this.uniforms.cameraNearFar.value.y
                    }
                    set normalDepthBuffer(e) {
                        this.uniforms.normalDepthBuffer.value = e,
                        e !== null ? this.defines.NORMAL_DEPTH = "1" : delete this.defines.NORMAL_DEPTH,
                        this.needsUpdate = !0
                    }
                    setNormalDepthBuffer(e) {
                        this.normalDepthBuffer = e
                    }
                    set normalBuffer(e) {
                        this.uniforms.normalBuffer.value = e
                    }
                    setNormalBuffer(e) {
                        this.uniforms.normalBuffer.value = e
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=ji) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    set noiseTexture(e) {
                        this.uniforms.noiseTexture.value = e
                    }
                    setNoiseTexture(e) {
                        this.uniforms.noiseTexture.value = e
                    }
                    get samples() {
                        return Number(this.defines.SAMPLES_INT)
                    }
                    set samples(e) {
                        this.defines.SAMPLES_INT = e.toFixed(0),
                        this.defines.INV_SAMPLES_FLOAT = (1 / e).toFixed(9),
                        this.needsUpdate = !0
                    }
                    getSamples() {
                        return this.samples
                    }
                    setSamples(e) {
                        this.samples = e
                    }
                    get rings() {
                        return Number(this.defines.SPIRAL_TURNS)
                    }
                    set rings(e) {
                        this.defines.SPIRAL_TURNS = e.toFixed(1),
                        this.needsUpdate = !0
                    }
                    getRings() {
                        return this.rings
                    }
                    setRings(e) {
                        this.rings = e
                    }
                    get intensity() {
                        return this.uniforms.intensity.value
                    }
                    set intensity(e) {
                        this.uniforms.intensity.value = e,
                        this.defines.LEGACY_INTENSITY === void 0 && (this.defines.LEGACY_INTENSITY = "1",
                        this.needsUpdate = !0)
                    }
                    getIntensity() {
                        return this.uniforms.intensity.value
                    }
                    setIntensity(e) {
                        this.uniforms.intensity.value = e
                    }
                    get fade() {
                        return this.uniforms.fade.value
                    }
                    set fade(e) {
                        this.uniforms.fade.value = e
                    }
                    getFade() {
                        return this.uniforms.fade.value
                    }
                    setFade(e) {
                        this.uniforms.fade.value = e
                    }
                    get bias() {
                        return this.uniforms.bias.value
                    }
                    set bias(e) {
                        this.uniforms.bias.value = e
                    }
                    getBias() {
                        return this.uniforms.bias.value
                    }
                    setBias(e) {
                        this.uniforms.bias.value = e
                    }
                    get minRadiusScale() {
                        return this.uniforms.minRadiusScale.value
                    }
                    set minRadiusScale(e) {
                        this.uniforms.minRadiusScale.value = e
                    }
                    getMinRadiusScale() {
                        return this.uniforms.minRadiusScale.value
                    }
                    setMinRadiusScale(e) {
                        this.uniforms.minRadiusScale.value = e
                    }
                    updateRadius() {
                        const e = this.r * this.resolution.height;
                        this.defines.RADIUS = e.toFixed(11),
                        this.defines.RADIUS_SQ = (e * e).toFixed(11),
                        this.needsUpdate = !0
                    }
                    get radius() {
                        return this.r
                    }
                    set radius(e) {
                        this.r = Math.min(Math.max(e, 1e-6), 1),
                        this.updateRadius()
                    }
                    getRadius() {
                        return this.radius
                    }
                    setRadius(e) {
                        this.radius = e
                    }
                    get distanceScaling() {
                        return !0
                    }
                    set distanceScaling(e) {}
                    isDistanceScalingEnabled() {
                        return this.distanceScaling
                    }
                    setDistanceScalingEnabled(e) {
                        this.distanceScaling = e
                    }
                    get distanceThreshold() {
                        return this.uniforms.distanceCutoff.value.x
                    }
                    set distanceThreshold(e) {
                        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + this.distanceFalloff, 0), 1))
                    }
                    get worldDistanceThreshold() {
                        return -jp(this.distanceThreshold, this.near, this.far)
                    }
                    set worldDistanceThreshold(e) {
                        this.distanceThreshold = Bf(-e, this.near, this.far)
                    }
                    get distanceFalloff() {
                        return this.uniforms.distanceCutoff.value.y - this.distanceThreshold
                    }
                    set distanceFalloff(e) {
                        this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + e, 0), 1)
                    }
                    get worldDistanceFalloff() {
                        return -jp(this.distanceFalloff, this.near, this.far)
                    }
                    set worldDistanceFalloff(e) {
                        this.distanceFalloff = Bf(-e, this.near, this.far)
                    }
                    setDistanceCutoff(e, t) {
                        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1))
                    }
                    get proximityThreshold() {
                        return this.uniforms.proximityCutoff.value.x
                    }
                    set proximityThreshold(e) {
                        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + this.proximityFalloff, 0), 1))
                    }
                    get worldProximityThreshold() {
                        return -jp(this.proximityThreshold, this.near, this.far)
                    }
                    set worldProximityThreshold(e) {
                        this.proximityThreshold = Bf(-e, this.near, this.far)
                    }
                    get proximityFalloff() {
                        return this.uniforms.proximityCutoff.value.y - this.proximityThreshold
                    }
                    set proximityFalloff(e) {
                        this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + e, 0), 1)
                    }
                    get worldProximityFalloff() {
                        return -jp(this.proximityFalloff, this.near, this.far)
                    }
                    set worldProximityFalloff(e) {
                        this.proximityFalloff = Bf(-e, this.near, this.far)
                    }
                    setProximityCutoff(e, t) {
                        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1))
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNearFar.value.set(e.near, e.far),
                        this.uniforms.projectionMatrix.value.copy(e.projectionMatrix),
                        this.uniforms.inverseProjectionMatrix.value.copy(e.projectionMatrix).invert(),
                        e instanceof hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                    setSize(e, t) {
                        const n = this.uniforms
                          , i = n.noiseTexture.value;
                        i !== null && n.noiseScale.value.set(e / i.image.width, t / i.image.height),
                        n.texelSize.value.set(1 / e, 1 / t),
                        this.resolution.set(e, t),
                        this.updateRadius()
                    }
                }
                  , WH = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`
                  , jH = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}"
                  , QH = class extends Fn {
                    constructor() {
                        super({
                            name: "DepthDownsamplingMaterial",
                            defines: {
                                DEPTH_PACKING: "0"
                            },
                            uniforms: {
                                depthBuffer: new Ce(null),
                                normalBuffer: new Ce(null),
                                texelSize: new Ce(new ye)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: WH,
                            vertexShader: jH
                        })
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=ji) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    set normalBuffer(e) {
                        this.uniforms.normalBuffer.value = e,
                        e !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS,
                        this.needsUpdate = !0
                    }
                    setNormalBuffer(e) {
                        this.normalBuffer = e
                    }
                    setTexelSize(e, t) {
                        this.uniforms.texelSize.value.set(e, t)
                    }
                    setSize(e, t) {
                        this.uniforms.texelSize.value.set(1 / e, 1 / t)
                    }
                }
                  , jR = class extends Ys {
                    constructor({normalBuffer: e=null, resolutionScale: t=.5, width: n=Hn.AUTO_SIZE, height: i=Hn.AUTO_SIZE, resolutionX: s=n, resolutionY: r=i}={}) {
                        super("DepthDownsamplingPass");
                        const l = new QH;
                        l.normalBuffer = e,
                        this.fullscreenMaterial = l,
                        this.needsDepthTexture = !0,
                        this.needsSwap = !1,
                        this.renderTarget = new Un(1,1,{
                            minFilter: ti,
                            magFilter: ti,
                            depthBuffer: !1,
                            type: Xs
                        }),
                        this.renderTarget.texture.name = "DepthDownsamplingPass.Target",
                        this.renderTarget.texture.generateMipmaps = !1;
                        const h = this.resolution = new Hn(this,s,r,t);
                        h.addEventListener("change", d => this.setSize(h.baseWidth, h.baseHeight))
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    setDepthTexture(e, t=ji) {
                        this.fullscreenMaterial.depthBuffer = e,
                        this.fullscreenMaterial.depthPacking = t
                    }
                    render(e, t, n, i, s) {
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height),
                        this.fullscreenMaterial.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        const i = e.getContext();
                        if (!(i.getExtension("EXT_color_buffer_float") || i.getExtension("EXT_color_buffer_half_float")))
                            throw new Error("Rendering to float texture is not supported.")
                    }
                }
                  , ZH = `uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;
#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#endif
#ifdef COLORIZE
uniform vec3 color;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;
#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300
vec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);
#else
float ao=aoLinear;
#endif
float l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);
#ifdef COLORIZE
outputColor=vec4(1.0-ao*(1.0-color),inputColor.a);
#else
outputColor=vec4(vec3(1.0-ao),inputColor.a);
#endif
}`
                  , QR = 64
                  , KH = class extends Ni {
                    constructor(e, t, {blendFunction: n=Yt.MULTIPLY, samples: i=9, rings: s=7, normalDepthBuffer: r=null, depthAwareUpsampling: l=!0, worldDistanceThreshold: h, worldDistanceFalloff: d, worldProximityThreshold: p, worldProximityFalloff: m, distanceThreshold: v=.97, distanceFalloff: _=.03, rangeThreshold: x=5e-4, rangeFalloff: b=.001, minRadiusScale: E=.1, luminanceInfluence: T=.7, radius: M=.1825, intensity: D=1, bias: R=.025, fade: O=.01, color: U=null, resolutionScale: B=1, width: I=Hn.AUTO_SIZE, height: F=Hn.AUTO_SIZE, resolutionX: P=I, resolutionY: L=F}={}) {
                        super("SSAOEffect", ZH, {
                            blendFunction: n,
                            attributes: za.DEPTH,
                            defines: new Map([["THRESHOLD", "0.997"]]),
                            uniforms: new Map([["aoBuffer", new Ce(null)], ["normalDepthBuffer", new Ce(r)], ["luminanceInfluence", new Ce(T)], ["color", new Ce(null)], ["intensity", new Ce(D)], ["scale", new Ce(0)]])
                        }),
                        this.renderTarget = new Un(1,1,{
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "AO.Target",
                        this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
                        const H = this.resolution = new Hn(this,P,L,B);
                        H.addEventListener("change", te => this.setSize(H.baseWidth, H.baseHeight)),
                        this.camera = e,
                        this.depthDownsamplingPass = new jR({
                            normalBuffer: t,
                            resolutionScale: B
                        }),
                        this.depthDownsamplingPass.enabled = r === null,
                        this.ssaoPass = new Dr(new YH(e));
                        const Z = new MM(QR,QR,ss);
                        Z.wrapS = Z.wrapT = Uu;
                        const K = this.ssaoMaterial;
                        K.normalBuffer = t,
                        K.noiseTexture = Z,
                        K.minRadiusScale = E,
                        K.samples = i,
                        K.radius = M,
                        K.rings = s,
                        K.fade = O,
                        K.bias = R,
                        K.distanceThreshold = v,
                        K.distanceFalloff = _,
                        K.proximityThreshold = x,
                        K.proximityFalloff = b,
                        h !== void 0 && (K.worldDistanceThreshold = h),
                        d !== void 0 && (K.worldDistanceFalloff = d),
                        p !== void 0 && (K.worldProximityThreshold = p),
                        m !== void 0 && (K.worldProximityFalloff = m),
                        r !== null && (this.ssaoMaterial.normalDepthBuffer = r,
                        this.defines.set("NORMAL_DEPTH", "1")),
                        this.depthAwareUpsampling = l,
                        this.color = U
                    }
                    set mainCamera(e) {
                        this.camera = e,
                        this.ssaoMaterial.copyCameraSettings(e)
                    }
                    get normalBuffer() {
                        return this.ssaoMaterial.normalBuffer
                    }
                    set normalBuffer(e) {
                        this.ssaoMaterial.normalBuffer = e,
                        this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = e
                    }
                    getResolution() {
                        return this.resolution
                    }
                    get ssaoMaterial() {
                        return this.ssaoPass.fullscreenMaterial
                    }
                    getSSAOMaterial() {
                        return this.ssaoMaterial
                    }
                    get samples() {
                        return this.ssaoMaterial.samples
                    }
                    set samples(e) {
                        this.ssaoMaterial.samples = e
                    }
                    get rings() {
                        return this.ssaoMaterial.rings
                    }
                    set rings(e) {
                        this.ssaoMaterial.rings = e
                    }
                    get radius() {
                        return this.ssaoMaterial.radius
                    }
                    set radius(e) {
                        this.ssaoMaterial.radius = e
                    }
                    get depthAwareUpsampling() {
                        return this.defines.has("DEPTH_AWARE_UPSAMPLING")
                    }
                    set depthAwareUpsampling(e) {
                        this.depthAwareUpsampling !== e && (e ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1") : this.defines.delete("DEPTH_AWARE_UPSAMPLING"),
                        this.setChanged())
                    }
                    isDepthAwareUpsamplingEnabled() {
                        return this.depthAwareUpsampling
                    }
                    setDepthAwareUpsamplingEnabled(e) {
                        this.depthAwareUpsampling = e
                    }
                    get distanceScaling() {
                        return !0
                    }
                    set distanceScaling(e) {}
                    get color() {
                        return this.uniforms.get("color").value
                    }
                    set color(e) {
                        const t = this.uniforms
                          , n = this.defines;
                        e !== null ? n.has("COLORIZE") ? t.get("color").value.set(e) : (n.set("COLORIZE", "1"),
                        t.get("color").value = new at(e),
                        this.setChanged()) : n.has("COLORIZE") && (n.delete("COLORIZE"),
                        t.get("color").value = null,
                        this.setChanged())
                    }
                    get luminanceInfluence() {
                        return this.uniforms.get("luminanceInfluence").value
                    }
                    set luminanceInfluence(e) {
                        this.uniforms.get("luminanceInfluence").value = e
                    }
                    get intensity() {
                        return this.uniforms.get("intensity").value
                    }
                    set intensity(e) {
                        this.uniforms.get("intensity").value = e
                    }
                    getColor() {
                        return this.color
                    }
                    setColor(e) {
                        this.color = e
                    }
                    setDistanceCutoff(e, t) {
                        this.ssaoMaterial.distanceThreshold = e,
                        this.ssaoMaterial.distanceFalloff = t
                    }
                    setProximityCutoff(e, t) {
                        this.ssaoMaterial.proximityThreshold = e,
                        this.ssaoMaterial.proximityFalloff = t
                    }
                    setDepthTexture(e, t=ji) {
                        this.depthDownsamplingPass.setDepthTexture(e, t),
                        this.ssaoMaterial.depthBuffer = e,
                        this.ssaoMaterial.depthPacking = t
                    }
                    update(e, t, n) {
                        const i = this.renderTarget;
                        this.depthDownsamplingPass.enabled && this.depthDownsamplingPass.render(e),
                        this.ssaoPass.render(e, null, i)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t);
                        const i = n.width
                          , s = n.height;
                        this.ssaoMaterial.copyCameraSettings(this.camera),
                        this.ssaoMaterial.setSize(i, s),
                        this.renderTarget.setSize(i, s),
                        this.depthDownsamplingPass.resolution.scale = n.scale,
                        this.depthDownsamplingPass.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        try {
                            let i = this.uniforms.get("normalDepthBuffer").value;
                            i === null && (this.depthDownsamplingPass.initialize(e, t, n),
                            i = this.depthDownsamplingPass.texture,
                            this.uniforms.get("normalDepthBuffer").value = i,
                            this.ssaoMaterial.normalDepthBuffer = i,
                            this.defines.set("NORMAL_DEPTH", "1"))
                        } catch {
                            this.depthDownsamplingPass.enabled = !1
                        }
                    }
                }
                  , JH = `#include <packing>
varying vec2 vUv;
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
float readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}
#else
#if INPUT_DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if INPUT_DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
void main(){
#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING
gl_FragColor=texture2D(depthBuffer,vUv);
#else
float depth=readDepth(vUv);
#if OUTPUT_DEPTH_PACKING == 3201
gl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);
#else
gl_FragColor=vec4(vec3(depth),1.0);
#endif
#endif
}`
                  , $H = `varying vec2 vUv;
#if DEPTH_COPY_MODE == 1
uniform vec2 texelPosition;
#endif
void main(){
#if DEPTH_COPY_MODE == 1
vUv=texelPosition;
#else
vUv=position.xy*0.5+0.5;
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`
                  , e5 = class extends Fn {
                    constructor() {
                        super({
                            name: "DepthCopyMaterial",
                            defines: {
                                INPUT_DEPTH_PACKING: "0",
                                OUTPUT_DEPTH_PACKING: "0",
                                DEPTH_COPY_MODE: "0"
                            },
                            uniforms: {
                                depthBuffer: new Ce(null),
                                texelPosition: new Ce(new ye)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            fragmentShader: JH,
                            vertexShader: $H
                        }),
                        this.depthCopyMode = Iv.FULL
                    }
                    get depthBuffer() {
                        return this.uniforms.depthBuffer.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    set inputDepthPacking(e) {
                        this.defines.INPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    get outputDepthPacking() {
                        return Number(this.defines.OUTPUT_DEPTH_PACKING)
                    }
                    set outputDepthPacking(e) {
                        this.defines.OUTPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=ji) {
                        this.depthBuffer = e,
                        this.inputDepthPacking = t
                    }
                    getInputDepthPacking() {
                        return Number(this.defines.INPUT_DEPTH_PACKING)
                    }
                    setInputDepthPacking(e) {
                        this.defines.INPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getOutputDepthPacking() {
                        return Number(this.defines.OUTPUT_DEPTH_PACKING)
                    }
                    setOutputDepthPacking(e) {
                        this.defines.OUTPUT_DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    get texelPosition() {
                        return this.uniforms.texelPosition.value
                    }
                    getTexelPosition() {
                        return this.uniforms.texelPosition.value
                    }
                    setTexelPosition(e) {
                        this.uniforms.texelPosition.value = e
                    }
                    get mode() {
                        return this.depthCopyMode
                    }
                    set mode(e) {
                        this.depthCopyMode = e,
                        this.defines.DEPTH_COPY_MODE = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    getMode() {
                        return this.mode
                    }
                    setMode(e) {
                        this.mode = e
                    }
                }
                  , t5 = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`
                  , n5 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}"
                  , i5 = class extends Fn {
                    constructor(e, t, n, i, s=!1) {
                        super({
                            name: "EffectMaterial",
                            defines: {
                                THREE_REVISION: xc.replace(/\D+/g, ""),
                                DEPTH_PACKING: "0",
                                ENCODE_OUTPUT: "1"
                            },
                            uniforms: {
                                inputBuffer: new Ce(null),
                                depthBuffer: new Ce(null),
                                resolution: new Ce(new ye),
                                texelSize: new Ce(new ye),
                                cameraNear: new Ce(.3),
                                cameraFar: new Ce(1e3),
                                aspect: new Ce(1),
                                time: new Ce(0)
                            },
                            blending: oi,
                            toneMapped: !1,
                            depthWrite: !1,
                            depthTest: !1,
                            dithering: s
                        }),
                        e && this.setShaderParts(e),
                        t && this.setDefines(t),
                        n && this.setUniforms(n),
                        this.copyCameraSettings(i)
                    }
                    set inputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    setInputBuffer(e) {
                        this.uniforms.inputBuffer.value = e
                    }
                    get depthBuffer() {
                        return this.uniforms.depthBuffer.value
                    }
                    set depthBuffer(e) {
                        this.uniforms.depthBuffer.value = e
                    }
                    get depthPacking() {
                        return Number(this.defines.DEPTH_PACKING)
                    }
                    set depthPacking(e) {
                        this.defines.DEPTH_PACKING = e.toFixed(0),
                        this.needsUpdate = !0
                    }
                    setDepthBuffer(e, t=ji) {
                        this.depthBuffer = e,
                        this.depthPacking = t
                    }
                    setShaderData(e) {
                        this.setShaderParts(e.shaderParts),
                        this.setDefines(e.defines),
                        this.setUniforms(e.uniforms),
                        this.setExtensions(e.extensions)
                    }
                    setShaderParts(e) {
                        return this.fragmentShader = t5.replace(Bn.FRAGMENT_HEAD, e.get(Bn.FRAGMENT_HEAD) || "").replace(Bn.FRAGMENT_MAIN_UV, e.get(Bn.FRAGMENT_MAIN_UV) || "").replace(Bn.FRAGMENT_MAIN_IMAGE, e.get(Bn.FRAGMENT_MAIN_IMAGE) || ""),
                        this.vertexShader = n5.replace(Bn.VERTEX_HEAD, e.get(Bn.VERTEX_HEAD) || "").replace(Bn.VERTEX_MAIN_SUPPORT, e.get(Bn.VERTEX_MAIN_SUPPORT) || ""),
                        this.needsUpdate = !0,
                        this
                    }
                    setDefines(e) {
                        for (const t of e.entries())
                            this.defines[t[0]] = t[1];
                        return this.needsUpdate = !0,
                        this
                    }
                    setUniforms(e) {
                        for (const t of e.entries())
                            this.uniforms[t[0]] = t[1];
                        return this
                    }
                    setExtensions(e) {
                        this.extensions = {};
                        for (const t of e)
                            this.extensions[t] = !0;
                        return this
                    }
                    get encodeOutput() {
                        return this.defines.ENCODE_OUTPUT !== void 0
                    }
                    set encodeOutput(e) {
                        this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
                        this.needsUpdate = !0)
                    }
                    isOutputEncodingEnabled(e) {
                        return this.encodeOutput
                    }
                    setOutputEncodingEnabled(e) {
                        this.encodeOutput = e
                    }
                    get time() {
                        return this.uniforms.time.value
                    }
                    set time(e) {
                        this.uniforms.time.value = e
                    }
                    setDeltaTime(e) {
                        this.uniforms.time.value += e
                    }
                    adoptCameraSettings(e) {
                        this.copyCameraSettings(e)
                    }
                    copyCameraSettings(e) {
                        e && (this.uniforms.cameraNear.value = e.near,
                        this.uniforms.cameraFar.value = e.far,
                        e instanceof hi ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                        this.needsUpdate = !0)
                    }
                    setSize(e, t) {
                        const n = this.uniforms;
                        n.resolution.value.set(e, t),
                        n.texelSize.value.set(1 / e, 1 / t),
                        n.aspect.value = e / t
                    }
                    static get Section() {
                        return Bn
                    }
                }
                  , s5 = class extends Ys {
                    constructor({depthPacking: e=Fo}={}) {
                        super("DepthCopyPass");
                        const t = new e5;
                        t.outputDepthPacking = e,
                        this.fullscreenMaterial = t,
                        this.needsDepthTexture = !0,
                        this.needsSwap = !1,
                        this.renderTarget = new Un(1,1,{
                            type: e === Fo ? ui : Xs,
                            minFilter: ti,
                            magFilter: ti,
                            depthBuffer: !1
                        }),
                        this.renderTarget.texture.name = "DepthCopyPass.Target"
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    get depthPacking() {
                        return this.fullscreenMaterial.outputDepthPacking
                    }
                    getDepthPacking() {
                        return this.fullscreenMaterial.outputDepthPacking
                    }
                    setDepthTexture(e, t=ji) {
                        this.fullscreenMaterial.depthBuffer = e,
                        this.fullscreenMaterial.inputDepthPacking = t
                    }
                    render(e, t, n, i, s) {
                        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                        e.render(this.scene, this.camera)
                    }
                    setSize(e, t) {
                        this.renderTarget.setSize(e, t)
                    }
                }
                  , a5 = Number(xc.replace(/\D+/g, ""))
                  , If = 255 / 256
                  , r5 = new Float32Array([If / 256 ** 3, If / 256 ** 2, If / 256, If])
                  , o5 = new Float32Array([If, If / 256, If / 256 ** 2, 1 / 256 ** 3]);
                function l5(e) {
                    const t = a5 >= 167 ? o5 : r5;
                    return (e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]) / 255
                }
                var c5 = class extends s5 {
                    constructor({depthPacking: e=Fo, mode: t=Iv.SINGLE}={}) {
                        if (e !== Fo && e !== ji)
                            throw new Error(`Unsupported depth packing: ${e}`);
                        super({
                            depthPacking: e
                        }),
                        this.name = "DepthPickingPass",
                        this.fullscreenMaterial.mode = t,
                        this.pixelBuffer = e === Fo ? new Uint8Array(4) : new Float32Array(4),
                        this.callback = null
                    }
                    readDepth(e) {
                        return this.fullscreenMaterial.texelPosition.set(e.x * .5 + .5, e.y * .5 + .5),
                        new Promise(t => {
                            this.callback = t
                        }
                        )
                    }
                    render(e, t, n, i, s) {
                        const r = this.fullscreenMaterial
                          , l = r.mode;
                        if (l === Iv.FULL && super.render(e),
                        this.callback !== null) {
                            const h = this.renderTarget
                              , d = this.pixelBuffer
                              , p = h.texture.type !== Xs;
                            let m = 0
                              , v = 0;
                            if (l === Iv.SINGLE)
                                super.render(e);
                            else {
                                const _ = r.texelPosition;
                                m = Math.round(_.x * h.width),
                                v = Math.round(_.y * h.height)
                            }
                            e.readRenderTargetPixels(h, m, v, 1, 1, d),
                            this.callback(p ? l5(d) : d[0]),
                            this.callback = null
                        }
                    }
                    setSize(e, t) {
                        this.fullscreenMaterial.mode === Iv.FULL && super.setSize(e, t)
                    }
                }
                ;
                function ZR(e, t, n) {
                    for (const i of t) {
                        const s = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1)
                          , r = new RegExp("([^\\.])(\\b" + i + "\\b)","g");
                        for (const l of n.entries())
                            l[1] !== null && n.set(l[0], l[1].replace(r, s))
                    }
                }
                function u5(e, t, n) {
                    let i = t.getFragmentShader()
                      , s = t.getVertexShader();
                    const r = i !== void 0 && /mainImage/.test(i)
                      , l = i !== void 0 && /mainUv/.test(i);
                    if (n.attributes |= t.getAttributes(),
                    i === void 0)
                        throw new Error(`Missing fragment shader (${t.name})`);
                    if (l && (n.attributes & za.CONVOLUTION) !== 0)
                        throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
                    if (!r && !l)
                        throw new Error(`Could not find mainImage or mainUv function (${t.name})`);
                    {
                        const h = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g
                          , d = n.shaderParts;
                        let p = d.get(Bn.FRAGMENT_HEAD) || ""
                          , m = d.get(Bn.FRAGMENT_MAIN_UV) || ""
                          , v = d.get(Bn.FRAGMENT_MAIN_IMAGE) || ""
                          , _ = d.get(Bn.VERTEX_HEAD) || ""
                          , x = d.get(Bn.VERTEX_MAIN_SUPPORT) || "";
                        const b = new Set
                          , E = new Set;
                        if (l && (m += `	${e}MainUv(UV);
`,
                        n.uvTransformation = !0),
                        s !== null && /mainSupport/.test(s)) {
                            const D = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
                            x += `	${e}MainSupport(`,
                            x += D ? `vUv);
` : `);
`;
                            for (const R of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                                for (const O of R[1].split(/\s*,\s*/))
                                    n.varyings.add(O),
                                    b.add(O),
                                    E.add(O);
                            for (const R of s.matchAll(h))
                                E.add(R[1])
                        }
                        for (const D of i.matchAll(h))
                            E.add(D[1]);
                        for (const D of t.defines.keys())
                            E.add(D.replace(/\([\w\s,]*\)/g, ""));
                        for (const D of t.uniforms.keys())
                            E.add(D);
                        E.delete("while"),
                        E.delete("for"),
                        E.delete("if"),
                        t.uniforms.forEach( (D, R) => n.uniforms.set(e + R.charAt(0).toUpperCase() + R.slice(1), D)),
                        t.defines.forEach( (D, R) => n.defines.set(e + R.charAt(0).toUpperCase() + R.slice(1), D));
                        const T = new Map([["fragment", i], ["vertex", s]]);
                        ZR(e, E, n.defines),
                        ZR(e, E, T),
                        i = T.get("fragment"),
                        s = T.get("vertex");
                        const M = t.blendMode;
                        if (n.blendModes.set(M.blendFunction, M),
                        r) {
                            t.inputColorSpace !== null && t.inputColorSpace !== n.colorSpace && (v += t.inputColorSpace === $t ? `color0 = sRGBTransferOETF(color0);
	` : `color0 = sRGBToLinear(color0);
	`),
                            t.outputColorSpace !== Ho ? n.colorSpace = t.outputColorSpace : t.inputColorSpace !== null && (n.colorSpace = t.inputColorSpace);
                            const D = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                            v += `${e}MainImage(color0, UV, `,
                            (n.attributes & za.DEPTH) !== 0 && D.test(i) && (v += "depth, ",
                            n.readDepth = !0),
                            v += `color1);
	`;
                            const R = e + "BlendOpacity";
                            n.uniforms.set(R, M.opacity),
                            v += `color0 = blend${M.blendFunction}(color0, color1, ${R});

	`,
                            p += `uniform float ${R};

`
                        }
                        if (p += i + `
`,
                        s !== null && (_ += s + `
`),
                        d.set(Bn.FRAGMENT_HEAD, p),
                        d.set(Bn.FRAGMENT_MAIN_UV, m),
                        d.set(Bn.FRAGMENT_MAIN_IMAGE, v),
                        d.set(Bn.VERTEX_HEAD, _),
                        d.set(Bn.VERTEX_MAIN_SUPPORT, x),
                        t.extensions !== null)
                            for (const D of t.extensions)
                                n.extensions.add(D)
                    }
                }
                var h5 = class extends Ys {
                    constructor(e, ...t) {
                        super("EffectPass"),
                        this.fullscreenMaterial = new i5(null,null,null,e),
                        this.listener = n => this.handleEvent(n),
                        this.effects = [],
                        this.setEffects(t),
                        this.skipRendering = !1,
                        this.minTime = 1,
                        this.maxTime = Number.POSITIVE_INFINITY,
                        this.timeScale = 1
                    }
                    set mainScene(e) {
                        for (const t of this.effects)
                            t.mainScene = e
                    }
                    set mainCamera(e) {
                        this.fullscreenMaterial.copyCameraSettings(e);
                        for (const t of this.effects)
                            t.mainCamera = e
                    }
                    get encodeOutput() {
                        return this.fullscreenMaterial.encodeOutput
                    }
                    set encodeOutput(e) {
                        this.fullscreenMaterial.encodeOutput = e
                    }
                    get dithering() {
                        return this.fullscreenMaterial.dithering
                    }
                    set dithering(e) {
                        const t = this.fullscreenMaterial;
                        t.dithering = e,
                        t.needsUpdate = !0
                    }
                    setEffects(e) {
                        for (const t of this.effects)
                            t.removeEventListener("change", this.listener);
                        this.effects = e.sort( (t, n) => n.attributes - t.attributes);
                        for (const t of this.effects)
                            t.addEventListener("change", this.listener)
                    }
                    updateMaterial() {
                        const e = new gF;
                        let t = 0;
                        for (const l of this.effects)
                            if (l.blendMode.blendFunction === Yt.DST)
                                e.attributes |= l.getAttributes() & za.DEPTH;
                            else {
                                if ((e.attributes & l.getAttributes() & za.CONVOLUTION) !== 0)
                                    throw new Error(`Convolution effects cannot be merged (${l.name})`);
                                u5("e" + t++, l, e)
                            }
                        let n = e.shaderParts.get(Bn.FRAGMENT_HEAD)
                          , i = e.shaderParts.get(Bn.FRAGMENT_MAIN_IMAGE)
                          , s = e.shaderParts.get(Bn.FRAGMENT_MAIN_UV);
                        const r = /\bblend\b/g;
                        for (const l of e.blendModes.values())
                            n += l.getShaderCode().replace(r, `blend${l.blendFunction}`) + `
`;
                        (e.attributes & za.DEPTH) !== 0 ? (e.readDepth && (i = `float depth = readDepth(UV);

	` + i),
                        this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1,
                        e.colorSpace === $t && (i += `color0 = sRGBToLinear(color0);
	`),
                        e.uvTransformation ? (s = `vec2 transformedUv = vUv;
` + s,
                        e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"),
                        e.shaderParts.set(Bn.FRAGMENT_HEAD, n),
                        e.shaderParts.set(Bn.FRAGMENT_MAIN_IMAGE, i),
                        e.shaderParts.set(Bn.FRAGMENT_MAIN_UV, s);
                        for (const [l,h] of e.shaderParts)
                            h !== null && e.shaderParts.set(l, h.trim().replace(/^#/, `
#`));
                        this.skipRendering = t === 0,
                        this.needsSwap = !this.skipRendering,
                        this.fullscreenMaterial.setShaderData(e)
                    }
                    recompile() {
                        this.updateMaterial()
                    }
                    getDepthTexture() {
                        return this.fullscreenMaterial.depthBuffer
                    }
                    setDepthTexture(e, t=ji) {
                        this.fullscreenMaterial.depthBuffer = e,
                        this.fullscreenMaterial.depthPacking = t;
                        for (const n of this.effects)
                            n.setDepthTexture(e, t)
                    }
                    render(e, t, n, i, s) {
                        for (const r of this.effects)
                            r.update(e, t, i);
                        if (!this.skipRendering || this.renderToScreen) {
                            const r = this.fullscreenMaterial;
                            r.inputBuffer = t.texture,
                            r.time += i * this.timeScale,
                            e.setRenderTarget(this.renderToScreen ? null : n),
                            e.render(this.scene, this.camera)
                        }
                    }
                    setSize(e, t) {
                        this.fullscreenMaterial.setSize(e, t);
                        for (const n of this.effects)
                            n.setSize(e, t)
                    }
                    initialize(e, t, n) {
                        this.renderer = e;
                        for (const i of this.effects)
                            i.initialize(e, t, n);
                        this.updateMaterial(),
                        n !== void 0 && n !== ui && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                    }
                    dispose() {
                        super.dispose();
                        for (const e of this.effects)
                            e.removeEventListener("change", this.listener),
                            e.dispose()
                    }
                    handleEvent(e) {
                        switch (e.type) {
                        case "change":
                            this.recompile();
                            break
                        }
                    }
                }
                  , f5 = class extends Ys {
                    constructor(e, t, {renderTarget: n, resolutionScale: i=1, width: s=Hn.AUTO_SIZE, height: r=Hn.AUTO_SIZE, resolutionX: l=s, resolutionY: h=r}={}) {
                        super("NormalPass"),
                        this.needsSwap = !1,
                        this.renderPass = new Pv(e,t,new TT);
                        const d = this.renderPass;
                        d.ignoreBackground = !0,
                        d.skipShadowMapUpdate = !0;
                        const p = d.getClearPass();
                        p.overrideClearColor = new at(7829503),
                        p.overrideClearAlpha = 1,
                        this.renderTarget = n,
                        this.renderTarget === void 0 && (this.renderTarget = new Un(1,1,{
                            minFilter: ti,
                            magFilter: ti
                        }),
                        this.renderTarget.texture.name = "NormalPass.Target");
                        const m = this.resolution = new Hn(this,l,h,i);
                        m.addEventListener("change", v => this.setSize(m.baseWidth, m.baseHeight))
                    }
                    set mainScene(e) {
                        this.renderPass.mainScene = e
                    }
                    set mainCamera(e) {
                        this.renderPass.mainCamera = e
                    }
                    get texture() {
                        return this.renderTarget.texture
                    }
                    getTexture() {
                        return this.renderTarget.texture
                    }
                    getResolution() {
                        return this.resolution
                    }
                    getResolutionScale() {
                        return this.resolution.scale
                    }
                    setResolutionScale(e) {
                        this.resolution.scale = e
                    }
                    render(e, t, n, i, s) {
                        const r = this.renderToScreen ? null : this.renderTarget;
                        this.renderPass.render(e, r, r)
                    }
                    setSize(e, t) {
                        const n = this.resolution;
                        n.setBaseSize(e, t),
                        this.renderTarget.setSize(n.width, n.height)
                    }
                }
                  , y9 = [new Float32Array(3), new Float32Array(3)]
                  , _9 = [new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3)]
                  , x9 = [[new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])]]
                  , S9 = [new Float32Array(2), new Float32Array(2)]
                  , A9 = new Float32Array([0, -.25, .25, -.125, .125, -.375, .375])
                  , T9 = [new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125])]
                  , M9 = [new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4])]
                  , b9 = [new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3])]
                  , E9 = new Map([[la(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])], [la(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])], [la(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])], [la(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])], [la(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])], [la(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])], [la(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])], [la(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])], [la(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])], [la(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])], [la(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])], [la(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])], [la(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])], [la(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])], [la(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])], [la(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]]);
                function EM(e, t, n) {
                    return e + (t - e) * n
                }
                function la(e, t, n, i) {
                    const s = EM(e, t, .75)
                      , r = EM(n, i, .75);
                    return EM(s, r, .875)
                }
                function zv(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n,
                    e
                }
                function wM(e, t) {
                    return wM = Object.setPrototypeOf || function(i, s) {
                        return i.__proto__ = s,
                        i
                    }
                    ,
                    wM(e, t)
                }
                function d5() {
                    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                        return !1;
                    if (typeof Proxy == "function")
                        return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
                        !0
                    } catch {
                        return !1
                    }
                }
                function CM(e, t) {
                    (t == null || t > e.length) && (t = e.length);
                    for (var n = 0, i = new Array(t); n < t; n++)
                        i[n] = e[n];
                    return i
                }
                function p5(e, t) {
                    if (e) {
                        if (typeof e == "string")
                            return CM(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        if (n === "Object" && e.constructor && (n = e.constructor.name),
                        n === "Map" || n === "Set")
                            return Array.from(e);
                        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                            return CM(e, t)
                    }
                }
                function m5(e) {
                    if (Array.isArray(e))
                        return CM(e)
                }
                function g5(e) {
                    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
                        return Array.from(e)
                }
                function v5() {
                    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function y5(e) {
                    return m5(e) || g5(e) || p5(e) || v5()
                }
                var w9 = new ye
                  , C9 = new ye;
                function _5(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                }
                function x5(e, t) {
                    return _5(e - Math.floor(e / t) * t, 0, t)
                }
                function S5(e, t) {
                    var n = x5(t - e, Math.PI * 2);
                    return n > Math.PI && (n -= Math.PI * 2),
                    n
                }
                function RM(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }
                var ro = function e(t, n, i) {
                    var s = this;
                    RM(this, e),
                    zv(this, "dot2", function(r, l) {
                        return s.x * r + s.y * l
                    }),
                    zv(this, "dot3", function(r, l, h) {
                        return s.x * r + s.y * l + s.z * h
                    }),
                    this.x = t,
                    this.y = n,
                    this.z = i
                }
                  , A5 = [new ro(1,1,0), new ro(-1,1,0), new ro(1,-1,0), new ro(-1,-1,0), new ro(1,0,1), new ro(-1,0,1), new ro(1,0,-1), new ro(-1,0,-1), new ro(0,1,1), new ro(0,-1,1), new ro(0,1,-1), new ro(0,-1,-1)]
                  , KR = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
                  , JR = new Array(512)
                  , $R = new Array(512)
                  , T5 = function(t) {
                    t > 0 && t < 1 && (t *= 65536),
                    t = Math.floor(t),
                    t < 256 && (t |= t << 8);
                    for (var n = 0; n < 256; n++) {
                        var i;
                        n & 1 ? i = KR[n] ^ t & 255 : i = KR[n] ^ t >> 8 & 255,
                        JR[n] = JR[n + 256] = i,
                        $R[n] = $R[n + 256] = A5[i % 12]
                    }
                };
                T5(0);
                var R9 = .5 * (Math.sqrt(3) - 1)
                  , D9 = (3 - Math.sqrt(3)) / 6
                  , O9 = 1 / 3
                  , N9 = 1 / 6
                  , U9 = Math.PI * 2;
                function M5(e) {
                    if (typeof e == "number")
                        e = Math.abs(e);
                    else if (typeof e == "string") {
                        var t = e;
                        e = 0;
                        for (var n = 0; n < t.length; n++)
                            e = (e + (n + 1) * (t.charCodeAt(n) % 96)) % 2147483647
                    }
                    return e === 0 && (e = 311),
                    e
                }
                function eD(e) {
                    var t = M5(e);
                    return function() {
                        var n = t * 48271 % 2147483647;
                        return t = n,
                        n / 2147483647
                    }
                }
                var b5 = function e(t) {
                    var n = this;
                    RM(this, e),
                    zv(this, "seed", 0),
                    zv(this, "init", function(i) {
                        n.seed = i,
                        n.value = eD(i)
                    }),
                    zv(this, "value", eD(this.seed)),
                    this.init(t)
                }
                  , B9 = new b5(Math.random())
                  , E5 = function(t) {
                    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .01
                      , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
                      , s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / (2 * Math.PI);
                    return i / Math.atan(1 / n) * Math.atan(Math.sin(2 * Math.PI * t * s) / n)
                }
                  , tD = function(t) {
                    return 1 / (1 + t + .48 * t * t + .235 * t * t * t)
                };
                function As(e, t, n) {
                    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : .25
                      , s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .01
                      , r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0
                      , l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : tD
                      , h = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : .001
                      , d = "velocity_" + t;
                    if (e.__damp === void 0 && (e.__damp = {}),
                    e.__damp[d] === void 0 && (e.__damp[d] = 0),
                    Math.abs(e[t] - n) <= h)
                        return e[t] = n,
                        !1;
                    i = Math.max(1e-4, i);
                    var p = 2 / i
                      , m = l(p * s)
                      , v = e[t] - n
                      , _ = n
                      , x = r * i;
                    v = Math.min(Math.max(v, -x), x),
                    n = e[t] - v;
                    var b = (e.__damp[d] + p * v) * s;
                    e.__damp[d] = (e.__damp[d] - p * b) * m;
                    var E = n + (v + b) * m;
                    return _ - e[t] > 0 == E > _ && (E = _,
                    e.__damp[d] = (E - _) / s),
                    e[t] = E,
                    !0
                }
                function Qp(e, t, n, i, s, r, l, h) {
                    return As(e, t, e[t] + S5(e[t], n), i, s, r, l, h)
                }
                var Fv = new ye, nD, iD;
                function w5(e, t, n, i, s, r, l) {
                    return typeof t == "number" ? Fv.setScalar(t) : Array.isArray(t) ? Fv.set(t[0], t[1]) : Fv.copy(t),
                    nD = As(e, "x", Fv.x, n, i, s, r, l),
                    iD = As(e, "y", Fv.y, n, i, s, r, l),
                    nD || iD
                }
                var Zp = new Q, sD, aD, rD;
                function DM(e, t, n, i, s, r, l) {
                    return typeof t == "number" ? Zp.setScalar(t) : Array.isArray(t) ? Zp.set(t[0], t[1], t[2]) : Zp.copy(t),
                    sD = As(e, "x", Zp.x, n, i, s, r, l),
                    aD = As(e, "y", Zp.y, n, i, s, r, l),
                    rD = As(e, "z", Zp.z, n, i, s, r, l),
                    sD || aD || rD
                }
                var Lf = new gn, oD, lD, cD, uD;
                function C5(e, t, n, i, s, r, l) {
                    return typeof t == "number" ? Lf.setScalar(t) : Array.isArray(t) ? Lf.set(t[0], t[1], t[2], t[3]) : Lf.copy(t),
                    oD = As(e, "x", Lf.x, n, i, s, r, l),
                    lD = As(e, "y", Lf.y, n, i, s, r, l),
                    cD = As(e, "z", Lf.z, n, i, s, r, l),
                    uD = As(e, "w", Lf.w, n, i, s, r, l),
                    oD || lD || cD || uD
                }
                var Hv = new io, hD, fD, dD;
                function R5(e, t, n, i, s, r, l) {
                    return Array.isArray(t) ? Hv.set(t[0], t[1], t[2], t[3]) : Hv.copy(t),
                    hD = Qp(e, "x", Hv.x, n, i, s, r, l),
                    fD = Qp(e, "y", Hv.y, n, i, s, r, l),
                    dD = Qp(e, "z", Hv.z, n, i, s, r, l),
                    hD || fD || dD
                }
                var Kp = new at, pD, mD, gD;
                function D5(e, t, n, i, s, r, l) {
                    return t instanceof at ? Kp.copy(t) : Array.isArray(t) ? Kp.setRGB(t[0], t[1], t[2]) : Kp.set(t),
                    pD = As(e, "r", Kp.r, n, i, s, r, l),
                    mD = As(e, "g", Kp.g, n, i, s, r, l),
                    gD = As(e, "b", Kp.b, n, i, s, r, l),
                    pD || mD || gD
                }
                var Wo = new _s, Uc = new gn, vD = new gn, Vv = new gn, yD, _D, xD, SD;
                function AD(e, t, n, i, s, r, l) {
                    var h = e;
                    Array.isArray(t) ? Wo.set(t[0], t[1], t[2], t[3]) : Wo.copy(t);
                    var d = e.dot(Wo) > 0 ? 1 : -1;
                    return Wo.x *= d,
                    Wo.y *= d,
                    Wo.z *= d,
                    Wo.w *= d,
                    yD = As(e, "x", Wo.x, n, i, s, r, l),
                    _D = As(e, "y", Wo.y, n, i, s, r, l),
                    xD = As(e, "z", Wo.z, n, i, s, r, l),
                    SD = As(e, "w", Wo.w, n, i, s, r, l),
                    Uc.set(e.x, e.y, e.z, e.w).normalize(),
                    vD.set(h.__damp.velocity_x, h.__damp.velocity_y, h.__damp.velocity_z, h.__damp.velocity_w),
                    Vv.copy(Uc).multiplyScalar(vD.dot(Uc) / Uc.dot(Uc)),
                    h.__damp.velocity_x -= Vv.x,
                    h.__damp.velocity_y -= Vv.y,
                    h.__damp.velocity_z -= Vv.z,
                    h.__damp.velocity_w -= Vv.w,
                    e.set(Uc.x, Uc.y, Uc.z, Uc.w),
                    yD || _D || xD || SD
                }
                var Gv = new px, TD, MD, bD;
                function O5(e, t, n, i, s, r, l) {
                    return Array.isArray(t) ? Gv.set(t[0], t[1], t[2]) : Gv.copy(t),
                    TD = As(e, "radius", Gv.radius, n, i, s, r, l),
                    MD = Qp(e, "phi", Gv.phi, n, i, s, r, l),
                    bD = Qp(e, "theta", Gv.theta, n, i, s, r, l),
                    TD || MD || bD
                }
                var Fx = new Xt, ED = new Q, wD = new _s, CD = new Q, RD, DD, OD;
                function N5(e, t, n, i, s, r, l) {
                    var h = e;
                    return h.__damp === void 0 && (h.__damp = {
                        position: new Q,
                        rotation: new _s,
                        scale: new Q
                    },
                    e.decompose(h.__damp.position, h.__damp.rotation, h.__damp.scale)),
                    Array.isArray(t) ? Fx.set.apply(Fx, y5(t)) : Fx.copy(t),
                    Fx.decompose(ED, wD, CD),
                    RD = DM(h.__damp.position, ED, n, i, s, r, l),
                    DD = AD(h.__damp.rotation, wD, n, i, s, r, l),
                    OD = DM(h.__damp.scale, CD, n, i, s, r, l),
                    e.compose(h.__damp.position, h.__damp.rotation, h.__damp.scale),
                    RD || DD || OD
                }
                var ND = Object.freeze({
                    __proto__: null,
                    rsqw: E5,
                    exp: tD,
                    damp: As,
                    dampAngle: Qp,
                    damp2: w5,
                    damp3: DM,
                    damp4: C5,
                    dampE: R5,
                    dampC: D5,
                    dampQ: AD,
                    dampS: O5,
                    dampM: N5
                });
                function U5(e, t) {
                    if (typeof t != "function" && t !== null)
                        throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    t && wM(e, t)
                }
                function Hx(e) {
                    return Hx = Object.setPrototypeOf ? Object.getPrototypeOf : function(n) {
                        return n.__proto__ || Object.getPrototypeOf(n)
                    }
                    ,
                    Hx(e)
                }
                function B5(e) {
                    if (e === void 0)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }
                function P5(e, t) {
                    if (t && (typeof t == "object" || typeof t == "function"))
                        return t;
                    if (t !== void 0)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return B5(e)
                }
                function I5(e) {
                    var t = d5();
                    return function() {
                        var i = Hx(e), s;
                        if (t) {
                            var r = Hx(this).constructor;
                            s = Reflect.construct(i, arguments, r)
                        } else
                            s = i.apply(this, arguments);
                        return P5(this, s)
                    }
                }
                var P9 = (function(e) {
                    U5(n, e);
                    var t = I5(n);
                    function n() {
                        var i, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : .2, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 16;
                        RM(this, n),
                        i = t.call(this);
                        for (var d = s / 2 - l, p = r / 2 - l, m = l / s, v = (s - l) / s, _ = l / r, x = (r - l) / r, b = [d, p, 0, -d, p, 0, -d, -p, 0, d, -p, 0], E = [v, x, m, x, m, _, v, _], T = [3 * (h + 1) + 3, 3 * (h + 1) + 4, h + 4, h + 5, 2 * (h + 1) + 4, 2, 1, 2 * (h + 1) + 3, 3, 4 * (h + 1) + 3, 4, 0], M = [T[0], T[1], T[2], T[0], T[2], T[3], T[4], T[5], T[6], T[4], T[6], T[7], T[8], T[9], T[10], T[8], T[10], T[11]], D, R, O, U, B, I, F, P, L = 0; L < 4; L++) {
                            U = L < 1 || L > 2 ? d : -d,
                            B = L < 2 ? p : -p,
                            I = L < 1 || L > 2 ? v : m,
                            F = L < 2 ? x : _;
                            for (var H = 0; H <= h; H++)
                                D = Math.PI / 2 * (L + H / h),
                                R = Math.cos(D),
                                O = Math.sin(D),
                                b.push(U + l * R, B + l * O, 0),
                                E.push(I + m * R, F + _ * O),
                                H < h && (P = (h + 1) * L + H + 4,
                                M.push(L, P, P + 1))
                        }
                        return i.setIndex(new wn(new Uint32Array(M),1)),
                        i.setAttribute("position", new wn(new Float32Array(b),3)),
                        i.setAttribute("uv", new wn(new Float32Array(E),2)),
                        i
                    }
                    return n
                }
                )(an);
                const I9 = parseInt(xc.replace(/\D+/g, "")) >= 162 ? class extends Un {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, {
                            ...i,
                            count: n
                        }),
                        this.isWebGLMultipleRenderTargets = !0
                    }
                    get texture() {
                        return this.textures
                    }
                }
                : class extends Un {
                    constructor(e=1, t=1, n=1, i={}) {
                        super(e, t, i),
                        this.isWebGLMultipleRenderTargets = !0;
                        const s = this.texture;
                        this.texture = [];
                        for (let r = 0; r < n; r++)
                            this.texture[r] = s.clone(),
                            this.texture[r].isRenderTargetTexture = !0
                    }
                    setSize(e, t, n=1) {
                        if (this.width !== e || this.height !== t || this.depth !== n) {
                            this.width = e,
                            this.height = t,
                            this.depth = n;
                            for (let i = 0, s = this.texture.length; i < s; i++)
                                this.texture[i].image.width = e,
                                this.texture[i].image.height = t,
                                this.texture[i].image.depth = n;
                            this.dispose()
                        }
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t)
                    }
                    copy(e) {
                        this.dispose(),
                        this.width = e.width,
                        this.height = e.height,
                        this.depth = e.depth,
                        this.scissor.copy(e.scissor),
                        this.scissorTest = e.scissorTest,
                        this.viewport.copy(e.viewport),
                        this.depthBuffer = e.depthBuffer,
                        this.stencilBuffer = e.stencilBuffer,
                        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                        this.texture.length = 0;
                        for (let t = 0, n = e.texture.length; t < n; t++)
                            this.texture[t] = e.texture[t].clone(),
                            this.texture[t].isRenderTargetTexture = !0;
                        return this
                    }
                }
                  , UD = (0,
                Le.createContext)(null)
                  , Zu = (0,
                Le.createContext)(null)
                  , BD = e => (e.getAttributes() & 2) === 2
                  , L5 = (0,
                Le.memo)((0,
                Le.forwardRef)( ({children: e, camera: t, scene: n, resolutionScale: i, enabled: s=!0, renderPriority: r=1, autoClear: l=!0, depthBuffer: h, enableNormalPass: d, stencilBuffer: p, multisampling: m=8, frameBufferType: v=tf}, _) => {
                    const {gl: x, scene: b, camera: E, size: T} = Us()
                      , M = n || b
                      , D = t || E
                      , [R,O,U] = (0,
                    Le.useMemo)( () => {
                        const F = new mF(x,{
                            depthBuffer: h,
                            stencilBuffer: p,
                            multisampling: m,
                            frameBufferType: v
                        });
                        F.addPass(new Pv(M,D));
                        let P = null
                          , L = null;
                        return d && (L = new f5(M,D),
                        L.enabled = !1,
                        F.addPass(L),
                        i !== void 0 && (P = new jR({
                            normalBuffer: L.texture,
                            resolutionScale: i
                        }),
                        P.enabled = !1,
                        F.addPass(P))),
                        [F, L, P]
                    }
                    , [D, x, h, p, m, v, M, d, i]);
                    (0,
                    Le.useEffect)( () => R?.setSize(T.width, T.height), [R, T]),
                    Nv( (F, P) => {
                        if (s) {
                            const L = x.autoClear;
                            x.autoClear = l,
                            p && !l && x.clearStencil(),
                            R.render(P),
                            x.autoClear = L
                        }
                    }
                    , s ? r : 0);
                    const B = (0,
                    Le.useRef)(null);
                    (0,
                    Le.useLayoutEffect)( () => {
                        const F = []
                          , P = B.current.__r3f;
                        if (P && R) {
                            const L = P.children;
                            for (let H = 0; H < L.length; H++) {
                                const Z = L[H].object;
                                if (Z instanceof Ni) {
                                    const K = [Z];
                                    if (!BD(Z)) {
                                        let ce = null;
                                        for (; (ce = L[H + 1]?.object)instanceof Ni && !BD(ce); )
                                            K.push(ce),
                                            H++
                                    }
                                    const te = new h5(D,...K);
                                    F.push(te)
                                } else
                                    Z instanceof Ys && F.push(Z)
                            }
                            for (const H of F)
                                R?.addPass(H);
                            O && (O.enabled = !0),
                            U && (U.enabled = !0)
                        }
                        return () => {
                            for (const L of F)
                                R?.removePass(L);
                            O && (O.enabled = !1),
                            U && (U.enabled = !1)
                        }
                    }
                    , [R, e, D, O, U]),
                    (0,
                    Le.useEffect)( () => {
                        const F = x.toneMapping;
                        return x.toneMapping = zo,
                        () => {
                            x.toneMapping = F
                        }
                    }
                    , [x]);
                    const I = (0,
                    Le.useMemo)( () => ({
                        composer: R,
                        normalPass: O,
                        downSamplingPass: U,
                        resolutionScale: i,
                        camera: D,
                        scene: M
                    }), [R, O, U, i, D, M]);
                    return (0,
                    Le.useImperativeHandle)(_, () => R, [R]),
                    (0,
                    Ut.jsx)(Zu.Provider, {
                        value: I,
                        children: (0,
                        Ut.jsx)("group", {
                            ref: B,
                            children: e
                        })
                    })
                }
                ))
                  , Ku = e => typeof e == "object" && e != null && "current"in e ? e.current : e;
                let z5 = 0;
                const PD = new WeakMap
                  , Or = (e, t) => function({blendFunction: n=t?.blendFunction, opacity: i=t?.opacity, ...s}) {
                    let r = PD.get(e);
                    if (!r) {
                        const d = `@react-three/postprocessing/${e.name}-${z5++}`;
                        SR({
                            [d]: e
                        }),
                        PD.set(e, r = d)
                    }
                    const l = Us(d => d.camera)
                      , h = Le.useMemo( () => [...t?.args ?? [], ...s.args ?? [{
                        ...t,
                        ...s
                    }]], [JSON.stringify(s)]);
                    return (0,
                    Ut.jsx)(r, {
                        camera: l,
                        "blendMode-blendFunction": n,
                        "blendMode-opacity-value": i,
                        ...s,
                        args: h
                    })
                }
                  , Vx = (e, t) => {
                    const n = e[t];
                    return Le.useMemo( () => typeof n == "number" ? new ye(n,n) : n ? new ye(...n) : new ye, [n])
                }
                  , F5 = (0,
                Le.forwardRef)(function({blendFunction: e, worldFocusDistance: t, worldFocusRange: n, focusDistance: i, focusRange: s, focalLength: r, bokehScale: l, resolutionScale: h, resolutionX: d, resolutionY: p, width: m, height: v, target: _, depthTexture: x, ...b}, E) {
                    const {camera: T} = (0,
                    Le.useContext)(Zu)
                      , M = _ != null
                      , D = (0,
                    Le.useMemo)( () => {
                        const R = new JF(T,{
                            blendFunction: e,
                            worldFocusDistance: t,
                            worldFocusRange: n,
                            focusDistance: i,
                            focusRange: s,
                            focalLength: r,
                            bokehScale: l,
                            resolutionScale: h,
                            resolutionX: d,
                            resolutionY: p,
                            width: m,
                            height: v
                        });
                        M && (R.target = new Q),
                        x && R.setDepthTexture(x.texture, x.packing);
                        const O = R.maskPass;
                        return O.maskFunction = TM.MULTIPLY_RGB_SET_ALPHA,
                        R
                    }
                    , [T, e, t, n, i, s, r, l, h, d, p, m, v, M, x]);
                    return (0,
                    Le.useEffect)( () => () => {
                        D.dispose()
                    }
                    , [D]),
                    (0,
                    Ut.jsx)("primitive", {
                        ...b,
                        ref: E,
                        object: D,
                        target: _
                    })
                })
                  , L9 = (0,
                Le.forwardRef)( ({target: e=void 0, mouse: t=!1, debug: n=void 0, manual: i=!1, smoothTime: s=.25, ...r}, l) => {
                    const h = (0,
                    Le.useRef)(null)
                      , d = (0,
                    Le.useRef)(null)
                      , p = (0,
                    Le.useRef)(null)
                      , m = Us( ({scene: U}) => U)
                      , v = Us( ({pointer: U}) => U)
                      , {composer: _, camera: x} = (0,
                    Le.useContext)(Zu)
                      , [b] = (0,
                    Le.useState)( () => new c5)
                      , [E] = (0,
                    Le.useState)( () => new IR);
                    (0,
                    Le.useEffect)( () => (_.addPass(b),
                    _.addPass(E),
                    () => {
                        _.removePass(b),
                        _.removePass(E)
                    }
                    ), [_, b, E]),
                    (0,
                    Le.useEffect)( () => () => {
                        b.dispose(),
                        E.dispose()
                    }
                    , [b, E]);
                    const [T] = (0,
                    Le.useState)( () => new Q(0,0,0))
                      , [M] = (0,
                    Le.useState)( () => new Q(0,0,0))
                      , D = (0,
                    Le.useCallback)(async (U, B) => (M.x = U,
                    M.y = B,
                    M.z = await b.readDepth(M),
                    M.z = M.z * 2 - 1,
                    1 - M.z > 1e-7 ? M.unproject(x) : !1), [M, b, x])
                      , R = (0,
                    Le.useCallback)(async (U, B=!0) => {
                        if (e)
                            T.set(...e);
                        else {
                            const {x: I, y: F} = t ? v : {
                                x: 0,
                                y: 0
                            }
                              , P = await D(I, F);
                            P && T.copy(P)
                        }
                        B && h.current?.target && (s > 0 && U > 0 ? ND.damp3(h.current.target, T, s, U) : h.current.target.copy(T))
                    }
                    , [e, T, t, D, s, v]);
                    Nv(async (U, B) => {
                        i || R(B),
                        d.current && d.current.position.copy(T),
                        p.current && h.current?.target && p.current.position.copy(h.current.target)
                    }
                    );
                    const O = (0,
                    Le.useMemo)( () => ({
                        dofRef: h,
                        hitpoint: T,
                        update: R
                    }), [T, R]);
                    return (0,
                    Le.useImperativeHandle)(l, () => O, [O]),
                    (0,
                    Ut.jsxs)(Ut.Fragment, {
                        children: [n ? Vz((0,
                        Ut.jsxs)(Ut.Fragment, {
                            children: [(0,
                            Ut.jsxs)("mesh", {
                                ref: d,
                                children: [(0,
                                Ut.jsx)("sphereGeometry", {
                                    args: [n, 16, 16]
                                }), (0,
                                Ut.jsx)("meshBasicMaterial", {
                                    color: "#00ff00",
                                    opacity: 1,
                                    transparent: !0,
                                    depthWrite: !1
                                })]
                            }), (0,
                            Ut.jsxs)("mesh", {
                                ref: p,
                                children: [(0,
                                Ut.jsx)("sphereGeometry", {
                                    args: [n / 2, 16, 16]
                                }), (0,
                                Ut.jsx)("meshBasicMaterial", {
                                    color: "#00ff00",
                                    opacity: .5,
                                    transparent: !0,
                                    depthWrite: !1
                                })]
                            })]
                        }), m) : null, (0,
                        Ut.jsx)(F5, {
                            ref: h,
                            ...r,
                            target: T
                        })]
                    })
                }
                )
                  , H5 = {
                    fragmentShader: `
    uniform float time;
    uniform vec2 lensPosition;
    uniform vec2 screenRes;
    uniform vec3 colorGain;
    uniform float starPoints;
    uniform float glareSize;
    uniform float flareSize;
    uniform float flareSpeed;
    uniform float flareShape;
    uniform float haloScale;
    uniform float opacity;
    uniform bool animated;
    uniform bool anamorphic;
    uniform bool enabled;
    uniform bool secondaryGhosts;
    uniform bool starBurst;
    uniform float ghostScale;
    uniform bool aditionalStreaks;
    uniform sampler2D lensDirtTexture;
    vec2 vTexCoord;
    
    float rand(float n){return fract(sin(n) * 43758.5453123);}

    float noise(float p){
      float fl = floor(p);
      float fc = fract(p);
      return mix(rand(fl),rand(fl + 1.0), fc);
    }

    vec3 hsv2rgb(vec3 c)
    {
      vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);
      return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);
    }

    float saturate(float x)
    {
      return clamp(x, 0.,1.);
    }

    vec2 rotateUV(vec2 uv, float rotation)
    {
      return vec2(
          cos(rotation) * uv.x + sin(rotation) * uv.y,
          cos(rotation) * uv.y - sin(rotation) * uv.x
      );
    }

    // Based on https://www.shadertoy.com/view/XtKfRV
    vec3 drawflare(vec2 p, float intensity, float rnd, float speed, int id)
    {
      float flarehueoffset = (1. / 32.) * float(id) * 0.1;
      float lingrad = distance(vec2(0.), p);
      float expgrad = 1. / exp(lingrad * (fract(rnd) * 0.66 + 0.33));
      vec3 colgrad = hsv2rgb(vec3( fract( (expgrad * 8.) + speed * flareSpeed + flarehueoffset), pow(1.-abs(expgrad*2.-1.), 0.45), 20.0 * expgrad * intensity)); //rainbow spectrum effect

      float internalStarPoints;

      if(anamorphic){
        internalStarPoints = 1.0;
      } else{
        internalStarPoints = starPoints;
      }
      
      float blades = length(p * flareShape * sin(internalStarPoints * atan(p.x, p.y)));
      
      float comp = pow(1.-saturate(blades), ( anamorphic ? 100. : 12.));
      comp += saturate(expgrad-0.9) * 3.;
      comp = pow(comp * expgrad, 8. + (1.-intensity) * 5.);
      
      if(flareSpeed > 0.0){
        return vec3(comp) * colgrad;
      } else{
        return vec3(comp) * flareSize * 15.;
      }
    }

    float dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }

    vec3 saturate(vec3 x)
    {
      return clamp(x, vec3(0.0), vec3(1.0));
    }

    // Based on https://www.shadertoy.com/view/XtKfRV
    float glare(vec2 uv, vec2 pos, float size)
    {
      vec2 main;

      if(animated){
        main = rotateUV(uv-pos, time * 0.1);      
      } else{
        main = uv-pos;     
      }
      
      float ang = atan(main.y, main.x) * (anamorphic ? 1.0 : starPoints);
      float dist = length(main); 
      dist = pow(dist, .9);
      
      float f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+.2);

      return f0+f0*(sin((ang))*.2 +.3);
    }

    float sdHex(vec2 p){
      p = abs(p);
      vec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);
      return dot(step(q.xy,q.yx), 1.0-q.yx);
    }

    //Based on https://www.shadertoy.com/view/dllSRX
    float fpow(float x, float k){
      return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;
    }

    vec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){
      uv -= p;
      if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){
          return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.1,sdHex(uv*20.0/s)));
      }
      return vec3(0);
    }

    // Based on https://www.shadertoy.com/view/4sX3Rs
    vec3 LensFlare(vec2 uv, vec2 pos)
    {
      vec2 main = uv-pos;
      vec2 uvd = uv*(length(uv));
      
      float ang = atan(main.x,main.y);
      
      float f0 = .3/(length(uv-pos)*16.0+1.0);
      
      f0 = f0*(sin(noise(sin(ang*3.9-(animated ? time : 0.0) * 0.3) * starPoints))*.2 );
      
      float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;

      float f2 = max(.9/(10.0+32.0*pow(length(uvd+0.99*pos),2.0)),.0)*0.35;
      float f22 = max(.9/(11.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*0.23;
      float f23 = max(.9/(12.0+32.0*pow(length(uvd+0.95*pos),2.0)),.0)*0.6;
      
      vec2 uvx = mix(uv,uvd, 0.1);
      
      float f4 = max(0.01-pow(length(uvx+0.4*pos),2.9),.0)*4.02;
      float f42 = max(0.0-pow(length(uvx+0.45*pos),2.9),.0)*4.1;
      float f43 = max(0.01-pow(length(uvx+0.5*pos),2.9),.0)*4.6;
      
      uvx = mix(uv,uvd,-.4);
      
      float f5 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;
      float f52 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;
      float f53 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;
      
      uvx = mix(uv,uvd, 2.1);
      
      float f6 = max(0.01-pow(length(uvx-0.3*pos),1.61),.0)*3.159;
      float f62 = max(0.01-pow(length(uvx-0.325*pos),1.614),.0)*3.14;
      float f63 = max(0.01-pow(length(uvx-0.389*pos),1.623),.0)*3.12;
      
      vec3 c = vec3(glare(uv,pos, glareSize));

      vec2 prot;

      if(animated){
        prot = rotateUV(uv - pos, (time * 0.1));  
      } else if(anamorphic){
        prot = rotateUV(uv - pos, 1.570796);     
      } else {
        prot = uv - pos;
      }

      c += drawflare(prot, (anamorphic ? flareSize * 10. : flareSize), 0.1, time, 1);
      
      c.r+=f1+f2+f4+f5+f6; c.g+=f1+f22+f42+f52+f62; c.b+=f1+f23+f43+f53+f63;
      c = c*1.3 * vec3(length(uvd)+.09);
      c+=vec3(f0);
      
      return c;
    }

    vec3 cc(vec3 color, float factor,float factor2)
    {
      float w = color.x+color.y+color.z;
      return mix(color,vec3(w)*factor,w*factor2);
    }    

    float rnd(vec2 p)
    {
      float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));
      return f;   
    }

    float rnd(float w)
    {
      float f = fract(sin(w)*1000.);
      return f;   
    }

    float regShape(vec2 p, int N)
    {
      float f;
      
      float a=atan(p.x,p.y)+.2;
      float b=6.28319/float(N);
      f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy)* 2.0  -ghostScale);
          
      return f;
    }

    // Based on https://www.shadertoy.com/view/Xlc3D2
    vec3 circle(vec2 p, float size, float decay, vec3 color, vec3 color2, float dist, vec2 position)
    {
      float l = length(p + position*(dist*2.))+size/2.;
      float l2 = length(p + position*(dist*4.))+size/3.;
      
      float c = max(0.01-pow(length(p + position*dist), size*ghostScale), 0.0)*10.;
      float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*20.), 0.0)*3.;
      float c2 =  max(0.09/pow(length(p-position*dist/.5)*1., .95), 0.0)/20.;
      float s = max(0.02-pow(regShape(p*5. + position*dist*5. + decay, 6) , 1.), 0.0)*1.5;
      
      color = cos(vec3(0.44, .24, .2)*16. + dist/8.)*0.5+.5;
      vec3 f = c*color;
      f += c1*color;
      f += c2*color;  
      f +=  s*color;
      return f;
    }

    vec4 getLensColor(float x){
      return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(0., 0., 0.),
        vec3(0., 0., 0.), smoothstep(0.0, 0.063, x)),
        vec3(0., 0., 0.), smoothstep(0.063, 0.125, x)),
        vec3(0.0, 0., 0.), smoothstep(0.125, 0.188, x)),
        vec3(0.188, 0.131, 0.116), smoothstep(0.188, 0.227, x)),
        vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),
        vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),
        vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),
        vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),
        vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),
        vec3(.1, 0.1, 0.1), smoothstep(0.604, 0.643, x)),
        vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),
        vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),
        vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),
        vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),
        vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),
      1.0);
    }

    float dirtNoise(vec2 p){
      vec2 f = fract(p);
      f = (f * f) * (3.0 - (2.0 * f));    
      float n = dot(floor(p), vec2(1.0, 157.0));
      vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);
      return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);
    } 

    float fbm(vec2 p){
      const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);
      float f = 0.0;
      f += 0.5000*dirtNoise(p); p = m*p*2.02;
      f += 0.2500*dirtNoise(p); p = m*p*2.03;
      f += 0.1250*dirtNoise(p); p = m*p*2.01;
      f += 0.0625*dirtNoise(p);
      return f/0.9375;
    }

    vec4 getLensStar(vec2 p){
      vec2 pp = (p - vec2(0.5)) * 2.0;
      float a = atan(pp.y, pp.x);
      vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));
      float d = sin(clamp(pow(length(vec2(0.5) - p) * 0.5 + haloScale /2., 5.0), 0.0, 1.0) * 3.14159);
      vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 10.6));
      c *= vec3(mix(2.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 1.5) + 0.5) * 0.3275;
      return vec4(vec3(c * 1.0), d);	
    }

    vec4 getLensDirt(vec2 p){
      p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 2.0)) * 0.0825;
      vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.1, 0.0, length(p - vec2(0.25))),
                                            smoothstep(0.4, 0.0, length(p - vec2(0.75)))),
                                            smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.125))))));
      o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;
      o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;
      o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;
      o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;
      o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;
      o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;
      return vec4(clamp(o, vec3(0.15), vec3(1.0)), 1.0);	
    }

    vec4 textureLimited(sampler2D tex, vec2 texCoord){
      if(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){
        return vec4(0.0);
      }else{
        return texture(tex, texCoord); 
      }
    }

    vec4 textureDistorted(sampler2D tex, vec2 texCoord, vec2 direction, vec3 distortion) {
      return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,
                  textureLimited(tex, (texCoord + (direction * distortion.g))).g,
                  textureLimited(tex, (texCoord + (direction * distortion.b))).b,
                  1.0);
    }

    // Based on https://www.shadertoy.com/view/4sK3W3
    vec4 getStartBurst(){
      vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0)) + vec2(0.5)); 
      vec2 texCoord = vec2(1.0) - vTexCoord; 
      vec2 ghostVec = (vec2(0.5) - texCoord) * 0.3 - lensPosition;
      vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0)) * vec2(1.0);
      vec2 haloVec = normalize(ghostVec) * 0.6;
      vec2 haloVecAspectNormalized = ghostVecAspectNormalized * 0.6;
      vec2 texelSize = vec2(1.0) / vec2(screenRes.xy);
      vec3 distortion = vec3(-(texelSize.x * 1.5), 0.2, texelSize.x * 1.5);
      vec4 c = vec4(0.0);
      for (int i = 0; i < 8; i++) {
        vec2 offset = texCoord + (ghostVec * float(i));
        c += textureDistorted(lensDirtTexture, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);
      }                       
      vec2 haloOffset = texCoord + haloVecAspectNormalized; 
      return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(haloScale))))) + 
            (textureDistorted(lensDirtTexture, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));
    } 

    void mainImage(vec4 inputColor, vec2 uv, out vec4 outputColor)
    {
      vec2 myUV = uv -0.5;
      myUV.y *= screenRes.y/screenRes.x;
      vec2 finalLensPosition = lensPosition * 0.5;
      finalLensPosition.y *= screenRes.y/screenRes.x;
      
      //First Lens flare pass
      vec3 finalColor = LensFlare(myUV, finalLensPosition) * 20.0 * colorGain / 256.;

      //Aditional streaks
      if(aditionalStreaks){
        vec3 circColor = vec3(0.9, 0.2, 0.1);
        vec3 circColor2 = vec3(0.3, 0.1, 0.9);

        for(float i=0.;i<10.;i++){
          finalColor += circle(myUV, pow(rnd(i*2000.)*2.8, .1)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, lensPosition);
        }
      }

      //Alternative ghosts
      if(secondaryGhosts){
        vec3 altGhosts = vec3(0);
        altGhosts += renderhex(myUV, -lensPosition*0.25, ghostScale * 1.4, vec3(0.25,0.35,0));
        altGhosts += renderhex(myUV, lensPosition*0.25, ghostScale * 0.5, vec3(1,0.5,0.5));
        altGhosts += renderhex(myUV, lensPosition*0.1, ghostScale * 1.6, vec3(1,1,1));
        altGhosts += renderhex(myUV, lensPosition*1.8, ghostScale * 2.0, vec3(0,0.5,0.75));
        altGhosts += renderhex(myUV, lensPosition*1.25, ghostScale * 0.8, vec3(1,1,0.5));
        altGhosts += renderhex(myUV, -lensPosition*1.25, ghostScale * 5.0, vec3(0.5,0.5,0.25));
        
        //Circular ghosts
        altGhosts += fpow(1.0 - abs(distance(lensPosition*0.8,myUV) - 0.7),0.985)*colorGain / 2100.;
        finalColor += altGhosts;
      }
      

      //Starburst                     
      if(starBurst){
        vTexCoord = myUV + 0.5;
        vec4 lensMod = getLensDirt(myUV);
        float tooBright = 1.0 - (clamp(0.5, 0.0, 0.5) * 2.0); 
        float tooDark = clamp(0.5 - 0.5, 0.0, 0.5) * 2.0;
        lensMod += mix(lensMod, pow(lensMod * 2.0, vec4(2.0)) * 0.5, tooBright);
        float lensStarRotationAngle = ((myUV.x + myUV.y)) * (1.0 / 6.0);
        vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * vTexCoord);
        lensMod += getLensStar(lensStarTexCoord) * 2.;
        
        finalColor += clamp((lensMod.rgb * getStartBurst().rgb ), 0.01, 1.0);
      }

      //Final composed output
      if(enabled){
        outputColor = vec4(mix(finalColor, vec3(.0), opacity) + inputColor.rgb, inputColor.a);
      } else {
        outputColor = vec4(inputColor);
      }
    }
  `
                };
                var V5 = class extends Ni {
                    constructor({blendFunction: e, enabled: t, glareSize: n, lensPosition: i, screenRes: s, starPoints: r, flareSize: l, flareSpeed: h, flareShape: d, animated: p, anamorphic: m, colorGain: v, lensDirtTexture: _, haloScale: x, secondaryGhosts: b, aditionalStreaks: E, ghostScale: T, opacity: M, starBurst: D}) {
                        super("LensFlareEffect", H5.fragmentShader, {
                            blendFunction: e,
                            uniforms: new Map([["enabled", new Ce(t)], ["glareSize", new Ce(n)], ["lensPosition", new Ce(i)], ["time", new Ce(0)], ["screenRes", new Ce(s)], ["starPoints", new Ce(r)], ["flareSize", new Ce(l)], ["flareSpeed", new Ce(h)], ["flareShape", new Ce(d)], ["animated", new Ce(p)], ["anamorphic", new Ce(m)], ["colorGain", new Ce(v)], ["lensDirtTexture", new Ce(_)], ["haloScale", new Ce(x)], ["secondaryGhosts", new Ce(b)], ["aditionalStreaks", new Ce(E)], ["ghostScale", new Ce(T)], ["starBurst", new Ce(D)], ["opacity", new Ce(M)]])
                        })
                    }
                    update(e, t, n) {
                        const i = this.uniforms.get("time");
                        i && (i.value += n)
                    }
                }
                ;
                const G5 = Or(V5)
                  , z9 = ({smoothTime: e=.07, blendFunction: t=23, enabled: n=!0, glareSize: i=.2, lensPosition: s=new Q(-25,6,-60), screenRes: r=new ye(0,0), starPoints: l=6, flareSize: h=.01, flareSpeed: d=.01, flareShape: p=.01, animated: m=!0, anamorphic: v=!1, colorGain: _=new at(20,20,20), lensDirtTexture: x=null, haloScale: b=.5, secondaryGhosts: E=!0, aditionalStreaks: T=!0, ghostScale: M=0, opacity: D=1, starBurst: R=!1}) => {
                    const O = Us( ({viewport: H}) => H)
                      , U = Us( ({raycaster: H}) => H)
                      , {scene: B, camera: I} = (0,
                    Le.useContext)(Zu)
                      , [F] = (0,
                    Le.useState)( () => new ye)
                      , [P] = (0,
                    Le.useState)( () => new Q)
                      , L = (0,
                    Le.useRef)(null);
                    return Nv( (H, Z) => {
                        if (!L?.current)
                            return;
                        const K = L.current.uniforms.get("lensPosition")
                          , te = L.current.uniforms.get("opacity");
                        if (!K || !te)
                            return;
                        let ce = 1;
                        if (P.copy(s).project(I),
                        P.z > 1)
                            return;
                        K.value.x = P.x,
                        K.value.y = P.y,
                        F.x = P.x,
                        F.y = P.y,
                        U.setFromCamera(F, I);
                        const G = U.intersectObjects(B.children, !0)
                          , {object: V} = G[0] || {};
                        V && (V.userData?.lensflare === "no-occlusion" ? ce = 0 : V instanceof Fi && (V.material.uniforms?._transmission?.value > .2 || V.material._transmission && V.material._transmission > .2 ? ce = .2 : V.material.transparent && (ce = V.material.opacity))),
                        ND.damp(te, "value", ce, e, Z)
                    }
                    ),
                    (0,
                    Le.useEffect)( () => {
                        if (!L?.current)
                            return;
                        const H = L.current.uniforms.get("screenRes");
                        H && (H.value.x = O.width,
                        H.value.y = O.height)
                    }
                    , [O]),
                    (0,
                    Ut.jsx)(G5, {
                        ref: L,
                        blendFunction: t,
                        enabled: n,
                        glareSize: i,
                        lensPosition: s,
                        screenRes: r,
                        starPoints: l,
                        flareSize: h,
                        flareSpeed: d,
                        flareShape: p,
                        animated: m,
                        anamorphic: v,
                        colorGain: _,
                        lensDirtTexture: x,
                        haloScale: b,
                        secondaryGhosts: E,
                        aditionalStreaks: T,
                        ghostScale: M,
                        opacity: D,
                        starBurst: R
                    })
                }
                  , k5 = Or(HR, {
                    blendFunction: 0
                })
                  , F9 = Or(IF)
                  , H9 = Or(kF)
                  , V9 = (0,
                Le.forwardRef)(function({blendFunction: e=23}, t) {
                    const n = (0,
                    Le.useMemo)( () => new zF(e), [e]);
                    return (0,
                    Ut.jsx)("primitive", {
                        ref: t,
                        object: n,
                        dispose: null
                    })
                })
                  , G9 = Or(HF)
                  , k9 = Or(qF)
                  , X9 = Or(eH)
                  , q9 = (0,
                Le.forwardRef)(function({active: e=!0, ...t}, n) {
                    const i = Us(p => p.invalidate)
                      , s = Vx(t, "delay")
                      , r = Vx(t, "duration")
                      , l = Vx(t, "strength")
                      , h = Vx(t, "chromaticAberrationOffset")
                      , d = (0,
                    Le.useMemo)( () => new rH({
                        ...t,
                        delay: s,
                        duration: r,
                        strength: l,
                        chromaticAberrationOffset: h
                    }), [s, r, t, l, h]);
                    return (0,
                    Le.useLayoutEffect)( () => {
                        d.mode = e ? t.mode || Pf.SPORADIC : Pf.DISABLED,
                        i()
                    }
                    , [e, d, i, t.mode]),
                    (0,
                    Le.useEffect)( () => () => {
                        d.dispose?.()
                    }
                    , [d]),
                    (0,
                    Ut.jsx)("primitive", {
                        ref: n,
                        object: d,
                        dispose: null
                    })
                })
                  , Y9 = (0,
                Le.forwardRef)(function(e, t) {
                    const {camera: n} = (0,
                    Le.useContext)(Zu)
                      , i = (0,
                    Le.useMemo)( () => new hH(n,Ku(e.sun),e), [n, e]);
                    return (0,
                    Le.useLayoutEffect)( () => void (i.lightSource = Ku(e.sun)), [i, e.sun]),
                    (0,
                    Ut.jsx)("primitive", {
                        ref: t,
                        object: i,
                        dispose: null
                    })
                })
                  , W9 = (0,
                Le.forwardRef)(function({size: e, ...t}, n) {
                    const i = Us(r => r.invalidate)
                      , s = (0,
                    Le.useMemo)( () => new dH(t), [t]);
                    return (0,
                    Le.useLayoutEffect)( () => {
                        e && s.setSize(e.width, e.height),
                        i()
                    }
                    , [s, e, i]),
                    (0,
                    Ut.jsx)("primitive", {
                        ref: n,
                        object: s,
                        dispose: null
                    })
                })
                  , j9 = Or(mH)
                  , Q9 = Or(yH, {
                    blendFunction: 5
                })
                  , Z9 = (0,
                Le.forwardRef)(function({selection: e=[], selectionLayer: t=10, blendFunction: n, patternTexture: i, edgeStrength: s, pulseSpeed: r, visibleEdgeColor: l, hiddenEdgeColor: h, width: d, height: p, kernelSize: m, blur: v, xRay: _, ...x}, b) {
                    const E = Us(O => O.invalidate)
                      , {scene: T, camera: M} = (0,
                    Le.useContext)(Zu)
                      , D = (0,
                    Le.useMemo)( () => new wH(T,M,{
                        blendFunction: n,
                        patternTexture: i,
                        edgeStrength: s,
                        pulseSpeed: r,
                        visibleEdgeColor: l,
                        hiddenEdgeColor: h,
                        width: d,
                        height: p,
                        kernelSize: m,
                        blur: v,
                        xRay: _,
                        ...x
                    }), [n, v, M, s, p, h, m, i, r, T, l, d, _])
                      , R = (0,
                    Le.useContext)(UD);
                    return (0,
                    Le.useEffect)( () => {
                        if (!R && e)
                            return D.selection.set(Array.isArray(e) ? e.map(Ku) : [Ku(e)]),
                            E(),
                            () => {
                                D.selection.clear(),
                                E()
                            }
                    }
                    , [D, e, R, E]),
                    (0,
                    Le.useEffect)( () => {
                        D.selectionLayer = t,
                        E()
                    }
                    , [D, E, t]),
                    (0,
                    Le.useRef)(void 0),
                    (0,
                    Le.useEffect)( () => {
                        if (R && R.enabled && R.selected?.length)
                            return D.selection.set(R.selected),
                            E(),
                            () => {
                                D.selection.clear(),
                                E()
                            }
                    }
                    , [R, D.selection, E]),
                    (0,
                    Le.useEffect)( () => () => {
                        D.dispose()
                    }
                    , [D]),
                    (0,
                    Ut.jsx)("primitive", {
                        ref: b,
                        object: D
                    })
                })
                  , K9 = (0,
                Le.forwardRef)(function({granularity: e=5}, t) {
                    const n = (0,
                    Le.useMemo)( () => new RH(e), [e]);
                    return (0,
                    Ut.jsx)("primitive", {
                        ref: t,
                        object: n,
                        dispose: null
                    })
                })
                  , J9 = Or(OH, {
                    blendFunction: 24,
                    density: 1.25
                })
                  , X5 = (e, t) => e.layers.enable(t.selection.layer)
                  , q5 = (e, t) => e.layers.disable(t.selection.layer)
                  , $9 = (0,
                Le.forwardRef)(function({selection: e=[], selectionLayer: t=10, lights: n=[], inverted: i=!1, ignoreBackground: s=!1, luminanceThreshold: r, luminanceSmoothing: l, intensity: h, width: d, height: p, kernelSize: m, mipmapBlur: v, ..._}, x) {
                    n.length === 0 && console.warn("SelectiveBloom requires lights to work.");
                    const b = Us(R => R.invalidate)
                      , {scene: E, camera: T} = (0,
                    Le.useContext)(Zu)
                      , M = (0,
                    Le.useMemo)( () => {
                        const R = new NH(E,T,{
                            blendFunction: 0,
                            luminanceThreshold: r,
                            luminanceSmoothing: l,
                            intensity: h,
                            width: d,
                            height: p,
                            kernelSize: m,
                            mipmapBlur: v,
                            ..._
                        });
                        return R.inverted = i,
                        R.ignoreBackground = s,
                        R
                    }
                    , [E, T, r, l, h, d, p, m, v, i, s, _])
                      , D = (0,
                    Le.useContext)(UD);
                    return (0,
                    Le.useEffect)( () => {
                        if (!D && e)
                            return M.selection.set(Array.isArray(e) ? e.map(Ku) : [Ku(e)]),
                            b(),
                            () => {
                                M.selection.clear(),
                                b()
                            }
                    }
                    , [M, e, D, b]),
                    (0,
                    Le.useEffect)( () => {
                        M.selection.layer = t,
                        b()
                    }
                    , [M, b, t]),
                    (0,
                    Le.useEffect)( () => {
                        if (n && n.length > 0)
                            return n.forEach(R => X5(Ku(R), M)),
                            b(),
                            () => {
                                n.forEach(R => q5(Ku(R), M)),
                                b()
                            }
                    }
                    , [M, b, n, t]),
                    (0,
                    Le.useEffect)( () => {
                        if (D && D.enabled && D.selected?.length)
                            return M.selection.set(D.selected),
                            b(),
                            () => {
                                M.selection.clear(),
                                b()
                            }
                    }
                    , [D, M.selection, b]),
                    (0,
                    Ut.jsx)("primitive", {
                        ref: x,
                        object: M,
                        dispose: null
                    })
                })
                  , eX = Or(BH)
                  , tX = (0,
                Le.forwardRef)(function(e, t) {
                    const {camera: n, normalPass: i, downSamplingPass: s, resolutionScale: r} = (0,
                    Le.useContext)(Zu)
                      , l = (0,
                    Le.useMemo)( () => i === null && s === null ? (console.error("Please enable the NormalPass in the EffectComposer in order to use SSAO."),
                    {}) : new KH(n,i && !s ? i.texture : null,{
                        blendFunction: 21,
                        samples: 30,
                        rings: 4,
                        distanceThreshold: 1,
                        distanceFalloff: 0,
                        rangeThreshold: .5,
                        rangeFalloff: .1,
                        luminanceInfluence: .9,
                        radius: 20,
                        bias: .5,
                        intensity: 1,
                        color: void 0,
                        normalDepthBuffer: s ? s.texture : null,
                        resolutionScale: r ?? 1,
                        depthAwareUpsampling: !0,
                        ...e
                    }), [n, s, i, r]);
                    return (0,
                    Ut.jsx)("primitive", {
                        ref: t,
                        object: l,
                        dispose: null
                    })
                })
                  , nX = Or(kH)
                  , iX = Or(iH)
                  , sX = {
                    fragmentShader: `
    uniform int rampType;

    uniform vec2 rampStart;
    uniform vec2 rampEnd;

    uniform vec4 startColor;
    uniform vec4 endColor;

    uniform float rampBias;
    uniform float rampGain;

    uniform bool rampMask;
    uniform bool rampInvert;

    float getBias(float time, float bias) {
      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);
    }

    float getGain(float time, float gain) {
      if (time < 0.5)
        return getBias(time * 2.0, gain) / 2.0;
      else
        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;
    }

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
      vec2 centerPixel = uv * resolution;
      vec2 startPixel = rampStart * resolution;
      vec2 endPixel = rampEnd * resolution;

      float rampAlpha;

      if (rampType == 1) {
        vec2 fuv = centerPixel / resolution.y;
        vec2 suv = startPixel / resolution.y;
        vec2 euv = endPixel / resolution.y;

        float radius = length(suv - euv);
        float falloff = length(fuv - suv);
        rampAlpha = smoothstep(0.0, radius, falloff);
      } else {
        float radius = length(startPixel - endPixel);
        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));

        float fade = dot(centerPixel - startPixel, direction);
        if (rampType == 2) fade = abs(fade);

        rampAlpha = smoothstep(0.0, 1.0, fade / radius);
      }

      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));

      if (rampMask) {
        vec4 inputBuff = texture2D(inputBuffer, uv);
        outputColor = mix(inputBuff, inputColor, rampAlpha);
      } else {
        outputColor = mix(startColor, endColor, rampAlpha);
      }
    }
  `
                }
                  , OM = "15.1.22";
                var Y5 = cn({
                    "node_modules/@babel/runtime/helpers/arrayWithHoles.js": ( (e, t) => {
                        function n(i) {
                            if (Array.isArray(i))
                                return i
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , W5 = cn({
                    "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js": ( (e, t) => {
                        function n(i, s) {
                            var r = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
                            if (r != null) {
                                var l, h, d, p, m = [], v = !0, _ = !1;
                                try {
                                    if (d = (r = r.call(i)).next,
                                    s === 0) {
                                        if (Object(r) !== r)
                                            return;
                                        v = !1
                                    } else
                                        for (; !(v = (l = d.call(r)).done) && (m.push(l.value),
                                        m.length !== s); v = !0)
                                            ;
                                } catch (x) {
                                    _ = !0,
                                    h = x
                                } finally {
                                    try {
                                        if (!v && r.return != null && (p = r.return(),
                                        Object(p) !== p))
                                            return
                                    } finally {
                                        if (_)
                                            throw h
                                    }
                                }
                                return m
                            }
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , j5 = cn({
                    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js": ( (e, t) => {
                        function n(i, s) {
                            (s == null || s > i.length) && (s = i.length);
                            for (var r = 0, l = Array(s); r < s; r++)
                                l[r] = i[r];
                            return l
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , Q5 = cn({
                    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js": ( (e, t) => {
                        var n = j5();
                        function i(s, r) {
                            if (s) {
                                if (typeof s == "string")
                                    return n(s, r);
                                var l = {}.toString.call(s).slice(8, -1);
                                return l === "Object" && s.constructor && (l = s.constructor.name),
                                l === "Map" || l === "Set" ? Array.from(s) : l === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l) ? n(s, r) : void 0
                            }
                        }
                        t.exports = i,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , Z5 = cn({
                    "node_modules/@babel/runtime/helpers/nonIterableRest.js": ( (e, t) => {
                        function n() {
                            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , K5 = cn({
                    "node_modules/@babel/runtime/helpers/slicedToArray.js": ( (e, t) => {
                        var n = Y5()
                          , i = W5()
                          , s = Q5()
                          , r = Z5();
                        function l(h, d) {
                            return n(h) || i(h, d) || s(h, d) || r()
                        }
                        t.exports = l,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , J5 = cn({
                    "node_modules/@babel/runtime/helpers/classCallCheck.js": ( (e, t) => {
                        function n(i, s) {
                            if (!(i instanceof s))
                                throw new TypeError("Cannot call a class as a function")
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , ID = cn({
                    "node_modules/@babel/runtime/helpers/typeof.js": ( (e, t) => {
                        function n(i) {
                            "@babel/helpers - typeof";
                            return t.exports = n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
                                return typeof s
                            }
                            : function(s) {
                                return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s
                            }
                            ,
                            t.exports.__esModule = !0,
                            t.exports.default = t.exports,
                            n(i)
                        }
                        t.exports = n,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , $5 = cn({
                    "node_modules/@babel/runtime/helpers/toPrimitive.js": ( (e, t) => {
                        var n = ID().default;
                        function i(s, r) {
                            if (n(s) != "object" || !s)
                                return s;
                            var l = s[Symbol.toPrimitive];
                            if (l !== void 0) {
                                var h = l.call(s, r || "default");
                                if (n(h) != "object")
                                    return h;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }
                            return (r === "string" ? String : Number)(s)
                        }
                        t.exports = i,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , eV = cn({
                    "node_modules/@babel/runtime/helpers/toPropertyKey.js": ( (e, t) => {
                        var n = ID().default
                          , i = $5();
                        function s(r) {
                            var l = i(r, "string");
                            return n(l) == "symbol" ? l : l + ""
                        }
                        t.exports = s,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , tV = cn({
                    "node_modules/@babel/runtime/helpers/createClass.js": ( (e, t) => {
                        var n = eV();
                        function i(r, l) {
                            for (var h = 0; h < l.length; h++) {
                                var d = l[h];
                                d.enumerable = d.enumerable || !1,
                                d.configurable = !0,
                                "value"in d && (d.writable = !0),
                                Object.defineProperty(r, n(d.key), d)
                            }
                        }
                        function s(r, l, h) {
                            return l && i(r.prototype, l),
                            h && i(r, h),
                            Object.defineProperty(r, "prototype", {
                                writable: !1
                            }),
                            r
                        }
                        t.exports = s,
                        t.exports.__esModule = !0,
                        t.exports.default = t.exports
                    }
                    )
                })
                  , LD = cn({
                    "node_modules/automation-events/build/es5/bundle.js": ( (e, t) => {
                        (function(n, i) {
                            typeof e == "object" && typeof t < "u" ? i(e, K5(), J5(), tV()) : typeof define == "function" && define.amd ? define(["exports", "@babel/runtime/helpers/slicedToArray", "@babel/runtime/helpers/classCallCheck", "@babel/runtime/helpers/createClass"], i) : (n = typeof globalThis < "u" ? globalThis : n || self,
                            i(n.automationEvents = {}, n._slicedToArray, n._classCallCheck, n._createClass))
                        }
                        )(e, (function(n, i, s, r) {
                            var l = function(V, q, ee) {
                                return {
                                    endTime: q,
                                    insertTime: ee,
                                    type: "exponentialRampToValue",
                                    value: V
                                }
                            }
                              , h = function(V, q, ee) {
                                return {
                                    endTime: q,
                                    insertTime: ee,
                                    type: "linearRampToValue",
                                    value: V
                                }
                            }
                              , d = function(V, q) {
                                return {
                                    startTime: q,
                                    type: "setValue",
                                    value: V
                                }
                            }
                              , p = function(V, q, ee) {
                                return {
                                    duration: ee,
                                    startTime: q,
                                    type: "setValueCurve",
                                    values: V
                                }
                            }
                              , m = function(V, q, ee) {
                                var se = ee.startTime
                                  , X = ee.target
                                  , J = ee.timeConstant;
                                return X + (q - X) * Math.exp((se - V) / J)
                            }
                              , v = function(V) {
                                return V.type === "exponentialRampToValue"
                            }
                              , _ = function(V) {
                                return V.type === "linearRampToValue"
                            }
                              , x = function(V) {
                                return v(V) || _(V)
                            }
                              , b = function(V) {
                                return V.type === "setValue"
                            }
                              , E = function(V) {
                                return V.type === "setValueCurve"
                            }
                              , T = function(V, q, ee, se) {
                                var X = V[q];
                                return X === void 0 ? se : x(X) || b(X) ? X.value : E(X) ? X.values[X.values.length - 1] : m(ee, T(V, q - 1, X.startTime, se), X)
                            }
                              , M = function(V, q, ee, se, X) {
                                return ee === void 0 ? [se.insertTime, X] : x(ee) ? [ee.endTime, ee.value] : b(ee) ? [ee.startTime, ee.value] : E(ee) ? [ee.startTime + ee.duration, ee.values[ee.values.length - 1]] : [ee.startTime, T(V, q - 1, ee.startTime, X)]
                            }
                              , D = function(V) {
                                return V.type === "cancelAndHold"
                            }
                              , R = function(V) {
                                return V.type === "cancelScheduledValues"
                            }
                              , O = function(V) {
                                return D(V) || R(V) ? V.cancelTime : v(V) || _(V) ? V.endTime : V.startTime
                            }
                              , U = function(V, q, ee, se) {
                                var X = se.endTime
                                  , J = se.value;
                                return ee === J ? J : 0 < ee && 0 < J || ee < 0 && J < 0 ? ee * Math.pow(J / ee, (V - q) / (X - q)) : 0
                            }
                              , B = function(V, q, ee, se) {
                                var X = se.endTime
                                  , J = se.value;
                                return ee + (V - q) / (X - q) * (J - ee)
                            }
                              , I = function(V, q) {
                                var ee = Math.floor(q)
                                  , se = Math.ceil(q);
                                return ee === se ? V[ee] : (1 - (q - ee)) * V[ee] + (1 - (se - q)) * V[se]
                            }
                              , F = function(V, q) {
                                var ee = q.duration
                                  , se = q.startTime
                                  , X = q.values
                                  , J = (V - se) / ee * (X.length - 1);
                                return I(X, J)
                            }
                              , P = function(V) {
                                return V.type === "setTarget"
                            }
                              , L = (function() {
                                function G(V) {
                                    s(this, G),
                                    this._automationEvents = [],
                                    this._currenTime = 0,
                                    this._defaultValue = V
                                }
                                return r(G, [{
                                    key: Symbol.iterator,
                                    value: function() {
                                        return this._automationEvents[Symbol.iterator]()
                                    }
                                }, {
                                    key: "add",
                                    value: function(q) {
                                        var ee = O(q);
                                        if (D(q) || R(q)) {
                                            var se = this._automationEvents.findIndex(function(Ye) {
                                                return R(q) && E(Ye) ? Ye.startTime + Ye.duration >= ee : O(Ye) >= ee
                                            })
                                              , X = this._automationEvents[se];
                                            if (se !== -1 && (this._automationEvents = this._automationEvents.slice(0, se)),
                                            D(q)) {
                                                var J = this._automationEvents[this._automationEvents.length - 1];
                                                if (X !== void 0 && x(X)) {
                                                    if (J !== void 0 && P(J))
                                                        throw new Error("The internal list is malformed.");
                                                    var ze = J === void 0 ? X.insertTime : E(J) ? J.startTime + J.duration : O(J)
                                                      , xe = J === void 0 ? this._defaultValue : E(J) ? J.values[J.values.length - 1] : J.value
                                                      , le = v(X) ? U(ee, ze, xe, X) : B(ee, ze, xe, X)
                                                      , Ne = v(X) ? l(le, ee, this._currenTime) : h(le, ee, this._currenTime);
                                                    this._automationEvents.push(Ne)
                                                }
                                                if (J !== void 0 && P(J) && this._automationEvents.push(d(this.getValue(ee), ee)),
                                                J !== void 0 && E(J) && J.startTime + J.duration > ee) {
                                                    var be = ee - J.startTime
                                                      , Ue = (J.values.length - 1) / J.duration
                                                      , $e = Math.max(2, 1 + Math.ceil(be * Ue))
                                                      , rt = be / ($e - 1) * Ue
                                                      , Et = J.values.slice(0, $e);
                                                    if (rt < 1)
                                                        for (var ne = 1; ne < $e; ne += 1) {
                                                            var Ve = rt * ne % 1;
                                                            Et[ne] = J.values[ne - 1] * (1 - Ve) + J.values[ne] * Ve
                                                        }
                                                    this._automationEvents[this._automationEvents.length - 1] = p(Et, J.startTime, be)
                                                }
                                            }
                                        } else {
                                            var de = this._automationEvents.findIndex(function(Ye) {
                                                return O(Ye) > ee
                                            })
                                              , Te = de === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[de - 1];
                                            if (Te !== void 0 && E(Te) && O(Te) + Te.duration > ee)
                                                return !1;
                                            var Pe = v(q) ? l(q.value, q.endTime, this._currenTime) : _(q) ? h(q.value, ee, this._currenTime) : q;
                                            if (de === -1)
                                                this._automationEvents.push(Pe);
                                            else {
                                                if (E(q) && ee + q.duration > O(this._automationEvents[de]))
                                                    return !1;
                                                this._automationEvents.splice(de, 0, Pe)
                                            }
                                        }
                                        return !0
                                    }
                                }, {
                                    key: "flush",
                                    value: function(q) {
                                        var ee = this._automationEvents.findIndex(function(J) {
                                            return O(J) > q
                                        });
                                        if (ee > 1) {
                                            var se = this._automationEvents.slice(ee - 1)
                                              , X = se[0];
                                            P(X) && se.unshift(d(T(this._automationEvents, ee - 2, X.startTime, this._defaultValue), X.startTime)),
                                            this._automationEvents = se
                                        }
                                    }
                                }, {
                                    key: "getValue",
                                    value: function(q) {
                                        if (this._automationEvents.length === 0)
                                            return this._defaultValue;
                                        var ee = this._automationEvents.findIndex(function(Et) {
                                            return O(Et) > q
                                        })
                                          , se = this._automationEvents[ee]
                                          , X = (ee === -1 ? this._automationEvents.length : ee) - 1
                                          , J = this._automationEvents[X];
                                        if (J !== void 0 && P(J) && (se === void 0 || !x(se) || se.insertTime > q))
                                            return m(q, T(this._automationEvents, X - 1, J.startTime, this._defaultValue), J);
                                        if (J !== void 0 && b(J) && (se === void 0 || !x(se)))
                                            return J.value;
                                        if (J !== void 0 && E(J) && (se === void 0 || !x(se) || J.startTime + J.duration > q))
                                            return q < J.startTime + J.duration ? F(q, J) : J.values[J.values.length - 1];
                                        if (J !== void 0 && x(J) && (se === void 0 || !x(se)))
                                            return J.value;
                                        if (se !== void 0 && v(se)) {
                                            var ze = M(this._automationEvents, X, J, se, this._defaultValue)
                                              , xe = i(ze, 2)
                                              , le = xe[0]
                                              , Ne = xe[1];
                                            return U(q, le, Ne, se)
                                        }
                                        if (se !== void 0 && _(se)) {
                                            var be = M(this._automationEvents, X, J, se, this._defaultValue)
                                              , Ue = i(be, 2)
                                              , $e = Ue[0]
                                              , rt = Ue[1];
                                            return B(q, $e, rt, se)
                                        }
                                        return this._defaultValue
                                    }
                                }])
                            }
                            )()
                              , H = function(V) {
                                return {
                                    cancelTime: V,
                                    type: "cancelAndHold"
                                }
                            }
                              , Z = function(V) {
                                return {
                                    cancelTime: V,
                                    type: "cancelScheduledValues"
                                }
                            }
                              , K = function(V, q) {
                                return {
                                    endTime: q,
                                    type: "exponentialRampToValue",
                                    value: V
                                }
                            }
                              , te = function(V, q) {
                                return {
                                    endTime: q,
                                    type: "linearRampToValue",
                                    value: V
                                }
                            }
                              , ce = function(V, q, ee) {
                                return {
                                    startTime: q,
                                    target: V,
                                    timeConstant: ee,
                                    type: "setTarget"
                                }
                            };
                            n.AutomationEventList = L,
                            n.createCancelAndHoldAutomationEvent = H,
                            n.createCancelScheduledValuesAutomationEvent = Z,
                            n.createExponentialRampToValueAutomationEvent = K,
                            n.createLinearRampToValueAutomationEvent = te,
                            n.createSetTargetAutomationEvent = ce,
                            n.createSetValueAutomationEvent = d,
                            n.createSetValueCurveAutomationEvent = p
                        }
                        ))
                    }
                    )
                })
                  , nV = tr(LD());
                const iV = () => new DOMException("","AbortError")
                  , sV = e => (t, n, [i,s,r], l) => {
                    e(t[s], [n, i, r], h => h[0] === n && h[1] === i, l)
                }
                  , aV = e => (t, n, i) => {
                    const s = [];
                    for (let r = 0; r < i.numberOfInputs; r += 1)
                        s.push(new Set);
                    e.set(t, {
                        activeInputs: s,
                        outputs: new Set,
                        passiveInputs: new WeakMap,
                        renderer: n
                    })
                }
                  , rV = e => (t, n) => {
                    e.set(t, {
                        activeInputs: new Set,
                        passiveInputs: new WeakMap,
                        renderer: n
                    })
                }
                  , Jp = new WeakSet
                  , zD = new WeakMap
                  , NM = new WeakMap
                  , FD = new WeakMap
                  , UM = new WeakMap
                  , Gx = new WeakMap
                  , HD = new WeakMap
                  , BM = new WeakMap
                  , PM = new WeakMap
                  , IM = new WeakMap
                  , VD = {
                    construct() {
                        return VD
                    }
                }
                  , oV = e => {
                    try {
                        new new Proxy(e,VD)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , GD = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/
                  , kD = (e, t) => {
                    const n = [];
                    let i = e.replace(/^[\s]+/, "")
                      , s = i.match(GD);
                    for (; s !== null; ) {
                        const r = s[1].slice(1, -1)
                          , l = s[0].replace(/([\s]+)?;?$/, "").replace(r, new URL(r,t).toString());
                        n.push(l),
                        i = i.slice(s[0].length).replace(/^[\s]+/, ""),
                        s = i.match(GD)
                    }
                    return [n.join(";"), i]
                }
                  , XD = e => {
                    if (e !== void 0 && !Array.isArray(e))
                        throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")
                }
                  , qD = e => {
                    if (!oV(e))
                        throw new TypeError("The given value for processorCtor should be a constructor.");
                    if (e.prototype === null || typeof e.prototype != "object")
                        throw new TypeError("The given value for processorCtor should have a prototype.")
                }
                  , lV = (e, t, n, i, s, r, l, h, d, p, m, v, _) => {
                    let x = 0;
                    return (b, E, T={
                        credentials: "omit"
                    }) => {
                        const M = m.get(b);
                        if (M !== void 0 && M.has(E))
                            return Promise.resolve();
                        const D = p.get(b);
                        if (D !== void 0) {
                            const U = D.get(E);
                            if (U !== void 0)
                                return U
                        }
                        const R = r(b)
                          , O = R.audioWorklet === void 0 ? s(E).then( ([U,B]) => {
                            const [I,F] = kD(U, B)
                              , P = `${I};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${F}
})})(window,'_AWGS')`;
                            return n(P)
                        }
                        ).then( () => {
                            const U = _._AWGS.pop();
                            if (U === void 0)
                                throw new SyntaxError;
                            i(R.currentTime, R.sampleRate, () => U(class {
                            }
                            , void 0, (B, I) => {
                                if (B.trim() === "")
                                    throw t();
                                const F = PM.get(R);
                                if (F !== void 0) {
                                    if (F.has(B))
                                        throw t();
                                    qD(I),
                                    XD(I.parameterDescriptors),
                                    F.set(B, I)
                                } else
                                    qD(I),
                                    XD(I.parameterDescriptors),
                                    PM.set(R, new Map([[B, I]]))
                            }
                            , R.sampleRate, void 0, void 0))
                        }
                        ) : Promise.all([s(E), Promise.resolve(e(v, v))]).then( ([[U,B],I]) => {
                            const F = x + 1;
                            x = F;
                            const [P,L] = kD(U, B)
                              , H = `${P};((AudioWorkletProcessor,registerProcessor)=>{${L}
})(${I ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${I ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${I ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${F}',class extends AudioWorkletProcessor{process(){return !1}})`
                              , Z = new Blob([H],{
                                type: "application/javascript; charset=utf-8"
                            })
                              , K = URL.createObjectURL(Z);
                            return R.audioWorklet.addModule(K, T).then( () => {
                                if (h(R))
                                    return R;
                                const te = l(R);
                                return te.audioWorklet.addModule(K, T).then( () => te)
                            }
                            ).then(te => {
                                if (d === null)
                                    throw new SyntaxError;
                                try {
                                    new d(te,`__sac${F}`)
                                } catch {
                                    throw new SyntaxError
                                }
                            }
                            ).finally( () => URL.revokeObjectURL(K))
                        }
                        );
                        return D === void 0 ? p.set(b, new Map([[E, O]])) : D.set(E, O),
                        O.then( () => {
                            const U = m.get(b);
                            U === void 0 ? m.set(b, new Set([E])) : U.add(E)
                        }
                        ).finally( () => {
                            const U = p.get(b);
                            U !== void 0 && U.delete(E)
                        }
                        ),
                        O
                    }
                }
                  , jo = (e, t) => {
                    const n = e.get(t);
                    if (n === void 0)
                        throw new Error("A value with the given key could not be found.");
                    return n
                }
                  , kx = (e, t) => {
                    const n = Array.from(e).filter(t);
                    if (n.length > 1)
                        throw Error("More than one element was found.");
                    if (n.length === 0)
                        throw Error("No element was found.");
                    const [i] = n;
                    return e.delete(i),
                    i
                }
                  , YD = (e, t, n, i) => {
                    const s = jo(e, t)
                      , r = kx(s, l => l[0] === n && l[1] === i);
                    return s.size === 0 && e.delete(t),
                    r
                }
                  , kv = e => jo(HD, e)
                  , $p = e => {
                    if (Jp.has(e))
                        throw new Error("The AudioNode is already stored.");
                    Jp.add(e),
                    kv(e).forEach(t => t(!0))
                }
                  , WD = e => "port"in e
                  , Xv = e => {
                    if (!Jp.has(e))
                        throw new Error("The AudioNode is not stored.");
                    Jp.delete(e),
                    kv(e).forEach(t => t(!1))
                }
                  , LM = (e, t) => {
                    !WD(e) && t.every(n => n.size === 0) && Xv(e)
                }
                  , cV = (e, t, n, i, s, r, l, h, d, p, m, v, _) => {
                    const x = new WeakMap;
                    return (b, E, T, M, D) => {
                        const {activeInputs: R, passiveInputs: O} = r(E)
                          , {outputs: U} = r(b)
                          , B = h(b)
                          , I = F => {
                            const P = d(E)
                              , L = d(b);
                            if (F) {
                                const H = YD(O, b, T, M);
                                e(R, b, H, !1),
                                !D && !v(b) && n(L, P, T, M),
                                _(E) && $p(E)
                            } else {
                                const H = i(R, b, T, M);
                                t(O, M, H, !1),
                                !D && !v(b) && s(L, P, T, M);
                                const Z = l(E);
                                if (Z === 0)
                                    m(E) && LM(E, R);
                                else {
                                    const K = x.get(E);
                                    K !== void 0 && clearTimeout(K),
                                    x.set(E, setTimeout( () => {
                                        m(E) && LM(E, R)
                                    }
                                    , Z * 1e3))
                                }
                            }
                        }
                        ;
                        return p(U, [E, T, M], F => F[0] === E && F[1] === T && F[2] === M, !0) ? (B.add(I),
                        m(b) ? e(R, b, [T, M, I], !0) : t(O, M, [b, T, I], !0),
                        !0) : !1
                    }
                }
                  , uV = e => (t, n, [i,s,r], l) => {
                    const h = t.get(i);
                    h === void 0 ? t.set(i, new Set([[s, n, r]])) : e(h, [s, n, r], d => d[0] === s && d[1] === n, l)
                }
                  , hV = e => (t, n) => {
                    const i = e(t, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    n.connect(i).connect(t.destination);
                    const s = () => {
                        n.removeEventListener("ended", s),
                        n.disconnect(i),
                        i.disconnect()
                    }
                    ;
                    n.addEventListener("ended", s)
                }
                  , fV = e => (t, n) => {
                    e(t).add(n)
                }
                  , dV = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    fftSize: 2048,
                    maxDecibels: -30,
                    minDecibels: -100,
                    smoothingTimeConstant: .8
                }
                  , pV = (e, t, n, i, s, r) => class extends e {
                    constructor(h, d) {
                        const p = s(h)
                          , m = {
                            ...dV,
                            ...d
                        }
                          , v = i(p, m)
                          , _ = r(p) ? t() : null;
                        super(h, !1, v, _),
                        this._nativeAnalyserNode = v
                    }
                    get fftSize() {
                        return this._nativeAnalyserNode.fftSize
                    }
                    set fftSize(h) {
                        this._nativeAnalyserNode.fftSize = h
                    }
                    get frequencyBinCount() {
                        return this._nativeAnalyserNode.frequencyBinCount
                    }
                    get maxDecibels() {
                        return this._nativeAnalyserNode.maxDecibels
                    }
                    set maxDecibels(h) {
                        const d = this._nativeAnalyserNode.maxDecibels;
                        if (this._nativeAnalyserNode.maxDecibels = h,
                        !(h > this._nativeAnalyserNode.minDecibels))
                            throw this._nativeAnalyserNode.maxDecibels = d,
                            n()
                    }
                    get minDecibels() {
                        return this._nativeAnalyserNode.minDecibels
                    }
                    set minDecibels(h) {
                        const d = this._nativeAnalyserNode.minDecibels;
                        if (this._nativeAnalyserNode.minDecibels = h,
                        !(this._nativeAnalyserNode.maxDecibels > h))
                            throw this._nativeAnalyserNode.minDecibels = d,
                            n()
                    }
                    get smoothingTimeConstant() {
                        return this._nativeAnalyserNode.smoothingTimeConstant
                    }
                    set smoothingTimeConstant(h) {
                        this._nativeAnalyserNode.smoothingTimeConstant = h
                    }
                    getByteFrequencyData(h) {
                        this._nativeAnalyserNode.getByteFrequencyData(h)
                    }
                    getByteTimeDomainData(h) {
                        this._nativeAnalyserNode.getByteTimeDomainData(h)
                    }
                    getFloatFrequencyData(h) {
                        this._nativeAnalyserNode.getFloatFrequencyData(h)
                    }
                    getFloatTimeDomainData(h) {
                        this._nativeAnalyserNode.getFloatTimeDomainData(h)
                    }
                }
                  , ca = (e, t) => e.context === t
                  , mV = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (r, l) => {
                        let h = t(r);
                        if (!ca(h, l)) {
                            const d = {
                                channelCount: h.channelCount,
                                channelCountMode: h.channelCountMode,
                                channelInterpretation: h.channelInterpretation,
                                fftSize: h.fftSize,
                                maxDecibels: h.maxDecibels,
                                minDecibels: h.minDecibels,
                                smoothingTimeConstant: h.smoothingTimeConstant
                            };
                            h = e(l, d)
                        }
                        return i.set(l, h),
                        await n(r, l, h),
                        h
                    }
                    ;
                    return {
                        render(r, l) {
                            const h = i.get(l);
                            return h !== void 0 ? Promise.resolve(h) : s(r, l)
                        }
                    }
                }
                  , Xx = e => {
                    try {
                        e.copyToChannel(new Float32Array(1), 0, -1)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , Gl = () => new DOMException("","IndexSizeError")
                  , zM = e => {
                    e.getChannelData = (t => n => {
                        try {
                            return t.call(e, n)
                        } catch (i) {
                            throw i.code === 12 ? Gl() : i
                        }
                    }
                    )(e.getChannelData)
                }
                  , gV = {
                    numberOfChannels: 1
                }
                  , vV = (e, t, n, i, s, r, l, h) => {
                    let d = null;
                    return class eN {
                        constructor(m) {
                            if (s === null)
                                throw new Error("Missing the native OfflineAudioContext constructor.");
                            const {length: v, numberOfChannels: _, sampleRate: x} = {
                                ...gV,
                                ...m
                            };
                            d === null && (d = new s(1,1,44100));
                            const b = i !== null && t(r, r) ? new i({
                                length: v,
                                numberOfChannels: _,
                                sampleRate: x
                            }) : d.createBuffer(_, v, x);
                            if (b.numberOfChannels === 0)
                                throw n();
                            return typeof b.copyFromChannel != "function" ? (l(b),
                            zM(b)) : t(Xx, () => Xx(b)) || h(b),
                            e.add(b),
                            b
                        }
                        static[Symbol.hasInstance](m) {
                            return m !== null && typeof m == "object" && Object.getPrototypeOf(m) === eN.prototype || e.has(m)
                        }
                    }
                }
                  , or = -34028234663852886e22
                  , Fa = -or
                  , Bc = e => Jp.has(e)
                  , yV = {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }
                  , _V = (e, t, n, i, s, r, l, h) => class extends e {
                    constructor(p, m) {
                        const v = r(p)
                          , _ = {
                            ...yV,
                            ...m
                        }
                          , x = s(v, _)
                          , b = l(v)
                          , E = b ? t() : null;
                        super(p, !1, x, E),
                        this._audioBufferSourceNodeRenderer = E,
                        this._isBufferNullified = !1,
                        this._isBufferSet = _.buffer !== null,
                        this._nativeAudioBufferSourceNode = x,
                        this._onended = null,
                        this._playbackRate = n(this, b, x.playbackRate, Fa, or)
                    }
                    get buffer() {
                        return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer
                    }
                    set buffer(p) {
                        if (this._nativeAudioBufferSourceNode.buffer = p,
                        p !== null) {
                            if (this._isBufferSet)
                                throw i();
                            this._isBufferSet = !0
                        }
                    }
                    get loop() {
                        return this._nativeAudioBufferSourceNode.loop
                    }
                    set loop(p) {
                        this._nativeAudioBufferSourceNode.loop = p
                    }
                    get loopEnd() {
                        return this._nativeAudioBufferSourceNode.loopEnd
                    }
                    set loopEnd(p) {
                        this._nativeAudioBufferSourceNode.loopEnd = p
                    }
                    get loopStart() {
                        return this._nativeAudioBufferSourceNode.loopStart
                    }
                    set loopStart(p) {
                        this._nativeAudioBufferSourceNode.loopStart = p
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(p) {
                        const m = typeof p == "function" ? h(this, p) : null;
                        this._nativeAudioBufferSourceNode.onended = m;
                        const v = this._nativeAudioBufferSourceNode.onended;
                        this._onended = v !== null && v === m ? p : v
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    start(p=0, m=0, v) {
                        if (this._nativeAudioBufferSourceNode.start(p, m, v),
                        this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = v === void 0 ? [p, m] : [p, m, v]),
                        this.context.state !== "closed") {
                            $p(this);
                            const _ = () => {
                                this._nativeAudioBufferSourceNode.removeEventListener("ended", _),
                                Bc(this) && Xv(this)
                            }
                            ;
                            this._nativeAudioBufferSourceNode.addEventListener("ended", _)
                        }
                    }
                    stop(p=0) {
                        this._nativeAudioBufferSourceNode.stop(p),
                        this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = p)
                    }
                }
                  , xV = (e, t, n, i, s) => () => {
                    const r = new WeakMap;
                    let l = null
                      , h = null;
                    const d = async (p, m) => {
                        let v = n(p);
                        const _ = ca(v, m);
                        if (!_) {
                            const x = {
                                buffer: v.buffer,
                                channelCount: v.channelCount,
                                channelCountMode: v.channelCountMode,
                                channelInterpretation: v.channelInterpretation,
                                loop: v.loop,
                                loopEnd: v.loopEnd,
                                loopStart: v.loopStart,
                                playbackRate: v.playbackRate.value
                            };
                            v = t(m, x),
                            l !== null && v.start(...l),
                            h !== null && v.stop(h)
                        }
                        return r.set(m, v),
                        _ ? await e(m, p.playbackRate, v.playbackRate) : await i(m, p.playbackRate, v.playbackRate),
                        await s(p, m, v),
                        v
                    }
                    ;
                    return {
                        set start(p) {
                            l = p
                        },
                        set stop(p) {
                            h = p
                        },
                        render(p, m) {
                            const v = r.get(m);
                            return v !== void 0 ? Promise.resolve(v) : d(p, m)
                        }
                    }
                }
                  , SV = e => "playbackRate"in e
                  , AV = e => "frequency"in e && "gain"in e
                  , TV = e => "offset"in e
                  , MV = e => !("frequency"in e) && "gain"in e
                  , bV = e => "detune"in e && "frequency"in e && !("gain"in e)
                  , EV = e => "pan"in e
                  , Ha = e => jo(zD, e)
                  , qv = e => jo(FD, e)
                  , FM = (e, t) => {
                    const {activeInputs: n} = Ha(e);
                    n.forEach(s => s.forEach( ([r]) => {
                        t.includes(e) || FM(r, [...t, e])
                    }
                    ));
                    const i = SV(e) ? [e.playbackRate] : WD(e) ? Array.from(e.parameters.values()) : AV(e) ? [e.Q, e.detune, e.frequency, e.gain] : TV(e) ? [e.offset] : MV(e) ? [e.gain] : bV(e) ? [e.detune, e.frequency] : EV(e) ? [e.pan] : [];
                    for (const s of i) {
                        const r = qv(s);
                        r !== void 0 && r.activeInputs.forEach( ([l]) => FM(l, t))
                    }
                    Bc(e) && Xv(e)
                }
                  , qx = e => {
                    FM(e.destination, [])
                }
                  , jD = e => e === void 0 || typeof e == "number" || typeof e == "string" && (e === "balanced" || e === "interactive" || e === "playback")
                  , wV = (e, t, n, i, s, r, l, h, d) => class extends e {
                    constructor(m={}) {
                        if (d === null)
                            throw new Error("Missing the native AudioContext constructor.");
                        let v;
                        try {
                            v = new d(m)
                        } catch (b) {
                            throw b.code === 12 && b.message === "sampleRate is not in range" ? n() : b
                        }
                        if (v === null)
                            throw i();
                        if (!jD(m.latencyHint))
                            throw new TypeError(`The provided value '${m.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                        if (m.sampleRate !== void 0 && v.sampleRate !== m.sampleRate)
                            throw n();
                        super(v, 2);
                        const {latencyHint: _} = m
                          , {sampleRate: x} = v;
                        if (this._baseLatency = typeof v.baseLatency == "number" ? v.baseLatency : _ === "balanced" ? 512 / x : _ === "interactive" || _ === void 0 ? 256 / x : _ === "playback" ? 1024 / x : Math.max(2, Math.min(128, Math.round(_ * x / 128))) * 128 / x,
                        this._nativeAudioContext = v,
                        d.name === "webkitAudioContext" ? (this._nativeGainNode = v.createGain(),
                        this._nativeOscillatorNode = v.createOscillator(),
                        this._nativeGainNode.gain.value = 1e-37,
                        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(v.destination),
                        this._nativeOscillatorNode.start()) : (this._nativeGainNode = null,
                        this._nativeOscillatorNode = null),
                        this._state = null,
                        v.state === "running") {
                            this._state = "suspended";
                            const b = () => {
                                this._state === "suspended" && (this._state = null),
                                v.removeEventListener("statechange", b)
                            }
                            ;
                            v.addEventListener("statechange", b)
                        }
                    }
                    get baseLatency() {
                        return this._baseLatency
                    }
                    get state() {
                        return this._state !== null ? this._state : this._nativeAudioContext.state
                    }
                    close() {
                        return this.state === "closed" ? this._nativeAudioContext.close().then( () => {
                            throw t()
                        }
                        ) : (this._state === "suspended" && (this._state = null),
                        this._nativeAudioContext.close().then( () => {
                            this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(),
                            this._nativeGainNode.disconnect(),
                            this._nativeOscillatorNode.disconnect()),
                            qx(this)
                        }
                        ))
                    }
                    createMediaElementSource(m) {
                        return new s(this,{
                            mediaElement: m
                        })
                    }
                    createMediaStreamDestination() {
                        return new r(this)
                    }
                    createMediaStreamSource(m) {
                        return new l(this,{
                            mediaStream: m
                        })
                    }
                    createMediaStreamTrackSource(m) {
                        return new h(this,{
                            mediaStreamTrack: m
                        })
                    }
                    resume() {
                        return this._state === "suspended" ? new Promise( (m, v) => {
                            const _ = () => {
                                this._nativeAudioContext.removeEventListener("statechange", _),
                                this._nativeAudioContext.state === "running" ? m() : this.resume().then(m, v)
                            }
                            ;
                            this._nativeAudioContext.addEventListener("statechange", _)
                        }
                        ) : this._nativeAudioContext.resume().catch(m => {
                            throw m === void 0 || m.code === 15 ? t() : m
                        }
                        )
                    }
                    suspend() {
                        return this._nativeAudioContext.suspend().catch(m => {
                            throw m === void 0 ? t() : m
                        }
                        )
                    }
                }
                  , CV = (e, t, n, i, s, r, l, h) => class extends e {
                    constructor(p, m) {
                        const v = r(p)
                          , _ = l(v)
                          , x = s(v, m, _)
                          , b = _ ? t(h) : null;
                        super(p, !1, x, b),
                        this._isNodeOfNativeOfflineAudioContext = _,
                        this._nativeAudioDestinationNode = x
                    }
                    get channelCount() {
                        return this._nativeAudioDestinationNode.channelCount
                    }
                    set channelCount(p) {
                        if (this._isNodeOfNativeOfflineAudioContext)
                            throw i();
                        if (p > this._nativeAudioDestinationNode.maxChannelCount)
                            throw n();
                        this._nativeAudioDestinationNode.channelCount = p
                    }
                    get channelCountMode() {
                        return this._nativeAudioDestinationNode.channelCountMode
                    }
                    set channelCountMode(p) {
                        if (this._isNodeOfNativeOfflineAudioContext)
                            throw i();
                        this._nativeAudioDestinationNode.channelCountMode = p
                    }
                    get maxChannelCount() {
                        return this._nativeAudioDestinationNode.maxChannelCount
                    }
                }
                  , RV = e => {
                    const t = new WeakMap
                      , n = async (i, s) => {
                        const r = s.destination;
                        return t.set(s, r),
                        await e(i, s, r),
                        r
                    }
                    ;
                    return {
                        render(i, s) {
                            const r = t.get(s);
                            return r !== void 0 ? Promise.resolve(r) : n(i, s)
                        }
                    }
                }
                  , DV = (e, t, n, i, s, r, l, h) => (d, p) => {
                    const m = p.listener
                      , v = () => {
                        const U = new Float32Array(1)
                          , B = t(p, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: 9
                        })
                          , I = l(p);
                        let F = !1
                          , P = [0, 0, -1, 0, 1, 0]
                          , L = [0, 0, 0];
                        const H = () => {
                            if (F)
                                return;
                            F = !0;
                            const ce = i(p, 256, 9, 0);
                            ce.onaudioprocess = ({inputBuffer: G}) => {
                                const V = [r(G, U, 0), r(G, U, 1), r(G, U, 2), r(G, U, 3), r(G, U, 4), r(G, U, 5)];
                                V.some( (ee, se) => ee !== P[se]) && (m.setOrientation(...V),
                                P = V);
                                const q = [r(G, U, 6), r(G, U, 7), r(G, U, 8)];
                                q.some( (ee, se) => ee !== L[se]) && (m.setPosition(...q),
                                L = q)
                            }
                            ,
                            B.connect(ce)
                        }
                          , Z = ce => G => {
                            G !== P[ce] && (P[ce] = G,
                            m.setOrientation(...P))
                        }
                          , K = ce => G => {
                            G !== L[ce] && (L[ce] = G,
                            m.setPosition(...L))
                        }
                          , te = (ce, G, V) => {
                            const q = n(p, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: G
                            });
                            q.connect(B, 0, ce),
                            q.start(),
                            Object.defineProperty(q.offset, "defaultValue", {
                                get() {
                                    return G
                                }
                            });
                            const ee = e({
                                context: d
                            }, I, q.offset, Fa, or);
                            return h(ee, "value", se => () => se.call(ee), se => X => {
                                try {
                                    se.call(ee, X)
                                } catch (J) {
                                    if (J.code !== 9)
                                        throw J
                                }
                                H(),
                                I && V(X)
                            }
                            ),
                            ee.cancelAndHoldAtTime = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.cancelAndHoldAtTime),
                            ee.cancelScheduledValues = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.cancelScheduledValues),
                            ee.exponentialRampToValueAtTime = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.exponentialRampToValueAtTime),
                            ee.linearRampToValueAtTime = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.linearRampToValueAtTime),
                            ee.setTargetAtTime = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.setTargetAtTime),
                            ee.setValueAtTime = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.setValueAtTime),
                            ee.setValueCurveAtTime = (se => I ? () => {
                                throw s()
                            }
                            : (...X) => {
                                const J = se.apply(ee, X);
                                return H(),
                                J
                            }
                            )(ee.setValueCurveAtTime),
                            ee
                        }
                        ;
                        return {
                            forwardX: te(0, 0, Z(0)),
                            forwardY: te(1, 0, Z(1)),
                            forwardZ: te(2, -1, Z(2)),
                            positionX: te(6, 0, K(0)),
                            positionY: te(7, 0, K(1)),
                            positionZ: te(8, 0, K(2)),
                            upX: te(3, 0, Z(3)),
                            upY: te(4, 1, Z(4)),
                            upZ: te(5, 0, Z(5))
                        }
                    }
                      , {forwardX: _, forwardY: x, forwardZ: b, positionX: E, positionY: T, positionZ: M, upX: D, upY: R, upZ: O} = m.forwardX === void 0 ? v() : m;
                    return {
                        get forwardX() {
                            return _
                        },
                        get forwardY() {
                            return x
                        },
                        get forwardZ() {
                            return b
                        },
                        get positionX() {
                            return E
                        },
                        get positionY() {
                            return T
                        },
                        get positionZ() {
                            return M
                        },
                        get upX() {
                            return D
                        },
                        get upY() {
                            return R
                        },
                        get upZ() {
                            return O
                        }
                    }
                }
                  , Yx = e => "context"in e
                  , Yv = e => Yx(e[0])
                  , zf = (e, t, n, i) => {
                    for (const s of e)
                        if (n(s)) {
                            if (i)
                                return !1;
                            throw Error("The set contains at least one similar element.")
                        }
                    return e.add(t),
                    !0
                }
                  , QD = (e, t, [n,i], s) => {
                    zf(e, [t, n, i], r => r[0] === t && r[1] === n, s)
                }
                  , ZD = (e, [t,n,i], s) => {
                    const r = e.get(t);
                    r === void 0 ? e.set(t, new Set([[n, i]])) : zf(r, [n, i], l => l[0] === n, s)
                }
                  , em = e => "inputs"in e
                  , Wx = (e, t, n, i) => {
                    if (em(t)) {
                        const s = t.inputs[i];
                        return e.connect(s, n, 0),
                        [s, n, 0]
                    }
                    return e.connect(t, n, i),
                    [t, n, i]
                }
                  , KD = (e, t, n) => {
                    for (const i of e)
                        if (i[0] === t && i[1] === n)
                            return e.delete(i),
                            i;
                    return null
                }
                  , OV = (e, t, n) => kx(e, i => i[0] === t && i[1] === n)
                  , JD = (e, t) => {
                    if (!kv(e).delete(t))
                        throw new Error("Missing the expected event listener.")
                }
                  , $D = (e, t, n) => {
                    const i = jo(e, t)
                      , s = kx(i, r => r[0] === n);
                    return i.size === 0 && e.delete(t),
                    s
                }
                  , jx = (e, t, n, i) => {
                    em(t) ? e.disconnect(t.inputs[i], n, 0) : e.disconnect(t, n, i)
                }
                  , gi = e => jo(NM, e)
                  , Wv = e => jo(UM, e)
                  , Ff = e => BM.has(e)
                  , Qx = e => !Jp.has(e)
                  , e2 = (e, t) => new Promise(n => {
                    if (t !== null)
                        n(!0);
                    else {
                        const i = e.createScriptProcessor(256, 1, 1)
                          , s = e.createGain()
                          , r = e.createBuffer(1, 2, 44100)
                          , l = r.getChannelData(0);
                        l[0] = 1,
                        l[1] = 1;
                        const h = e.createBufferSource();
                        h.buffer = r,
                        h.loop = !0,
                        h.connect(i).connect(e.destination),
                        h.connect(s),
                        h.disconnect(s),
                        i.onaudioprocess = d => {
                            const p = d.inputBuffer.getChannelData(0);
                            Array.prototype.some.call(p, m => m === 1) ? n(!0) : n(!1),
                            h.stop(),
                            i.onaudioprocess = null,
                            h.disconnect(i),
                            i.disconnect(e.destination)
                        }
                        ,
                        h.start()
                    }
                }
                )
                  , HM = (e, t) => {
                    const n = new Map;
                    for (const i of e)
                        for (const s of i) {
                            const r = n.get(s);
                            n.set(s, r === void 0 ? 1 : r + 1)
                        }
                    n.forEach( (i, s) => t(s, i))
                }
                  , Zx = e => "context"in e
                  , NV = e => {
                    const t = new Map;
                    e.connect = (n => (i, s=0, r=0) => {
                        const l = Zx(i) ? n(i, s, r) : n(i, s)
                          , h = t.get(i);
                        return h === void 0 ? t.set(i, [{
                            input: r,
                            output: s
                        }]) : h.every(d => d.input !== r || d.output !== s) && h.push({
                            input: r,
                            output: s
                        }),
                        l
                    }
                    )(e.connect.bind(e)),
                    e.disconnect = (n => (i, s, r) => {
                        if (n.apply(e),
                        i === void 0)
                            t.clear();
                        else if (typeof i == "number")
                            for (const [l,h] of t) {
                                const d = h.filter(p => p.output !== i);
                                d.length === 0 ? t.delete(l) : t.set(l, d)
                            }
                        else if (t.has(i))
                            if (s === void 0)
                                t.delete(i);
                            else {
                                const l = t.get(i);
                                if (l !== void 0) {
                                    const h = l.filter(d => d.output !== s && (d.input !== r || r === void 0));
                                    h.length === 0 ? t.delete(i) : t.set(i, h)
                                }
                            }
                        for (const [l,h] of t)
                            h.forEach(d => {
                                Zx(l) ? e.connect(l, d.output, d.input) : e.connect(l, d.output)
                            }
                            )
                    }
                    )(e.disconnect)
                }
                  , UV = (e, t, n, i) => {
                    const {activeInputs: s, passiveInputs: r} = qv(t)
                      , {outputs: l} = Ha(e)
                      , h = kv(e)
                      , d = p => {
                        const m = gi(e)
                          , v = Wv(t);
                        if (p) {
                            const _ = $D(r, e, n);
                            QD(s, e, _, !1),
                            !i && !Ff(e) && m.connect(v, n)
                        } else {
                            const _ = OV(s, e, n);
                            ZD(r, _, !1),
                            !i && !Ff(e) && m.disconnect(v, n)
                        }
                    }
                    ;
                    return zf(l, [t, n], p => p[0] === t && p[1] === n, !0) ? (h.add(d),
                    Bc(e) ? QD(s, e, [n, d], !0) : ZD(r, [e, n, d], !0),
                    !0) : !1
                }
                  , BV = (e, t, n, i) => {
                    const {activeInputs: s, passiveInputs: r} = Ha(t)
                      , l = KD(s[i], e, n);
                    return l === null ? [YD(r, e, n, i)[2], !1] : [l[2], !0]
                }
                  , PV = (e, t, n) => {
                    const {activeInputs: i, passiveInputs: s} = qv(t)
                      , r = KD(i, e, n);
                    return r === null ? [$D(s, e, n)[1], !1] : [r[2], !0]
                }
                  , VM = (e, t, n, i, s) => {
                    const [r,l] = BV(e, n, i, s);
                    if (r !== null && (JD(e, r),
                    l && !t && !Ff(e) && jx(gi(e), gi(n), i, s)),
                    Bc(n)) {
                        const {activeInputs: h} = Ha(n);
                        LM(n, h)
                    }
                }
                  , GM = (e, t, n, i) => {
                    const [s,r] = PV(e, n, i);
                    s !== null && (JD(e, s),
                    r && !t && !Ff(e) && gi(e).disconnect(Wv(n), i))
                }
                  , IV = (e, t) => {
                    const n = Ha(e)
                      , i = [];
                    for (const s of n.outputs)
                        Yv(s) ? VM(e, t, ...s) : GM(e, t, ...s),
                        i.push(s[0]);
                    return n.outputs.clear(),
                    i
                }
                  , LV = (e, t, n) => {
                    const i = Ha(e)
                      , s = [];
                    for (const r of i.outputs)
                        r[1] === n && (Yv(r) ? VM(e, t, ...r) : GM(e, t, ...r),
                        s.push(r[0]),
                        i.outputs.delete(r));
                    return s
                }
                  , zV = (e, t, n, i, s) => {
                    const r = Ha(e);
                    return Array.from(r.outputs).filter(l => l[0] === n && (i === void 0 || l[1] === i) && (s === void 0 || l[2] === s)).map(l => (Yv(l) ? VM(e, t, ...l) : GM(e, t, ...l),
                    r.outputs.delete(l),
                    l[0]))
                }
                  , FV = (e, t, n, i, s, r, l, h, d, p, m, v, _, x, b, E) => class extends p {
                    constructor(M, D, R, O) {
                        super(R),
                        this._context = M,
                        this._nativeAudioNode = R;
                        const U = m(M);
                        v(U) && n(e2, () => e2(U, E)) !== !0 && NV(R),
                        NM.set(this, R),
                        HD.set(this, new Set),
                        M.state !== "closed" && D && $p(this),
                        e(this, O, R)
                    }
                    get channelCount() {
                        return this._nativeAudioNode.channelCount
                    }
                    set channelCount(M) {
                        this._nativeAudioNode.channelCount = M
                    }
                    get channelCountMode() {
                        return this._nativeAudioNode.channelCountMode
                    }
                    set channelCountMode(M) {
                        this._nativeAudioNode.channelCountMode = M
                    }
                    get channelInterpretation() {
                        return this._nativeAudioNode.channelInterpretation
                    }
                    set channelInterpretation(M) {
                        this._nativeAudioNode.channelInterpretation = M
                    }
                    get context() {
                        return this._context
                    }
                    get numberOfInputs() {
                        return this._nativeAudioNode.numberOfInputs
                    }
                    get numberOfOutputs() {
                        return this._nativeAudioNode.numberOfOutputs
                    }
                    connect(M, D=0, R=0) {
                        if (D < 0 || D >= this._nativeAudioNode.numberOfOutputs)
                            throw s();
                        const O = m(this._context)
                          , U = b(O);
                        if (_(M) || x(M))
                            throw r();
                        if (Yx(M)) {
                            const I = gi(M);
                            try {
                                const F = Wx(this._nativeAudioNode, I, D, R)
                                  , P = Qx(this);
                                (U || P) && this._nativeAudioNode.disconnect(...F),
                                this.context.state !== "closed" && !P && Qx(M) && $p(M)
                            } catch (F) {
                                throw F.code === 12 ? r() : F
                            }
                            if (t(this, M, D, R, U)) {
                                const F = d([this], M);
                                HM(F, i(U))
                            }
                            return M
                        }
                        const B = Wv(M);
                        if (B.name === "playbackRate" && B.maxValue === 1024)
                            throw l();
                        try {
                            this._nativeAudioNode.connect(B, D),
                            (U || Qx(this)) && this._nativeAudioNode.disconnect(B, D)
                        } catch (I) {
                            throw I.code === 12 ? r() : I
                        }
                        if (UV(this, M, D, U)) {
                            const I = d([this], M);
                            HM(I, i(U))
                        }
                    }
                    disconnect(M, D, R) {
                        let O;
                        const U = m(this._context)
                          , B = b(U);
                        if (M === void 0)
                            O = IV(this, B);
                        else if (typeof M == "number") {
                            if (M < 0 || M >= this.numberOfOutputs)
                                throw s();
                            O = LV(this, B, M)
                        } else {
                            if (D !== void 0 && (D < 0 || D >= this.numberOfOutputs) || Yx(M) && R !== void 0 && (R < 0 || R >= M.numberOfInputs))
                                throw s();
                            if (O = zV(this, B, M, D, R),
                            O.length === 0)
                                throw r()
                        }
                        for (const I of O) {
                            const F = d([this], I);
                            HM(F, h)
                        }
                    }
                }
                  , HV = (e, t, n, i, s, r, l, h, d, p, m, v, _) => (x, b, E, T=null, M=null) => {
                    const D = E.value
                      , R = new nV.AutomationEventList(D)
                      , O = b ? i(R) : null
                      , U = {
                        get defaultValue() {
                            return D
                        },
                        get maxValue() {
                            return T === null ? E.maxValue : T
                        },
                        get minValue() {
                            return M === null ? E.minValue : M
                        },
                        get value() {
                            return E.value
                        },
                        set value(B) {
                            E.value = B,
                            U.setValueAtTime(B, x.context.currentTime)
                        },
                        cancelAndHoldAtTime(B) {
                            if (typeof E.cancelAndHoldAtTime == "function")
                                O === null && R.flush(x.context.currentTime),
                                R.add(s(B)),
                                E.cancelAndHoldAtTime(B);
                            else {
                                const I = Array.from(R).pop();
                                O === null && R.flush(x.context.currentTime),
                                R.add(s(B));
                                const F = Array.from(R).pop();
                                E.cancelScheduledValues(B),
                                I !== F && F !== void 0 && (F.type === "exponentialRampToValue" ? E.exponentialRampToValueAtTime(F.value, F.endTime) : F.type === "linearRampToValue" ? E.linearRampToValueAtTime(F.value, F.endTime) : F.type === "setValue" ? E.setValueAtTime(F.value, F.startTime) : F.type === "setValueCurve" && E.setValueCurveAtTime(F.values, F.startTime, F.duration))
                            }
                            return U
                        },
                        cancelScheduledValues(B) {
                            return O === null && R.flush(x.context.currentTime),
                            R.add(r(B)),
                            E.cancelScheduledValues(B),
                            U
                        },
                        exponentialRampToValueAtTime(B, I) {
                            if (B === 0)
                                throw new RangeError;
                            if (!Number.isFinite(I) || I < 0)
                                throw new RangeError;
                            const F = x.context.currentTime;
                            return O === null && R.flush(F),
                            Array.from(R).length === 0 && (R.add(p(D, F)),
                            E.setValueAtTime(D, F)),
                            R.add(l(B, I)),
                            E.exponentialRampToValueAtTime(B, I),
                            U
                        },
                        linearRampToValueAtTime(B, I) {
                            const F = x.context.currentTime;
                            return O === null && R.flush(F),
                            Array.from(R).length === 0 && (R.add(p(D, F)),
                            E.setValueAtTime(D, F)),
                            R.add(h(B, I)),
                            E.linearRampToValueAtTime(B, I),
                            U
                        },
                        setTargetAtTime(B, I, F) {
                            return O === null && R.flush(x.context.currentTime),
                            R.add(d(B, I, F)),
                            E.setTargetAtTime(B, I, F),
                            U
                        },
                        setValueAtTime(B, I) {
                            return O === null && R.flush(x.context.currentTime),
                            R.add(p(B, I)),
                            E.setValueAtTime(B, I),
                            U
                        },
                        setValueCurveAtTime(B, I, F) {
                            const P = B instanceof Float32Array ? B : new Float32Array(B);
                            if (v !== null && v.name === "webkitAudioContext") {
                                const L = I + F
                                  , H = x.context.sampleRate
                                  , Z = Math.ceil(I * H)
                                  , K = Math.floor(L * H)
                                  , te = K - Z
                                  , ce = new Float32Array(te);
                                for (let V = 0; V < te; V += 1) {
                                    const q = (P.length - 1) / F * ((Z + V) / H - I)
                                      , ee = Math.floor(q)
                                      , se = Math.ceil(q);
                                    ce[V] = ee === se ? P[ee] : (1 - (q - ee)) * P[ee] + (1 - (se - q)) * P[se]
                                }
                                O === null && R.flush(x.context.currentTime),
                                R.add(m(ce, I, F)),
                                E.setValueCurveAtTime(ce, I, F);
                                const G = K / H;
                                G < L && _(U, ce[ce.length - 1], G),
                                _(U, P[P.length - 1], L)
                            } else
                                O === null && R.flush(x.context.currentTime),
                                R.add(m(P, I, F)),
                                E.setValueCurveAtTime(P, I, F);
                            return U
                        }
                    };
                    return n.set(U, E),
                    t.set(U, x),
                    e(U, O),
                    U
                }
                  , VV = e => ({
                    replay(t) {
                        for (const n of e)
                            if (n.type === "exponentialRampToValue") {
                                const {endTime: i, value: s} = n;
                                t.exponentialRampToValueAtTime(s, i)
                            } else if (n.type === "linearRampToValue") {
                                const {endTime: i, value: s} = n;
                                t.linearRampToValueAtTime(s, i)
                            } else if (n.type === "setTarget") {
                                const {startTime: i, target: s, timeConstant: r} = n;
                                t.setTargetAtTime(s, i, r)
                            } else if (n.type === "setValue") {
                                const {startTime: i, value: s} = n;
                                t.setValueAtTime(s, i)
                            } else if (n.type === "setValueCurve") {
                                const {duration: i, startTime: s, values: r} = n;
                                t.setValueCurveAtTime(r, s, i)
                            } else
                                throw new Error("Can't apply an unknown automation.")
                    }
                });
                var t2 = class {
                    constructor(e) {
                        this._map = new Map(e)
                    }
                    get size() {
                        return this._map.size
                    }
                    entries() {
                        return this._map.entries()
                    }
                    forEach(e, t=null) {
                        return this._map.forEach( (n, i) => e.call(t, n, i, this))
                    }
                    get(e) {
                        return this._map.get(e)
                    }
                    has(e) {
                        return this._map.has(e)
                    }
                    keys() {
                        return this._map.keys()
                    }
                    values() {
                        return this._map.values()
                    }
                }
                ;
                const GV = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: 1,
                    numberOfOutputs: 1,
                    parameterData: {},
                    processorOptions: {}
                }
                  , kV = (e, t, n, i, s, r, l, h, d, p, m, v, _, x) => class extends t {
                    constructor(E, T, M) {
                        var D;
                        const R = h(E)
                          , O = d(R)
                          , U = m({
                            ...GV,
                            ...M
                        });
                        _(U);
                        const B = PM.get(R)
                          , I = B?.get(T)
                          , F = O || R.state !== "closed" ? R : (D = l(R)) !== null && D !== void 0 ? D : R
                          , P = s(F, O ? null : E.baseLatency, p, T, I, U)
                          , L = O ? i(T, U, I) : null;
                        super(E, !0, P, L);
                        const H = [];
                        P.parameters.forEach( (K, te) => {
                            const ce = n(this, O, K);
                            H.push([te, ce])
                        }
                        ),
                        this._nativeAudioWorkletNode = P,
                        this._onprocessorerror = null,
                        this._parameters = new t2(H),
                        O && e(R, this);
                        const {activeInputs: Z} = r(this);
                        v(P, Z)
                    }
                    get onprocessorerror() {
                        return this._onprocessorerror
                    }
                    set onprocessorerror(E) {
                        const T = typeof E == "function" ? x(this, E) : null;
                        this._nativeAudioWorkletNode.onprocessorerror = T;
                        const M = this._nativeAudioWorkletNode.onprocessorerror;
                        this._onprocessorerror = M !== null && M === T ? E : M
                    }
                    get parameters() {
                        return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters
                    }
                    get port() {
                        return this._nativeAudioWorkletNode.port
                    }
                }
                ;
                function Kx(e, t, n, i, s) {
                    if (typeof e.copyFromChannel == "function")
                        t[n].byteLength === 0 && (t[n] = new Float32Array(128)),
                        e.copyFromChannel(t[n], i, s);
                    else {
                        const r = e.getChannelData(i);
                        if (t[n].byteLength === 0)
                            t[n] = r.slice(s, s + 128);
                        else {
                            const l = new Float32Array(r.buffer,s * Float32Array.BYTES_PER_ELEMENT,128);
                            t[n].set(l)
                        }
                    }
                }
                const n2 = (e, t, n, i, s) => {
                    typeof e.copyToChannel == "function" ? t[n].byteLength !== 0 && e.copyToChannel(t[n], i, s) : t[n].byteLength !== 0 && e.getChannelData(i).set(t[n], s)
                }
                  , Jx = (e, t) => {
                    const n = [];
                    for (let i = 0; i < e; i += 1) {
                        const s = []
                          , r = typeof t == "number" ? t : t[i];
                        for (let l = 0; l < r; l += 1)
                            s.push(new Float32Array(128));
                        n.push(s)
                    }
                    return n
                }
                  , XV = (e, t) => {
                    const n = jo(IM, e)
                      , i = gi(t);
                    return jo(n, i)
                }
                  , qV = async (e, t, n, i, s, r, l) => {
                    const h = t === null ? Math.ceil(e.context.length / 128) * 128 : t.length
                      , d = i.channelCount * i.numberOfInputs
                      , p = s.reduce( (T, M) => T + M, 0)
                      , m = p === 0 ? null : n.createBuffer(p, h, n.sampleRate);
                    if (r === void 0)
                        throw new Error("Missing the processor constructor.");
                    const v = Ha(e)
                      , _ = await XV(n, e)
                      , x = Jx(i.numberOfInputs, i.channelCount)
                      , b = Jx(i.numberOfOutputs, s)
                      , E = Array.from(e.parameters.keys()).reduce( (T, M) => ({
                        ...T,
                        [M]: new Float32Array(128)
                    }), {});
                    for (let T = 0; T < h; T += 128) {
                        if (i.numberOfInputs > 0 && t !== null)
                            for (let M = 0; M < i.numberOfInputs; M += 1)
                                for (let D = 0; D < i.channelCount; D += 1)
                                    Kx(t, x[M], D, D, T);
                        r.parameterDescriptors !== void 0 && t !== null && r.parameterDescriptors.forEach( ({name: M}, D) => {
                            Kx(t, E, M, d + D, T)
                        }
                        );
                        for (let M = 0; M < i.numberOfInputs; M += 1)
                            for (let D = 0; D < s[M]; D += 1)
                                b[M][D].byteLength === 0 && (b[M][D] = new Float32Array(128));
                        try {
                            const M = x.map( (R, O) => v.activeInputs[O].size === 0 ? [] : R)
                              , D = l(T / n.sampleRate, n.sampleRate, () => _.process(M, b, E));
                            if (m !== null)
                                for (let R = 0, O = 0; R < i.numberOfOutputs; R += 1) {
                                    for (let U = 0; U < s[R]; U += 1)
                                        n2(m, b[R], U, O + U, T);
                                    O += s[R]
                                }
                            if (!D)
                                break
                        } catch (M) {
                            e.dispatchEvent(new ErrorEvent("processorerror",{
                                colno: M.colno,
                                filename: M.filename,
                                lineno: M.lineno,
                                message: M.message
                            }));
                            break
                        }
                    }
                    return m
                }
                  , YV = (e, t, n, i, s, r, l, h, d, p, m, v, _, x, b, E) => (T, M, D) => {
                    const R = new WeakMap;
                    let O = null;
                    const U = async (B, I) => {
                        let F = m(B)
                          , P = null;
                        const L = ca(F, I)
                          , H = Array.isArray(M.outputChannelCount) ? M.outputChannelCount : Array.from(M.outputChannelCount);
                        if (v === null) {
                            const Z = H.reduce( (G, V) => G + V, 0)
                              , K = s(I, {
                                channelCount: Math.max(1, Z),
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                numberOfOutputs: Math.max(1, Z)
                            })
                              , te = [];
                            for (let G = 0; G < B.numberOfOutputs; G += 1)
                                te.push(i(I, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: H[G]
                                }));
                            const ce = l(I, {
                                channelCount: M.channelCount,
                                channelCountMode: M.channelCountMode,
                                channelInterpretation: M.channelInterpretation,
                                gain: 1
                            });
                            ce.connect = t.bind(null, te),
                            ce.disconnect = d.bind(null, te),
                            P = [K, te, ce]
                        } else
                            L || (F = new v(I,T));
                        if (R.set(I, P === null ? F : P[2]),
                        P !== null) {
                            if (O === null) {
                                if (D === void 0)
                                    throw new Error("Missing the processor constructor.");
                                if (_ === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const V = B.channelCount * B.numberOfInputs
                                  , q = D.parameterDescriptors === void 0 ? 0 : D.parameterDescriptors.length
                                  , ee = V + q;
                                O = qV(B, ee === 0 ? null : await (async () => {
                                    const X = new _(ee,Math.ceil(B.context.length / 128) * 128,I.sampleRate)
                                      , J = []
                                      , ze = [];
                                    for (let Ne = 0; Ne < M.numberOfInputs; Ne += 1)
                                        J.push(l(X, {
                                            channelCount: M.channelCount,
                                            channelCountMode: M.channelCountMode,
                                            channelInterpretation: M.channelInterpretation,
                                            gain: 1
                                        })),
                                        ze.push(s(X, {
                                            channelCount: M.channelCount,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            numberOfOutputs: M.channelCount
                                        }));
                                    const xe = await Promise.all(Array.from(B.parameters.values()).map(async Ne => {
                                        const be = r(X, {
                                            channelCount: 1,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            offset: Ne.value
                                        });
                                        return await x(X, Ne, be.offset),
                                        be
                                    }
                                    ))
                                      , le = i(X, {
                                        channelCount: 1,
                                        channelCountMode: "explicit",
                                        channelInterpretation: "speakers",
                                        numberOfInputs: Math.max(1, V + q)
                                    });
                                    for (let Ne = 0; Ne < M.numberOfInputs; Ne += 1) {
                                        J[Ne].connect(ze[Ne]);
                                        for (let be = 0; be < M.channelCount; be += 1)
                                            ze[Ne].connect(le, be, Ne * M.channelCount + be)
                                    }
                                    for (const [Ne,be] of xe.entries())
                                        be.connect(le, 0, V + Ne),
                                        be.start(0);
                                    return le.connect(X.destination),
                                    await Promise.all(J.map(Ne => b(B, X, Ne))),
                                    E(X)
                                }
                                )(), I, M, H, D, p)
                            }
                            const Z = await O
                              , K = n(I, {
                                buffer: null,
                                channelCount: 2,
                                channelCountMode: "max",
                                channelInterpretation: "speakers",
                                loop: !1,
                                loopEnd: 0,
                                loopStart: 0,
                                playbackRate: 1
                            })
                              , [te,ce,G] = P;
                            Z !== null && (K.buffer = Z,
                            K.start(0)),
                            K.connect(te);
                            for (let V = 0, q = 0; V < B.numberOfOutputs; V += 1) {
                                const ee = ce[V];
                                for (let se = 0; se < H[V]; se += 1)
                                    te.connect(ee, q + se, se);
                                q += H[V]
                            }
                            return G
                        }
                        if (L)
                            for (const [Z,K] of B.parameters.entries())
                                await e(I, K, F.parameters.get(Z));
                        else
                            for (const [Z,K] of B.parameters.entries())
                                await x(I, K, F.parameters.get(Z));
                        return await b(B, I, F),
                        F
                    }
                    ;
                    return {
                        render(B, I) {
                            h(I, B);
                            const F = R.get(I);
                            return F !== void 0 ? Promise.resolve(F) : U(B, I)
                        }
                    }
                }
                  , WV = (e, t, n, i, s, r, l, h, d, p, m, v, _, x, b, E, T, M, D, R) => class extends b {
                    constructor(U, B) {
                        super(U, B),
                        this._nativeContext = U,
                        this._audioWorklet = e === void 0 ? void 0 : {
                            addModule: (I, F) => e(this, I, F)
                        }
                    }
                    get audioWorklet() {
                        return this._audioWorklet
                    }
                    createAnalyser() {
                        return new t(this)
                    }
                    createBiquadFilter() {
                        return new s(this)
                    }
                    createBuffer(U, B, I) {
                        return new n({
                            length: B,
                            numberOfChannels: U,
                            sampleRate: I
                        })
                    }
                    createBufferSource() {
                        return new i(this)
                    }
                    createChannelMerger(U=6) {
                        return new r(this,{
                            numberOfInputs: U
                        })
                    }
                    createChannelSplitter(U=6) {
                        return new l(this,{
                            numberOfOutputs: U
                        })
                    }
                    createConstantSource() {
                        return new h(this)
                    }
                    createConvolver() {
                        return new d(this)
                    }
                    createDelay(U=1) {
                        return new m(this,{
                            maxDelayTime: U
                        })
                    }
                    createDynamicsCompressor() {
                        return new v(this)
                    }
                    createGain() {
                        return new _(this)
                    }
                    createIIRFilter(U, B) {
                        return new x(this,{
                            feedback: B,
                            feedforward: U
                        })
                    }
                    createOscillator() {
                        return new E(this)
                    }
                    createPanner() {
                        return new T(this)
                    }
                    createPeriodicWave(U, B, I={
                        disableNormalization: !1
                    }) {
                        return new M(this,{
                            ...I,
                            imag: B,
                            real: U
                        })
                    }
                    createStereoPanner() {
                        return new D(this)
                    }
                    createWaveShaper() {
                        return new R(this)
                    }
                    decodeAudioData(U, B, I) {
                        return p(this._nativeContext, U).then(F => (typeof B == "function" && B(F),
                        F), F => {
                            throw typeof I == "function" && I(F),
                            F
                        }
                        )
                    }
                }
                  , jV = {
                    Q: 1,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    detune: 0,
                    frequency: 350,
                    gain: 0,
                    type: "lowpass"
                }
                  , QV = (e, t, n, i, s, r, l, h) => class extends e {
                    constructor(p, m) {
                        const v = r(p)
                          , _ = {
                            ...jV,
                            ...m
                        }
                          , x = s(v, _)
                          , b = l(v)
                          , E = b ? n() : null;
                        super(p, !1, x, E),
                        this._Q = t(this, b, x.Q, Fa, or),
                        this._detune = t(this, b, x.detune, 1200 * Math.log2(Fa), -1200 * Math.log2(Fa)),
                        this._frequency = t(this, b, x.frequency, p.sampleRate / 2, 0),
                        this._gain = t(this, b, x.gain, 40 * Math.log10(Fa), or),
                        this._nativeBiquadFilterNode = x,
                        h(this, 1)
                    }
                    get detune() {
                        return this._detune
                    }
                    get frequency() {
                        return this._frequency
                    }
                    get gain() {
                        return this._gain
                    }
                    get Q() {
                        return this._Q
                    }
                    get type() {
                        return this._nativeBiquadFilterNode.type
                    }
                    set type(p) {
                        this._nativeBiquadFilterNode.type = p
                    }
                    getFrequencyResponse(p, m, v) {
                        try {
                            this._nativeBiquadFilterNode.getFrequencyResponse(p, m, v)
                        } catch (_) {
                            throw _.code === 11 ? i() : _
                        }
                        if (p.length !== m.length || m.length !== v.length)
                            throw i()
                    }
                }
                  , ZV = (e, t, n, i, s) => () => {
                    const r = new WeakMap
                      , l = async (h, d) => {
                        let p = n(h);
                        const m = ca(p, d);
                        if (!m) {
                            const v = {
                                Q: p.Q.value,
                                channelCount: p.channelCount,
                                channelCountMode: p.channelCountMode,
                                channelInterpretation: p.channelInterpretation,
                                detune: p.detune.value,
                                frequency: p.frequency.value,
                                gain: p.gain.value,
                                type: p.type
                            };
                            p = t(d, v)
                        }
                        return r.set(d, p),
                        m ? (await e(d, h.Q, p.Q),
                        await e(d, h.detune, p.detune),
                        await e(d, h.frequency, p.frequency),
                        await e(d, h.gain, p.gain)) : (await i(d, h.Q, p.Q),
                        await i(d, h.detune, p.detune),
                        await i(d, h.frequency, p.frequency),
                        await i(d, h.gain, p.gain)),
                        await s(h, d, p),
                        p
                    }
                    ;
                    return {
                        render(h, d) {
                            const p = r.get(d);
                            return p !== void 0 ? Promise.resolve(p) : l(h, d)
                        }
                    }
                }
                  , KV = (e, t) => (n, i) => {
                    const s = t.get(n);
                    if (s !== void 0)
                        return s;
                    const r = e.get(n);
                    if (r !== void 0)
                        return r;
                    try {
                        const l = i();
                        return l instanceof Promise ? (e.set(n, l),
                        l.catch( () => !1).then(h => (e.delete(n),
                        t.set(n, h),
                        h))) : (t.set(n, l),
                        l)
                    } catch {
                        return t.set(n, !1),
                        !1
                    }
                }
                  , JV = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: 6
                }
                  , $V = (e, t, n, i, s) => class extends e {
                    constructor(l, h) {
                        const d = i(l)
                          , p = {
                            ...JV,
                            ...h
                        }
                          , m = n(d, p)
                          , v = s(d) ? t() : null;
                        super(l, !1, m, v)
                    }
                }
                  , eG = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (r, l) => {
                        let h = t(r);
                        if (!ca(h, l)) {
                            const d = {
                                channelCount: h.channelCount,
                                channelCountMode: h.channelCountMode,
                                channelInterpretation: h.channelInterpretation,
                                numberOfInputs: h.numberOfInputs
                            };
                            h = e(l, d)
                        }
                        return i.set(l, h),
                        await n(r, l, h),
                        h
                    }
                    ;
                    return {
                        render(r, l) {
                            const h = i.get(l);
                            return h !== void 0 ? Promise.resolve(h) : s(r, l)
                        }
                    }
                }
                  , tG = {
                    channelCount: 6,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    numberOfOutputs: 6
                }
                  , nG = (e, t, n, i, s, r) => class extends e {
                    constructor(h, d) {
                        const p = i(h)
                          , m = r({
                            ...tG,
                            ...d
                        })
                          , v = n(p, m)
                          , _ = s(p) ? t() : null;
                        super(h, !1, v, _)
                    }
                }
                  , iG = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (r, l) => {
                        let h = t(r);
                        if (!ca(h, l)) {
                            const d = {
                                channelCount: h.channelCount,
                                channelCountMode: h.channelCountMode,
                                channelInterpretation: h.channelInterpretation,
                                numberOfOutputs: h.numberOfOutputs
                            };
                            h = e(l, d)
                        }
                        return i.set(l, h),
                        await n(r, l, h),
                        h
                    }
                    ;
                    return {
                        render(r, l) {
                            const h = i.get(l);
                            return h !== void 0 ? Promise.resolve(h) : s(r, l)
                        }
                    }
                }
                  , sG = e => (t, n, i) => e(n, t, i)
                  , aG = e => (t, n, i=0, s=0) => {
                    const r = t[i];
                    if (r === void 0)
                        throw e();
                    return Zx(n) ? r.connect(n, 0, s) : r.connect(n, 0)
                }
                  , rG = e => (t, n) => {
                    const i = e(t, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    });
                    return i.buffer = t.createBuffer(1, 2, 44100),
                    i.loop = !0,
                    i.connect(n),
                    i.start(),
                    () => {
                        i.stop(),
                        i.disconnect(n)
                    }
                }
                  , oG = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    offset: 1
                }
                  , lG = (e, t, n, i, s, r, l) => class extends e {
                    constructor(d, p) {
                        const m = s(d)
                          , v = {
                            ...oG,
                            ...p
                        }
                          , _ = i(m, v)
                          , x = r(m)
                          , b = x ? n() : null;
                        super(d, !1, _, b),
                        this._constantSourceNodeRenderer = b,
                        this._nativeConstantSourceNode = _,
                        this._offset = t(this, x, _.offset, Fa, or),
                        this._onended = null
                    }
                    get offset() {
                        return this._offset
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(d) {
                        const p = typeof d == "function" ? l(this, d) : null;
                        this._nativeConstantSourceNode.onended = p;
                        const m = this._nativeConstantSourceNode.onended;
                        this._onended = m !== null && m === p ? d : m
                    }
                    start(d=0) {
                        if (this._nativeConstantSourceNode.start(d),
                        this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = d),
                        this.context.state !== "closed") {
                            $p(this);
                            const p = () => {
                                this._nativeConstantSourceNode.removeEventListener("ended", p),
                                Bc(this) && Xv(this)
                            }
                            ;
                            this._nativeConstantSourceNode.addEventListener("ended", p)
                        }
                    }
                    stop(d=0) {
                        this._nativeConstantSourceNode.stop(d),
                        this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = d)
                    }
                }
                  , cG = (e, t, n, i, s) => () => {
                    const r = new WeakMap;
                    let l = null
                      , h = null;
                    const d = async (p, m) => {
                        let v = n(p);
                        const _ = ca(v, m);
                        if (!_) {
                            const x = {
                                channelCount: v.channelCount,
                                channelCountMode: v.channelCountMode,
                                channelInterpretation: v.channelInterpretation,
                                offset: v.offset.value
                            };
                            v = t(m, x),
                            l !== null && v.start(l),
                            h !== null && v.stop(h)
                        }
                        return r.set(m, v),
                        _ ? await e(m, p.offset, v.offset) : await i(m, p.offset, v.offset),
                        await s(p, m, v),
                        v
                    }
                    ;
                    return {
                        set start(p) {
                            l = p
                        },
                        set stop(p) {
                            h = p
                        },
                        render(p, m) {
                            const v = r.get(m);
                            return v !== void 0 ? Promise.resolve(v) : d(p, m)
                        }
                    }
                }
                  , uG = e => t => (e[0] = t,
                e[0])
                  , hG = {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    disableNormalization: !1
                }
                  , fG = (e, t, n, i, s, r) => class extends e {
                    constructor(h, d) {
                        const p = i(h)
                          , m = {
                            ...hG,
                            ...d
                        }
                          , v = n(p, m)
                          , _ = s(p) ? t() : null;
                        super(h, !1, v, _),
                        this._isBufferNullified = !1,
                        this._nativeConvolverNode = v,
                        m.buffer !== null && r(this, m.buffer.duration)
                    }
                    get buffer() {
                        return this._isBufferNullified ? null : this._nativeConvolverNode.buffer
                    }
                    set buffer(h) {
                        if (this._nativeConvolverNode.buffer = h,
                        h === null && this._nativeConvolverNode.buffer !== null) {
                            const d = this._nativeConvolverNode.context;
                            this._nativeConvolverNode.buffer = d.createBuffer(1, 1, d.sampleRate),
                            this._isBufferNullified = !0,
                            r(this, 0)
                        } else
                            this._isBufferNullified = !1,
                            r(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration)
                    }
                    get normalize() {
                        return this._nativeConvolverNode.normalize
                    }
                    set normalize(h) {
                        this._nativeConvolverNode.normalize = h
                    }
                }
                  , dG = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (r, l) => {
                        let h = t(r);
                        if (!ca(h, l)) {
                            const d = {
                                buffer: h.buffer,
                                channelCount: h.channelCount,
                                channelCountMode: h.channelCountMode,
                                channelInterpretation: h.channelInterpretation,
                                disableNormalization: !h.normalize
                            };
                            h = e(l, d)
                        }
                        return i.set(l, h),
                        em(h) ? await n(r, l, h.inputs[0]) : await n(r, l, h),
                        h
                    }
                    ;
                    return {
                        render(r, l) {
                            const h = i.get(l);
                            return h !== void 0 ? Promise.resolve(h) : s(r, l)
                        }
                    }
                }
                  , pG = (e, t) => (n, i, s) => {
                    if (t === null)
                        throw new Error("Missing the native OfflineAudioContext constructor.");
                    try {
                        return new t(n,i,s)
                    } catch (r) {
                        throw r.name === "SyntaxError" ? e() : r
                    }
                }
                  , mG = () => new DOMException("","DataCloneError")
                  , i2 = e => {
                    const {port1: t, port2: n} = new MessageChannel;
                    return new Promise(i => {
                        const s = () => {
                            n.onmessage = null,
                            t.close(),
                            n.close(),
                            i()
                        }
                        ;
                        n.onmessage = () => s();
                        try {
                            t.postMessage(e, [e])
                        } catch {} finally {
                            s()
                        }
                    }
                    )
                }
                  , gG = (e, t, n, i, s, r, l, h, d, p, m) => (v, _) => {
                    const x = l(v) ? v : r(v);
                    if (s.has(_)) {
                        const b = n();
                        return Promise.reject(b)
                    }
                    try {
                        s.add(_)
                    } catch {}
                    return t(d, () => d(x)) ? x.decodeAudioData(_).then(b => (i2(_).catch( () => {}
                    ),
                    t(h, () => h(b)) || m(b),
                    e.add(b),
                    b)) : new Promise( (b, E) => {
                        const T = async () => {
                            try {
                                await i2(_)
                            } catch {}
                        }
                          , M = D => {
                            E(D),
                            T()
                        }
                        ;
                        try {
                            x.decodeAudioData(_, D => {
                                typeof D.copyFromChannel != "function" && (p(D),
                                zM(D)),
                                e.add(D),
                                T().then( () => b(D))
                            }
                            , D => {
                                M(D === null ? i() : D)
                            }
                            )
                        } catch (D) {
                            M(D)
                        }
                    }
                    )
                }
                  , vG = (e, t, n, i, s, r, l, h) => (d, p) => {
                    const m = t.get(d);
                    if (m === void 0)
                        throw new Error("Missing the expected cycle count.");
                    const v = r(d.context)
                      , _ = h(v);
                    if (m === p) {
                        if (t.delete(d),
                        !_ && l(d)) {
                            const x = i(d)
                              , {outputs: b} = n(d);
                            for (const E of b)
                                if (Yv(E)) {
                                    const T = i(E[0]);
                                    e(x, T, E[1], E[2])
                                } else {
                                    const T = s(E[0]);
                                    x.connect(T, E[1])
                                }
                        }
                    } else
                        t.set(d, m - p)
                }
                  , yG = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    delayTime: 0,
                    maxDelayTime: 1
                }
                  , _G = (e, t, n, i, s, r, l) => class extends e {
                    constructor(d, p) {
                        const m = s(d)
                          , v = {
                            ...yG,
                            ...p
                        }
                          , _ = i(m, v)
                          , x = r(m)
                          , b = x ? n(v.maxDelayTime) : null;
                        super(d, !1, _, b),
                        this._delayTime = t(this, x, _.delayTime),
                        l(this, v.maxDelayTime)
                    }
                    get delayTime() {
                        return this._delayTime
                    }
                }
                  , xG = (e, t, n, i, s) => r => {
                    const l = new WeakMap
                      , h = async (d, p) => {
                        let m = n(d);
                        const v = ca(m, p);
                        if (!v) {
                            const _ = {
                                channelCount: m.channelCount,
                                channelCountMode: m.channelCountMode,
                                channelInterpretation: m.channelInterpretation,
                                delayTime: m.delayTime.value,
                                maxDelayTime: r
                            };
                            m = t(p, _)
                        }
                        return l.set(p, m),
                        v ? await e(p, d.delayTime, m.delayTime) : await i(p, d.delayTime, m.delayTime),
                        await s(d, p, m),
                        m
                    }
                    ;
                    return {
                        render(d, p) {
                            const m = l.get(p);
                            return m !== void 0 ? Promise.resolve(m) : h(d, p)
                        }
                    }
                }
                  , SG = e => (t, n, i, s) => e(t[s], r => r[0] === n && r[1] === i)
                  , AG = e => (t, n) => {
                    e(t).delete(n)
                }
                  , TG = e => "delayTime"in e
                  , MG = (e, t, n) => function i(s, r) {
                    const l = Yx(r) ? r : n(e, r);
                    if (TG(l))
                        return [];
                    if (s[0] === l)
                        return [s];
                    if (s.includes(l))
                        return [];
                    const {outputs: h} = t(l);
                    return Array.from(h).map(d => i([...s, l], d[0])).reduce( (d, p) => d.concat(p), [])
                }
                  , $x = (e, t, n) => {
                    const i = t[n];
                    if (i === void 0)
                        throw e();
                    return i
                }
                  , bG = e => (t, n=void 0, i=void 0, s=0) => n === void 0 ? t.forEach(r => r.disconnect()) : typeof n == "number" ? $x(e, t, n).disconnect() : Zx(n) ? i === void 0 ? t.forEach(r => r.disconnect(n)) : s === void 0 ? $x(e, t, i).disconnect(n, 0) : $x(e, t, i).disconnect(n, 0, s) : i === void 0 ? t.forEach(r => r.disconnect(n)) : $x(e, t, i).disconnect(n, 0)
                  , EG = {
                    attack: .003,
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    knee: 30,
                    ratio: 12,
                    release: .25,
                    threshold: -24
                }
                  , wG = (e, t, n, i, s, r, l, h) => class extends e {
                    constructor(p, m) {
                        const v = r(p)
                          , _ = {
                            ...EG,
                            ...m
                        }
                          , x = i(v, _)
                          , b = l(v)
                          , E = b ? n() : null;
                        super(p, !1, x, E),
                        this._attack = t(this, b, x.attack),
                        this._knee = t(this, b, x.knee),
                        this._nativeDynamicsCompressorNode = x,
                        this._ratio = t(this, b, x.ratio),
                        this._release = t(this, b, x.release),
                        this._threshold = t(this, b, x.threshold),
                        h(this, .006)
                    }
                    get attack() {
                        return this._attack
                    }
                    get channelCount() {
                        return this._nativeDynamicsCompressorNode.channelCount
                    }
                    set channelCount(p) {
                        const m = this._nativeDynamicsCompressorNode.channelCount;
                        if (this._nativeDynamicsCompressorNode.channelCount = p,
                        p > 2)
                            throw this._nativeDynamicsCompressorNode.channelCount = m,
                            s()
                    }
                    get channelCountMode() {
                        return this._nativeDynamicsCompressorNode.channelCountMode
                    }
                    set channelCountMode(p) {
                        const m = this._nativeDynamicsCompressorNode.channelCountMode;
                        if (this._nativeDynamicsCompressorNode.channelCountMode = p,
                        p === "max")
                            throw this._nativeDynamicsCompressorNode.channelCountMode = m,
                            s()
                    }
                    get knee() {
                        return this._knee
                    }
                    get ratio() {
                        return this._ratio
                    }
                    get reduction() {
                        return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction
                    }
                    get release() {
                        return this._release
                    }
                    get threshold() {
                        return this._threshold
                    }
                }
                  , CG = (e, t, n, i, s) => () => {
                    const r = new WeakMap
                      , l = async (h, d) => {
                        let p = n(h);
                        const m = ca(p, d);
                        if (!m) {
                            const v = {
                                attack: p.attack.value,
                                channelCount: p.channelCount,
                                channelCountMode: p.channelCountMode,
                                channelInterpretation: p.channelInterpretation,
                                knee: p.knee.value,
                                ratio: p.ratio.value,
                                release: p.release.value,
                                threshold: p.threshold.value
                            };
                            p = t(d, v)
                        }
                        return r.set(d, p),
                        m ? (await e(d, h.attack, p.attack),
                        await e(d, h.knee, p.knee),
                        await e(d, h.ratio, p.ratio),
                        await e(d, h.release, p.release),
                        await e(d, h.threshold, p.threshold)) : (await i(d, h.attack, p.attack),
                        await i(d, h.knee, p.knee),
                        await i(d, h.ratio, p.ratio),
                        await i(d, h.release, p.release),
                        await i(d, h.threshold, p.threshold)),
                        await s(h, d, p),
                        p
                    }
                    ;
                    return {
                        render(h, d) {
                            const p = r.get(d);
                            return p !== void 0 ? Promise.resolve(p) : l(h, d)
                        }
                    }
                }
                  , RG = () => new DOMException("","EncodingError")
                  , DG = e => t => new Promise( (n, i) => {
                    if (e === null) {
                        i(new SyntaxError);
                        return
                    }
                    const s = e.document.head;
                    if (s === null)
                        i(new SyntaxError);
                    else {
                        const r = e.document.createElement("script")
                          , l = new Blob([t],{
                            type: "application/javascript"
                        })
                          , h = URL.createObjectURL(l)
                          , d = e.onerror
                          , p = () => {
                            e.onerror = d,
                            URL.revokeObjectURL(h)
                        }
                        ;
                        e.onerror = (m, v, _, x, b) => {
                            if (v === h || v === e.location.href && _ === 1 && x === 1)
                                return p(),
                                i(b),
                                !1;
                            if (d !== null)
                                return d(m, v, _, x, b)
                        }
                        ,
                        r.onerror = () => {
                            p(),
                            i(new SyntaxError)
                        }
                        ,
                        r.onload = () => {
                            p(),
                            n()
                        }
                        ,
                        r.src = h,
                        r.type = "module",
                        s.appendChild(r)
                    }
                }
                )
                  , OG = e => class {
                    constructor(n) {
                        this._nativeEventTarget = n,
                        this._listeners = new WeakMap
                    }
                    addEventListener(n, i, s) {
                        if (i !== null) {
                            let r = this._listeners.get(i);
                            r === void 0 && (r = e(this, i),
                            typeof i == "function" && this._listeners.set(i, r)),
                            this._nativeEventTarget.addEventListener(n, r, s)
                        }
                    }
                    dispatchEvent(n) {
                        return this._nativeEventTarget.dispatchEvent(n)
                    }
                    removeEventListener(n, i, s) {
                        const r = i === null ? void 0 : this._listeners.get(i);
                        this._nativeEventTarget.removeEventListener(n, r === void 0 ? null : r, s)
                    }
                }
                  , NG = e => (t, n, i) => {
                    Object.defineProperties(e, {
                        currentFrame: {
                            configurable: !0,
                            get() {
                                return Math.round(t * n)
                            }
                        },
                        currentTime: {
                            configurable: !0,
                            get() {
                                return t
                            }
                        }
                    });
                    try {
                        return i()
                    } finally {
                        e !== null && (delete e.currentFrame,
                        delete e.currentTime)
                    }
                }
                  , UG = e => async t => {
                    try {
                        const n = await fetch(t);
                        if (n.ok)
                            return [await n.text(), n.url]
                    } catch {}
                    throw e()
                }
                  , BG = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    gain: 1
                }
                  , PG = (e, t, n, i, s, r) => class extends e {
                    constructor(h, d) {
                        const p = s(h)
                          , m = {
                            ...BG,
                            ...d
                        }
                          , v = i(p, m)
                          , _ = r(p)
                          , x = _ ? n() : null;
                        super(h, !1, v, x),
                        this._gain = t(this, _, v.gain, Fa, or)
                    }
                    get gain() {
                        return this._gain
                    }
                }
                  , IG = (e, t, n, i, s) => () => {
                    const r = new WeakMap
                      , l = async (h, d) => {
                        let p = n(h);
                        const m = ca(p, d);
                        if (!m) {
                            const v = {
                                channelCount: p.channelCount,
                                channelCountMode: p.channelCountMode,
                                channelInterpretation: p.channelInterpretation,
                                gain: p.gain.value
                            };
                            p = t(d, v)
                        }
                        return r.set(d, p),
                        m ? await e(d, h.gain, p.gain) : await i(d, h.gain, p.gain),
                        await s(h, d, p),
                        p
                    }
                    ;
                    return {
                        render(h, d) {
                            const p = r.get(d);
                            return p !== void 0 ? Promise.resolve(p) : l(h, d)
                        }
                    }
                }
                  , LG = (e, t) => n => t(e, n)
                  , zG = e => t => {
                    const n = e(t);
                    if (n.renderer === null)
                        throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
                    return n.renderer
                }
                  , FG = e => t => {
                    var n;
                    return (n = e.get(t)) !== null && n !== void 0 ? n : 0
                }
                  , HG = e => t => {
                    const n = e(t);
                    if (n.renderer === null)
                        throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
                    return n.renderer
                }
                  , VG = e => t => e.get(t)
                  , rs = () => new DOMException("","InvalidStateError")
                  , GG = e => t => {
                    const n = e.get(t);
                    if (n === void 0)
                        throw rs();
                    return n
                }
                  , kG = (e, t) => n => {
                    let i = e.get(n);
                    if (i !== void 0)
                        return i;
                    if (t === null)
                        throw new Error("Missing the native OfflineAudioContext constructor.");
                    return i = new t(1,1,44100),
                    e.set(n, i),
                    i
                }
                  , XG = e => t => {
                    const n = e.get(t);
                    if (n === void 0)
                        throw new Error("The context has no set of AudioWorkletNodes.");
                    return n
                }
                  , eS = () => new DOMException("","InvalidAccessError")
                  , qG = e => {
                    e.getFrequencyResponse = (t => (n, i, s) => {
                        if (n.length !== i.length || i.length !== s.length)
                            throw eS();
                        return t.call(e, n, i, s)
                    }
                    )(e.getFrequencyResponse)
                }
                  , YG = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers"
                }
                  , WG = (e, t, n, i, s, r) => class extends e {
                    constructor(h, d) {
                        const p = i(h)
                          , m = s(p)
                          , v = {
                            ...YG,
                            ...d
                        }
                          , _ = t(p, m ? null : h.baseLatency, v)
                          , x = m ? n(v.feedback, v.feedforward) : null;
                        super(h, !1, _, x),
                        qG(_),
                        this._nativeIIRFilterNode = _,
                        r(this, 1)
                    }
                    getFrequencyResponse(h, d, p) {
                        return this._nativeIIRFilterNode.getFrequencyResponse(h, d, p)
                    }
                }
                  , s2 = (e, t, n, i, s, r, l, h, d, p, m) => {
                    const v = p.length;
                    let _ = h;
                    for (let x = 0; x < v; x += 1) {
                        let b = n[0] * p[x];
                        for (let E = 1; E < s; E += 1) {
                            const T = _ - E & d - 1;
                            b += n[E] * r[T],
                            b -= e[E] * l[T]
                        }
                        for (let E = s; E < i; E += 1)
                            b += n[E] * r[_ - E & d - 1];
                        for (let E = s; E < t; E += 1)
                            b -= e[E] * l[_ - E & d - 1];
                        r[_] = p[x],
                        l[_] = b,
                        _ = _ + 1 & d - 1,
                        m[x] = b
                    }
                    return _
                }
                  , jG = (e, t, n, i) => {
                    const s = n instanceof Float64Array ? n : new Float64Array(n)
                      , r = i instanceof Float64Array ? i : new Float64Array(i)
                      , l = s.length
                      , h = r.length
                      , d = Math.min(l, h);
                    if (s[0] !== 1) {
                        for (let b = 0; b < l; b += 1)
                            r[b] /= s[0];
                        for (let b = 1; b < h; b += 1)
                            s[b] /= s[0]
                    }
                    const p = 32
                      , m = new Float32Array(p)
                      , v = new Float32Array(p)
                      , _ = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate)
                      , x = e.numberOfChannels;
                    for (let b = 0; b < x; b += 1) {
                        const E = e.getChannelData(b)
                          , T = _.getChannelData(b);
                        m.fill(0),
                        v.fill(0),
                        s2(s, l, r, h, d, m, v, 0, p, E, T)
                    }
                    return _
                }
                  , QG = (e, t, n, i, s) => (r, l) => {
                    const h = new WeakMap;
                    let d = null;
                    const p = async (m, v) => {
                        let _ = null
                          , x = t(m);
                        const b = ca(x, v);
                        if (v.createIIRFilter === void 0 ? _ = e(v, {
                            buffer: null,
                            channelCount: 2,
                            channelCountMode: "max",
                            channelInterpretation: "speakers",
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            playbackRate: 1
                        }) : b || (x = v.createIIRFilter(l, r)),
                        h.set(v, _ === null ? x : _),
                        _ !== null) {
                            if (d === null) {
                                if (n === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const E = new n(m.context.destination.channelCount,m.context.length,v.sampleRate);
                                d = (async () => {
                                    await i(m, E, E.destination);
                                    const T = await s(E);
                                    return jG(T, v, r, l)
                                }
                                )()
                            }
                            return _.buffer = await d,
                            _.start(0),
                            _
                        }
                        return await i(m, v, x),
                        x
                    }
                    ;
                    return {
                        render(m, v) {
                            const _ = h.get(v);
                            return _ !== void 0 ? Promise.resolve(_) : p(m, v)
                        }
                    }
                }
                  , ZG = (e, t, n, i, s, r) => l => (h, d) => {
                    const p = e.get(h);
                    if (p === void 0) {
                        if (!l && r(h)) {
                            const m = i(h)
                              , {outputs: v} = n(h);
                            for (const _ of v)
                                if (Yv(_)) {
                                    const x = i(_[0]);
                                    t(m, x, _[1], _[2])
                                } else {
                                    const x = s(_[0]);
                                    m.disconnect(x, _[1])
                                }
                        }
                        e.set(h, d)
                    } else
                        e.set(h, p + d)
                }
                  , KG = (e, t) => n => {
                    const i = e.get(n);
                    return t(i) || t(n)
                }
                  , JG = (e, t) => n => e.has(n) || t(n)
                  , $G = (e, t) => n => e.has(n) || t(n)
                  , e6 = (e, t) => n => {
                    const i = e.get(n);
                    return t(i) || t(n)
                }
                  , t6 = e => t => e !== null && t instanceof e
                  , n6 = e => t => e !== null && typeof e.AudioNode == "function" && t instanceof e.AudioNode
                  , i6 = e => t => e !== null && typeof e.AudioParam == "function" && t instanceof e.AudioParam
                  , s6 = (e, t) => n => e(n) || t(n)
                  , a6 = e => t => e !== null && t instanceof e
                  , r6 = e => e !== null && e.isSecureContext
                  , o6 = (e, t, n, i) => class extends e {
                    constructor(r, l) {
                        const h = n(r)
                          , d = t(h, l);
                        if (i(h))
                            throw TypeError();
                        super(r, !0, d, null),
                        this._nativeMediaElementAudioSourceNode = d
                    }
                    get mediaElement() {
                        return this._nativeMediaElementAudioSourceNode.mediaElement
                    }
                }
                  , l6 = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers"
                }
                  , c6 = (e, t, n, i) => class extends e {
                    constructor(r, l) {
                        const h = n(r);
                        if (i(h))
                            throw new TypeError;
                        const d = {
                            ...l6,
                            ...l
                        }
                          , p = t(h, d);
                        super(r, !1, p, null),
                        this._nativeMediaStreamAudioDestinationNode = p
                    }
                    get stream() {
                        return this._nativeMediaStreamAudioDestinationNode.stream
                    }
                }
                  , u6 = (e, t, n, i) => class extends e {
                    constructor(r, l) {
                        const h = n(r)
                          , d = t(h, l);
                        if (i(h))
                            throw new TypeError;
                        super(r, !0, d, null),
                        this._nativeMediaStreamAudioSourceNode = d
                    }
                    get mediaStream() {
                        return this._nativeMediaStreamAudioSourceNode.mediaStream
                    }
                }
                  , h6 = (e, t, n) => class extends e {
                    constructor(s, r) {
                        const l = n(s)
                          , h = t(l, r);
                        super(s, !0, h, null)
                    }
                }
                  , f6 = (e, t, n, i, s) => class extends i {
                    constructor(l={}) {
                        if (s === null)
                            throw new Error("Missing the native AudioContext constructor.");
                        let h;
                        try {
                            h = new s(l)
                        } catch (m) {
                            throw m.code === 12 && m.message === "sampleRate is not in range" ? t() : m
                        }
                        if (h === null)
                            throw n();
                        if (!jD(l.latencyHint))
                            throw new TypeError(`The provided value '${l.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                        if (l.sampleRate !== void 0 && h.sampleRate !== l.sampleRate)
                            throw t();
                        super(h, 2);
                        const {latencyHint: d} = l
                          , {sampleRate: p} = h;
                        if (this._baseLatency = typeof h.baseLatency == "number" ? h.baseLatency : d === "balanced" ? 512 / p : d === "interactive" || d === void 0 ? 256 / p : d === "playback" ? 1024 / p : Math.max(2, Math.min(128, Math.round(d * p / 128))) * 128 / p,
                        this._nativeAudioContext = h,
                        s.name === "webkitAudioContext" ? (this._nativeGainNode = h.createGain(),
                        this._nativeOscillatorNode = h.createOscillator(),
                        this._nativeGainNode.gain.value = 1e-37,
                        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(h.destination),
                        this._nativeOscillatorNode.start()) : (this._nativeGainNode = null,
                        this._nativeOscillatorNode = null),
                        this._state = null,
                        h.state === "running") {
                            this._state = "suspended";
                            const m = () => {
                                this._state === "suspended" && (this._state = null),
                                h.removeEventListener("statechange", m)
                            }
                            ;
                            h.addEventListener("statechange", m)
                        }
                    }
                    get baseLatency() {
                        return this._baseLatency
                    }
                    get state() {
                        return this._state !== null ? this._state : this._nativeAudioContext.state
                    }
                    close() {
                        return this.state === "closed" ? this._nativeAudioContext.close().then( () => {
                            throw e()
                        }
                        ) : (this._state === "suspended" && (this._state = null),
                        this._nativeAudioContext.close().then( () => {
                            this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(),
                            this._nativeGainNode.disconnect(),
                            this._nativeOscillatorNode.disconnect()),
                            qx(this)
                        }
                        ))
                    }
                    resume() {
                        return this._state === "suspended" ? new Promise( (l, h) => {
                            const d = () => {
                                this._nativeAudioContext.removeEventListener("statechange", d),
                                this._nativeAudioContext.state === "running" ? l() : this.resume().then(l, h)
                            }
                            ;
                            this._nativeAudioContext.addEventListener("statechange", d)
                        }
                        ) : this._nativeAudioContext.resume().catch(l => {
                            throw l === void 0 || l.code === 15 ? e() : l
                        }
                        )
                    }
                    suspend() {
                        return this._nativeAudioContext.suspend().catch(l => {
                            throw l === void 0 ? e() : l
                        }
                        )
                    }
                }
                  , d6 = (e, t, n, i, s, r) => class extends n {
                    constructor(h, d) {
                        super(h),
                        this._nativeContext = h,
                        Gx.set(this, h),
                        i(h) && s.set(h, new Set),
                        this._destination = new e(this,d),
                        this._listener = t(this, h),
                        this._onstatechange = null
                    }
                    get currentTime() {
                        return this._nativeContext.currentTime
                    }
                    get destination() {
                        return this._destination
                    }
                    get listener() {
                        return this._listener
                    }
                    get onstatechange() {
                        return this._onstatechange
                    }
                    set onstatechange(h) {
                        const d = typeof h == "function" ? r(this, h) : null;
                        this._nativeContext.onstatechange = d;
                        const p = this._nativeContext.onstatechange;
                        this._onstatechange = p !== null && p === d ? h : p
                    }
                    get sampleRate() {
                        return this._nativeContext.sampleRate
                    }
                    get state() {
                        return this._nativeContext.state
                    }
                }
                  , Hf = e => {
                    const t = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
                    try {
                        const n = e.decodeAudioData(t.buffer, () => {}
                        );
                        return n === void 0 ? !1 : (n.catch( () => {}
                        ),
                        !0)
                    } catch {}
                    return !1
                }
                  , p6 = {
                    numberOfChannels: 1
                }
                  , m6 = (e, t, n, i, s) => class extends i {
                    constructor(l) {
                        const {length: h, numberOfChannels: d, sampleRate: p} = {
                            ...p6,
                            ...l
                        }
                          , m = n(d, h, p);
                        e(Hf, () => Hf(m)) || m.addEventListener("statechange", ( () => {
                            let v = 0;
                            const _ = x => {
                                this._state === "running" && (v > 0 ? (m.removeEventListener("statechange", _),
                                x.stopImmediatePropagation(),
                                this._waitForThePromiseToSettle(x)) : v += 1)
                            }
                            ;
                            return _
                        }
                        )()),
                        super(m, d),
                        this._length = h,
                        this._nativeOfflineAudioContext = m,
                        this._state = null
                    }
                    get length() {
                        return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
                    }
                    get state() {
                        return this._state === null ? this._nativeOfflineAudioContext.state : this._state
                    }
                    startRendering() {
                        return this._state === "running" ? Promise.reject(t()) : (this._state = "running",
                        s(this.destination, this._nativeOfflineAudioContext).finally( () => {
                            this._state = null,
                            qx(this)
                        }
                        ))
                    }
                    _waitForThePromiseToSettle(l) {
                        this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(l) : setTimeout( () => this._waitForThePromiseToSettle(l))
                    }
                }
                  , g6 = (e, t) => (n, i, s) => {
                    const r = new Set;
                    return n.connect = (l => (h, d=0, p=0) => {
                        const m = r.size === 0;
                        if (t(h))
                            return l.call(n, h, d, p),
                            e(r, [h, d, p], v => v[0] === h && v[1] === d && v[2] === p, !0),
                            m && i(),
                            h;
                        l.call(n, h, d),
                        e(r, [h, d], v => v[0] === h && v[1] === d, !0),
                        m && i()
                    }
                    )(n.connect),
                    n.disconnect = (l => (h, d, p) => {
                        const m = r.size > 0;
                        if (h === void 0)
                            l.apply(n),
                            r.clear();
                        else if (typeof h == "number") {
                            l.call(n, h);
                            for (const _ of r)
                                _[1] === h && r.delete(_)
                        } else {
                            t(h) ? l.call(n, h, d, p) : l.call(n, h, d);
                            for (const _ of r)
                                _[0] === h && (d === void 0 || _[1] === d) && (p === void 0 || _[2] === p) && r.delete(_)
                        }
                        const v = r.size === 0;
                        m && v && s()
                    }
                    )(n.disconnect),
                    n
                }
                  , Si = (e, t, n) => {
                    const i = t[n];
                    i !== void 0 && i !== e[n] && (e[n] = i)
                }
                  , Ts = (e, t) => {
                    Si(e, t, "channelCount"),
                    Si(e, t, "channelCountMode"),
                    Si(e, t, "channelInterpretation")
                }
                  , a2 = e => typeof e.getFloatTimeDomainData == "function"
                  , v6 = e => {
                    e.getFloatTimeDomainData = t => {
                        const n = new Uint8Array(t.length);
                        e.getByteTimeDomainData(n);
                        const i = Math.max(n.length, e.fftSize);
                        for (let s = 0; s < i; s += 1)
                            t[s] = (n[s] - 128) * .0078125;
                        return t
                    }
                }
                  , y6 = (e, t) => (n, i) => {
                    const s = n.createAnalyser();
                    if (Ts(s, i),
                    !(i.maxDecibels > i.minDecibels))
                        throw t();
                    return Si(s, i, "fftSize"),
                    Si(s, i, "maxDecibels"),
                    Si(s, i, "minDecibels"),
                    Si(s, i, "smoothingTimeConstant"),
                    e(a2, () => a2(s)) || v6(s),
                    s
                }
                  , _6 = e => e === null ? null : e.hasOwnProperty("AudioBuffer") ? e.AudioBuffer : null
                  , Vi = (e, t, n) => {
                    const i = t[n];
                    i !== void 0 && i !== e[n].value && (e[n].value = i)
                }
                  , x6 = e => {
                    e.start = (t => {
                        let n = !1;
                        return (i=0, s=0, r) => {
                            if (n)
                                throw rs();
                            t.call(e, i, s, r),
                            n = !0
                        }
                    }
                    )(e.start)
                }
                  , kM = e => {
                    e.start = (t => (n=0, i=0, s) => {
                        if (typeof s == "number" && s < 0 || i < 0 || n < 0)
                            throw new RangeError("The parameters can't be negative.");
                        t.call(e, n, i, s)
                    }
                    )(e.start)
                }
                  , XM = e => {
                    e.stop = (t => (n=0) => {
                        if (n < 0)
                            throw new RangeError("The parameter can't be negative.");
                        t.call(e, n)
                    }
                    )(e.stop)
                }
                  , S6 = (e, t, n, i, s, r, l, h, d, p, m) => (v, _) => {
                    const x = v.createBufferSource();
                    return Ts(x, _),
                    Vi(x, _, "playbackRate"),
                    Si(x, _, "buffer"),
                    Si(x, _, "loop"),
                    Si(x, _, "loopEnd"),
                    Si(x, _, "loopStart"),
                    t(n, () => n(v)) || x6(x),
                    t(i, () => i(v)) || d(x),
                    t(s, () => s(v)) || p(x, v),
                    t(r, () => r(v)) || kM(x),
                    t(l, () => l(v)) || m(x, v),
                    t(h, () => h(v)) || XM(x),
                    e(v, x),
                    x
                }
                  , A6 = e => e === null ? null : e.hasOwnProperty("AudioContext") ? e.AudioContext : e.hasOwnProperty("webkitAudioContext") ? e.webkitAudioContext : null
                  , T6 = (e, t) => (n, i, s) => {
                    const r = n.destination;
                    if (r.channelCount !== i)
                        try {
                            r.channelCount = i
                        } catch {}
                    s && r.channelCountMode !== "explicit" && (r.channelCountMode = "explicit"),
                    r.maxChannelCount === 0 && Object.defineProperty(r, "maxChannelCount", {
                        value: i
                    });
                    const l = e(n, {
                        channelCount: i,
                        channelCountMode: r.channelCountMode,
                        channelInterpretation: r.channelInterpretation,
                        gain: 1
                    });
                    return t(l, "channelCount", h => () => h.call(l), h => d => {
                        h.call(l, d);
                        try {
                            r.channelCount = d
                        } catch (p) {
                            if (d > r.maxChannelCount)
                                throw p
                        }
                    }
                    ),
                    t(l, "channelCountMode", h => () => h.call(l), h => d => {
                        h.call(l, d),
                        r.channelCountMode = d
                    }
                    ),
                    t(l, "channelInterpretation", h => () => h.call(l), h => d => {
                        h.call(l, d),
                        r.channelInterpretation = d
                    }
                    ),
                    Object.defineProperty(l, "maxChannelCount", {
                        get: () => r.maxChannelCount
                    }),
                    l.connect(r),
                    l
                }
                  , M6 = e => e === null ? null : e.hasOwnProperty("AudioWorkletNode") ? e.AudioWorkletNode : null
                  , b6 = e => {
                    const {port1: t} = new MessageChannel;
                    try {
                        t.postMessage(e)
                    } finally {
                        t.close()
                    }
                }
                  , E6 = (e, t, n, i, s) => (r, l, h, d, p, m) => {
                    if (h !== null)
                        try {
                            const v = new h(r,d,m)
                              , _ = new Map;
                            let x = null;
                            if (Object.defineProperties(v, {
                                channelCount: {
                                    get: () => m.channelCount,
                                    set: () => {
                                        throw e()
                                    }
                                },
                                channelCountMode: {
                                    get: () => "explicit",
                                    set: () => {
                                        throw e()
                                    }
                                },
                                onprocessorerror: {
                                    get: () => x,
                                    set: b => {
                                        typeof x == "function" && v.removeEventListener("processorerror", x),
                                        x = typeof b == "function" ? b : null,
                                        typeof x == "function" && v.addEventListener("processorerror", x)
                                    }
                                }
                            }),
                            v.addEventListener = (b => (...E) => {
                                if (E[0] === "processorerror") {
                                    const T = typeof E[1] == "function" ? E[1] : typeof E[1] == "object" && E[1] !== null && typeof E[1].handleEvent == "function" ? E[1].handleEvent : null;
                                    if (T !== null) {
                                        const M = _.get(E[1]);
                                        M !== void 0 ? E[1] = M : (E[1] = D => {
                                            D.type === "error" ? (Object.defineProperties(D, {
                                                type: {
                                                    value: "processorerror"
                                                }
                                            }),
                                            T(D)) : T(new ErrorEvent(E[0],{
                                                ...D
                                            }))
                                        }
                                        ,
                                        _.set(T, E[1]))
                                    }
                                }
                                return b.call(v, "error", E[1], E[2]),
                                b.call(v, ...E)
                            }
                            )(v.addEventListener),
                            v.removeEventListener = (b => (...E) => {
                                if (E[0] === "processorerror") {
                                    const T = _.get(E[1]);
                                    T !== void 0 && (_.delete(E[1]),
                                    E[1] = T)
                                }
                                return b.call(v, "error", E[1], E[2]),
                                b.call(v, E[0], E[1], E[2])
                            }
                            )(v.removeEventListener),
                            m.numberOfOutputs !== 0) {
                                const b = n(r, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "discrete",
                                    gain: 0
                                });
                                return v.connect(b).connect(r.destination),
                                s(v, () => b.disconnect(), () => b.connect(r.destination))
                            }
                            return v
                        } catch (v) {
                            throw v.code === 11 ? i() : v
                        }
                    if (p === void 0)
                        throw i();
                    return b6(m),
                    t(r, l, p, m)
                }
                  , r2 = (e, t) => e === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(e * t)))))
                  , w6 = e => new Promise( (t, n) => {
                    const {port1: i, port2: s} = new MessageChannel;
                    i.onmessage = ({data: r}) => {
                        i.close(),
                        s.close(),
                        t(r)
                    }
                    ,
                    i.onmessageerror = ({data: r}) => {
                        i.close(),
                        s.close(),
                        n(r)
                    }
                    ,
                    s.postMessage(e)
                }
                )
                  , C6 = async (e, t) => {
                    const n = await w6(t);
                    return new e(n)
                }
                  , R6 = (e, t, n, i) => {
                    let s = IM.get(e);
                    s === void 0 && (s = new WeakMap,
                    IM.set(e, s));
                    const r = C6(n, i);
                    return s.set(t, r),
                    r
                }
                  , D6 = (e, t, n, i, s, r, l, h, d, p, m, v, _) => (x, b, E, T) => {
                    if (T.numberOfInputs === 0 && T.numberOfOutputs === 0)
                        throw d();
                    const M = Array.isArray(T.outputChannelCount) ? T.outputChannelCount : Array.from(T.outputChannelCount);
                    if (M.some(de => de < 1))
                        throw d();
                    if (M.length !== T.numberOfOutputs)
                        throw t();
                    if (T.channelCountMode !== "explicit")
                        throw d();
                    const D = T.channelCount * T.numberOfInputs
                      , R = M.reduce( (de, Te) => de + Te, 0)
                      , O = E.parameterDescriptors === void 0 ? 0 : E.parameterDescriptors.length;
                    if (D + O > 6 || R > 6)
                        throw d();
                    const U = new MessageChannel
                      , B = []
                      , I = [];
                    for (let de = 0; de < T.numberOfInputs; de += 1)
                        B.push(l(x, {
                            channelCount: T.channelCount,
                            channelCountMode: T.channelCountMode,
                            channelInterpretation: T.channelInterpretation,
                            gain: 1
                        })),
                        I.push(s(x, {
                            channelCount: T.channelCount,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: T.channelCount
                        }));
                    const F = [];
                    if (E.parameterDescriptors !== void 0)
                        for (const {defaultValue: de, maxValue: Te, minValue: Pe, name: Ye} of E.parameterDescriptors) {
                            const Ie = r(x, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: T.parameterData[Ye] !== void 0 ? T.parameterData[Ye] : de === void 0 ? 0 : de
                            });
                            Object.defineProperties(Ie.offset, {
                                defaultValue: {
                                    get: () => de === void 0 ? 0 : de
                                },
                                maxValue: {
                                    get: () => Te === void 0 ? Fa : Te
                                },
                                minValue: {
                                    get: () => Pe === void 0 ? or : Pe
                                }
                            }),
                            F.push(Ie)
                        }
                    const P = i(x, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "speakers",
                        numberOfInputs: Math.max(1, D + O)
                    })
                      , L = r2(b, x.sampleRate)
                      , H = h(x, L, D + O, Math.max(1, R))
                      , Z = s(x, {
                        channelCount: Math.max(1, R),
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        numberOfOutputs: Math.max(1, R)
                    })
                      , K = [];
                    for (let de = 0; de < T.numberOfOutputs; de += 1)
                        K.push(i(x, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: M[de]
                        }));
                    for (let de = 0; de < T.numberOfInputs; de += 1) {
                        B[de].connect(I[de]);
                        for (let Te = 0; Te < T.channelCount; Te += 1)
                            I[de].connect(P, Te, de * T.channelCount + Te)
                    }
                    const te = new t2(E.parameterDescriptors === void 0 ? [] : E.parameterDescriptors.map( ({name: de}, Te) => {
                        const Pe = F[Te];
                        return Pe.connect(P, 0, D + Te),
                        Pe.start(0),
                        [de, Pe.offset]
                    }
                    ));
                    P.connect(H);
                    let ce = T.channelInterpretation
                      , G = null;
                    const V = T.numberOfOutputs === 0 ? [H] : K
                      , q = {
                        get bufferSize() {
                            return L
                        },
                        get channelCount() {
                            return T.channelCount
                        },
                        set channelCount(de) {
                            throw n()
                        },
                        get channelCountMode() {
                            return T.channelCountMode
                        },
                        set channelCountMode(de) {
                            throw n()
                        },
                        get channelInterpretation() {
                            return ce
                        },
                        set channelInterpretation(de) {
                            for (const Te of B)
                                Te.channelInterpretation = de;
                            ce = de
                        },
                        get context() {
                            return H.context
                        },
                        get inputs() {
                            return B
                        },
                        get numberOfInputs() {
                            return T.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return T.numberOfOutputs
                        },
                        get onprocessorerror() {
                            return G
                        },
                        set onprocessorerror(de) {
                            typeof G == "function" && q.removeEventListener("processorerror", G),
                            G = typeof de == "function" ? de : null,
                            typeof G == "function" && q.addEventListener("processorerror", G)
                        },
                        get parameters() {
                            return te
                        },
                        get port() {
                            return U.port2
                        },
                        addEventListener(...de) {
                            return H.addEventListener(de[0], de[1], de[2])
                        },
                        connect: e.bind(null, V),
                        disconnect: p.bind(null, V),
                        dispatchEvent(...de) {
                            return H.dispatchEvent(de[0])
                        },
                        removeEventListener(...de) {
                            return H.removeEventListener(de[0], de[1], de[2])
                        }
                    }
                      , ee = new Map;
                    U.port1.addEventListener = (de => (...Te) => {
                        if (Te[0] === "message") {
                            const Pe = typeof Te[1] == "function" ? Te[1] : typeof Te[1] == "object" && Te[1] !== null && typeof Te[1].handleEvent == "function" ? Te[1].handleEvent : null;
                            if (Pe !== null) {
                                const Ye = ee.get(Te[1]);
                                Ye !== void 0 ? Te[1] = Ye : (Te[1] = Ie => {
                                    m(x.currentTime, x.sampleRate, () => Pe(Ie))
                                }
                                ,
                                ee.set(Pe, Te[1]))
                            }
                        }
                        return de.call(U.port1, Te[0], Te[1], Te[2])
                    }
                    )(U.port1.addEventListener),
                    U.port1.removeEventListener = (de => (...Te) => {
                        if (Te[0] === "message") {
                            const Pe = ee.get(Te[1]);
                            Pe !== void 0 && (ee.delete(Te[1]),
                            Te[1] = Pe)
                        }
                        return de.call(U.port1, Te[0], Te[1], Te[2])
                    }
                    )(U.port1.removeEventListener);
                    let se = null;
                    Object.defineProperty(U.port1, "onmessage", {
                        get: () => se,
                        set: de => {
                            typeof se == "function" && U.port1.removeEventListener("message", se),
                            se = typeof de == "function" ? de : null,
                            typeof se == "function" && (U.port1.addEventListener("message", se),
                            U.port1.start())
                        }
                    }),
                    E.prototype.port = U.port1;
                    let X = null;
                    R6(x, q, E, T).then(de => X = de);
                    const J = Jx(T.numberOfInputs, T.channelCount)
                      , ze = Jx(T.numberOfOutputs, M)
                      , xe = E.parameterDescriptors === void 0 ? [] : E.parameterDescriptors.reduce( (de, {name: Te}) => ({
                        ...de,
                        [Te]: new Float32Array(128)
                    }), {});
                    let le = !0;
                    const Ne = () => {
                        T.numberOfOutputs > 0 && H.disconnect(Z);
                        for (let de = 0, Te = 0; de < T.numberOfOutputs; de += 1) {
                            const Pe = K[de];
                            for (let Ye = 0; Ye < M[de]; Ye += 1)
                                Z.disconnect(Pe, Te + Ye, Ye);
                            Te += M[de]
                        }
                    }
                      , be = new Map;
                    H.onaudioprocess = ({inputBuffer: de, outputBuffer: Te}) => {
                        if (X !== null) {
                            const Pe = v(q);
                            for (let Ye = 0; Ye < L; Ye += 128) {
                                for (let Ie = 0; Ie < T.numberOfInputs; Ie += 1)
                                    for (let Fe = 0; Fe < T.channelCount; Fe += 1)
                                        Kx(de, J[Ie], Fe, Fe, Ye);
                                E.parameterDescriptors !== void 0 && E.parameterDescriptors.forEach( ({name: Ie}, Fe) => {
                                    Kx(de, xe, Ie, D + Fe, Ye)
                                }
                                );
                                for (let Ie = 0; Ie < T.numberOfInputs; Ie += 1)
                                    for (let Fe = 0; Fe < M[Ie]; Fe += 1)
                                        ze[Ie][Fe].byteLength === 0 && (ze[Ie][Fe] = new Float32Array(128));
                                try {
                                    const Ie = J.map( (Fe, xt) => {
                                        if (Pe[xt].size > 0)
                                            return be.set(xt, L / 128),
                                            Fe;
                                        const yt = be.get(xt);
                                        return yt === void 0 ? [] : (Fe.every(wt => wt.every($ => $ === 0)) && (yt === 1 ? be.delete(xt) : be.set(xt, yt - 1)),
                                        Fe)
                                    }
                                    );
                                    le = m(x.currentTime + Ye / x.sampleRate, x.sampleRate, () => X.process(Ie, ze, xe));
                                    for (let Fe = 0, xt = 0; Fe < T.numberOfOutputs; Fe += 1) {
                                        for (let yt = 0; yt < M[Fe]; yt += 1)
                                            n2(Te, ze[Fe], yt, xt + yt, Ye);
                                        xt += M[Fe]
                                    }
                                } catch (Ie) {
                                    le = !1,
                                    q.dispatchEvent(new ErrorEvent("processorerror",{
                                        colno: Ie.colno,
                                        filename: Ie.filename,
                                        lineno: Ie.lineno,
                                        message: Ie.message
                                    }))
                                }
                                if (!le) {
                                    for (let Ie = 0; Ie < T.numberOfInputs; Ie += 1) {
                                        B[Ie].disconnect(I[Ie]);
                                        for (let Fe = 0; Fe < T.channelCount; Fe += 1)
                                            I[Ye].disconnect(P, Fe, Ie * T.channelCount + Fe)
                                    }
                                    if (E.parameterDescriptors !== void 0) {
                                        const Ie = E.parameterDescriptors.length;
                                        for (let Fe = 0; Fe < Ie; Fe += 1) {
                                            const xt = F[Fe];
                                            xt.disconnect(P, 0, D + Fe),
                                            xt.stop()
                                        }
                                    }
                                    P.disconnect(H),
                                    H.onaudioprocess = null,
                                    Ue ? Ne() : Et();
                                    break
                                }
                            }
                        }
                    }
                    ;
                    let Ue = !1;
                    const $e = l(x, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    })
                      , rt = () => H.connect($e).connect(x.destination)
                      , Et = () => {
                        H.disconnect($e),
                        $e.disconnect()
                    }
                      , ne = () => {
                        if (le) {
                            Et(),
                            T.numberOfOutputs > 0 && H.connect(Z);
                            for (let de = 0, Te = 0; de < T.numberOfOutputs; de += 1) {
                                const Pe = K[de];
                                for (let Ye = 0; Ye < M[de]; Ye += 1)
                                    Z.connect(Pe, Te + Ye, Ye);
                                Te += M[de]
                            }
                        }
                        Ue = !0
                    }
                      , Ve = () => {
                        le && (rt(),
                        Ne()),
                        Ue = !1
                    }
                    ;
                    return rt(),
                    _(q, ne, Ve)
                }
                  , o2 = (e, t) => {
                    const n = e.createBiquadFilter();
                    return Ts(n, t),
                    Vi(n, t, "Q"),
                    Vi(n, t, "detune"),
                    Vi(n, t, "frequency"),
                    Vi(n, t, "gain"),
                    Si(n, t, "type"),
                    n
                }
                  , O6 = (e, t) => (n, i) => {
                    const s = n.createChannelMerger(i.numberOfInputs);
                    return e !== null && e.name === "webkitAudioContext" && t(n, s),
                    Ts(s, i),
                    s
                }
                  , N6 = e => {
                    const t = e.numberOfOutputs;
                    Object.defineProperty(e, "channelCount", {
                        get: () => t,
                        set: n => {
                            if (n !== t)
                                throw rs()
                        }
                    }),
                    Object.defineProperty(e, "channelCountMode", {
                        get: () => "explicit",
                        set: n => {
                            if (n !== "explicit")
                                throw rs()
                        }
                    }),
                    Object.defineProperty(e, "channelInterpretation", {
                        get: () => "discrete",
                        set: n => {
                            if (n !== "discrete")
                                throw rs()
                        }
                    })
                }
                  , jv = (e, t) => {
                    const n = e.createChannelSplitter(t.numberOfOutputs);
                    return Ts(n, t),
                    N6(n),
                    n
                }
                  , U6 = (e, t, n, i, s) => (r, l) => {
                    if (r.createConstantSource === void 0)
                        return n(r, l);
                    const h = r.createConstantSource();
                    return Ts(h, l),
                    Vi(h, l, "offset"),
                    t(i, () => i(r)) || kM(h),
                    t(s, () => s(r)) || XM(h),
                    e(r, h),
                    h
                }
                  , tm = (e, t) => (e.connect = t.connect.bind(t),
                e.disconnect = t.disconnect.bind(t),
                e)
                  , B6 = (e, t, n, i) => (s, {offset: r, ...l}) => {
                    const h = s.createBuffer(1, 2, 44100)
                      , d = t(s, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    })
                      , p = n(s, {
                        ...l,
                        gain: r
                    })
                      , m = h.getChannelData(0);
                    m[0] = 1,
                    m[1] = 1,
                    d.buffer = h,
                    d.loop = !0;
                    const v = {
                        get bufferSize() {},
                        get channelCount() {
                            return p.channelCount
                        },
                        set channelCount(b) {
                            p.channelCount = b
                        },
                        get channelCountMode() {
                            return p.channelCountMode
                        },
                        set channelCountMode(b) {
                            p.channelCountMode = b
                        },
                        get channelInterpretation() {
                            return p.channelInterpretation
                        },
                        set channelInterpretation(b) {
                            p.channelInterpretation = b
                        },
                        get context() {
                            return p.context
                        },
                        get inputs() {
                            return []
                        },
                        get numberOfInputs() {
                            return d.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return p.numberOfOutputs
                        },
                        get offset() {
                            return p.gain
                        },
                        get onended() {
                            return d.onended
                        },
                        set onended(b) {
                            d.onended = b
                        },
                        addEventListener(...b) {
                            return d.addEventListener(b[0], b[1], b[2])
                        },
                        dispatchEvent(...b) {
                            return d.dispatchEvent(b[0])
                        },
                        removeEventListener(...b) {
                            return d.removeEventListener(b[0], b[1], b[2])
                        },
                        start(b=0) {
                            d.start.call(d, b)
                        },
                        stop(b=0) {
                            d.stop.call(d, b)
                        }
                    }
                      , _ = () => d.connect(p)
                      , x = () => d.disconnect(p);
                    return e(s, d),
                    i(tm(v, p), _, x)
                }
                  , P6 = (e, t) => (n, i) => {
                    const s = n.createConvolver();
                    if (Ts(s, i),
                    i.disableNormalization === s.normalize && (s.normalize = !i.disableNormalization),
                    Si(s, i, "buffer"),
                    i.channelCount > 2 || (t(s, "channelCount", r => () => r.call(s), r => l => {
                        if (l > 2)
                            throw e();
                        return r.call(s, l)
                    }
                    ),
                    i.channelCountMode === "max"))
                        throw e();
                    return t(s, "channelCountMode", r => () => r.call(s), r => l => {
                        if (l === "max")
                            throw e();
                        return r.call(s, l)
                    }
                    ),
                    s
                }
                  , l2 = (e, t) => {
                    const n = e.createDelay(t.maxDelayTime);
                    return Ts(n, t),
                    Vi(n, t, "delayTime"),
                    n
                }
                  , I6 = e => (t, n) => {
                    const i = t.createDynamicsCompressor();
                    if (Ts(i, n),
                    n.channelCount > 2 || n.channelCountMode === "max")
                        throw e();
                    return Vi(i, n, "attack"),
                    Vi(i, n, "knee"),
                    Vi(i, n, "ratio"),
                    Vi(i, n, "release"),
                    Vi(i, n, "threshold"),
                    i
                }
                  , lr = (e, t) => {
                    const n = e.createGain();
                    return Ts(n, t),
                    Vi(n, t, "gain"),
                    n
                }
                  , L6 = e => (t, n, i) => {
                    if (t.createIIRFilter === void 0)
                        return e(t, n, i);
                    const s = t.createIIRFilter(i.feedforward, i.feedback);
                    return Ts(s, i),
                    s
                }
                ;
                function z6(e, t) {
                    const n = t[0] * t[0] + t[1] * t[1];
                    return [(e[0] * t[0] + e[1] * t[1]) / n, (e[1] * t[0] - e[0] * t[1]) / n]
                }
                function F6(e, t) {
                    return [e[0] * t[0] - e[1] * t[1], e[0] * t[1] + e[1] * t[0]]
                }
                function c2(e, t) {
                    let n = [0, 0];
                    for (let i = e.length - 1; i >= 0; i -= 1)
                        n = F6(n, t),
                        n[0] += e[i];
                    return n
                }
                const H6 = (e, t, n, i) => (s, r, {channelCount: l, channelCountMode: h, channelInterpretation: d, feedback: p, feedforward: m}) => {
                    const v = r2(r, s.sampleRate)
                      , _ = p instanceof Float64Array ? p : new Float64Array(p)
                      , x = m instanceof Float64Array ? m : new Float64Array(m)
                      , b = _.length
                      , E = x.length
                      , T = Math.min(b, E);
                    if (b === 0 || b > 20)
                        throw i();
                    if (_[0] === 0)
                        throw t();
                    if (E === 0 || E > 20)
                        throw i();
                    if (x[0] === 0)
                        throw t();
                    if (_[0] !== 1) {
                        for (let I = 0; I < E; I += 1)
                            x[I] /= _[0];
                        for (let I = 1; I < b; I += 1)
                            _[I] /= _[0]
                    }
                    const M = n(s, v, l, l);
                    M.channelCount = l,
                    M.channelCountMode = h,
                    M.channelInterpretation = d;
                    const D = 32
                      , R = []
                      , O = []
                      , U = [];
                    for (let I = 0; I < l; I += 1) {
                        R.push(0);
                        const F = new Float32Array(D)
                          , P = new Float32Array(D);
                        F.fill(0),
                        P.fill(0),
                        O.push(F),
                        U.push(P)
                    }
                    M.onaudioprocess = I => {
                        const F = I.inputBuffer
                          , P = I.outputBuffer
                          , L = F.numberOfChannels;
                        for (let H = 0; H < L; H += 1) {
                            const Z = F.getChannelData(H)
                              , K = P.getChannelData(H);
                            R[H] = s2(_, b, x, E, T, O[H], U[H], R[H], D, Z, K)
                        }
                    }
                    ;
                    const B = s.sampleRate / 2;
                    return tm({
                        get bufferSize() {
                            return v
                        },
                        get channelCount() {
                            return M.channelCount
                        },
                        set channelCount(I) {
                            M.channelCount = I
                        },
                        get channelCountMode() {
                            return M.channelCountMode
                        },
                        set channelCountMode(I) {
                            M.channelCountMode = I
                        },
                        get channelInterpretation() {
                            return M.channelInterpretation
                        },
                        set channelInterpretation(I) {
                            M.channelInterpretation = I
                        },
                        get context() {
                            return M.context
                        },
                        get inputs() {
                            return [M]
                        },
                        get numberOfInputs() {
                            return M.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return M.numberOfOutputs
                        },
                        addEventListener(...I) {
                            return M.addEventListener(I[0], I[1], I[2])
                        },
                        dispatchEvent(...I) {
                            return M.dispatchEvent(I[0])
                        },
                        getFrequencyResponse(I, F, P) {
                            if (I.length !== F.length || F.length !== P.length)
                                throw e();
                            const L = I.length;
                            for (let H = 0; H < L; H += 1) {
                                const Z = -Math.PI * (I[H] / B)
                                  , K = [Math.cos(Z), Math.sin(Z)]
                                  , te = c2(x, K)
                                  , ce = c2(_, K)
                                  , G = z6(te, ce);
                                F[H] = Math.sqrt(G[0] * G[0] + G[1] * G[1]),
                                P[H] = Math.atan2(G[1], G[0])
                            }
                        },
                        removeEventListener(...I) {
                            return M.removeEventListener(I[0], I[1], I[2])
                        }
                    }, M)
                }
                  , V6 = (e, t) => e.createMediaElementSource(t.mediaElement)
                  , G6 = (e, t) => {
                    const n = e.createMediaStreamDestination();
                    return Ts(n, t),
                    n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", {
                        get: () => 0
                    }),
                    n
                }
                  , k6 = (e, {mediaStream: t}) => {
                    const n = t.getAudioTracks();
                    n.sort( (r, l) => r.id < l.id ? -1 : r.id > l.id ? 1 : 0);
                    const i = n.slice(0, 1)
                      , s = e.createMediaStreamSource(new MediaStream(i));
                    return Object.defineProperty(s, "mediaStream", {
                        value: t
                    }),
                    s
                }
                  , X6 = (e, t) => (n, {mediaStreamTrack: i}) => {
                    if (typeof n.createMediaStreamTrackSource == "function")
                        return n.createMediaStreamTrackSource(i);
                    const s = new MediaStream([i])
                      , r = n.createMediaStreamSource(s);
                    if (i.kind !== "audio")
                        throw e();
                    if (t(n))
                        throw new TypeError;
                    return r
                }
                  , q6 = e => e === null ? null : e.hasOwnProperty("OfflineAudioContext") ? e.OfflineAudioContext : e.hasOwnProperty("webkitOfflineAudioContext") ? e.webkitOfflineAudioContext : null
                  , Y6 = (e, t, n, i, s, r) => (l, h) => {
                    const d = l.createOscillator();
                    return Ts(d, h),
                    Vi(d, h, "detune"),
                    Vi(d, h, "frequency"),
                    h.periodicWave !== void 0 ? d.setPeriodicWave(h.periodicWave) : Si(d, h, "type"),
                    t(n, () => n(l)) || kM(d),
                    t(i, () => i(l)) || r(d, l),
                    t(s, () => s(l)) || XM(d),
                    e(l, d),
                    d
                }
                  , W6 = e => (t, n) => {
                    const i = t.createPanner();
                    return i.orientationX === void 0 ? e(t, n) : (Ts(i, n),
                    Vi(i, n, "orientationX"),
                    Vi(i, n, "orientationY"),
                    Vi(i, n, "orientationZ"),
                    Vi(i, n, "positionX"),
                    Vi(i, n, "positionY"),
                    Vi(i, n, "positionZ"),
                    Si(i, n, "coneInnerAngle"),
                    Si(i, n, "coneOuterAngle"),
                    Si(i, n, "coneOuterGain"),
                    Si(i, n, "distanceModel"),
                    Si(i, n, "maxDistance"),
                    Si(i, n, "panningModel"),
                    Si(i, n, "refDistance"),
                    Si(i, n, "rolloffFactor"),
                    i)
                }
                  , j6 = (e, t, n, i, s, r, l, h, d, p) => (m, {coneInnerAngle: v, coneOuterAngle: _, coneOuterGain: x, distanceModel: b, maxDistance: E, orientationX: T, orientationY: M, orientationZ: D, panningModel: R, positionX: O, positionY: U, positionZ: B, refDistance: I, rolloffFactor: F, ...P}) => {
                    const L = m.createPanner();
                    if (P.channelCount > 2 || P.channelCountMode === "max")
                        throw l();
                    Ts(L, P);
                    const H = {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete"
                    }
                      , Z = n(m, {
                        ...H,
                        channelInterpretation: "speakers",
                        numberOfInputs: 6
                    })
                      , K = i(m, {
                        ...P,
                        gain: 1
                    })
                      , te = i(m, {
                        ...H,
                        gain: 1
                    })
                      , ce = i(m, {
                        ...H,
                        gain: 0
                    })
                      , G = i(m, {
                        ...H,
                        gain: 0
                    })
                      , V = i(m, {
                        ...H,
                        gain: 0
                    })
                      , q = i(m, {
                        ...H,
                        gain: 0
                    })
                      , ee = i(m, {
                        ...H,
                        gain: 0
                    })
                      , se = s(m, 256, 6, 1)
                      , X = r(m, {
                        ...H,
                        curve: new Float32Array([1, 1]),
                        oversample: "none"
                    });
                    let J = [T, M, D]
                      , ze = [O, U, B];
                    const xe = new Float32Array(1);
                    se.onaudioprocess = ({inputBuffer: Ue}) => {
                        const $e = [d(Ue, xe, 0), d(Ue, xe, 1), d(Ue, xe, 2)];
                        $e.some( (Et, ne) => Et !== J[ne]) && (L.setOrientation(...$e),
                        J = $e);
                        const rt = [d(Ue, xe, 3), d(Ue, xe, 4), d(Ue, xe, 5)];
                        rt.some( (Et, ne) => Et !== ze[ne]) && (L.setPosition(...rt),
                        ze = rt)
                    }
                    ,
                    Object.defineProperty(ce.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(G.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(V.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(q.gain, "defaultValue", {
                        get: () => 0
                    }),
                    Object.defineProperty(ee.gain, "defaultValue", {
                        get: () => 0
                    });
                    const le = {
                        get bufferSize() {},
                        get channelCount() {
                            return L.channelCount
                        },
                        set channelCount(Ue) {
                            if (Ue > 2)
                                throw l();
                            K.channelCount = Ue,
                            L.channelCount = Ue
                        },
                        get channelCountMode() {
                            return L.channelCountMode
                        },
                        set channelCountMode(Ue) {
                            if (Ue === "max")
                                throw l();
                            K.channelCountMode = Ue,
                            L.channelCountMode = Ue
                        },
                        get channelInterpretation() {
                            return L.channelInterpretation
                        },
                        set channelInterpretation(Ue) {
                            K.channelInterpretation = Ue,
                            L.channelInterpretation = Ue
                        },
                        get coneInnerAngle() {
                            return L.coneInnerAngle
                        },
                        set coneInnerAngle(Ue) {
                            L.coneInnerAngle = Ue
                        },
                        get coneOuterAngle() {
                            return L.coneOuterAngle
                        },
                        set coneOuterAngle(Ue) {
                            L.coneOuterAngle = Ue
                        },
                        get coneOuterGain() {
                            return L.coneOuterGain
                        },
                        set coneOuterGain(Ue) {
                            if (Ue < 0 || Ue > 1)
                                throw t();
                            L.coneOuterGain = Ue
                        },
                        get context() {
                            return L.context
                        },
                        get distanceModel() {
                            return L.distanceModel
                        },
                        set distanceModel(Ue) {
                            L.distanceModel = Ue
                        },
                        get inputs() {
                            return [K]
                        },
                        get maxDistance() {
                            return L.maxDistance
                        },
                        set maxDistance(Ue) {
                            if (Ue < 0)
                                throw new RangeError;
                            L.maxDistance = Ue
                        },
                        get numberOfInputs() {
                            return L.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return L.numberOfOutputs
                        },
                        get orientationX() {
                            return te.gain
                        },
                        get orientationY() {
                            return ce.gain
                        },
                        get orientationZ() {
                            return G.gain
                        },
                        get panningModel() {
                            return L.panningModel
                        },
                        set panningModel(Ue) {
                            L.panningModel = Ue
                        },
                        get positionX() {
                            return V.gain
                        },
                        get positionY() {
                            return q.gain
                        },
                        get positionZ() {
                            return ee.gain
                        },
                        get refDistance() {
                            return L.refDistance
                        },
                        set refDistance(Ue) {
                            if (Ue < 0)
                                throw new RangeError;
                            L.refDistance = Ue
                        },
                        get rolloffFactor() {
                            return L.rolloffFactor
                        },
                        set rolloffFactor(Ue) {
                            if (Ue < 0)
                                throw new RangeError;
                            L.rolloffFactor = Ue
                        },
                        addEventListener(...Ue) {
                            return K.addEventListener(Ue[0], Ue[1], Ue[2])
                        },
                        dispatchEvent(...Ue) {
                            return K.dispatchEvent(Ue[0])
                        },
                        removeEventListener(...Ue) {
                            return K.removeEventListener(Ue[0], Ue[1], Ue[2])
                        }
                    };
                    v !== le.coneInnerAngle && (le.coneInnerAngle = v),
                    _ !== le.coneOuterAngle && (le.coneOuterAngle = _),
                    x !== le.coneOuterGain && (le.coneOuterGain = x),
                    b !== le.distanceModel && (le.distanceModel = b),
                    E !== le.maxDistance && (le.maxDistance = E),
                    T !== le.orientationX.value && (le.orientationX.value = T),
                    M !== le.orientationY.value && (le.orientationY.value = M),
                    D !== le.orientationZ.value && (le.orientationZ.value = D),
                    R !== le.panningModel && (le.panningModel = R),
                    O !== le.positionX.value && (le.positionX.value = O),
                    U !== le.positionY.value && (le.positionY.value = U),
                    B !== le.positionZ.value && (le.positionZ.value = B),
                    I !== le.refDistance && (le.refDistance = I),
                    F !== le.rolloffFactor && (le.rolloffFactor = F),
                    (J[0] !== 1 || J[1] !== 0 || J[2] !== 0) && L.setOrientation(...J),
                    (ze[0] !== 0 || ze[1] !== 0 || ze[2] !== 0) && L.setPosition(...ze);
                    const Ne = () => {
                        K.connect(L),
                        e(K, X, 0, 0),
                        X.connect(te).connect(Z, 0, 0),
                        X.connect(ce).connect(Z, 0, 1),
                        X.connect(G).connect(Z, 0, 2),
                        X.connect(V).connect(Z, 0, 3),
                        X.connect(q).connect(Z, 0, 4),
                        X.connect(ee).connect(Z, 0, 5),
                        Z.connect(se).connect(m.destination)
                    }
                      , be = () => {
                        K.disconnect(L),
                        h(K, X, 0, 0),
                        X.disconnect(te),
                        te.disconnect(Z),
                        X.disconnect(ce),
                        ce.disconnect(Z),
                        X.disconnect(G),
                        G.disconnect(Z),
                        X.disconnect(V),
                        V.disconnect(Z),
                        X.disconnect(q),
                        q.disconnect(Z),
                        X.disconnect(ee),
                        ee.disconnect(Z),
                        Z.disconnect(se),
                        se.disconnect(m.destination)
                    }
                    ;
                    return p(tm(le, L), Ne, be)
                }
                  , Q6 = e => (t, {disableNormalization: n, imag: i, real: s}) => {
                    const r = i instanceof Float32Array ? i : new Float32Array(i)
                      , l = s instanceof Float32Array ? s : new Float32Array(s)
                      , h = t.createPeriodicWave(l, r, {
                        disableNormalization: n
                    });
                    if (Array.from(i).length < 2)
                        throw e();
                    return h
                }
                  , Qv = (e, t, n, i) => e.createScriptProcessor(t, n, i)
                  , Z6 = (e, t) => (n, i) => {
                    const s = i.channelCountMode;
                    if (s === "clamped-max")
                        throw t();
                    if (n.createStereoPanner === void 0)
                        return e(n, i);
                    const r = n.createStereoPanner();
                    return Ts(r, i),
                    Vi(r, i, "pan"),
                    Object.defineProperty(r, "channelCountMode", {
                        get: () => s,
                        set: l => {
                            if (l !== s)
                                throw t()
                        }
                    }),
                    r
                }
                  , K6 = (e, t, n, i, s, r) => {
                    const h = new Float32Array([1, 1])
                      , d = Math.PI / 2
                      , p = {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete"
                    }
                      , m = {
                        ...p,
                        oversample: "none"
                    }
                      , v = (b, E, T, M) => {
                        const D = new Float32Array(16385)
                          , R = new Float32Array(16385);
                        for (let P = 0; P < 16385; P += 1) {
                            const L = P / 16384 * d;
                            D[P] = Math.cos(L),
                            R[P] = Math.sin(L)
                        }
                        const O = n(b, {
                            ...p,
                            gain: 0
                        })
                          , U = i(b, {
                            ...m,
                            curve: D
                        })
                          , B = i(b, {
                            ...m,
                            curve: h
                        })
                          , I = n(b, {
                            ...p,
                            gain: 0
                        })
                          , F = i(b, {
                            ...m,
                            curve: R
                        });
                        return {
                            connectGraph() {
                                E.connect(O),
                                E.connect(B.inputs === void 0 ? B : B.inputs[0]),
                                E.connect(I),
                                B.connect(T),
                                T.connect(U.inputs === void 0 ? U : U.inputs[0]),
                                T.connect(F.inputs === void 0 ? F : F.inputs[0]),
                                U.connect(O.gain),
                                F.connect(I.gain),
                                O.connect(M, 0, 0),
                                I.connect(M, 0, 1)
                            },
                            disconnectGraph() {
                                E.disconnect(O),
                                E.disconnect(B.inputs === void 0 ? B : B.inputs[0]),
                                E.disconnect(I),
                                B.disconnect(T),
                                T.disconnect(U.inputs === void 0 ? U : U.inputs[0]),
                                T.disconnect(F.inputs === void 0 ? F : F.inputs[0]),
                                U.disconnect(O.gain),
                                F.disconnect(I.gain),
                                O.disconnect(M, 0, 0),
                                I.disconnect(M, 0, 1)
                            }
                        }
                    }
                      , _ = (b, E, T, M) => {
                        const D = new Float32Array(16385)
                          , R = new Float32Array(16385)
                          , O = new Float32Array(16385)
                          , U = new Float32Array(16385)
                          , B = Math.floor(16385 / 2);
                        for (let V = 0; V < 16385; V += 1)
                            if (V > B) {
                                const q = (V - B) / (16384 - B) * d;
                                D[V] = Math.cos(q),
                                R[V] = Math.sin(q),
                                O[V] = 0,
                                U[V] = 1
                            } else {
                                const q = V / (16384 - B) * d;
                                D[V] = 1,
                                R[V] = 0,
                                O[V] = Math.cos(q),
                                U[V] = Math.sin(q)
                            }
                        const I = t(b, {
                            channelCount: 2,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: 2
                        })
                          , F = n(b, {
                            ...p,
                            gain: 0
                        })
                          , P = i(b, {
                            ...m,
                            curve: D
                        })
                          , L = n(b, {
                            ...p,
                            gain: 0
                        })
                          , H = i(b, {
                            ...m,
                            curve: R
                        })
                          , Z = i(b, {
                            ...m,
                            curve: h
                        })
                          , K = n(b, {
                            ...p,
                            gain: 0
                        })
                          , te = i(b, {
                            ...m,
                            curve: O
                        })
                          , ce = n(b, {
                            ...p,
                            gain: 0
                        })
                          , G = i(b, {
                            ...m,
                            curve: U
                        });
                        return {
                            connectGraph() {
                                E.connect(I),
                                E.connect(Z.inputs === void 0 ? Z : Z.inputs[0]),
                                I.connect(F, 0),
                                I.connect(L, 0),
                                I.connect(K, 1),
                                I.connect(ce, 1),
                                Z.connect(T),
                                T.connect(P.inputs === void 0 ? P : P.inputs[0]),
                                T.connect(H.inputs === void 0 ? H : H.inputs[0]),
                                T.connect(te.inputs === void 0 ? te : te.inputs[0]),
                                T.connect(G.inputs === void 0 ? G : G.inputs[0]),
                                P.connect(F.gain),
                                H.connect(L.gain),
                                te.connect(K.gain),
                                G.connect(ce.gain),
                                F.connect(M, 0, 0),
                                K.connect(M, 0, 0),
                                L.connect(M, 0, 1),
                                ce.connect(M, 0, 1)
                            },
                            disconnectGraph() {
                                E.disconnect(I),
                                E.disconnect(Z.inputs === void 0 ? Z : Z.inputs[0]),
                                I.disconnect(F, 0),
                                I.disconnect(L, 0),
                                I.disconnect(K, 1),
                                I.disconnect(ce, 1),
                                Z.disconnect(T),
                                T.disconnect(P.inputs === void 0 ? P : P.inputs[0]),
                                T.disconnect(H.inputs === void 0 ? H : H.inputs[0]),
                                T.disconnect(te.inputs === void 0 ? te : te.inputs[0]),
                                T.disconnect(G.inputs === void 0 ? G : G.inputs[0]),
                                P.disconnect(F.gain),
                                H.disconnect(L.gain),
                                te.disconnect(K.gain),
                                G.disconnect(ce.gain),
                                F.disconnect(M, 0, 0),
                                K.disconnect(M, 0, 0),
                                L.disconnect(M, 0, 1),
                                ce.disconnect(M, 0, 1)
                            }
                        }
                    }
                      , x = (b, E, T, M, D) => {
                        if (E === 1)
                            return v(b, T, M, D);
                        if (E === 2)
                            return _(b, T, M, D);
                        throw s()
                    }
                    ;
                    return (b, {channelCount: E, channelCountMode: T, pan: M, ...D}) => {
                        if (T === "max")
                            throw s();
                        const R = e(b, {
                            ...D,
                            channelCount: 1,
                            channelCountMode: T,
                            numberOfInputs: 2
                        })
                          , O = n(b, {
                            ...D,
                            channelCount: E,
                            channelCountMode: T,
                            gain: 1
                        })
                          , U = n(b, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            gain: M
                        });
                        let {connectGraph: B, disconnectGraph: I} = x(b, E, O, U, R);
                        Object.defineProperty(U.gain, "defaultValue", {
                            get: () => 0
                        }),
                        Object.defineProperty(U.gain, "maxValue", {
                            get: () => 1
                        }),
                        Object.defineProperty(U.gain, "minValue", {
                            get: () => -1
                        });
                        const F = {
                            get bufferSize() {},
                            get channelCount() {
                                return O.channelCount
                            },
                            set channelCount(Z) {
                                O.channelCount !== Z && (P && I(),
                                {connectGraph: B, disconnectGraph: I} = x(b, Z, O, U, R),
                                P && B()),
                                O.channelCount = Z
                            },
                            get channelCountMode() {
                                return O.channelCountMode
                            },
                            set channelCountMode(Z) {
                                if (Z === "clamped-max" || Z === "max")
                                    throw s();
                                O.channelCountMode = Z
                            },
                            get channelInterpretation() {
                                return O.channelInterpretation
                            },
                            set channelInterpretation(Z) {
                                O.channelInterpretation = Z
                            },
                            get context() {
                                return O.context
                            },
                            get inputs() {
                                return [O]
                            },
                            get numberOfInputs() {
                                return O.numberOfInputs
                            },
                            get numberOfOutputs() {
                                return O.numberOfOutputs
                            },
                            get pan() {
                                return U.gain
                            },
                            addEventListener(...Z) {
                                return O.addEventListener(Z[0], Z[1], Z[2])
                            },
                            dispatchEvent(...Z) {
                                return O.dispatchEvent(Z[0])
                            },
                            removeEventListener(...Z) {
                                return O.removeEventListener(Z[0], Z[1], Z[2])
                            }
                        };
                        let P = !1;
                        const L = () => {
                            B(),
                            P = !0
                        }
                          , H = () => {
                            I(),
                            P = !1
                        }
                        ;
                        return r(tm(F, R), L, H)
                    }
                }
                  , J6 = (e, t, n, i, s, r, l) => (h, d) => {
                    const p = h.createWaveShaper();
                    if (r !== null && r.name === "webkitAudioContext" && h.createGain().gain.automationRate === void 0)
                        return n(h, d);
                    Ts(p, d);
                    const m = d.curve === null || d.curve instanceof Float32Array ? d.curve : new Float32Array(d.curve);
                    if (m !== null && m.length < 2)
                        throw t();
                    Si(p, {
                        curve: m
                    }, "curve"),
                    Si(p, d, "oversample");
                    let v = null
                      , _ = !1;
                    return l(p, "curve", E => () => E.call(p), E => T => (E.call(p, T),
                    _ && (i(T) && v === null ? v = e(h, p) : !i(T) && v !== null && (v(),
                    v = null)),
                    T)),
                    s(p, () => {
                        _ = !0,
                        i(p.curve) && (v = e(h, p))
                    }
                    , () => {
                        _ = !1,
                        v !== null && (v(),
                        v = null)
                    }
                    )
                }
                  , $6 = (e, t, n, i, s) => (r, {curve: l, oversample: h, ...d}) => {
                    const p = r.createWaveShaper()
                      , m = r.createWaveShaper();
                    Ts(p, d),
                    Ts(m, d);
                    const v = n(r, {
                        ...d,
                        gain: 1
                    })
                      , _ = n(r, {
                        ...d,
                        gain: -1
                    })
                      , x = n(r, {
                        ...d,
                        gain: 1
                    })
                      , b = n(r, {
                        ...d,
                        gain: -1
                    });
                    let E = null
                      , T = !1
                      , M = null;
                    const D = {
                        get bufferSize() {},
                        get channelCount() {
                            return p.channelCount
                        },
                        set channelCount(U) {
                            v.channelCount = U,
                            _.channelCount = U,
                            p.channelCount = U,
                            x.channelCount = U,
                            m.channelCount = U,
                            b.channelCount = U
                        },
                        get channelCountMode() {
                            return p.channelCountMode
                        },
                        set channelCountMode(U) {
                            v.channelCountMode = U,
                            _.channelCountMode = U,
                            p.channelCountMode = U,
                            x.channelCountMode = U,
                            m.channelCountMode = U,
                            b.channelCountMode = U
                        },
                        get channelInterpretation() {
                            return p.channelInterpretation
                        },
                        set channelInterpretation(U) {
                            v.channelInterpretation = U,
                            _.channelInterpretation = U,
                            p.channelInterpretation = U,
                            x.channelInterpretation = U,
                            m.channelInterpretation = U,
                            b.channelInterpretation = U
                        },
                        get context() {
                            return p.context
                        },
                        get curve() {
                            return M
                        },
                        set curve(U) {
                            if (U !== null && U.length < 2)
                                throw t();
                            if (U === null)
                                p.curve = U,
                                m.curve = U;
                            else {
                                const B = U.length
                                  , I = new Float32Array(B + 2 - B % 2)
                                  , F = new Float32Array(B + 2 - B % 2);
                                I[0] = U[0],
                                F[0] = -U[B - 1];
                                const P = Math.ceil((B + 1) / 2)
                                  , L = (B + 1) / 2 - 1;
                                for (let H = 1; H < P; H += 1) {
                                    const Z = H / P * L
                                      , K = Math.floor(Z)
                                      , te = Math.ceil(Z);
                                    I[H] = K === te ? U[K] : (1 - (Z - K)) * U[K] + (1 - (te - Z)) * U[te],
                                    F[H] = K === te ? -U[B - 1 - K] : -((1 - (Z - K)) * U[B - 1 - K]) - (1 - (te - Z)) * U[B - 1 - te]
                                }
                                I[P] = B % 2 === 1 ? U[P - 1] : (U[P - 2] + U[P - 1]) / 2,
                                p.curve = I,
                                m.curve = F
                            }
                            M = U,
                            T && (i(M) && E === null ? E = e(r, v) : E !== null && (E(),
                            E = null))
                        },
                        get inputs() {
                            return [v]
                        },
                        get numberOfInputs() {
                            return p.numberOfInputs
                        },
                        get numberOfOutputs() {
                            return p.numberOfOutputs
                        },
                        get oversample() {
                            return p.oversample
                        },
                        set oversample(U) {
                            p.oversample = U,
                            m.oversample = U
                        },
                        addEventListener(...U) {
                            return v.addEventListener(U[0], U[1], U[2])
                        },
                        dispatchEvent(...U) {
                            return v.dispatchEvent(U[0])
                        },
                        removeEventListener(...U) {
                            return v.removeEventListener(U[0], U[1], U[2])
                        }
                    };
                    l !== null && (D.curve = l instanceof Float32Array ? l : new Float32Array(l)),
                    h !== D.oversample && (D.oversample = h);
                    const R = () => {
                        v.connect(p).connect(x),
                        v.connect(_).connect(m).connect(b).connect(x),
                        T = !0,
                        i(M) && (E = e(r, v))
                    }
                      , O = () => {
                        v.disconnect(p),
                        p.disconnect(x),
                        v.disconnect(_),
                        _.disconnect(m),
                        m.disconnect(b),
                        b.disconnect(x),
                        T = !1,
                        E !== null && (E(),
                        E = null)
                    }
                    ;
                    return s(tm(D, x), R, O)
                }
                  , ua = () => new DOMException("","NotSupportedError")
                  , ek = {
                    numberOfChannels: 1
                }
                  , tk = (e, t, n, i, s) => class extends e {
                    constructor(l, h, d) {
                        let p;
                        if (typeof l == "number" && h !== void 0 && d !== void 0)
                            p = {
                                length: h,
                                numberOfChannels: l,
                                sampleRate: d
                            };
                        else if (typeof l == "object")
                            p = l;
                        else
                            throw new Error("The given parameters are not valid.");
                        const {length: m, numberOfChannels: v, sampleRate: _} = {
                            ...ek,
                            ...p
                        }
                          , x = i(v, m, _);
                        t(Hf, () => Hf(x)) || x.addEventListener("statechange", ( () => {
                            let b = 0;
                            const E = T => {
                                this._state === "running" && (b > 0 ? (x.removeEventListener("statechange", E),
                                T.stopImmediatePropagation(),
                                this._waitForThePromiseToSettle(T)) : b += 1)
                            }
                            ;
                            return E
                        }
                        )()),
                        super(x, v),
                        this._length = m,
                        this._nativeOfflineAudioContext = x,
                        this._state = null
                    }
                    get length() {
                        return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
                    }
                    get state() {
                        return this._state === null ? this._nativeOfflineAudioContext.state : this._state
                    }
                    startRendering() {
                        return this._state === "running" ? Promise.reject(n()) : (this._state = "running",
                        s(this.destination, this._nativeOfflineAudioContext).finally( () => {
                            this._state = null,
                            qx(this)
                        }
                        ))
                    }
                    _waitForThePromiseToSettle(l) {
                        this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(l) : setTimeout( () => this._waitForThePromiseToSettle(l))
                    }
                }
                  , nk = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    detune: 0,
                    frequency: 440,
                    periodicWave: void 0,
                    type: "sine"
                }
                  , ik = (e, t, n, i, s, r, l) => class extends e {
                    constructor(d, p) {
                        const m = s(d)
                          , v = {
                            ...nk,
                            ...p
                        }
                          , _ = n(m, v)
                          , x = r(m)
                          , b = x ? i() : null
                          , E = d.sampleRate / 2;
                        super(d, !1, _, b),
                        this._detune = t(this, x, _.detune, 153600, -153600),
                        this._frequency = t(this, x, _.frequency, E, -E),
                        this._nativeOscillatorNode = _,
                        this._onended = null,
                        this._oscillatorNodeRenderer = b,
                        this._oscillatorNodeRenderer !== null && v.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = v.periodicWave)
                    }
                    get detune() {
                        return this._detune
                    }
                    get frequency() {
                        return this._frequency
                    }
                    get onended() {
                        return this._onended
                    }
                    set onended(d) {
                        const p = typeof d == "function" ? l(this, d) : null;
                        this._nativeOscillatorNode.onended = p;
                        const m = this._nativeOscillatorNode.onended;
                        this._onended = m !== null && m === p ? d : m
                    }
                    get type() {
                        return this._nativeOscillatorNode.type
                    }
                    set type(d) {
                        this._nativeOscillatorNode.type = d,
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null)
                    }
                    setPeriodicWave(d) {
                        this._nativeOscillatorNode.setPeriodicWave(d),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = d)
                    }
                    start(d=0) {
                        if (this._nativeOscillatorNode.start(d),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = d),
                        this.context.state !== "closed") {
                            $p(this);
                            const p = () => {
                                this._nativeOscillatorNode.removeEventListener("ended", p),
                                Bc(this) && Xv(this)
                            }
                            ;
                            this._nativeOscillatorNode.addEventListener("ended", p)
                        }
                    }
                    stop(d=0) {
                        this._nativeOscillatorNode.stop(d),
                        this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = d)
                    }
                }
                  , sk = (e, t, n, i, s) => () => {
                    const r = new WeakMap;
                    let l = null
                      , h = null
                      , d = null;
                    const p = async (m, v) => {
                        let _ = n(m);
                        const x = ca(_, v);
                        if (!x) {
                            const b = {
                                channelCount: _.channelCount,
                                channelCountMode: _.channelCountMode,
                                channelInterpretation: _.channelInterpretation,
                                detune: _.detune.value,
                                frequency: _.frequency.value,
                                periodicWave: l === null ? void 0 : l,
                                type: _.type
                            };
                            _ = t(v, b),
                            h !== null && _.start(h),
                            d !== null && _.stop(d)
                        }
                        return r.set(v, _),
                        x ? (await e(v, m.detune, _.detune),
                        await e(v, m.frequency, _.frequency)) : (await i(v, m.detune, _.detune),
                        await i(v, m.frequency, _.frequency)),
                        await s(m, v, _),
                        _
                    }
                    ;
                    return {
                        set periodicWave(m) {
                            l = m
                        },
                        set start(m) {
                            h = m
                        },
                        set stop(m) {
                            d = m
                        },
                        render(m, v) {
                            const _ = r.get(v);
                            return _ !== void 0 ? Promise.resolve(_) : p(m, v)
                        }
                    }
                }
                  , ak = {
                    channelCount: 2,
                    channelCountMode: "clamped-max",
                    channelInterpretation: "speakers",
                    coneInnerAngle: 360,
                    coneOuterAngle: 360,
                    coneOuterGain: 0,
                    distanceModel: "inverse",
                    maxDistance: 1e4,
                    orientationX: 1,
                    orientationY: 0,
                    orientationZ: 0,
                    panningModel: "equalpower",
                    positionX: 0,
                    positionY: 0,
                    positionZ: 0,
                    refDistance: 1,
                    rolloffFactor: 1
                }
                  , rk = (e, t, n, i, s, r, l) => class extends e {
                    constructor(d, p) {
                        const m = s(d)
                          , v = {
                            ...ak,
                            ...p
                        }
                          , _ = n(m, v)
                          , x = r(m)
                          , b = x ? i() : null;
                        super(d, !1, _, b),
                        this._nativePannerNode = _,
                        this._orientationX = t(this, x, _.orientationX, Fa, or),
                        this._orientationY = t(this, x, _.orientationY, Fa, or),
                        this._orientationZ = t(this, x, _.orientationZ, Fa, or),
                        this._positionX = t(this, x, _.positionX, Fa, or),
                        this._positionY = t(this, x, _.positionY, Fa, or),
                        this._positionZ = t(this, x, _.positionZ, Fa, or),
                        l(this, 1)
                    }
                    get coneInnerAngle() {
                        return this._nativePannerNode.coneInnerAngle
                    }
                    set coneInnerAngle(d) {
                        this._nativePannerNode.coneInnerAngle = d
                    }
                    get coneOuterAngle() {
                        return this._nativePannerNode.coneOuterAngle
                    }
                    set coneOuterAngle(d) {
                        this._nativePannerNode.coneOuterAngle = d
                    }
                    get coneOuterGain() {
                        return this._nativePannerNode.coneOuterGain
                    }
                    set coneOuterGain(d) {
                        this._nativePannerNode.coneOuterGain = d
                    }
                    get distanceModel() {
                        return this._nativePannerNode.distanceModel
                    }
                    set distanceModel(d) {
                        this._nativePannerNode.distanceModel = d
                    }
                    get maxDistance() {
                        return this._nativePannerNode.maxDistance
                    }
                    set maxDistance(d) {
                        this._nativePannerNode.maxDistance = d
                    }
                    get orientationX() {
                        return this._orientationX
                    }
                    get orientationY() {
                        return this._orientationY
                    }
                    get orientationZ() {
                        return this._orientationZ
                    }
                    get panningModel() {
                        return this._nativePannerNode.panningModel
                    }
                    set panningModel(d) {
                        this._nativePannerNode.panningModel = d
                    }
                    get positionX() {
                        return this._positionX
                    }
                    get positionY() {
                        return this._positionY
                    }
                    get positionZ() {
                        return this._positionZ
                    }
                    get refDistance() {
                        return this._nativePannerNode.refDistance
                    }
                    set refDistance(d) {
                        this._nativePannerNode.refDistance = d
                    }
                    get rolloffFactor() {
                        return this._nativePannerNode.rolloffFactor
                    }
                    set rolloffFactor(d) {
                        this._nativePannerNode.rolloffFactor = d
                    }
                }
                  , ok = (e, t, n, i, s, r, l, h, d, p) => () => {
                    const m = new WeakMap;
                    let v = null;
                    const _ = async (x, b) => {
                        let E = null
                          , T = r(x);
                        const M = {
                            channelCount: T.channelCount,
                            channelCountMode: T.channelCountMode,
                            channelInterpretation: T.channelInterpretation
                        }
                          , D = {
                            ...M,
                            coneInnerAngle: T.coneInnerAngle,
                            coneOuterAngle: T.coneOuterAngle,
                            coneOuterGain: T.coneOuterGain,
                            distanceModel: T.distanceModel,
                            maxDistance: T.maxDistance,
                            panningModel: T.panningModel,
                            refDistance: T.refDistance,
                            rolloffFactor: T.rolloffFactor
                        }
                          , R = ca(T, b);
                        if ("bufferSize"in T)
                            E = i(b, {
                                ...M,
                                gain: 1
                            });
                        else if (!R) {
                            const O = {
                                ...D,
                                orientationX: T.orientationX.value,
                                orientationY: T.orientationY.value,
                                orientationZ: T.orientationZ.value,
                                positionX: T.positionX.value,
                                positionY: T.positionY.value,
                                positionZ: T.positionZ.value
                            };
                            T = s(b, O)
                        }
                        if (m.set(b, E === null ? T : E),
                        E !== null) {
                            if (v === null) {
                                if (l === null)
                                    throw new Error("Missing the native OfflineAudioContext constructor.");
                                const H = new l(6,x.context.length,b.sampleRate)
                                  , Z = t(H, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: 6
                                });
                                Z.connect(H.destination),
                                v = (async () => {
                                    const K = await Promise.all([x.orientationX, x.orientationY, x.orientationZ, x.positionX, x.positionY, x.positionZ].map(async (te, ce) => {
                                        const G = n(H, {
                                            channelCount: 1,
                                            channelCountMode: "explicit",
                                            channelInterpretation: "discrete",
                                            offset: ce === 0 ? 1 : 0
                                        });
                                        return await h(H, te, G.offset),
                                        G
                                    }
                                    ));
                                    for (let te = 0; te < 6; te += 1)
                                        K[te].connect(Z, 0, te),
                                        K[te].start(0);
                                    return p(H)
                                }
                                )()
                            }
                            const O = await v
                              , U = i(b, {
                                ...M,
                                gain: 1
                            });
                            await d(x, b, U);
                            const B = [];
                            for (let H = 0; H < O.numberOfChannels; H += 1)
                                B.push(O.getChannelData(H));
                            let I = [B[0][0], B[1][0], B[2][0]]
                              , F = [B[3][0], B[4][0], B[5][0]]
                              , P = i(b, {
                                ...M,
                                gain: 1
                            })
                              , L = s(b, {
                                ...D,
                                orientationX: I[0],
                                orientationY: I[1],
                                orientationZ: I[2],
                                positionX: F[0],
                                positionY: F[1],
                                positionZ: F[2]
                            });
                            U.connect(P).connect(L.inputs[0]),
                            L.connect(E);
                            for (let H = 128; H < O.length; H += 128) {
                                const Z = [B[0][H], B[1][H], B[2][H]]
                                  , K = [B[3][H], B[4][H], B[5][H]];
                                if (Z.some( (te, ce) => te !== I[ce]) || K.some( (te, ce) => te !== F[ce])) {
                                    I = Z,
                                    F = K;
                                    const te = H / b.sampleRate;
                                    P.gain.setValueAtTime(0, te),
                                    P = i(b, {
                                        ...M,
                                        gain: 0
                                    }),
                                    L = s(b, {
                                        ...D,
                                        orientationX: I[0],
                                        orientationY: I[1],
                                        orientationZ: I[2],
                                        positionX: F[0],
                                        positionY: F[1],
                                        positionZ: F[2]
                                    }),
                                    P.gain.setValueAtTime(1, te),
                                    U.connect(P).connect(L.inputs[0]),
                                    L.connect(E)
                                }
                            }
                            return E
                        }
                        return R ? (await e(b, x.orientationX, T.orientationX),
                        await e(b, x.orientationY, T.orientationY),
                        await e(b, x.orientationZ, T.orientationZ),
                        await e(b, x.positionX, T.positionX),
                        await e(b, x.positionY, T.positionY),
                        await e(b, x.positionZ, T.positionZ)) : (await h(b, x.orientationX, T.orientationX),
                        await h(b, x.orientationY, T.orientationY),
                        await h(b, x.orientationZ, T.orientationZ),
                        await h(b, x.positionX, T.positionX),
                        await h(b, x.positionY, T.positionY),
                        await h(b, x.positionZ, T.positionZ)),
                        em(T) ? await d(x, b, T.inputs[0]) : await d(x, b, T),
                        T
                    }
                    ;
                    return {
                        render(x, b) {
                            const E = m.get(b);
                            return E !== void 0 ? Promise.resolve(E) : _(x, b)
                        }
                    }
                }
                  , lk = {
                    disableNormalization: !1
                }
                  , ck = (e, t, n, i) => class tN {
                    constructor(r, l) {
                        const h = t(r)
                          , d = i({
                            ...lk,
                            ...l
                        })
                          , p = e(h, d);
                        return n.add(p),
                        p
                    }
                    static[Symbol.hasInstance](r) {
                        return r !== null && typeof r == "object" && Object.getPrototypeOf(r) === tN.prototype || n.has(r)
                    }
                }
                  , uk = (e, t) => (n, i, s) => (e(i).replay(s),
                t(i, n, s))
                  , hk = (e, t, n) => async (i, s, r) => {
                    const l = e(i);
                    await Promise.all(l.activeInputs.map( (h, d) => Array.from(h).map(async ([p,m]) => {
                        const v = await t(p).render(p, s)
                          , _ = i.context.destination;
                        !n(p) && (i !== _ || !n(i)) && v.connect(r, m, d)
                    }
                    )).reduce( (h, d) => [...h, ...d], []))
                }
                  , fk = (e, t, n) => async (i, s, r) => {
                    const l = t(i);
                    await Promise.all(Array.from(l.activeInputs).map(async ([h,d]) => {
                        const p = await e(h).render(h, s);
                        n(h) || p.connect(r, d)
                    }
                    ))
                }
                  , dk = (e, t, n, i) => s => e(Hf, () => Hf(s)) ? Promise.resolve(e(i, i)).then(r => {
                    if (!r) {
                        const l = n(s, 512, 0, 1);
                        s.oncomplete = () => {
                            l.onaudioprocess = null,
                            l.disconnect()
                        }
                        ,
                        l.onaudioprocess = () => s.currentTime,
                        l.connect(s.destination)
                    }
                    return s.startRendering()
                }
                ) : new Promise(r => {
                    const l = t(s, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    s.oncomplete = h => {
                        l.disconnect(),
                        r(h.renderedBuffer)
                    }
                    ,
                    l.connect(s.destination),
                    s.startRendering()
                }
                )
                  , pk = e => (t, n) => {
                    e.set(t, n)
                }
                  , mk = e => (t, n) => e.set(t, n)
                  , gk = (e, t, n, i, s, r, l, h) => (d, p) => n(d).render(d, p).then( () => Promise.all(Array.from(i(p)).map(m => n(m).render(m, p)))).then( () => s(p)).then(m => (typeof m.copyFromChannel != "function" ? (l(m),
                zM(m)) : t(r, () => r(m)) || h(m),
                e.add(m),
                m))
                  , vk = {
                    channelCount: 2,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    pan: 0
                }
                  , yk = (e, t, n, i, s, r) => class extends e {
                    constructor(h, d) {
                        const p = s(h)
                          , m = {
                            ...vk,
                            ...d
                        }
                          , v = n(p, m)
                          , _ = r(p)
                          , x = _ ? i() : null;
                        super(h, !1, v, x),
                        this._pan = t(this, _, v.pan)
                    }
                    get pan() {
                        return this._pan
                    }
                }
                  , _k = (e, t, n, i, s) => () => {
                    const r = new WeakMap
                      , l = async (h, d) => {
                        let p = n(h);
                        const m = ca(p, d);
                        if (!m) {
                            const v = {
                                channelCount: p.channelCount,
                                channelCountMode: p.channelCountMode,
                                channelInterpretation: p.channelInterpretation,
                                pan: p.pan.value
                            };
                            p = t(d, v)
                        }
                        return r.set(d, p),
                        m ? await e(d, h.pan, p.pan) : await i(d, h.pan, p.pan),
                        em(p) ? await s(h, d, p.inputs[0]) : await s(h, d, p),
                        p
                    }
                    ;
                    return {
                        render(h, d) {
                            const p = r.get(d);
                            return p !== void 0 ? Promise.resolve(p) : l(h, d)
                        }
                    }
                }
                  , xk = e => () => {
                    if (e === null)
                        return !1;
                    try {
                        new e({
                            length: 1,
                            sampleRate: 44100
                        })
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , Sk = (e, t) => async () => {
                    if (e === null)
                        return !0;
                    if (t === null)
                        return !1;
                    const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{
                        type: "application/javascript; charset=utf-8"
                    })
                      , i = new t(1,128,44100)
                      , s = URL.createObjectURL(n);
                    let r = !1
                      , l = !1;
                    try {
                        await i.audioWorklet.addModule(s);
                        const h = new e(i,"a",{
                            numberOfOutputs: 0
                        })
                          , d = i.createOscillator();
                        h.port.onmessage = () => r = !0,
                        h.onprocessorerror = () => l = !0,
                        d.connect(h),
                        d.start(0),
                        await i.startRendering(),
                        await new Promise(p => setTimeout(p))
                    } catch {} finally {
                        URL.revokeObjectURL(s)
                    }
                    return r && !l
                }
                  , Ak = (e, t) => () => {
                    if (t === null)
                        return Promise.resolve(!1);
                    const n = new t(1,1,44100)
                      , i = e(n, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    return new Promise(s => {
                        n.oncomplete = () => {
                            i.disconnect(),
                            s(n.currentTime !== 0)
                        }
                        ,
                        n.startRendering()
                    }
                    )
                }
                  , u2 = () => new DOMException("","UnknownError")
                  , Tk = {
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    curve: null,
                    oversample: "none"
                }
                  , Mk = (e, t, n, i, s, r, l) => class extends e {
                    constructor(d, p) {
                        const m = s(d)
                          , v = {
                            ...Tk,
                            ...p
                        }
                          , _ = n(m, v)
                          , x = r(m) ? i() : null;
                        super(d, !0, _, x),
                        this._isCurveNullified = !1,
                        this._nativeWaveShaperNode = _,
                        l(this, 1)
                    }
                    get curve() {
                        return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve
                    }
                    set curve(d) {
                        if (d === null)
                            this._isCurveNullified = !0,
                            this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
                        else {
                            if (d.length < 2)
                                throw t();
                            this._isCurveNullified = !1,
                            this._nativeWaveShaperNode.curve = d
                        }
                    }
                    get oversample() {
                        return this._nativeWaveShaperNode.oversample
                    }
                    set oversample(d) {
                        this._nativeWaveShaperNode.oversample = d
                    }
                }
                  , bk = (e, t, n) => () => {
                    const i = new WeakMap
                      , s = async (r, l) => {
                        let h = t(r);
                        if (!ca(h, l)) {
                            const d = {
                                channelCount: h.channelCount,
                                channelCountMode: h.channelCountMode,
                                channelInterpretation: h.channelInterpretation,
                                curve: h.curve,
                                oversample: h.oversample
                            };
                            h = e(l, d)
                        }
                        return i.set(l, h),
                        em(h) ? await n(r, l, h.inputs[0]) : await n(r, l, h),
                        h
                    }
                    ;
                    return {
                        render(r, l) {
                            const h = i.get(l);
                            return h !== void 0 ? Promise.resolve(h) : s(r, l)
                        }
                    }
                }
                  , Ek = () => typeof window > "u" ? null : window
                  , wk = (e, t) => n => {
                    n.copyFromChannel = (i, s, r=0) => {
                        const l = e(r)
                          , h = e(s);
                        if (h >= n.numberOfChannels)
                            throw t();
                        const d = n.length
                          , p = n.getChannelData(h)
                          , m = i.length;
                        for (let v = l < 0 ? -l : 0; v + l < d && v < m; v += 1)
                            i[v] = p[v + l]
                    }
                    ,
                    n.copyToChannel = (i, s, r=0) => {
                        const l = e(r)
                          , h = e(s);
                        if (h >= n.numberOfChannels)
                            throw t();
                        const d = n.length
                          , p = n.getChannelData(h)
                          , m = i.length;
                        for (let v = l < 0 ? -l : 0; v + l < d && v < m; v += 1)
                            p[v + l] = i[v]
                    }
                }
                  , Ck = e => t => {
                    t.copyFromChannel = (n => (i, s, r=0) => {
                        const l = e(r)
                          , h = e(s);
                        if (l < t.length)
                            return n.call(t, i, h, l)
                    }
                    )(t.copyFromChannel),
                    t.copyToChannel = (n => (i, s, r=0) => {
                        const l = e(r)
                          , h = e(s);
                        if (l < t.length)
                            return n.call(t, i, h, l)
                    }
                    )(t.copyToChannel)
                }
                  , Rk = e => (t, n) => {
                    const i = n.createBuffer(1, 1, 44100);
                    t.buffer === null && (t.buffer = i),
                    e(t, "buffer", s => () => {
                        const r = s.call(t);
                        return r === i ? null : r
                    }
                    , s => r => s.call(t, r === null ? i : r))
                }
                  , Dk = (e, t) => (n, i) => {
                    i.channelCount = 1,
                    i.channelCountMode = "explicit",
                    Object.defineProperty(i, "channelCount", {
                        get: () => 1,
                        set: () => {
                            throw e()
                        }
                    }),
                    Object.defineProperty(i, "channelCountMode", {
                        get: () => "explicit",
                        set: () => {
                            throw e()
                        }
                    });
                    const s = n.createBufferSource();
                    t(i, () => {
                        const h = i.numberOfInputs;
                        for (let d = 0; d < h; d += 1)
                            s.connect(i, 0, d)
                    }
                    , () => s.disconnect(i))
                }
                  , h2 = (e, t, n) => e.copyFromChannel === void 0 ? e.getChannelData(n)[0] : (e.copyFromChannel(t, n),
                t[0])
                  , f2 = e => {
                    if (e === null)
                        return !1;
                    const t = e.length;
                    return t % 2 !== 0 ? e[Math.floor(t / 2)] !== 0 : e[t / 2 - 1] + e[t / 2] !== 0
                }
                  , Zv = (e, t, n, i) => {
                    let s = e;
                    for (; !s.hasOwnProperty(t); )
                        s = Object.getPrototypeOf(s);
                    const {get: r, set: l} = Object.getOwnPropertyDescriptor(s, t);
                    Object.defineProperty(e, t, {
                        get: n(r),
                        set: i(l)
                    })
                }
                  , Ok = e => ({
                    ...e,
                    outputChannelCount: e.outputChannelCount !== void 0 ? e.outputChannelCount : e.numberOfInputs === 1 && e.numberOfOutputs === 1 ? [e.channelCount] : Array.from({
                        length: e.numberOfOutputs
                    }, () => 1)
                })
                  , Nk = e => ({
                    ...e,
                    channelCount: e.numberOfOutputs
                })
                  , Uk = e => {
                    const {imag: t, real: n} = e;
                    return t === void 0 ? n === void 0 ? {
                        ...e,
                        imag: [0, 0],
                        real: [0, 0]
                    } : {
                        ...e,
                        imag: Array.from(n, () => 0),
                        real: n
                    } : n === void 0 ? {
                        ...e,
                        imag: t,
                        real: Array.from(t, () => 0)
                    } : {
                        ...e,
                        imag: t,
                        real: n
                    }
                }
                  , d2 = (e, t, n) => {
                    try {
                        e.setValueAtTime(t, n)
                    } catch (i) {
                        if (i.code !== 9)
                            throw i;
                        d2(e, t, n + 1e-7)
                    }
                }
                  , Bk = e => {
                    const t = e.createBufferSource();
                    t.start();
                    try {
                        t.start()
                    } catch {
                        return !0
                    }
                    return !1
                }
                  , Pk = e => {
                    const t = e.createBufferSource();
                    t.buffer = e.createBuffer(1, 1, 44100);
                    try {
                        t.start(0, 1)
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , Ik = e => {
                    const t = e.createBufferSource();
                    t.start();
                    try {
                        t.stop()
                    } catch {
                        return !1
                    }
                    return !0
                }
                  , qM = e => {
                    const t = e.createOscillator();
                    try {
                        t.start(-1)
                    } catch (n) {
                        return n instanceof RangeError
                    }
                    return !1
                }
                  , p2 = e => {
                    const t = e.createBuffer(1, 1, 44100)
                      , n = e.createBufferSource();
                    n.buffer = t,
                    n.start(),
                    n.stop();
                    try {
                        return n.stop(),
                        !0
                    } catch {
                        return !1
                    }
                }
                  , YM = e => {
                    const t = e.createOscillator();
                    try {
                        t.stop(-1)
                    } catch (n) {
                        return n instanceof RangeError
                    }
                    return !1
                }
                  , Lk = e => {
                    const {port1: t, port2: n} = new MessageChannel;
                    try {
                        t.postMessage(e)
                    } finally {
                        t.close(),
                        n.close()
                    }
                }
                  , zk = e => {
                    e.start = (t => (n=0, i=0, s) => {
                        const r = e.buffer
                          , l = r === null ? i : Math.min(r.duration, i);
                        r !== null && l > r.duration - .5 / e.context.sampleRate ? t.call(e, n, 0, 0) : t.call(e, n, l, s)
                    }
                    )(e.start)
                }
                  , m2 = (e, t) => {
                    const n = t.createGain();
                    e.connect(n);
                    const i = (s => () => {
                        s.call(e, n),
                        e.removeEventListener("ended", i)
                    }
                    )(e.disconnect);
                    e.addEventListener("ended", i),
                    tm(e, n),
                    e.stop = (s => {
                        let r = !1;
                        return (l=0) => {
                            if (r)
                                try {
                                    s.call(e, l)
                                } catch {
                                    n.gain.setValueAtTime(0, l)
                                }
                            else
                                s.call(e, l),
                                r = !0
                        }
                    }
                    )(e.stop)
                }
                  , nm = (e, t) => n => {
                    const i = {
                        value: e
                    };
                    return Object.defineProperties(n, {
                        currentTarget: i,
                        target: i
                    }),
                    typeof t == "function" ? t.call(e, n) : t.handleEvent.call(e, n)
                }
                ;
                var Vf = tr(LD());
                const Fk = sV(zf)
                  , Hk = uV(zf)
                  , Vk = SG(kx)
                  , g2 = new WeakMap
                  , Gk = FG(g2)
                  , oo = KV(new Map, new WeakMap)
                  , kl = Ek()
                  , v2 = y6(oo, Gl)
                  , WM = zG(Ha)
                  , Ws = hk(Ha, WM, Ff)
                  , kk = mV(v2, gi, Ws)
                  , fi = GG(Gx)
                  , Pc = q6(kl)
                  , ni = a6(Pc)
                  , y2 = new WeakMap
                  , _2 = OG(nm)
                  , im = A6(kl)
                  , jM = t6(im)
                  , QM = n6(kl)
                  , x2 = i6(kl)
                  , Kv = M6(kl)
                  , Zi = FV(aV(zD), cV(Fk, Hk, Wx, Vk, jx, Ha, Gk, kv, gi, zf, Bc, Ff, Qx), oo, ZG(BM, jx, Ha, gi, Wv, Bc), Gl, eS, ua, vG(Wx, BM, Ha, gi, Wv, fi, Bc, ni), MG(y2, Ha, jo), _2, fi, jM, QM, x2, ni, Kv)
                  , Xk = pV(Zi, kk, Gl, v2, fi, ni)
                  , ZM = new WeakSet
                  , S2 = _6(kl)
                  , A2 = uG(new Uint32Array(1))
                  , KM = wk(A2, Gl)
                  , JM = Ck(A2)
                  , T2 = vV(ZM, oo, ua, S2, Pc, xk(S2), KM, JM)
                  , tS = hV(lr)
                  , M2 = fk(WM, qv, Ff)
                  , Xl = sG(M2)
                  , sm = S6(tS, oo, Bk, Pk, Ik, qM, p2, YM, zk, Rk(Zv), m2)
                  , ql = uk(HG(qv), M2)
                  , qk = xV(Xl, sm, gi, ql, Ws)
                  , Qo = HV(rV(FD), y2, UM, VV, Vf.createCancelAndHoldAutomationEvent, Vf.createCancelScheduledValuesAutomationEvent, Vf.createExponentialRampToValueAutomationEvent, Vf.createLinearRampToValueAutomationEvent, Vf.createSetTargetAutomationEvent, Vf.createSetValueAutomationEvent, Vf.createSetValueCurveAutomationEvent, im, d2)
                  , Yk = _V(Zi, qk, Qo, rs, sm, fi, ni, nm)
                  , Wk = CV(Zi, RV, Gl, rs, T6(lr, Zv), fi, ni, Ws)
                  , jk = ZV(Xl, o2, gi, ql, Ws)
                  , Gf = mk(g2)
                  , Qk = QV(Zi, Qo, jk, eS, o2, fi, ni, Gf)
                  , Ju = g6(zf, QM)
                  , Zk = Dk(rs, Ju)
                  , $u = O6(im, Zk)
                  , Kk = eG($u, gi, Ws)
                  , Jk = $V(Zi, Kk, $u, fi, ni)
                  , $k = iG(jv, gi, Ws)
                  , e8 = nG(Zi, $k, jv, fi, ni, Nk)
                  , t8 = B6(tS, sm, lr, Ju)
                  , am = U6(tS, oo, t8, qM, YM)
                  , n8 = cG(Xl, am, gi, ql, Ws)
                  , i8 = lG(Zi, Qo, n8, am, fi, ni, nm)
                  , b2 = P6(ua, Zv)
                  , s8 = dG(b2, gi, Ws)
                  , a8 = fG(Zi, s8, b2, fi, ni, Gf)
                  , r8 = xG(Xl, l2, gi, ql, Ws)
                  , o8 = _G(Zi, Qo, r8, l2, fi, ni, Gf)
                  , E2 = I6(ua)
                  , l8 = CG(Xl, E2, gi, ql, Ws)
                  , c8 = wG(Zi, Qo, l8, E2, ua, fi, ni, Gf)
                  , u8 = IG(Xl, lr, gi, ql, Ws)
                  , h8 = PG(Zi, Qo, u8, lr, fi, ni)
                  , f8 = H6(eS, rs, Qv, ua)
                  , nS = dk(oo, lr, Qv, Ak(lr, Pc))
                  , d8 = QG(sm, gi, Pc, Ws, nS)
                  , p8 = L6(f8)
                  , m8 = WG(Zi, p8, d8, fi, ni, Gf)
                  , g8 = DV(Qo, $u, am, Qv, ua, h2, ni, Zv)
                  , w2 = new WeakMap
                  , $M = d6(Wk, g8, _2, ni, w2, nm)
                  , C2 = Y6(tS, oo, qM, p2, YM, m2)
                  , v8 = sk(Xl, C2, gi, ql, Ws)
                  , y8 = ik(Zi, Qo, C2, v8, fi, ni, nm)
                  , R2 = rG(sm)
                  , _8 = $6(R2, rs, lr, f2, Ju)
                  , iS = J6(R2, rs, _8, f2, Ju, im, Zv)
                  , x8 = j6(Wx, rs, $u, lr, Qv, iS, ua, jx, h2, Ju)
                  , D2 = W6(x8)
                  , S8 = ok(Xl, $u, am, lr, D2, gi, Pc, ql, Ws, nS)
                  , A8 = rk(Zi, Qo, D2, S8, fi, ni, Gf)
                  , T8 = Q6(Gl)
                  , M8 = ck(T8, fi, new WeakSet, Uk)
                  , b8 = K6($u, jv, lr, iS, ua, Ju)
                  , O2 = Z6(b8, ua)
                  , E8 = _k(Xl, O2, gi, ql, Ws)
                  , w8 = yk(Zi, Qo, O2, E8, fi, ni)
                  , C8 = bk(iS, gi, Ws)
                  , R8 = Mk(Zi, rs, iS, C8, fi, ni, Gf)
                  , N2 = r6(kl)
                  , eb = NG(kl)
                  , U2 = new WeakMap
                  , D8 = kG(U2, Pc)
                  , O8 = N2 ? lV(oo, ua, DG(kl), eb, UG(iV), fi, D8, ni, Kv, new WeakMap, new WeakMap, Sk(Kv, Pc), kl) : void 0
                  , N8 = s6(jM, ni)
                  , U8 = gG(ZM, oo, mG, RG, new WeakSet, fi, N8, Xx, Hf, KM, JM)
                  , B2 = WV(O8, Xk, T2, Yk, Qk, Jk, e8, i8, a8, U8, o8, c8, h8, m8, $M, y8, A8, M8, w8, R8)
                  , B8 = o6(Zi, V6, fi, ni)
                  , P8 = c6(Zi, G6, fi, ni)
                  , I8 = u6(Zi, k6, fi, ni)
                  , L8 = X6(rs, ni)
                  , z8 = h6(Zi, L8, fi)
                  , F8 = wV(B2, rs, ua, u2, B8, P8, I8, z8, im)
                  , tb = XG(w2)
                  , H8 = fV(tb)
                  , P2 = aG(Gl)
                  , V8 = AG(tb)
                  , I2 = bG(Gl)
                  , L2 = new WeakMap
                  , G8 = LG(L2, jo)
                  , k8 = D6(P2, Gl, rs, $u, jv, am, lr, Qv, ua, I2, eb, G8, Ju)
                  , X8 = E6(rs, k8, lr, ua, Ju)
                  , q8 = YV(Xl, P2, sm, $u, jv, am, lr, V8, I2, eb, gi, Kv, Pc, ql, Ws, nS)
                  , Y8 = VG(U2)
                  , W8 = pk(L2)
                  , z2 = N2 ? kV(H8, Zi, Qo, q8, X8, Ha, Y8, fi, ni, Kv, Ok, W8, Lk, nm) : void 0
                  , PX = f6(rs, ua, u2, $M, im)
                  , F2 = pG(ua, Pc)
                  , H2 = gk(ZM, oo, WM, tb, nS, Xx, KM, JM)
                  , IX = m6(oo, rs, F2, $M, H2)
                  , j8 = tk(B2, oo, rs, F2, H2)
                  , Q8 = KG(Gx, jM)
                  , Z8 = JG(NM, QM)
                  , K8 = $G(UM, x2)
                  , J8 = e6(Gx, ni);
                function Nr(e) {
                    return e === void 0
                }
                function fn(e) {
                    return e !== void 0
                }
                function $8(e) {
                    return typeof e == "function"
                }
                function Yl(e) {
                    return typeof e == "number"
                }
                function eh(e) {
                    return Object.prototype.toString.call(e) === "[object Object]" && e.constructor === Object
                }
                function V2(e) {
                    return typeof e == "boolean"
                }
                function ha(e) {
                    return Array.isArray(e)
                }
                function Wl(e) {
                    return typeof e == "string"
                }
                function sS(e) {
                    return Wl(e) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(e)
                }
                function Wt(e, t) {
                    if (!e)
                        throw new Error(t)
                }
                function lo(e, t, n=1 / 0) {
                    if (!(t <= e && e <= n))
                        throw new RangeError(`Value must be within [${t}, ${n}], got: ${e}`)
                }
                function G2(e) {
                    !e.isOffline && e.state !== "running" && aS('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')
                }
                let k2 = !1
                  , X2 = !1;
                function q2(e) {
                    k2 = e
                }
                function e7(e) {
                    Nr(e) && k2 && !X2 && (X2 = !0,
                    aS("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"))
                }
                let Y2 = console;
                function t7(...e) {
                    Y2.log(...e)
                }
                function aS(...e) {
                    Y2.warn(...e)
                }
                function n7(e) {
                    return new F8(e)
                }
                function i7(e, t, n) {
                    return new j8(e,t,n)
                }
                const Ur = typeof self == "object" ? self : null
                  , s7 = Ur && (Ur.hasOwnProperty("AudioContext") || Ur.hasOwnProperty("webkitAudioContext"));
                function a7(e, t, n) {
                    return Wt(fn(z2), "AudioWorkletNode only works in a secure context (https or localhost)"),
                    new (e instanceof Ur?.BaseAudioContext ? Ur?.AudioWorkletNode : z2)(e,t,n)
                }
                function Zo(e, t, n, i) {
                    var s = arguments.length, r = s < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, n) : i, l;
                    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                        r = Reflect.decorate(e, t, n, i);
                    else
                        for (var h = e.length - 1; h >= 0; h--)
                            (l = e[h]) && (r = (s < 3 ? l(r) : s > 3 ? l(t, n, r) : l(t, n)) || r);
                    return s > 3 && r && Object.defineProperty(t, n, r),
                    r
                }
                function Ki(e, t, n, i) {
                    function s(r) {
                        return r instanceof n ? r : new n(function(l) {
                            l(r)
                        }
                        )
                    }
                    return new (n || (n = Promise))(function(r, l) {
                        function h(m) {
                            try {
                                p(i.next(m))
                            } catch (v) {
                                l(v)
                            }
                        }
                        function d(m) {
                            try {
                                p(i.throw(m))
                            } catch (v) {
                                l(v)
                            }
                        }
                        function p(m) {
                            m.done ? r(m.value) : s(m.value).then(h, d)
                        }
                        p((i = i.apply(e, t || [])).next())
                    }
                    )
                }
                var r7 = class {
                    constructor(e, t, n, i) {
                        this._callback = e,
                        this._type = t,
                        this._minimumUpdateInterval = Math.max(128 / (i || 44100), .001),
                        this.updateInterval = n,
                        this._createClock()
                    }
                    _createWorker() {
                        const e = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`],{
                            type: "text/javascript"
                        })
                          , t = URL.createObjectURL(e)
                          , n = new Worker(t);
                        n.onmessage = this._callback.bind(this),
                        this._worker = n
                    }
                    _createTimeout() {
                        this._timeout = setTimeout( () => {
                            this._createTimeout(),
                            this._callback()
                        }
                        , this._updateInterval * 1e3)
                    }
                    _createClock() {
                        if (this._type === "worker")
                            try {
                                this._createWorker()
                            } catch {
                                this._type = "timeout",
                                this._createClock()
                            }
                        else
                            this._type === "timeout" && this._createTimeout()
                    }
                    _disposeClock() {
                        this._timeout && clearTimeout(this._timeout),
                        this._worker && (this._worker.terminate(),
                        this._worker.onmessage = null)
                    }
                    get updateInterval() {
                        return this._updateInterval
                    }
                    set updateInterval(e) {
                        var t;
                        this._updateInterval = Math.max(e, this._minimumUpdateInterval),
                        this._type === "worker" && ((t = this._worker) === null || t === void 0 || t.postMessage(this._updateInterval * 1e3))
                    }
                    get type() {
                        return this._type
                    }
                    set type(e) {
                        this._disposeClock(),
                        this._type = e,
                        this._createClock()
                    }
                    dispose() {
                        this._disposeClock()
                    }
                }
                ;
                function kf(e) {
                    return K8(e)
                }
                function th(e) {
                    return Z8(e)
                }
                function rS(e) {
                    return J8(e)
                }
                function rm(e) {
                    return Q8(e)
                }
                function o7(e) {
                    return e instanceof T2
                }
                function l7(e, t) {
                    return e === "value" || kf(t) || th(t) || o7(t)
                }
                function Xf(e, ...t) {
                    if (!t.length)
                        return e;
                    const n = t.shift();
                    if (eh(e) && eh(n))
                        for (const i in n)
                            l7(i, n[i]) ? e[i] = n[i] : eh(n[i]) ? (e[i] || Object.assign(e, {
                                [i]: {}
                            }),
                            Xf(e[i], n[i])) : Object.assign(e, {
                                [i]: n[i]
                            });
                    return Xf(e, ...t)
                }
                function c7(e, t) {
                    return e.length === t.length && e.every( (n, i) => t[i] === n)
                }
                function Pt(e, t, n=[], i) {
                    const s = {}
                      , r = Array.from(t);
                    if (eh(r[0]) && i && !Reflect.has(r[0], i) && (Object.keys(r[0]).some(l => Reflect.has(e, l)) || (Xf(s, {
                        [i]: r[0]
                    }),
                    n.splice(n.indexOf(i), 1),
                    r.shift())),
                    r.length === 1 && eh(r[0]))
                        Xf(s, r[0]);
                    else
                        for (let l = 0; l < n.length; l++)
                            fn(r[l]) && (s[n[l]] = r[l]);
                    return Xf(e, s)
                }
                function u7(e) {
                    return e.constructor.getDefaults()
                }
                function jl(e, t) {
                    return Nr(e) ? t : e
                }
                function nh(e, t) {
                    return t.forEach(n => {
                        Reflect.has(e, n) && delete e[n]
                    }
                    ),
                    e
                }
                var Ic = class {
                    constructor() {
                        this.debug = !1,
                        this._wasDisposed = !1
                    }
                    static getDefaults() {
                        return {}
                    }
                    log(...e) {
                        (this.debug || Ur && this.toString() === Ur.TONE_DEBUG_CLASS) && t7(this, ...e)
                    }
                    dispose() {
                        return this._wasDisposed = !0,
                        this
                    }
                    get disposed() {
                        return this._wasDisposed
                    }
                    toString() {
                        return this.name
                    }
                }
                ;
                Ic.version = OM;
                const nb = 1e-6;
                function om(e, t) {
                    return e > t + nb
                }
                function ib(e, t) {
                    return om(e, t) || Ko(e, t)
                }
                function oS(e, t) {
                    return e + nb < t
                }
                function Ko(e, t) {
                    return Math.abs(e - t) < nb
                }
                function h7(e, t, n) {
                    return Math.max(Math.min(e, n), t)
                }
                var Ql = class nN extends Ic {
                    constructor() {
                        super(),
                        this.name = "Timeline",
                        this._timeline = [];
                        const t = Pt(nN.getDefaults(), arguments, ["memory"]);
                        this.memory = t.memory,
                        this.increasing = t.increasing
                    }
                    static getDefaults() {
                        return {
                            memory: 1 / 0,
                            increasing: !1
                        }
                    }
                    get length() {
                        return this._timeline.length
                    }
                    add(t) {
                        if (Wt(Reflect.has(t, "time"), "Timeline: events must have a time attribute"),
                        t.time = t.time.valueOf(),
                        this.increasing && this.length) {
                            const n = this._timeline[this.length - 1];
                            Wt(ib(t.time, n.time), "The time must be greater than or equal to the last scheduled time"),
                            this._timeline.push(t)
                        } else {
                            const n = this._search(t.time);
                            this._timeline.splice(n + 1, 0, t)
                        }
                        if (this.length > this.memory) {
                            const n = this.length - this.memory;
                            this._timeline.splice(0, n)
                        }
                        return this
                    }
                    remove(t) {
                        const n = this._timeline.indexOf(t);
                        return n !== -1 && this._timeline.splice(n, 1),
                        this
                    }
                    get(t, n="time") {
                        const i = this._search(t, n);
                        return i !== -1 ? this._timeline[i] : null
                    }
                    peek() {
                        return this._timeline[0]
                    }
                    shift() {
                        return this._timeline.shift()
                    }
                    getAfter(t, n="time") {
                        const i = this._search(t, n);
                        return i + 1 < this._timeline.length ? this._timeline[i + 1] : null
                    }
                    getBefore(t) {
                        const n = this._timeline.length;
                        if (n > 0 && this._timeline[n - 1].time < t)
                            return this._timeline[n - 1];
                        const i = this._search(t);
                        return i - 1 >= 0 ? this._timeline[i - 1] : null
                    }
                    cancel(t) {
                        if (this._timeline.length > 1) {
                            let n = this._search(t);
                            if (n >= 0)
                                if (Ko(this._timeline[n].time, t)) {
                                    for (let i = n; i >= 0 && Ko(this._timeline[i].time, t); i--)
                                        n = i;
                                    this._timeline = this._timeline.slice(0, n)
                                } else
                                    this._timeline = this._timeline.slice(0, n + 1);
                            else
                                this._timeline = []
                        } else
                            this._timeline.length === 1 && ib(this._timeline[0].time, t) && (this._timeline = []);
                        return this
                    }
                    cancelBefore(t) {
                        const n = this._search(t);
                        return n >= 0 && (this._timeline = this._timeline.slice(n + 1)),
                        this
                    }
                    previousEvent(t) {
                        const n = this._timeline.indexOf(t);
                        return n > 0 ? this._timeline[n - 1] : null
                    }
                    _search(t, n="time") {
                        if (this._timeline.length === 0)
                            return -1;
                        let i = 0;
                        const s = this._timeline.length;
                        let r = s;
                        if (s > 0 && this._timeline[s - 1][n] <= t)
                            return s - 1;
                        for (; i < r; ) {
                            let l = Math.floor(i + (r - i) / 2);
                            const h = this._timeline[l]
                              , d = this._timeline[l + 1];
                            if (Ko(h[n], t)) {
                                for (let p = l; p < this._timeline.length; p++) {
                                    const m = this._timeline[p];
                                    if (Ko(m[n], t))
                                        l = p;
                                    else
                                        break
                                }
                                return l
                            } else {
                                if (oS(h[n], t) && om(d[n], t))
                                    return l;
                                om(h[n], t) ? r = l : i = l + 1
                            }
                        }
                        return -1
                    }
                    _iterate(t, n=0, i=this._timeline.length - 1) {
                        this._timeline.slice(n, i + 1).forEach(t)
                    }
                    forEach(t) {
                        return this._iterate(t),
                        this
                    }
                    forEachBefore(t, n) {
                        const i = this._search(t);
                        return i !== -1 && this._iterate(n, 0, i),
                        this
                    }
                    forEachAfter(t, n) {
                        const i = this._search(t);
                        return this._iterate(n, i + 1),
                        this
                    }
                    forEachBetween(t, n, i) {
                        let s = this._search(t)
                          , r = this._search(n);
                        return s !== -1 && r !== -1 ? (this._timeline[s].time !== t && (s += 1),
                        this._timeline[r].time === n && (r -= 1),
                        this._iterate(i, s, r)) : s === -1 && this._iterate(i, 0, r),
                        this
                    }
                    forEachFrom(t, n) {
                        let i = this._search(t);
                        for (; i >= 0 && this._timeline[i].time >= t; )
                            i--;
                        return this._iterate(n, i + 1),
                        this
                    }
                    forEachAtTime(t, n) {
                        const i = this._search(t);
                        if (i !== -1 && Ko(this._timeline[i].time, t)) {
                            let s = i;
                            for (let r = i; r >= 0 && Ko(this._timeline[r].time, t); r--)
                                s = r;
                            this._iterate(r => {
                                n(r)
                            }
                            , s, i)
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._timeline = [],
                        this
                    }
                }
                ;
                const W2 = [];
                function lS(e) {
                    W2.push(e)
                }
                function f7(e) {
                    W2.forEach(t => t(e))
                }
                const j2 = [];
                function cS(e) {
                    j2.push(e)
                }
                function d7(e) {
                    j2.forEach(t => t(e))
                }
                var sb = class iN extends Ic {
                    constructor() {
                        super(...arguments),
                        this.name = "Emitter"
                    }
                    on(t, n) {
                        return t.split(/\W+/).forEach(i => {
                            Nr(this._events) && (this._events = {}),
                            this._events.hasOwnProperty(i) || (this._events[i] = []),
                            this._events[i].push(n)
                        }
                        ),
                        this
                    }
                    once(t, n) {
                        const i = (...s) => {
                            n(...s),
                            this.off(t, i)
                        }
                        ;
                        return this.on(t, i),
                        this
                    }
                    off(t, n) {
                        return t.split(/\W+/).forEach(i => {
                            if (Nr(this._events) && (this._events = {}),
                            this._events.hasOwnProperty(i))
                                if (Nr(n))
                                    this._events[i] = [];
                                else {
                                    const s = this._events[i];
                                    for (let r = s.length - 1; r >= 0; r--)
                                        s[r] === n && s.splice(r, 1)
                                }
                        }
                        ),
                        this
                    }
                    emit(t, ...n) {
                        if (this._events && this._events.hasOwnProperty(t)) {
                            const i = this._events[t].slice(0);
                            for (let s = 0, r = i.length; s < r; s++)
                                i[s].apply(this, n)
                        }
                        return this
                    }
                    static mixin(t) {
                        ["on", "once", "off", "emit"].forEach(n => {
                            const i = Object.getOwnPropertyDescriptor(iN.prototype, n);
                            Object.defineProperty(t.prototype, n, i)
                        }
                        )
                    }
                    dispose() {
                        return super.dispose(),
                        this._events = void 0,
                        this
                    }
                }
                  , Q2 = class extends sb {
                    constructor() {
                        super(...arguments),
                        this.isOffline = !1
                    }
                    toJSON() {
                        return {}
                    }
                }
                  , ab = class sN extends Q2 {
                    constructor() {
                        var t, n;
                        super(),
                        this.name = "Context",
                        this._constants = new Map,
                        this._timeouts = new Ql,
                        this._timeoutIds = 0,
                        this._initialized = !1,
                        this._closeStarted = !1,
                        this.isOffline = !1,
                        this._workletPromise = null;
                        const i = Pt(sN.getDefaults(), arguments, ["context"]);
                        i.context ? (this._context = i.context,
                        this._latencyHint = ((t = arguments[0]) === null || t === void 0 ? void 0 : t.latencyHint) || "") : (this._context = n7({
                            latencyHint: i.latencyHint
                        }),
                        this._latencyHint = i.latencyHint),
                        this._ticker = new r7(this.emit.bind(this, "tick"),i.clockSource,i.updateInterval,this._context.sampleRate),
                        this.on("tick", this._timeoutLoop.bind(this)),
                        this._context.onstatechange = () => {
                            this.emit("statechange", this.state)
                        }
                        ,
                        this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = i.lookAhead
                    }
                    static getDefaults() {
                        return {
                            clockSource: "worker",
                            latencyHint: "interactive",
                            lookAhead: .1,
                            updateInterval: .05
                        }
                    }
                    initialize() {
                        return this._initialized || (f7(this),
                        this._initialized = !0),
                        this
                    }
                    createAnalyser() {
                        return this._context.createAnalyser()
                    }
                    createOscillator() {
                        return this._context.createOscillator()
                    }
                    createBufferSource() {
                        return this._context.createBufferSource()
                    }
                    createBiquadFilter() {
                        return this._context.createBiquadFilter()
                    }
                    createBuffer(t, n, i) {
                        return this._context.createBuffer(t, n, i)
                    }
                    createChannelMerger(t) {
                        return this._context.createChannelMerger(t)
                    }
                    createChannelSplitter(t) {
                        return this._context.createChannelSplitter(t)
                    }
                    createConstantSource() {
                        return this._context.createConstantSource()
                    }
                    createConvolver() {
                        return this._context.createConvolver()
                    }
                    createDelay(t) {
                        return this._context.createDelay(t)
                    }
                    createDynamicsCompressor() {
                        return this._context.createDynamicsCompressor()
                    }
                    createGain() {
                        return this._context.createGain()
                    }
                    createIIRFilter(t, n) {
                        return this._context.createIIRFilter(t, n)
                    }
                    createPanner() {
                        return this._context.createPanner()
                    }
                    createPeriodicWave(t, n, i) {
                        return this._context.createPeriodicWave(t, n, i)
                    }
                    createStereoPanner() {
                        return this._context.createStereoPanner()
                    }
                    createWaveShaper() {
                        return this._context.createWaveShaper()
                    }
                    createMediaStreamSource(t) {
                        return Wt(rm(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaStreamSource(t)
                    }
                    createMediaElementSource(t) {
                        return Wt(rm(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaElementSource(t)
                    }
                    createMediaStreamDestination() {
                        return Wt(rm(this._context), "Not available if OfflineAudioContext"),
                        this._context.createMediaStreamDestination()
                    }
                    decodeAudioData(t) {
                        return this._context.decodeAudioData(t)
                    }
                    get currentTime() {
                        return this._context.currentTime
                    }
                    get state() {
                        return this._context.state
                    }
                    get sampleRate() {
                        return this._context.sampleRate
                    }
                    get listener() {
                        return this.initialize(),
                        this._listener
                    }
                    set listener(t) {
                        Wt(!this._initialized, "The listener cannot be set after initialization."),
                        this._listener = t
                    }
                    get transport() {
                        return this.initialize(),
                        this._transport
                    }
                    set transport(t) {
                        Wt(!this._initialized, "The transport cannot be set after initialization."),
                        this._transport = t
                    }
                    get draw() {
                        return this.initialize(),
                        this._draw
                    }
                    set draw(t) {
                        Wt(!this._initialized, "Draw cannot be set after initialization."),
                        this._draw = t
                    }
                    get destination() {
                        return this.initialize(),
                        this._destination
                    }
                    set destination(t) {
                        Wt(!this._initialized, "The destination cannot be set after initialization."),
                        this._destination = t
                    }
                    createAudioWorkletNode(t, n) {
                        return a7(this.rawContext, t, n)
                    }
                    addAudioWorkletModule(t) {
                        return Ki(this, void 0, void 0, function*() {
                            Wt(fn(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"),
                            this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)),
                            yield this._workletPromise
                        })
                    }
                    workletsAreReady() {
                        return Ki(this, void 0, void 0, function*() {
                            (yield this._workletPromise) ? this._workletPromise : Promise.resolve()
                        })
                    }
                    get updateInterval() {
                        return this._ticker.updateInterval
                    }
                    set updateInterval(t) {
                        this._ticker.updateInterval = t
                    }
                    get clockSource() {
                        return this._ticker.type
                    }
                    set clockSource(t) {
                        this._ticker.type = t
                    }
                    get lookAhead() {
                        return this._lookAhead
                    }
                    set lookAhead(t) {
                        this._lookAhead = t,
                        this.updateInterval = t ? t / 2 : .01
                    }
                    get latencyHint() {
                        return this._latencyHint
                    }
                    get rawContext() {
                        return this._context
                    }
                    now() {
                        return this._context.currentTime + this._lookAhead
                    }
                    immediate() {
                        return this._context.currentTime
                    }
                    resume() {
                        return rm(this._context) ? this._context.resume() : Promise.resolve()
                    }
                    close() {
                        return Ki(this, void 0, void 0, function*() {
                            rm(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0,
                            yield this._context.close()),
                            this._initialized && d7(this)
                        })
                    }
                    getConstant(t) {
                        if (this._constants.has(t))
                            return this._constants.get(t);
                        {
                            const n = this._context.createBuffer(1, 128, this._context.sampleRate)
                              , i = n.getChannelData(0);
                            for (let r = 0; r < i.length; r++)
                                i[r] = t;
                            const s = this._context.createBufferSource();
                            return s.channelCount = 1,
                            s.channelCountMode = "explicit",
                            s.buffer = n,
                            s.loop = !0,
                            s.start(0),
                            this._constants.set(t, s),
                            s
                        }
                    }
                    dispose() {
                        return super.dispose(),
                        this._ticker.dispose(),
                        this._timeouts.dispose(),
                        Object.keys(this._constants).map(t => this._constants[t].disconnect()),
                        this.close(),
                        this
                    }
                    _timeoutLoop() {
                        const t = this.now();
                        this._timeouts.forEachBefore(t, n => {
                            n.callback(),
                            this._timeouts.remove(n)
                        }
                        )
                    }
                    setTimeout(t, n) {
                        this._timeoutIds++;
                        const i = this.now();
                        return this._timeouts.add({
                            callback: t,
                            id: this._timeoutIds,
                            time: i + n
                        }),
                        this._timeoutIds
                    }
                    clearTimeout(t) {
                        return this._timeouts.forEach(n => {
                            n.id === t && this._timeouts.remove(n)
                        }
                        ),
                        this
                    }
                    clearInterval(t) {
                        return this.clearTimeout(t)
                    }
                    setInterval(t, n) {
                        const i = ++this._timeoutIds
                          , s = () => {
                            const r = this.now();
                            this._timeouts.add({
                                callback: () => {
                                    t(),
                                    s()
                                }
                                ,
                                id: i,
                                time: r + n
                            })
                        }
                        ;
                        return s(),
                        i
                    }
                }
                  , p7 = class extends Q2 {
                    constructor() {
                        super(...arguments),
                        this.lookAhead = 0,
                        this.latencyHint = 0,
                        this.isOffline = !1
                    }
                    createAnalyser() {
                        return {}
                    }
                    createOscillator() {
                        return {}
                    }
                    createBufferSource() {
                        return {}
                    }
                    createBiquadFilter() {
                        return {}
                    }
                    createBuffer(e, t, n) {
                        return {}
                    }
                    createChannelMerger(e) {
                        return {}
                    }
                    createChannelSplitter(e) {
                        return {}
                    }
                    createConstantSource() {
                        return {}
                    }
                    createConvolver() {
                        return {}
                    }
                    createDelay(e) {
                        return {}
                    }
                    createDynamicsCompressor() {
                        return {}
                    }
                    createGain() {
                        return {}
                    }
                    createIIRFilter(e, t) {
                        return {}
                    }
                    createPanner() {
                        return {}
                    }
                    createPeriodicWave(e, t, n) {
                        return {}
                    }
                    createStereoPanner() {
                        return {}
                    }
                    createWaveShaper() {
                        return {}
                    }
                    createMediaStreamSource(e) {
                        return {}
                    }
                    createMediaElementSource(e) {
                        return {}
                    }
                    createMediaStreamDestination() {
                        return {}
                    }
                    decodeAudioData(e) {
                        return Promise.resolve({})
                    }
                    createAudioWorkletNode(e, t) {
                        return {}
                    }
                    get rawContext() {
                        return {}
                    }
                    addAudioWorkletModule(e) {
                        return Ki(this, void 0, void 0, function*() {
                            return Promise.resolve()
                        })
                    }
                    resume() {
                        return Promise.resolve()
                    }
                    setTimeout(e, t) {
                        return 0
                    }
                    clearTimeout(e) {
                        return this
                    }
                    setInterval(e, t) {
                        return 0
                    }
                    clearInterval(e) {
                        return this
                    }
                    getConstant(e) {
                        return {}
                    }
                    get currentTime() {
                        return 0
                    }
                    get state() {
                        return {}
                    }
                    get sampleRate() {
                        return 0
                    }
                    get listener() {
                        return {}
                    }
                    get transport() {
                        return {}
                    }
                    get draw() {
                        return {}
                    }
                    set draw(e) {}
                    get destination() {
                        return {}
                    }
                    set destination(e) {}
                    now() {
                        return 0
                    }
                    immediate() {
                        return 0
                    }
                }
                ;
                function ii(e, t) {
                    ha(t) ? t.forEach(n => ii(e, n)) : Object.defineProperty(e, t, {
                        enumerable: !0,
                        writable: !1
                    })
                }
                function Z2(e, t) {
                    ha(t) ? t.forEach(n => Z2(e, n)) : Object.defineProperty(e, t, {
                        writable: !0
                    })
                }
                const Vn = () => {}
                ;
                var Jo = class da extends Ic {
                    constructor() {
                        super(),
                        this.name = "ToneAudioBuffer",
                        this.onload = Vn;
                        const t = Pt(da.getDefaults(), arguments, ["url", "onload", "onerror"]);
                        this.reverse = t.reverse,
                        this.onload = t.onload,
                        Wl(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url)
                    }
                    static getDefaults() {
                        return {
                            onerror: Vn,
                            onload: Vn,
                            reverse: !1
                        }
                    }
                    get sampleRate() {
                        return this._buffer ? this._buffer.sampleRate : co().sampleRate
                    }
                    set(t) {
                        return t instanceof da ? t.loaded ? this._buffer = t.get() : t.onload = () => {
                            this.set(t),
                            this.onload(this)
                        }
                        : this._buffer = t,
                        this._reversed && this._reverse(),
                        this
                    }
                    get() {
                        return this._buffer
                    }
                    load(t) {
                        return Ki(this, void 0, void 0, function*() {
                            const n = da.load(t).then(i => {
                                this.set(i),
                                this.onload(this)
                            }
                            );
                            da.downloads.push(n);
                            try {
                                yield n
                            } finally {
                                const i = da.downloads.indexOf(n);
                                da.downloads.splice(i, 1)
                            }
                            return this
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffer = void 0,
                        this
                    }
                    fromArray(t) {
                        const n = ha(t) && t[0].length > 0
                          , i = n ? t.length : 1
                          , s = n ? t[0].length : t.length
                          , r = co()
                          , l = r.createBuffer(i, s, r.sampleRate)
                          , h = !n && i === 1 ? [t] : t;
                        for (let d = 0; d < i; d++)
                            l.copyToChannel(h[d], d);
                        return this._buffer = l,
                        this
                    }
                    toMono(t) {
                        if (Yl(t))
                            this.fromArray(this.toArray(t));
                        else {
                            let n = new Float32Array(this.length);
                            const i = this.numberOfChannels;
                            for (let s = 0; s < i; s++) {
                                const r = this.toArray(s);
                                for (let l = 0; l < r.length; l++)
                                    n[l] += r[l]
                            }
                            n = n.map(s => s / i),
                            this.fromArray(n)
                        }
                        return this
                    }
                    toArray(t) {
                        if (Yl(t))
                            return this.getChannelData(t);
                        if (this.numberOfChannels === 1)
                            return this.toArray(0);
                        {
                            const n = [];
                            for (let i = 0; i < this.numberOfChannels; i++)
                                n[i] = this.getChannelData(i);
                            return n
                        }
                    }
                    getChannelData(t) {
                        return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0)
                    }
                    slice(t, n=this.duration) {
                        Wt(this.loaded, "Buffer is not loaded");
                        const i = Math.floor(t * this.sampleRate)
                          , s = Math.floor(n * this.sampleRate);
                        Wt(i < s, "The start time must be less than the end time");
                        const r = s - i
                          , l = co().createBuffer(this.numberOfChannels, r, this.sampleRate);
                        for (let h = 0; h < this.numberOfChannels; h++)
                            l.copyToChannel(this.getChannelData(h).subarray(i, s), h);
                        return new da(l)
                    }
                    _reverse() {
                        if (this.loaded)
                            for (let t = 0; t < this.numberOfChannels; t++)
                                this.getChannelData(t).reverse();
                        return this
                    }
                    get loaded() {
                        return this.length > 0
                    }
                    get duration() {
                        return this._buffer ? this._buffer.duration : 0
                    }
                    get length() {
                        return this._buffer ? this._buffer.length : 0
                    }
                    get numberOfChannels() {
                        return this._buffer ? this._buffer.numberOfChannels : 0
                    }
                    get reverse() {
                        return this._reversed
                    }
                    set reverse(t) {
                        this._reversed !== t && (this._reversed = t,
                        this._reverse())
                    }
                    static fromArray(t) {
                        return new da().fromArray(t)
                    }
                    static fromUrl(t) {
                        return Ki(this, void 0, void 0, function*() {
                            return yield new da().load(t)
                        })
                    }
                    static load(t) {
                        return Ki(this, void 0, void 0, function*() {
                            const n = da.baseUrl === "" || da.baseUrl.endsWith("/") ? da.baseUrl : da.baseUrl + "/"
                              , i = yield fetch(n + t);
                            if (!i.ok)
                                throw new Error(`could not load url: ${t}`);
                            const s = yield i.arrayBuffer();
                            return yield co().decodeAudioData(s)
                        })
                    }
                    static supportsType(t) {
                        const n = t.split(".")
                          , i = n[n.length - 1];
                        return document.createElement("audio").canPlayType("audio/" + i) !== ""
                    }
                    static loaded() {
                        return Ki(this, void 0, void 0, function*() {
                            for (yield Promise.resolve(); da.downloads.length; )
                                yield da.downloads[0]
                        })
                    }
                }
                ;
                Jo.baseUrl = "",
                Jo.downloads = [];
                var uS = class extends ab {
                    constructor() {
                        super({
                            clockSource: "offline",
                            context: rS(arguments[0]) ? arguments[0] : i7(arguments[0], arguments[1] * arguments[2], arguments[2]),
                            lookAhead: 0,
                            updateInterval: rS(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
                        }),
                        this.name = "OfflineContext",
                        this._currentTime = 0,
                        this.isOffline = !0,
                        this._duration = rS(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1]
                    }
                    now() {
                        return this._currentTime
                    }
                    get currentTime() {
                        return this._currentTime
                    }
                    _renderClock(e) {
                        return Ki(this, void 0, void 0, function*() {
                            let t = 0;
                            for (; this._duration - this._currentTime >= 0; ) {
                                this.emit("tick"),
                                this._currentTime += 128 / this.sampleRate,
                                t++;
                                const n = Math.floor(this.sampleRate / 128);
                                e && t % n === 0 && (yield new Promise(i => setTimeout(i, 1)))
                            }
                        })
                    }
                    render() {
                        return Ki(this, arguments, void 0, function*(e=!0) {
                            yield this.workletsAreReady(),
                            yield this._renderClock(e);
                            const t = yield this._context.startRendering();
                            return new Jo(t)
                        })
                    }
                    close() {
                        return Promise.resolve()
                    }
                }
                ;
                const K2 = new p7;
                let qf = K2;
                function co() {
                    return qf === K2 && s7 && m7(new ab),
                    qf
                }
                function m7(e, t=!1) {
                    t && qf.dispose(),
                    rm(e) ? qf = new ab(e) : rS(e) ? qf = new uS(e) : qf = e
                }
                function g7() {
                    return qf.resume()
                }
                if (Ur && !Ur.TONE_SILENCE_LOGGING) {
                    let e = "v";
                    OM === "dev" && (e = "");
                    const t = ` * Tone.js ${e}${OM} * `;
                    console.log(`%c${t}`, "background: #000; color: #fff")
                }
                function v7(e) {
                    return Math.pow(10, e / 20)
                }
                function y7(e) {
                    return 20 * (Math.log(e) / Math.LN10)
                }
                function J2(e) {
                    return Math.pow(2, e / 12)
                }
                let hS = 440;
                function _7() {
                    return hS
                }
                function x7(e) {
                    hS = e
                }
                function Yf(e) {
                    return Math.round($2(e))
                }
                function $2(e) {
                    return 69 + 12 * Math.log2(e / hS)
                }
                function eO(e) {
                    return hS * Math.pow(2, (e - 69) / 12)
                }
                var S7 = class aN extends Ic {
                    constructor(t, n, i) {
                        super(),
                        this.defaultUnits = "s",
                        this._val = n,
                        this._units = i,
                        this.context = t,
                        this._expressions = this._getExpressions()
                    }
                    _getExpressions() {
                        return {
                            hz: {
                                method: t => this._frequencyToUnits(parseFloat(t)),
                                regexp: /^(\d+(?:\.\d+)?)hz$/i
                            },
                            i: {
                                method: t => this._ticksToUnits(parseInt(t, 10)),
                                regexp: /^(\d+)i$/i
                            },
                            m: {
                                method: t => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
                                regexp: /^(\d+)m$/i
                            },
                            n: {
                                method: (t, n) => {
                                    const i = parseInt(t, 10)
                                      , s = n === "." ? 1.5 : 1;
                                    return i === 1 ? this._beatsToUnits(this._getTimeSignature()) * s : this._beatsToUnits(4 / i) * s
                                }
                                ,
                                regexp: /^(\d+)n(\.?)$/i
                            },
                            number: {
                                method: t => this._expressions[this.defaultUnits].method.call(this, t),
                                regexp: /^(\d+(?:\.\d+)?)$/
                            },
                            s: {
                                method: t => this._secondsToUnits(parseFloat(t)),
                                regexp: /^(\d+(?:\.\d+)?)s$/
                            },
                            samples: {
                                method: t => parseInt(t, 10) / this.context.sampleRate,
                                regexp: /^(\d+)samples$/
                            },
                            t: {
                                method: t => {
                                    const n = parseInt(t, 10);
                                    return this._beatsToUnits(8 / (Math.floor(n) * 3))
                                }
                                ,
                                regexp: /^(\d+)t$/i
                            },
                            tr: {
                                method: (t, n, i) => {
                                    let s = 0;
                                    return t && t !== "0" && (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))),
                                    n && n !== "0" && (s += this._beatsToUnits(parseFloat(n))),
                                    i && i !== "0" && (s += this._beatsToUnits(parseFloat(i) / 4)),
                                    s
                                }
                                ,
                                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
                            }
                        }
                    }
                    valueOf() {
                        if (this._val instanceof aN && this.fromType(this._val),
                        Nr(this._val))
                            return this._noArg();
                        if (Wl(this._val) && Nr(this._units)) {
                            for (const t in this._expressions)
                                if (this._expressions[t].regexp.test(this._val.trim())) {
                                    this._units = t;
                                    break
                                }
                        } else if (eh(this._val)) {
                            let t = 0;
                            for (const n in this._val)
                                if (fn(this._val[n])) {
                                    const i = this._val[n]
                                      , s = new this.constructor(this.context,n).valueOf() * i;
                                    t += s
                                }
                            return t
                        }
                        if (fn(this._units)) {
                            const t = this._expressions[this._units]
                              , n = this._val.toString().trim().match(t.regexp);
                            return n ? t.method.apply(this, n.slice(1)) : t.method.call(this, this._val)
                        } else
                            return Wl(this._val) ? parseFloat(this._val) : this._val
                    }
                    _frequencyToUnits(t) {
                        return 1 / t
                    }
                    _beatsToUnits(t) {
                        return 60 / this._getBpm() * t
                    }
                    _secondsToUnits(t) {
                        return t
                    }
                    _ticksToUnits(t) {
                        return t * this._beatsToUnits(1) / this._getPPQ()
                    }
                    _noArg() {
                        return this._now()
                    }
                    _getBpm() {
                        return this.context.transport.bpm.value
                    }
                    _getTimeSignature() {
                        return this.context.transport.timeSignature
                    }
                    _getPPQ() {
                        return this.context.transport.PPQ
                    }
                    fromType(t) {
                        switch (this._units = void 0,
                        this.defaultUnits) {
                        case "s":
                            this._val = t.toSeconds();
                            break;
                        case "i":
                            this._val = t.toTicks();
                            break;
                        case "hz":
                            this._val = t.toFrequency();
                            break;
                        case "midi":
                            this._val = t.toMidi();
                            break
                        }
                        return this
                    }
                    toFrequency() {
                        return 1 / this.toSeconds()
                    }
                    toSamples() {
                        return this.toSeconds() * this.context.sampleRate
                    }
                    toMilliseconds() {
                        return this.toSeconds() * 1e3
                    }
                }
                  , Wf = class xS extends S7 {
                    constructor() {
                        super(...arguments),
                        this.name = "TimeClass"
                    }
                    _getExpressions() {
                        return Object.assign(super._getExpressions(), {
                            now: {
                                method: t => this._now() + new this.constructor(this.context,t).valueOf(),
                                regexp: /^\+(.+)/
                            },
                            quantize: {
                                method: t => {
                                    const n = new xS(this.context,t).valueOf();
                                    return this._secondsToUnits(this.context.transport.nextSubdivision(n))
                                }
                                ,
                                regexp: /^@(.+)/
                            }
                        })
                    }
                    quantize(t, n=1) {
                        const i = new this.constructor(this.context,t).valueOf()
                          , s = this.valueOf()
                          , r = Math.round(s / i) * i - s;
                        return s + r * n
                    }
                    toNotation() {
                        const t = this.toSeconds()
                          , n = ["1m"];
                        for (let r = 1; r < 9; r++) {
                            const l = Math.pow(2, r);
                            n.push(l + "n."),
                            n.push(l + "n"),
                            n.push(l + "t")
                        }
                        n.push("0");
                        let i = n[0]
                          , s = new xS(this.context,n[0]).toSeconds();
                        return n.forEach(r => {
                            const l = new xS(this.context,r).toSeconds();
                            Math.abs(l - t) < Math.abs(s - t) && (i = r,
                            s = l)
                        }
                        ),
                        i
                    }
                    toBarsBeatsSixteenths() {
                        const t = this._beatsToUnits(1);
                        let n = this.valueOf() / t;
                        n = parseFloat(n.toFixed(4));
                        const i = Math.floor(n / this._getTimeSignature());
                        let s = n % 1 * 4;
                        n = Math.floor(n) % this._getTimeSignature();
                        const r = s.toString();
                        return r.length > 3 && (s = parseFloat(parseFloat(r).toFixed(3))),
                        [i, n, s].join(":")
                    }
                    toTicks() {
                        const t = this._beatsToUnits(1);
                        return this.valueOf() / t * this._getPPQ()
                    }
                    toSeconds() {
                        return this.valueOf()
                    }
                    toMidi() {
                        return Yf(this.toFrequency())
                    }
                    _now() {
                        return this.context.now()
                    }
                }
                  , ih = class n0 extends Wf {
                    constructor() {
                        super(...arguments),
                        this.name = "Frequency",
                        this.defaultUnits = "hz"
                    }
                    static get A4() {
                        return _7()
                    }
                    static set A4(t) {
                        x7(t)
                    }
                    _getExpressions() {
                        return Object.assign({}, super._getExpressions(), {
                            midi: {
                                regexp: /^(\d+(?:\.\d+)?midi)/,
                                method(t) {
                                    return this.defaultUnits === "midi" ? t : n0.mtof(t)
                                }
                            },
                            note: {
                                regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
                                method(t, n) {
                                    const i = A7[t.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
                                    return this.defaultUnits === "midi" ? i : n0.mtof(i)
                                }
                            },
                            tr: {
                                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                                method(t, n, i) {
                                    let s = 1;
                                    return t && t !== "0" && (s *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))),
                                    n && n !== "0" && (s *= this._beatsToUnits(parseFloat(n))),
                                    i && i !== "0" && (s *= this._beatsToUnits(parseFloat(i) / 4)),
                                    s
                                }
                            }
                        })
                    }
                    transpose(t) {
                        return new n0(this.context,this.valueOf() * J2(t))
                    }
                    harmonize(t) {
                        return t.map(n => this.transpose(n))
                    }
                    toMidi() {
                        return Yf(this.valueOf())
                    }
                    toNote() {
                        const t = this.toFrequency()
                          , n = Math.log2(t / n0.A4);
                        let i = Math.round(12 * n) + 57;
                        const s = Math.floor(i / 12);
                        return s < 0 && (i += -12 * s),
                        T7[i % 12] + s.toString()
                    }
                    toSeconds() {
                        return 1 / super.toSeconds()
                    }
                    toTicks() {
                        const t = this._beatsToUnits(1)
                          , n = this.valueOf() / t;
                        return Math.floor(n * this._getPPQ())
                    }
                    _noArg() {
                        return 0
                    }
                    _frequencyToUnits(t) {
                        return t
                    }
                    _ticksToUnits(t) {
                        return 1 / (t * 60 / (this._getBpm() * this._getPPQ()))
                    }
                    _beatsToUnits(t) {
                        return 1 / super._beatsToUnits(t)
                    }
                    _secondsToUnits(t) {
                        return 1 / t
                    }
                    static mtof(t) {
                        return eO(t)
                    }
                    static ftom(t) {
                        return Yf(t)
                    }
                }
                ;
                const A7 = {
                    cbbb: -3,
                    cbb: -2,
                    cb: -1,
                    c: 0,
                    "c#": 1,
                    cx: 2,
                    "c##": 2,
                    "c###": 3,
                    "cx#": 3,
                    "c#x": 3,
                    dbbb: -1,
                    dbb: 0,
                    db: 1,
                    d: 2,
                    "d#": 3,
                    dx: 4,
                    "d##": 4,
                    "d###": 5,
                    "dx#": 5,
                    "d#x": 5,
                    ebbb: 1,
                    ebb: 2,
                    eb: 3,
                    e: 4,
                    "e#": 5,
                    ex: 6,
                    "e##": 6,
                    "e###": 7,
                    "ex#": 7,
                    "e#x": 7,
                    fbbb: 2,
                    fbb: 3,
                    fb: 4,
                    f: 5,
                    "f#": 6,
                    fx: 7,
                    "f##": 7,
                    "f###": 8,
                    "fx#": 8,
                    "f#x": 8,
                    gbbb: 4,
                    gbb: 5,
                    gb: 6,
                    g: 7,
                    "g#": 8,
                    gx: 9,
                    "g##": 9,
                    "g###": 10,
                    "gx#": 10,
                    "g#x": 10,
                    abbb: 6,
                    abb: 7,
                    ab: 8,
                    a: 9,
                    "a#": 10,
                    ax: 11,
                    "a##": 11,
                    "a###": 12,
                    "ax#": 12,
                    "a#x": 12,
                    bbbb: 8,
                    bbb: 9,
                    bb: 10,
                    b: 11,
                    "b#": 12,
                    bx: 13,
                    "b##": 13,
                    "b###": 14,
                    "bx#": 14,
                    "b#x": 14
                }
                  , T7 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
                var lm = class extends Wf {
                    constructor() {
                        super(...arguments),
                        this.name = "TransportTime"
                    }
                    _now() {
                        return this.context.transport.seconds
                    }
                }
                  , uo = class SS extends Ic {
                    constructor() {
                        super();
                        const t = Pt(SS.getDefaults(), arguments, ["context"]);
                        this.defaultContext ? this.context = this.defaultContext : this.context = t.context
                    }
                    static getDefaults() {
                        return {
                            context: co()
                        }
                    }
                    now() {
                        return this.context.currentTime + this.context.lookAhead
                    }
                    immediate() {
                        return this.context.currentTime
                    }
                    get sampleTime() {
                        return 1 / this.context.sampleRate
                    }
                    get blockTime() {
                        return 128 / this.context.sampleRate
                    }
                    toSeconds(t) {
                        return e7(t),
                        new Wf(this.context,t).toSeconds()
                    }
                    toFrequency(t) {
                        return new ih(this.context,t).toFrequency()
                    }
                    toTicks(t) {
                        return new lm(this.context,t).toTicks()
                    }
                    _getPartialProperties(t) {
                        const n = this.get();
                        return Object.keys(n).forEach(i => {
                            Nr(t[i]) && delete n[i]
                        }
                        ),
                        n
                    }
                    get() {
                        const t = u7(this);
                        return Object.keys(t).forEach(n => {
                            if (Reflect.has(this, n)) {
                                const i = this[n];
                                fn(i) && fn(i.value) && fn(i.setValueAtTime) ? t[n] = i.value : i instanceof SS ? t[n] = i._getPartialProperties(t[n]) : ha(i) || Yl(i) || Wl(i) || V2(i) ? t[n] = i : delete t[n]
                            }
                        }
                        ),
                        t
                    }
                    set(t) {
                        return Object.keys(t).forEach(n => {
                            Reflect.has(this, n) && fn(this[n]) && (this[n] && fn(this[n].value) && fn(this[n].setValueAtTime) ? this[n].value !== t[n] && (this[n].value = t[n]) : this[n]instanceof SS ? this[n].set(t[n]) : this[n] = t[n])
                        }
                        ),
                        this
                    }
                }
                  , Jv = class extends Ql {
                    constructor(e="stopped") {
                        super(),
                        this.name = "StateTimeline",
                        this._initial = e,
                        this.setStateAtTime(this._initial, 0)
                    }
                    getValueAtTime(e) {
                        const t = this.get(e);
                        return t !== null ? t.state : this._initial
                    }
                    setStateAtTime(e, t, n) {
                        return lo(t, 0),
                        this.add(Object.assign({}, n, {
                            state: e,
                            time: t
                        })),
                        this
                    }
                    getLastState(e, t) {
                        const n = this._search(t);
                        for (let i = n; i >= 0; i--) {
                            const s = this._timeline[i];
                            if (s.state === e)
                                return s
                        }
                    }
                    getNextState(e, t) {
                        const n = this._search(t);
                        if (n !== -1)
                            for (let i = n; i < this._timeline.length; i++) {
                                const s = this._timeline[i];
                                if (s.state === e)
                                    return s
                            }
                    }
                }
                  , Ji = class gb extends uo {
                    constructor() {
                        const t = Pt(gb.getDefaults(), arguments, ["param", "units", "convert"]);
                        for (super(t),
                        this.name = "Param",
                        this.overridden = !1,
                        this._minOutput = 1e-7,
                        Wt(fn(t.param) && (kf(t.param) || t.param instanceof gb), "param must be an AudioParam"); !kf(t.param); )
                            t.param = t.param._param;
                        this._swappable = fn(t.swappable) ? t.swappable : !1,
                        this._swappable ? (this.input = this.context.createGain(),
                        this._param = t.param,
                        this.input.connect(this._param)) : this._param = this.input = t.param,
                        this._events = new Ql(1e3),
                        this._initialValue = this._param.defaultValue,
                        this.units = t.units,
                        this.convert = t.convert,
                        this._minValue = t.minValue,
                        this._maxValue = t.maxValue,
                        fn(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(uo.getDefaults(), {
                            convert: !0,
                            units: "number"
                        })
                    }
                    get value() {
                        const t = this.now();
                        return this.getValueAtTime(t)
                    }
                    set value(t) {
                        this.cancelScheduledValues(this.now()),
                        this.setValueAtTime(t, this.now())
                    }
                    get minValue() {
                        return fn(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue
                    }
                    get maxValue() {
                        return fn(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue
                    }
                    _is(t, n) {
                        return this.units === n
                    }
                    _assertRange(t) {
                        return fn(this.maxValue) && fn(this.minValue) && lo(t, this._fromType(this.minValue), this._fromType(this.maxValue)),
                        t
                    }
                    _fromType(t) {
                        return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? v7(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t
                    }
                    _toType(t) {
                        return this.convert && this.units === "decibels" ? y7(t) : t
                    }
                    setValueAtTime(t, n) {
                        const i = this.toSeconds(n)
                          , s = this._fromType(t);
                        return Wt(isFinite(s) && isFinite(i), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._assertRange(s),
                        this.log(this.units, "setValueAtTime", t, i),
                        this._events.add({
                            time: i,
                            type: "setValueAtTime",
                            value: s
                        }),
                        this._param.setValueAtTime(s, i),
                        this
                    }
                    getValueAtTime(t) {
                        const n = Math.max(this.toSeconds(t), 0)
                          , i = this._events.getAfter(n)
                          , s = this._events.get(n);
                        let r = this._initialValue;
                        if (s === null)
                            r = this._initialValue;
                        else if (s.type === "setTargetAtTime" && (i === null || i.type === "setValueAtTime")) {
                            const l = this._events.getBefore(s.time);
                            let h;
                            l === null ? h = this._initialValue : h = l.value,
                            s.type === "setTargetAtTime" && (r = this._exponentialApproach(s.time, h, s.value, s.constant, n))
                        } else if (i === null)
                            r = s.value;
                        else if (i.type === "linearRampToValueAtTime" || i.type === "exponentialRampToValueAtTime") {
                            let l = s.value;
                            if (s.type === "setTargetAtTime") {
                                const h = this._events.getBefore(s.time);
                                h === null ? l = this._initialValue : l = h.value
                            }
                            i.type === "linearRampToValueAtTime" ? r = this._linearInterpolate(s.time, l, i.time, i.value, n) : r = this._exponentialInterpolate(s.time, l, i.time, i.value, n)
                        } else
                            r = s.value;
                        return this._toType(r)
                    }
                    setRampPoint(t) {
                        t = this.toSeconds(t);
                        let n = this.getValueAtTime(t);
                        return this.cancelAndHoldAtTime(t),
                        this._fromType(n) === 0 && (n = this._toType(this._minOutput)),
                        this.setValueAtTime(n, t),
                        this
                    }
                    linearRampToValueAtTime(t, n) {
                        const i = this._fromType(t)
                          , s = this.toSeconds(n);
                        return Wt(isFinite(i) && isFinite(s), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._assertRange(i),
                        this._events.add({
                            time: s,
                            type: "linearRampToValueAtTime",
                            value: i
                        }),
                        this.log(this.units, "linearRampToValueAtTime", t, s),
                        this._param.linearRampToValueAtTime(i, s),
                        this
                    }
                    exponentialRampToValueAtTime(t, n) {
                        let i = this._fromType(t);
                        i = Ko(i, 0) ? this._minOutput : i,
                        this._assertRange(i);
                        const s = this.toSeconds(n);
                        return Wt(isFinite(i) && isFinite(s), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._events.add({
                            time: s,
                            type: "exponentialRampToValueAtTime",
                            value: i
                        }),
                        this.log(this.units, "exponentialRampToValueAtTime", t, s),
                        this._param.exponentialRampToValueAtTime(i, s),
                        this
                    }
                    exponentialRampTo(t, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.exponentialRampToValueAtTime(t, i + this.toSeconds(n)),
                        this
                    }
                    linearRampTo(t, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.linearRampToValueAtTime(t, i + this.toSeconds(n)),
                        this
                    }
                    targetRampTo(t, n, i) {
                        return i = this.toSeconds(i),
                        this.setRampPoint(i),
                        this.exponentialApproachValueAtTime(t, i, n),
                        this
                    }
                    exponentialApproachValueAtTime(t, n, i) {
                        n = this.toSeconds(n),
                        i = this.toSeconds(i);
                        const s = Math.log(i + 1) / Math.log(200);
                        return this.setTargetAtTime(t, n, s),
                        this.cancelAndHoldAtTime(n + i * .9),
                        this.linearRampToValueAtTime(t, n + i),
                        this
                    }
                    setTargetAtTime(t, n, i) {
                        const s = this._fromType(t);
                        Wt(isFinite(i) && i > 0, "timeConstant must be a number greater than 0");
                        const r = this.toSeconds(n);
                        return this._assertRange(s),
                        Wt(isFinite(s) && isFinite(r), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`),
                        this._events.add({
                            constant: i,
                            time: r,
                            type: "setTargetAtTime",
                            value: s
                        }),
                        this.log(this.units, "setTargetAtTime", t, r, i),
                        this._param.setTargetAtTime(s, r, i),
                        this
                    }
                    setValueCurveAtTime(t, n, i, s=1) {
                        i = this.toSeconds(i),
                        n = this.toSeconds(n);
                        const r = this._fromType(t[0]) * s;
                        this.setValueAtTime(this._toType(r), n);
                        const l = i / (t.length - 1);
                        for (let h = 1; h < t.length; h++) {
                            const d = this._fromType(t[h]) * s;
                            this.linearRampToValueAtTime(this._toType(d), n + h * l)
                        }
                        return this
                    }
                    cancelScheduledValues(t) {
                        const n = this.toSeconds(t);
                        return Wt(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`),
                        this._events.cancel(n),
                        this._param.cancelScheduledValues(n),
                        this.log(this.units, "cancelScheduledValues", n),
                        this
                    }
                    cancelAndHoldAtTime(t) {
                        const n = this.toSeconds(t)
                          , i = this._fromType(this.getValueAtTime(n));
                        Wt(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`),
                        this.log(this.units, "cancelAndHoldAtTime", n, "value=" + i);
                        const s = this._events.get(n)
                          , r = this._events.getAfter(n);
                        return s && Ko(s.time, n) ? r ? (this._param.cancelScheduledValues(r.time),
                        this._events.cancel(r.time)) : (this._param.cancelAndHoldAtTime(n),
                        this._events.cancel(n + this.sampleTime)) : r && (this._param.cancelScheduledValues(r.time),
                        this._events.cancel(r.time),
                        r.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(i), n) : r.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(i), n)),
                        this._events.add({
                            time: n,
                            type: "setValueAtTime",
                            value: i
                        }),
                        this._param.setValueAtTime(i, n),
                        this
                    }
                    rampTo(t, n=.1, i) {
                        return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(t, n, i) : this.linearRampTo(t, n, i),
                        this
                    }
                    apply(t) {
                        const n = this.context.currentTime;
                        t.setValueAtTime(this.getValueAtTime(n), n);
                        const i = this._events.get(n);
                        if (i && i.type === "setTargetAtTime") {
                            const s = this._events.getAfter(i.time)
                              , r = s ? s.time : n + 2
                              , l = (r - n) / 10;
                            for (let h = n; h < r; h += l)
                                t.linearRampToValueAtTime(this.getValueAtTime(h), h)
                        }
                        return this._events.forEachAfter(this.context.currentTime, s => {
                            s.type === "cancelScheduledValues" ? t.cancelScheduledValues(s.time) : s.type === "setTargetAtTime" ? t.setTargetAtTime(s.value, s.time, s.constant) : t[s.type](s.value, s.time)
                        }
                        ),
                        this
                    }
                    setParam(t) {
                        Wt(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
                        const n = this.input;
                        return n.disconnect(this._param),
                        this.apply(t),
                        this._param = t,
                        n.connect(this._param),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._events.dispose(),
                        this
                    }
                    get defaultValue() {
                        return this._toType(this._param.defaultValue)
                    }
                    _exponentialApproach(t, n, i, s, r) {
                        return i + (n - i) * Math.exp(-(r - t) / s)
                    }
                    _linearInterpolate(t, n, i, s, r) {
                        return n + (s - n) * ((r - t) / (i - t))
                    }
                    _exponentialInterpolate(t, n, i, s, r) {
                        return n * Math.pow(s / n, (r - t) / (i - t))
                    }
                }
                  , tn = class AS extends uo {
                    constructor() {
                        super(...arguments),
                        this._internalChannels = []
                    }
                    get numberOfInputs() {
                        return fn(this.input) ? kf(this.input) || this.input instanceof Ji ? 1 : this.input.numberOfInputs : 0
                    }
                    get numberOfOutputs() {
                        return fn(this.output) ? this.output.numberOfOutputs : 0
                    }
                    _isAudioNode(t) {
                        return fn(t) && (t instanceof AS || th(t))
                    }
                    _getInternalNodes() {
                        const t = this._internalChannels.slice(0);
                        return this._isAudioNode(this.input) && t.push(this.input),
                        this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output),
                        t
                    }
                    _setChannelProperties(t) {
                        this._getInternalNodes().forEach(n => {
                            n.channelCount = t.channelCount,
                            n.channelCountMode = t.channelCountMode,
                            n.channelInterpretation = t.channelInterpretation
                        }
                        )
                    }
                    _getChannelProperties() {
                        const t = this._getInternalNodes();
                        Wt(t.length > 0, "ToneAudioNode does not have any internal nodes");
                        const n = t[0];
                        return {
                            channelCount: n.channelCount,
                            channelCountMode: n.channelCountMode,
                            channelInterpretation: n.channelInterpretation
                        }
                    }
                    get channelCount() {
                        return this._getChannelProperties().channelCount
                    }
                    set channelCount(t) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelCount: t
                        }))
                    }
                    get channelCountMode() {
                        return this._getChannelProperties().channelCountMode
                    }
                    set channelCountMode(t) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelCountMode: t
                        }))
                    }
                    get channelInterpretation() {
                        return this._getChannelProperties().channelInterpretation
                    }
                    set channelInterpretation(t) {
                        const n = this._getChannelProperties();
                        this._setChannelProperties(Object.assign(n, {
                            channelInterpretation: t
                        }))
                    }
                    connect(t, n=0, i=0) {
                        return sh(this, t, n, i),
                        this
                    }
                    toDestination() {
                        return this.connect(this.context.destination),
                        this
                    }
                    toMaster() {
                        return aS("toMaster() has been renamed toDestination()"),
                        this.toDestination()
                    }
                    disconnect(t, n=0, i=0) {
                        return M7(this, t, n, i),
                        this
                    }
                    chain(...t) {
                        return rb(this, ...t),
                        this
                    }
                    fan(...t) {
                        return t.forEach(n => this.connect(n)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        fn(this.input) && (this.input instanceof AS ? this.input.dispose() : th(this.input) && this.input.disconnect()),
                        fn(this.output) && (this.output instanceof AS ? this.output.dispose() : th(this.output) && this.output.disconnect()),
                        this._internalChannels = [],
                        this
                    }
                }
                ;
                function rb(...e) {
                    const t = e.shift();
                    e.reduce( (n, i) => (n instanceof tn ? n.connect(i) : th(n) && sh(n, i),
                    i), t)
                }
                function sh(e, t, n=0, i=0) {
                    for (Wt(fn(e), "Cannot connect from undefined node"),
                    Wt(fn(t), "Cannot connect to undefined node"),
                    (t instanceof tn || th(t)) && Wt(t.numberOfInputs > 0, "Cannot connect to node with no inputs"),
                    Wt(e.numberOfOutputs > 0, "Cannot connect from node with no outputs"); t instanceof tn || t instanceof Ji; )
                        fn(t.input) && (t = t.input);
                    for (; e instanceof tn; )
                        fn(e.output) && (e = e.output);
                    kf(t) ? e.connect(t, n) : e.connect(t, n, i)
                }
                function M7(e, t, n=0, i=0) {
                    if (fn(t))
                        for (; t instanceof tn; )
                            t = t.input;
                    for (; !th(e); )
                        fn(e.output) && (e = e.output);
                    kf(t) ? e.disconnect(t, n) : th(t) ? e.disconnect(t, n, i) : e.disconnect()
                }
                var Ui = class rN extends tn {
                    constructor() {
                        const t = Pt(rN.getDefaults(), arguments, ["gain", "units"]);
                        super(t),
                        this.name = "Gain",
                        this._gainNode = this.context.createGain(),
                        this.input = this._gainNode,
                        this.output = this._gainNode,
                        this.gain = new Ji({
                            context: this.context,
                            convert: t.convert,
                            param: this._gainNode.gain,
                            units: t.units,
                            value: t.gain,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        }),
                        ii(this, "gain")
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            convert: !0,
                            gain: 1,
                            units: "gain"
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.disconnect(),
                        this.gain.dispose(),
                        this
                    }
                }
                  , cm = class extends tn {
                    constructor(e) {
                        super(e),
                        this.onended = Vn,
                        this._startTime = -1,
                        this._stopTime = -1,
                        this._timeout = -1,
                        this.output = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        this._gainNode = this.output,
                        this.getStateAtTime = function(t) {
                            const n = this.toSeconds(t);
                            return this._startTime !== -1 && n >= this._startTime && (this._stopTime === -1 || n <= this._stopTime) ? "started" : "stopped"
                        }
                        ,
                        this._fadeIn = e.fadeIn,
                        this._fadeOut = e.fadeOut,
                        this._curve = e.curve,
                        this.onended = e.onended
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            curve: "linear",
                            fadeIn: 0,
                            fadeOut: 0,
                            onended: Vn
                        })
                    }
                    _startGain(e, t=1) {
                        Wt(this._startTime === -1, "Source cannot be started more than once");
                        const n = this.toSeconds(this._fadeIn);
                        return this._startTime = e + n,
                        this._startTime = Math.max(this._startTime, this.context.currentTime),
                        n > 0 ? (this._gainNode.gain.setValueAtTime(0, e),
                        this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(t, e + n) : this._gainNode.gain.exponentialApproachValueAtTime(t, e, n)) : this._gainNode.gain.setValueAtTime(t, e),
                        this
                    }
                    stop(e) {
                        return this.log("stop", e),
                        this._stopGain(this.toSeconds(e)),
                        this
                    }
                    _stopGain(e) {
                        Wt(this._startTime !== -1, "'start' must be called before 'stop'"),
                        this.cancelStop();
                        const t = this.toSeconds(this._fadeOut);
                        return this._stopTime = this.toSeconds(e) + t,
                        this._stopTime = Math.max(this._stopTime, this.now()),
                        t > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, t, e) : this._gainNode.gain.targetRampTo(0, t, e) : (this._gainNode.gain.cancelAndHoldAtTime(e),
                        this._gainNode.gain.setValueAtTime(0, e)),
                        this.context.clearTimeout(this._timeout),
                        this._timeout = this.context.setTimeout( () => {
                            const n = this._curve === "exponential" ? t * 2 : 0;
                            this._stopSource(this.now() + n),
                            this._onended()
                        }
                        , this._stopTime - this.context.currentTime),
                        this
                    }
                    _onended() {
                        if (this.onended !== Vn && (this.onended(this),
                        this.onended = Vn,
                        !this.context.isOffline)) {
                            const e = () => this.dispose();
                            typeof requestIdleCallback < "u" ? requestIdleCallback(e) : setTimeout(e, 10)
                        }
                    }
                    get state() {
                        return this.getStateAtTime(this.now())
                    }
                    cancelStop() {
                        return this.log("cancelStop"),
                        Wt(this._startTime !== -1, "Source is not started"),
                        this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime),
                        this.context.clearTimeout(this._timeout),
                        this._stopTime = -1,
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.dispose(),
                        this.onended = Vn,
                        this
                    }
                }
                  , b7 = class oN extends cm {
                    constructor() {
                        const t = Pt(oN.getDefaults(), arguments, ["offset"]);
                        super(t),
                        this.name = "ToneConstantSource",
                        this._source = this.context.createConstantSource(),
                        sh(this._source, this._gainNode),
                        this.offset = new Ji({
                            context: this.context,
                            convert: t.convert,
                            param: this._source.offset,
                            units: t.units,
                            value: t.offset,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        })
                    }
                    static getDefaults() {
                        return Object.assign(cm.getDefaults(), {
                            convert: !0,
                            offset: 1,
                            units: "number"
                        })
                    }
                    start(t) {
                        const n = this.toSeconds(t);
                        return this.log("start", n),
                        this._startGain(n),
                        this._source.start(n),
                        this
                    }
                    _stopSource(t) {
                        this._source.stop(t)
                    }
                    dispose() {
                        return super.dispose(),
                        this.state === "started" && this.stop(),
                        this._source.disconnect(),
                        this.offset.dispose(),
                        this
                    }
                }
                  , Ms = class lN extends tn {
                    constructor() {
                        const t = Pt(lN.getDefaults(), arguments, ["value", "units"]);
                        super(t),
                        this.name = "Signal",
                        this.override = !0,
                        this.output = this._constantSource = new b7({
                            context: this.context,
                            convert: t.convert,
                            offset: t.value,
                            units: t.units,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        }),
                        this._constantSource.start(0),
                        this.input = this._param = this._constantSource.offset
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            convert: !0,
                            units: "number",
                            value: 0
                        })
                    }
                    connect(t, n=0, i=0) {
                        return ob(this, t, n, i),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._param.dispose(),
                        this._constantSource.dispose(),
                        this
                    }
                    setValueAtTime(t, n) {
                        return this._param.setValueAtTime(t, n),
                        this
                    }
                    getValueAtTime(t) {
                        return this._param.getValueAtTime(t)
                    }
                    setRampPoint(t) {
                        return this._param.setRampPoint(t),
                        this
                    }
                    linearRampToValueAtTime(t, n) {
                        return this._param.linearRampToValueAtTime(t, n),
                        this
                    }
                    exponentialRampToValueAtTime(t, n) {
                        return this._param.exponentialRampToValueAtTime(t, n),
                        this
                    }
                    exponentialRampTo(t, n, i) {
                        return this._param.exponentialRampTo(t, n, i),
                        this
                    }
                    linearRampTo(t, n, i) {
                        return this._param.linearRampTo(t, n, i),
                        this
                    }
                    targetRampTo(t, n, i) {
                        return this._param.targetRampTo(t, n, i),
                        this
                    }
                    exponentialApproachValueAtTime(t, n, i) {
                        return this._param.exponentialApproachValueAtTime(t, n, i),
                        this
                    }
                    setTargetAtTime(t, n, i) {
                        return this._param.setTargetAtTime(t, n, i),
                        this
                    }
                    setValueCurveAtTime(t, n, i, s) {
                        return this._param.setValueCurveAtTime(t, n, i, s),
                        this
                    }
                    cancelScheduledValues(t) {
                        return this._param.cancelScheduledValues(t),
                        this
                    }
                    cancelAndHoldAtTime(t) {
                        return this._param.cancelAndHoldAtTime(t),
                        this
                    }
                    rampTo(t, n, i) {
                        return this._param.rampTo(t, n, i),
                        this
                    }
                    get value() {
                        return this._param.value
                    }
                    set value(t) {
                        this._param.value = t
                    }
                    get convert() {
                        return this._param.convert
                    }
                    set convert(t) {
                        this._param.convert = t
                    }
                    get units() {
                        return this._param.units
                    }
                    get overridden() {
                        return this._param.overridden
                    }
                    set overridden(t) {
                        this._param.overridden = t
                    }
                    get maxValue() {
                        return this._param.maxValue
                    }
                    get minValue() {
                        return this._param.minValue
                    }
                    apply(t) {
                        return this._param.apply(t),
                        this
                    }
                }
                ;
                function ob(e, t, n, i) {
                    (t instanceof Ji || kf(t) || t instanceof Ms && t.override) && (t.cancelScheduledValues(0),
                    t.setValueAtTime(0, 0),
                    t instanceof Ms && (t.overridden = !0)),
                    sh(e, t, n, i)
                }
                var E7 = class cN extends Ji {
                    constructor() {
                        const t = Pt(cN.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "TickParam",
                        this._events = new Ql(1 / 0),
                        this._multiplier = 1,
                        this._multiplier = t.multiplier,
                        this._events.cancel(0),
                        this._events.add({
                            ticks: 0,
                            time: 0,
                            type: "setValueAtTime",
                            value: this._fromType(t.value)
                        }),
                        this.setValueAtTime(t.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(Ji.getDefaults(), {
                            multiplier: 1,
                            units: "hertz",
                            value: 1
                        })
                    }
                    setTargetAtTime(t, n, i) {
                        n = this.toSeconds(n),
                        this.setRampPoint(n);
                        const s = this._fromType(t)
                          , r = this._events.get(n)
                          , l = Math.round(Math.max(1 / i, 1));
                        for (let h = 0; h <= l; h++) {
                            const d = i * h + n
                              , p = this._exponentialApproach(r.time, r.value, s, i, d);
                            this.linearRampToValueAtTime(this._toType(p), d)
                        }
                        return this
                    }
                    setValueAtTime(t, n) {
                        const i = this.toSeconds(n);
                        super.setValueAtTime(t, n);
                        const s = this._events.get(i)
                          , r = this._events.previousEvent(s)
                          , l = this._getTicksUntilEvent(r, i);
                        return s.ticks = Math.max(l, 0),
                        this
                    }
                    linearRampToValueAtTime(t, n) {
                        const i = this.toSeconds(n);
                        super.linearRampToValueAtTime(t, n);
                        const s = this._events.get(i)
                          , r = this._events.previousEvent(s)
                          , l = this._getTicksUntilEvent(r, i);
                        return s.ticks = Math.max(l, 0),
                        this
                    }
                    exponentialRampToValueAtTime(t, n) {
                        n = this.toSeconds(n);
                        const i = this._fromType(t)
                          , s = this._events.get(n)
                          , r = Math.round(Math.max((n - s.time) * 10, 1))
                          , l = (n - s.time) / r;
                        for (let h = 0; h <= r; h++) {
                            const d = l * h + s.time
                              , p = this._exponentialInterpolate(s.time, s.value, n, i, d);
                            this.linearRampToValueAtTime(this._toType(p), d)
                        }
                        return this
                    }
                    _getTicksUntilEvent(t, n) {
                        if (t === null)
                            t = {
                                ticks: 0,
                                time: 0,
                                type: "setValueAtTime",
                                value: 0
                            };
                        else if (Nr(t.ticks)) {
                            const l = this._events.previousEvent(t);
                            t.ticks = this._getTicksUntilEvent(l, t.time)
                        }
                        const i = this._fromType(this.getValueAtTime(t.time));
                        let s = this._fromType(this.getValueAtTime(n));
                        const r = this._events.get(n);
                        return r && r.time === n && r.type === "setValueAtTime" && (s = this._fromType(this.getValueAtTime(n - this.sampleTime))),
                        .5 * (n - t.time) * (i + s) + t.ticks
                    }
                    getTicksAtTime(t) {
                        const n = this.toSeconds(t)
                          , i = this._events.get(n);
                        return Math.max(this._getTicksUntilEvent(i, n), 0)
                    }
                    getDurationOfTicks(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.getTicksAtTime(n);
                        return this.getTimeOfTick(s + t) - i
                    }
                    getTimeOfTick(t) {
                        const n = this._events.get(t, "ticks")
                          , i = this._events.getAfter(t, "ticks");
                        if (n && n.ticks === t)
                            return n.time;
                        if (n && i && i.type === "linearRampToValueAtTime" && n.value !== i.value) {
                            const s = this._fromType(this.getValueAtTime(n.time))
                              , r = (this._fromType(this.getValueAtTime(i.time)) - s) / (i.time - n.time)
                              , l = Math.sqrt(Math.pow(s, 2) - 2 * r * (n.ticks - t))
                              , h = (-s + l) / r
                              , d = (-s - l) / r;
                            return (h > 0 ? h : d) + n.time
                        } else
                            return n ? n.value === 0 ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue
                    }
                    ticksToTime(t, n) {
                        return this.getDurationOfTicks(t, n)
                    }
                    timeToTicks(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.toSeconds(t)
                          , r = this.getTicksAtTime(i);
                        return this.getTicksAtTime(i + s) - r
                    }
                    _fromType(t) {
                        return this.units === "bpm" && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t)
                    }
                    _toType(t) {
                        return this.units === "bpm" && this.multiplier ? t / this.multiplier * 60 : super._toType(t)
                    }
                    get multiplier() {
                        return this._multiplier
                    }
                    set multiplier(t) {
                        const n = this.value;
                        this._multiplier = t,
                        this.cancelScheduledValues(0),
                        this.setValueAtTime(n, 0)
                    }
                }
                  , w7 = class uN extends Ms {
                    constructor() {
                        const t = Pt(uN.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "TickSignal",
                        this.input = this._param = new E7({
                            context: this.context,
                            convert: t.convert,
                            multiplier: t.multiplier,
                            param: this._constantSource.offset,
                            units: t.units,
                            value: t.value
                        })
                    }
                    static getDefaults() {
                        return Object.assign(Ms.getDefaults(), {
                            multiplier: 1,
                            units: "hertz",
                            value: 1
                        })
                    }
                    ticksToTime(t, n) {
                        return this._param.ticksToTime(t, n)
                    }
                    timeToTicks(t, n) {
                        return this._param.timeToTicks(t, n)
                    }
                    getTimeOfTick(t) {
                        return this._param.getTimeOfTick(t)
                    }
                    getDurationOfTicks(t, n) {
                        return this._param.getDurationOfTicks(t, n)
                    }
                    getTicksAtTime(t) {
                        return this._param.getTicksAtTime(t)
                    }
                    get multiplier() {
                        return this._param.multiplier
                    }
                    set multiplier(t) {
                        this._param.multiplier = t
                    }
                    dispose() {
                        return super.dispose(),
                        this._param.dispose(),
                        this
                    }
                }
                  , C7 = class hN extends uo {
                    constructor() {
                        const t = Pt(hN.getDefaults(), arguments, ["frequency"]);
                        super(t),
                        this.name = "TickSource",
                        this._state = new Jv,
                        this._tickOffset = new Ql,
                        this._ticksAtTime = new Ql,
                        this._secondsAtTime = new Ql,
                        this.frequency = new w7({
                            context: this.context,
                            units: t.units,
                            value: t.frequency
                        }),
                        ii(this, "frequency"),
                        this._state.setStateAtTime("stopped", 0),
                        this.setTicksAtTime(0, 0)
                    }
                    static getDefaults() {
                        return Object.assign({
                            frequency: 1,
                            units: "hertz"
                        }, uo.getDefaults())
                    }
                    get state() {
                        return this.getStateAtTime(this.now())
                    }
                    start(t, n) {
                        const i = this.toSeconds(t);
                        return this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i),
                        fn(n) && this.setTicksAtTime(n, i),
                        this._ticksAtTime.cancel(i),
                        this._secondsAtTime.cancel(i)),
                        this
                    }
                    stop(t) {
                        const n = this.toSeconds(t);
                        if (this._state.getValueAtTime(n) === "stopped") {
                            const i = this._state.get(n);
                            i && i.time > 0 && (this._tickOffset.cancel(i.time),
                            this._state.cancel(i.time))
                        }
                        return this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this.setTicksAtTime(0, n),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n),
                        this
                    }
                    pause(t) {
                        const n = this.toSeconds(t);
                        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n)),
                        this
                    }
                    cancel(t) {
                        return t = this.toSeconds(t),
                        this._state.cancel(t),
                        this._tickOffset.cancel(t),
                        this._ticksAtTime.cancel(t),
                        this._secondsAtTime.cancel(t),
                        this
                    }
                    getTicksAtTime(t) {
                        const n = this.toSeconds(t)
                          , i = this._state.getLastState("stopped", n)
                          , s = this._ticksAtTime.get(n)
                          , r = {
                            state: "paused",
                            time: n
                        };
                        this._state.add(r);
                        let l = s || i
                          , h = s ? s.ticks : 0
                          , d = null;
                        return this._state.forEachBetween(l.time, n + this.sampleTime, p => {
                            let m = l.time;
                            const v = this._tickOffset.get(p.time);
                            v && v.time >= l.time && (h = v.ticks,
                            m = v.time),
                            l.state === "started" && p.state !== "started" && (h += this.frequency.getTicksAtTime(p.time) - this.frequency.getTicksAtTime(m),
                            p.time !== r.time && (d = {
                                state: p.state,
                                time: p.time,
                                ticks: h
                            })),
                            l = p
                        }
                        ),
                        this._state.remove(r),
                        d && this._ticksAtTime.add(d),
                        h
                    }
                    get ticks() {
                        return this.getTicksAtTime(this.now())
                    }
                    set ticks(t) {
                        this.setTicksAtTime(t, this.now())
                    }
                    get seconds() {
                        return this.getSecondsAtTime(this.now())
                    }
                    set seconds(t) {
                        const n = this.now()
                          , i = this.frequency.timeToTicks(t, n);
                        this.setTicksAtTime(i, n)
                    }
                    getSecondsAtTime(t) {
                        t = this.toSeconds(t);
                        const n = this._state.getLastState("stopped", t)
                          , i = {
                            state: "paused",
                            time: t
                        };
                        this._state.add(i);
                        const s = this._secondsAtTime.get(t);
                        let r = s || n
                          , l = s ? s.seconds : 0
                          , h = null;
                        return this._state.forEachBetween(r.time, t + this.sampleTime, d => {
                            let p = r.time;
                            const m = this._tickOffset.get(d.time);
                            m && m.time >= r.time && (l = m.seconds,
                            p = m.time),
                            r.state === "started" && d.state !== "started" && (l += d.time - p,
                            d.time !== i.time && (h = {
                                state: d.state,
                                time: d.time,
                                seconds: l
                            })),
                            r = d
                        }
                        ),
                        this._state.remove(i),
                        h && this._secondsAtTime.add(h),
                        l
                    }
                    setTicksAtTime(t, n) {
                        return n = this.toSeconds(n),
                        this._tickOffset.cancel(n),
                        this._tickOffset.add({
                            seconds: this.frequency.getDurationOfTicks(t, n),
                            ticks: t,
                            time: n
                        }),
                        this._ticksAtTime.cancel(n),
                        this._secondsAtTime.cancel(n),
                        this
                    }
                    getStateAtTime(t) {
                        return t = this.toSeconds(t),
                        this._state.getValueAtTime(t)
                    }
                    getTimeOfTick(t, n=this.now()) {
                        const i = this._tickOffset.get(n)
                          , s = this._state.get(n)
                          , r = Math.max(i.time, s.time)
                          , l = this.frequency.getTicksAtTime(r) + t - i.ticks;
                        return this.frequency.getTimeOfTick(l)
                    }
                    forEachTickBetween(t, n, i) {
                        let s = this._state.get(t);
                        this._state.forEachBetween(t, n, l => {
                            s && s.state === "started" && l.state !== "started" && this.forEachTickBetween(Math.max(s.time, t), l.time - this.sampleTime, i),
                            s = l
                        }
                        );
                        let r = null;
                        if (s && s.state === "started") {
                            const l = Math.max(s.time, t)
                              , h = this.frequency.getTicksAtTime(l)
                              , d = this.frequency.getTicksAtTime(s.time)
                              , p = h - d;
                            let m = Math.ceil(p) - p;
                            m = Ko(m, 1) ? 0 : m;
                            let v = this.frequency.getTimeOfTick(h + m);
                            for (; v < n; ) {
                                try {
                                    i(v, Math.round(this.getTicksAtTime(v)))
                                } catch (_) {
                                    r = _;
                                    break
                                }
                                v += this.frequency.getDurationOfTicks(1, v)
                            }
                        }
                        if (r)
                            throw r;
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._state.dispose(),
                        this._tickOffset.dispose(),
                        this._ticksAtTime.dispose(),
                        this._secondsAtTime.dispose(),
                        this.frequency.dispose(),
                        this
                    }
                }
                  , tO = class fN extends uo {
                    constructor() {
                        const t = Pt(fN.getDefaults(), arguments, ["callback", "frequency"]);
                        super(t),
                        this.name = "Clock",
                        this.callback = Vn,
                        this._lastUpdate = 0,
                        this._state = new Jv("stopped"),
                        this._boundLoop = this._loop.bind(this),
                        this.callback = t.callback,
                        this._tickSource = new C7({
                            context: this.context,
                            frequency: t.frequency,
                            units: t.units
                        }),
                        this._lastUpdate = 0,
                        this.frequency = this._tickSource.frequency,
                        ii(this, "frequency"),
                        this._state.setStateAtTime("stopped", 0),
                        this.context.on("tick", this._boundLoop)
                    }
                    static getDefaults() {
                        return Object.assign(uo.getDefaults(), {
                            callback: Vn,
                            frequency: 1,
                            units: "hertz"
                        })
                    }
                    get state() {
                        return this._state.getValueAtTime(this.now())
                    }
                    start(t, n) {
                        G2(this.context);
                        const i = this.toSeconds(t);
                        return this.log("start", i),
                        this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i),
                        this._tickSource.start(i, n),
                        i < this._lastUpdate && this.emit("start", i, n)),
                        this
                    }
                    stop(t) {
                        const n = this.toSeconds(t);
                        return this.log("stop", n),
                        this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this._tickSource.stop(n),
                        n < this._lastUpdate && this.emit("stop", n),
                        this
                    }
                    pause(t) {
                        const n = this.toSeconds(t);
                        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n),
                        this._tickSource.pause(n),
                        n < this._lastUpdate && this.emit("pause", n)),
                        this
                    }
                    get ticks() {
                        return Math.ceil(this.getTicksAtTime(this.now()))
                    }
                    set ticks(t) {
                        this._tickSource.ticks = t
                    }
                    get seconds() {
                        return this._tickSource.seconds
                    }
                    set seconds(t) {
                        this._tickSource.seconds = t
                    }
                    getSecondsAtTime(t) {
                        return this._tickSource.getSecondsAtTime(t)
                    }
                    setTicksAtTime(t, n) {
                        return this._tickSource.setTicksAtTime(t, n),
                        this
                    }
                    getTimeOfTick(t, n=this.now()) {
                        return this._tickSource.getTimeOfTick(t, n)
                    }
                    getTicksAtTime(t) {
                        return this._tickSource.getTicksAtTime(t)
                    }
                    nextTickTime(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.getTicksAtTime(i);
                        return this._tickSource.getTimeOfTick(s + t, i)
                    }
                    _loop() {
                        const t = this._lastUpdate
                          , n = this.now();
                        this._lastUpdate = n,
                        this.log("loop", t, n),
                        t !== n && (this._state.forEachBetween(t, n, i => {
                            switch (i.state) {
                            case "started":
                                const s = this._tickSource.getTicksAtTime(i.time);
                                this.emit("start", i.time, s);
                                break;
                            case "stopped":
                                i.time !== 0 && this.emit("stop", i.time);
                                break;
                            case "paused":
                                this.emit("pause", i.time);
                                break
                            }
                        }
                        ),
                        this._tickSource.forEachTickBetween(t, n, (i, s) => {
                            this.callback(i, s)
                        }
                        ))
                    }
                    getStateAtTime(t) {
                        const n = this.toSeconds(t);
                        return this._state.getValueAtTime(n)
                    }
                    dispose() {
                        return super.dispose(),
                        this.context.off("tick", this._boundLoop),
                        this._tickSource.dispose(),
                        this._state.dispose(),
                        this
                    }
                }
                ;
                sb.mixin(tO);
                var R7 = class dN extends tn {
                    constructor() {
                        const t = Pt(dN.getDefaults(), arguments, ["delayTime", "maxDelay"]);
                        super(t),
                        this.name = "Delay";
                        const n = this.toSeconds(t.maxDelay);
                        this._maxDelay = Math.max(n, this.toSeconds(t.delayTime)),
                        this._delayNode = this.input = this.output = this.context.createDelay(n),
                        this.delayTime = new Ji({
                            context: this.context,
                            param: this._delayNode.delayTime,
                            units: "time",
                            value: t.delayTime,
                            minValue: 0,
                            maxValue: this.maxDelay
                        }),
                        ii(this, "delayTime")
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            delayTime: 0,
                            maxDelay: 1
                        })
                    }
                    get maxDelay() {
                        return this._maxDelay
                    }
                    dispose() {
                        return super.dispose(),
                        this._delayNode.disconnect(),
                        this.delayTime.dispose(),
                        this
                    }
                }
                  , fS = class pN extends tn {
                    constructor() {
                        const t = Pt(pN.getDefaults(), arguments, ["volume"]);
                        super(t),
                        this.name = "Volume",
                        this.input = this.output = new Ui({
                            context: this.context,
                            gain: t.volume,
                            units: "decibels"
                        }),
                        this.volume = this.output.gain,
                        ii(this, "volume"),
                        this._unmutedVolume = t.volume,
                        this.mute = t.mute
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            mute: !1,
                            volume: 0
                        })
                    }
                    get mute() {
                        return this.volume.value === -1 / 0
                    }
                    set mute(t) {
                        !this.mute && t ? (this._unmutedVolume = this.volume.value,
                        this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume)
                    }
                    dispose() {
                        return super.dispose(),
                        this.input.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                  , D7 = class mN extends tn {
                    constructor() {
                        const t = Pt(mN.getDefaults(), arguments);
                        super(t),
                        this.name = "Destination",
                        this.input = new fS({
                            context: this.context
                        }),
                        this.output = new Ui({
                            context: this.context
                        }),
                        this.volume = this.input.volume,
                        rb(this.input, this.output, this.context.rawContext.destination),
                        this.mute = t.mute,
                        this._internalChannels = [this.input, this.context.rawContext.destination, this.output]
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            mute: !1,
                            volume: 0
                        })
                    }
                    get mute() {
                        return this.input.mute
                    }
                    set mute(t) {
                        this.input.mute = t
                    }
                    chain(...t) {
                        return this.input.disconnect(),
                        t.unshift(this.input),
                        t.push(this.output),
                        rb(...t),
                        this
                    }
                    get maxChannelCount() {
                        return this.context.rawContext.destination.maxChannelCount
                    }
                    dispose() {
                        return super.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                ;
                lS(e => {
                    e.destination = new D7({
                        context: e
                    })
                }
                ),
                cS(e => {
                    e.destination.dispose()
                }
                );
                var O7 = class extends tn {
                    constructor() {
                        super(...arguments),
                        this.name = "Listener",
                        this.positionX = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.positionX
                        }),
                        this.positionY = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.positionY
                        }),
                        this.positionZ = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.positionZ
                        }),
                        this.forwardX = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardX
                        }),
                        this.forwardY = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardY
                        }),
                        this.forwardZ = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.forwardZ
                        }),
                        this.upX = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.upX
                        }),
                        this.upY = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.upY
                        }),
                        this.upZ = new Ji({
                            context: this.context,
                            param: this.context.rawContext.listener.upZ
                        })
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            positionX: 0,
                            positionY: 0,
                            positionZ: 0,
                            forwardX: 0,
                            forwardY: 0,
                            forwardZ: -1,
                            upX: 0,
                            upY: 1,
                            upZ: 0
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.positionX.dispose(),
                        this.positionY.dispose(),
                        this.positionZ.dispose(),
                        this.forwardX.dispose(),
                        this.forwardY.dispose(),
                        this.forwardZ.dispose(),
                        this.upX.dispose(),
                        this.upY.dispose(),
                        this.upZ.dispose(),
                        this
                    }
                }
                ;
                lS(e => {
                    e.listener = new O7({
                        context: e
                    })
                }
                ),
                cS(e => {
                    e.listener.dispose()
                }
                );
                var N7 = class gN extends Ic {
                    constructor() {
                        super(),
                        this.name = "ToneAudioBuffers",
                        this._buffers = new Map,
                        this._loadingCount = 0;
                        const t = Pt(gN.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
                        this.baseUrl = t.baseUrl,
                        Object.keys(t.urls).forEach(n => {
                            this._loadingCount++;
                            const i = t.urls[n];
                            this.add(n, i, this._bufferLoaded.bind(this, t.onload), t.onerror)
                        }
                        )
                    }
                    static getDefaults() {
                        return {
                            baseUrl: "",
                            onerror: Vn,
                            onload: Vn,
                            urls: {}
                        }
                    }
                    has(t) {
                        return this._buffers.has(t.toString())
                    }
                    get(t) {
                        return Wt(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`),
                        this._buffers.get(t.toString())
                    }
                    _bufferLoaded(t) {
                        this._loadingCount--,
                        this._loadingCount === 0 && t && t()
                    }
                    get loaded() {
                        return Array.from(this._buffers).every( ([t,n]) => n.loaded)
                    }
                    add(t, n, i=Vn, s=Vn) {
                        return Wl(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""),
                        this._buffers.set(t.toString(), new Jo(this.baseUrl + n,i,s))) : this._buffers.set(t.toString(), new Jo(n,i,s)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffers.forEach(t => t.dispose()),
                        this._buffers.clear(),
                        this
                    }
                }
                  , nO = class vN extends ih {
                    constructor() {
                        super(...arguments),
                        this.name = "MidiClass",
                        this.defaultUnits = "midi"
                    }
                    _frequencyToUnits(t) {
                        return Yf(super._frequencyToUnits(t))
                    }
                    _ticksToUnits(t) {
                        return Yf(super._ticksToUnits(t))
                    }
                    _beatsToUnits(t) {
                        return Yf(super._beatsToUnits(t))
                    }
                    _secondsToUnits(t) {
                        return Yf(super._secondsToUnits(t))
                    }
                    toMidi() {
                        return this.valueOf()
                    }
                    toFrequency() {
                        return eO(this.toMidi())
                    }
                    transpose(t) {
                        return new vN(this.context,this.toMidi() + t)
                    }
                }
                  , Gi = class extends lm {
                    constructor() {
                        super(...arguments),
                        this.name = "Ticks",
                        this.defaultUnits = "i"
                    }
                    _now() {
                        return this.context.transport.ticks
                    }
                    _beatsToUnits(e) {
                        return this._getPPQ() * e
                    }
                    _secondsToUnits(e) {
                        return Math.floor(e / (60 / this._getBpm()) * this._getPPQ())
                    }
                    _ticksToUnits(e) {
                        return e
                    }
                    toTicks() {
                        return this.valueOf()
                    }
                    toSeconds() {
                        return this.valueOf() / this._getPPQ() * (60 / this._getBpm())
                    }
                }
                  , U7 = class extends uo {
                    constructor() {
                        super(...arguments),
                        this.name = "Draw",
                        this.expiration = .25,
                        this.anticipation = .008,
                        this._events = new Ql,
                        this._boundDrawLoop = this._drawLoop.bind(this),
                        this._animationFrame = -1
                    }
                    schedule(e, t) {
                        return this._events.add({
                            callback: e,
                            time: this.toSeconds(t)
                        }),
                        this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)),
                        this
                    }
                    cancel(e) {
                        return this._events.cancel(this.toSeconds(e)),
                        this
                    }
                    _drawLoop() {
                        const e = this.context.currentTime;
                        this._events.forEachBefore(e + this.anticipation, t => {
                            e - t.time <= this.expiration && t.callback(),
                            this._events.remove(t)
                        }
                        ),
                        this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop))
                    }
                    dispose() {
                        return super.dispose(),
                        this._events.dispose(),
                        cancelAnimationFrame(this._animationFrame),
                        this
                    }
                }
                ;
                lS(e => {
                    e.draw = new U7({
                        context: e
                    })
                }
                ),
                cS(e => {
                    e.draw.dispose()
                }
                );
                var B7 = class extends Ic {
                    constructor() {
                        super(...arguments),
                        this.name = "IntervalTimeline",
                        this._root = null,
                        this._length = 0
                    }
                    add(e) {
                        Wt(fn(e.time), "Events must have a time property"),
                        Wt(fn(e.duration), "Events must have a duration parameter"),
                        e.time = e.time.valueOf();
                        let t = new P7(e.time,e.time + e.duration,e);
                        for (this._root === null ? this._root = t : this._root.insert(t),
                        this._length++; t !== null; )
                            t.updateHeight(),
                            t.updateMax(),
                            this._rebalance(t),
                            t = t.parent;
                        return this
                    }
                    remove(e) {
                        if (this._root !== null) {
                            const t = [];
                            this._root.search(e.time, t);
                            for (const n of t)
                                if (n.event === e) {
                                    this._removeNode(n),
                                    this._length--;
                                    break
                                }
                        }
                        return this
                    }
                    get length() {
                        return this._length
                    }
                    cancel(e) {
                        return this.forEachFrom(e, t => this.remove(t)),
                        this
                    }
                    _setRoot(e) {
                        this._root = e,
                        this._root !== null && (this._root.parent = null)
                    }
                    _replaceNodeInParent(e, t) {
                        e.parent !== null ? (e.isLeftChild() ? e.parent.left = t : e.parent.right = t,
                        this._rebalance(e.parent)) : this._setRoot(t)
                    }
                    _removeNode(e) {
                        if (e.left === null && e.right === null)
                            this._replaceNodeInParent(e, null);
                        else if (e.right === null)
                            this._replaceNodeInParent(e, e.left);
                        else if (e.left === null)
                            this._replaceNodeInParent(e, e.right);
                        else {
                            const t = e.getBalance();
                            let n, i = null;
                            if (t > 0)
                                if (e.left.right === null)
                                    n = e.left,
                                    n.right = e.right,
                                    i = n;
                                else {
                                    for (n = e.left.right; n.right !== null; )
                                        n = n.right;
                                    n.parent && (n.parent.right = n.left,
                                    i = n.parent,
                                    n.left = e.left,
                                    n.right = e.right)
                                }
                            else if (e.right.left === null)
                                n = e.right,
                                n.left = e.left,
                                i = n;
                            else {
                                for (n = e.right.left; n.left !== null; )
                                    n = n.left;
                                n.parent && (n.parent.left = n.right,
                                i = n.parent,
                                n.left = e.left,
                                n.right = e.right)
                            }
                            e.parent !== null ? e.isLeftChild() ? e.parent.left = n : e.parent.right = n : this._setRoot(n),
                            i && this._rebalance(i)
                        }
                        e.dispose()
                    }
                    _rotateLeft(e) {
                        const t = e.parent
                          , n = e.isLeftChild()
                          , i = e.right;
                        i && (e.right = i.left,
                        i.left = e),
                        t !== null ? n ? t.left = i : t.right = i : this._setRoot(i)
                    }
                    _rotateRight(e) {
                        const t = e.parent
                          , n = e.isLeftChild()
                          , i = e.left;
                        i && (e.left = i.right,
                        i.right = e),
                        t !== null ? n ? t.left = i : t.right = i : this._setRoot(i)
                    }
                    _rebalance(e) {
                        const t = e.getBalance();
                        t > 1 && e.left ? e.left.getBalance() < 0 ? this._rotateLeft(e.left) : this._rotateRight(e) : t < -1 && e.right && (e.right.getBalance() > 0 ? this._rotateRight(e.right) : this._rotateLeft(e))
                    }
                    get(e) {
                        if (this._root !== null) {
                            const t = [];
                            if (this._root.search(e, t),
                            t.length > 0) {
                                let n = t[0];
                                for (let i = 1; i < t.length; i++)
                                    t[i].low > n.low && (n = t[i]);
                                return n.event
                            }
                        }
                        return null
                    }
                    forEach(e) {
                        if (this._root !== null) {
                            const t = [];
                            this._root.traverse(n => t.push(n)),
                            t.forEach(n => {
                                n.event && e(n.event)
                            }
                            )
                        }
                        return this
                    }
                    forEachAtTime(e, t) {
                        if (this._root !== null) {
                            const n = [];
                            this._root.search(e, n),
                            n.forEach(i => {
                                i.event && t(i.event)
                            }
                            )
                        }
                        return this
                    }
                    forEachFrom(e, t) {
                        if (this._root !== null) {
                            const n = [];
                            this._root.searchAfter(e, n),
                            n.forEach(i => {
                                i.event && t(i.event)
                            }
                            )
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._root !== null && this._root.traverse(e => e.dispose()),
                        this._root = null,
                        this
                    }
                }
                  , P7 = class {
                    constructor(e, t, n) {
                        this._left = null,
                        this._right = null,
                        this.parent = null,
                        this.height = 0,
                        this.event = n,
                        this.low = e,
                        this.high = t,
                        this.max = this.high
                    }
                    insert(e) {
                        e.low <= this.low ? this.left === null ? this.left = e : this.left.insert(e) : this.right === null ? this.right = e : this.right.insert(e)
                    }
                    search(e, t) {
                        e > this.max || (this.left !== null && this.left.search(e, t),
                        this.low <= e && this.high > e && t.push(this),
                        !(this.low > e) && this.right !== null && this.right.search(e, t))
                    }
                    searchAfter(e, t) {
                        this.low >= e && (t.push(this),
                        this.left !== null && this.left.searchAfter(e, t)),
                        this.right !== null && this.right.searchAfter(e, t)
                    }
                    traverse(e) {
                        e(this),
                        this.left !== null && this.left.traverse(e),
                        this.right !== null && this.right.traverse(e)
                    }
                    updateHeight() {
                        this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0
                    }
                    updateMax() {
                        this.max = this.high,
                        this.left !== null && (this.max = Math.max(this.max, this.left.max)),
                        this.right !== null && (this.max = Math.max(this.max, this.right.max))
                    }
                    getBalance() {
                        let e = 0;
                        return this.left !== null && this.right !== null ? e = this.left.height - this.right.height : this.left !== null ? e = this.left.height + 1 : this.right !== null && (e = -(this.right.height + 1)),
                        e
                    }
                    isLeftChild() {
                        return this.parent !== null && this.parent.left === this
                    }
                    get left() {
                        return this._left
                    }
                    set left(e) {
                        this._left = e,
                        e !== null && (e.parent = this),
                        this.updateHeight(),
                        this.updateMax()
                    }
                    get right() {
                        return this._right
                    }
                    set right(e) {
                        this._right = e,
                        e !== null && (e.parent = this),
                        this.updateHeight(),
                        this.updateMax()
                    }
                    dispose() {
                        this.parent = null,
                        this._left = null,
                        this._right = null,
                        this.event = null
                    }
                }
                  , I7 = class extends Ic {
                    constructor(e) {
                        super(),
                        this.name = "TimelineValue",
                        this._timeline = new Ql({
                            memory: 10
                        }),
                        this._initialValue = e
                    }
                    set(e, t) {
                        return this._timeline.add({
                            value: e,
                            time: t
                        }),
                        this
                    }
                    get(e) {
                        const t = this._timeline.get(e);
                        return t ? t.value : this._initialValue
                    }
                }
                  , $v = class yN extends tn {
                    constructor() {
                        super(Pt(yN.getDefaults(), arguments, ["context"]))
                    }
                    connect(t, n=0, i=0) {
                        return ob(this, t, n, i),
                        this
                    }
                }
                  , dS = class _N extends $v {
                    constructor() {
                        const t = Pt(_N.getDefaults(), arguments, ["mapping", "length"]);
                        super(t),
                        this.name = "WaveShaper",
                        this._shaper = this.context.createWaveShaper(),
                        this.input = this._shaper,
                        this.output = this._shaper,
                        ha(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : $8(t.mapping) && this.setMap(t.mapping, t.length)
                    }
                    static getDefaults() {
                        return Object.assign(Ms.getDefaults(), {
                            length: 1024
                        })
                    }
                    setMap(t, n=1024) {
                        const i = new Float32Array(n);
                        for (let s = 0, r = n; s < r; s++) {
                            const l = s / (r - 1) * 2 - 1;
                            i[s] = t(l, s)
                        }
                        return this.curve = i,
                        this
                    }
                    get curve() {
                        return this._shaper.curve
                    }
                    set curve(t) {
                        this._shaper.curve = t
                    }
                    get oversample() {
                        return this._shaper.oversample
                    }
                    set oversample(t) {
                        const n = ["none", "2x", "4x"].some(i => i.includes(t));
                        Wt(n, "oversampling must be either 'none', '2x', or '4x'"),
                        this._shaper.oversample = t
                    }
                    dispose() {
                        return super.dispose(),
                        this._shaper.disconnect(),
                        this
                    }
                }
                  , L7 = class xN extends $v {
                    constructor() {
                        const t = Pt(xN.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "Pow",
                        this._exponentScaler = this.input = this.output = new dS({
                            context: this.context,
                            mapping: this._expFunc(t.value),
                            length: 8192
                        }),
                        this._exponent = t.value
                    }
                    static getDefaults() {
                        return Object.assign($v.getDefaults(), {
                            value: 1
                        })
                    }
                    _expFunc(t) {
                        return n => Math.pow(Math.abs(n), t)
                    }
                    get value() {
                        return this._exponent
                    }
                    set value(t) {
                        this._exponent = t,
                        this._exponentScaler.setMap(this._expFunc(this._exponent))
                    }
                    dispose() {
                        return super.dispose(),
                        this._exponentScaler.dispose(),
                        this
                    }
                }
                  , e0 = class vb {
                    constructor(t, n) {
                        this.id = vb._eventId++,
                        this._remainderTime = 0;
                        const i = Object.assign(vb.getDefaults(), n);
                        this.transport = t,
                        this.callback = i.callback,
                        this._once = i.once,
                        this.time = Math.floor(i.time),
                        this._remainderTime = i.time - this.time
                    }
                    static getDefaults() {
                        return {
                            callback: Vn,
                            once: !1,
                            time: 0
                        }
                    }
                    get floatTime() {
                        return this.time + this._remainderTime
                    }
                    invoke(t) {
                        if (this.callback) {
                            const n = this.transport.bpm.getDurationOfTicks(1, t);
                            this.callback(t + this._remainderTime * n),
                            this._once && this.transport.clear(this.id)
                        }
                    }
                    dispose() {
                        return this.callback = void 0,
                        this
                    }
                }
                ;
                e0._eventId = 0;
                var z7 = class SN extends e0 {
                    constructor(t, n) {
                        super(t, n),
                        this._currentId = -1,
                        this._nextId = -1,
                        this._nextTick = this.time,
                        this._boundRestart = this._restart.bind(this);
                        const i = Object.assign(SN.getDefaults(), n);
                        this.duration = i.duration,
                        this._interval = i.interval,
                        this._nextTick = i.time,
                        this.transport.on("start", this._boundRestart),
                        this.transport.on("loopStart", this._boundRestart),
                        this.transport.on("ticks", this._boundRestart),
                        this.context = this.transport.context,
                        this._restart()
                    }
                    static getDefaults() {
                        return Object.assign({}, e0.getDefaults(), {
                            duration: 1 / 0,
                            interval: 1,
                            once: !1
                        })
                    }
                    invoke(t) {
                        this._createEvents(t),
                        super.invoke(t)
                    }
                    _createEvent() {
                        return oS(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new Gi(this.context,this._nextTick).toSeconds()) : -1
                    }
                    _createEvents(t) {
                        oS(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval,
                        this._currentId = this._nextId,
                        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Gi(this.context,this._nextTick).toSeconds()))
                    }
                    _restart(t) {
                        this.transport.clear(this._currentId),
                        this.transport.clear(this._nextId),
                        this._nextTick = this.floatTime;
                        const n = this.transport.getTicksAtTime(t);
                        om(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval),
                        this._currentId = this._createEvent(),
                        this._nextTick += this._interval,
                        this._nextId = this._createEvent()
                    }
                    dispose() {
                        return super.dispose(),
                        this.transport.clear(this._currentId),
                        this.transport.clear(this._nextId),
                        this.transport.off("start", this._boundRestart),
                        this.transport.off("loopStart", this._boundRestart),
                        this.transport.off("ticks", this._boundRestart),
                        this
                    }
                }
                  , iO = class AN extends uo {
                    constructor() {
                        const t = Pt(AN.getDefaults(), arguments);
                        super(t),
                        this.name = "Transport",
                        this._loop = new I7(!1),
                        this._loopStart = 0,
                        this._loopEnd = 0,
                        this._scheduledEvents = {},
                        this._timeline = new Ql,
                        this._repeatedEvents = new B7,
                        this._syncedSignals = [],
                        this._swingAmount = 0,
                        this._ppq = t.ppq,
                        this._clock = new tO({
                            callback: this._processTick.bind(this),
                            context: this.context,
                            frequency: 0,
                            units: "bpm"
                        }),
                        this._bindClockEvents(),
                        this.bpm = this._clock.frequency,
                        this._clock.frequency.multiplier = t.ppq,
                        this.bpm.setValueAtTime(t.bpm, 0),
                        ii(this, "bpm"),
                        this._timeSignature = t.timeSignature,
                        this._swingTicks = t.ppq / 2
                    }
                    static getDefaults() {
                        return Object.assign(uo.getDefaults(), {
                            bpm: 120,
                            loopEnd: "4m",
                            loopStart: 0,
                            ppq: 192,
                            swing: 0,
                            swingSubdivision: "8n",
                            timeSignature: 4
                        })
                    }
                    _processTick(t, n) {
                        if (this._loop.get(t) && n >= this._loopEnd && (this.emit("loopEnd", t),
                        this._clock.setTicksAtTime(this._loopStart, t),
                        n = this._loopStart,
                        this.emit("loopStart", t, this._clock.getSecondsAtTime(t)),
                        this.emit("loop", t)),
                        this._swingAmount > 0 && n % this._ppq !== 0 && n % (this._swingTicks * 2) !== 0) {
                            const i = n % (this._swingTicks * 2) / (this._swingTicks * 2)
                              , s = Math.sin(i * Math.PI) * this._swingAmount;
                            t += new Gi(this.context,this._swingTicks * 2 / 3).toSeconds() * s
                        }
                        q2(!0),
                        this._timeline.forEachAtTime(n, i => i.invoke(t)),
                        q2(!1)
                    }
                    schedule(t, n) {
                        const i = new e0(this,{
                            callback: t,
                            time: new lm(this.context,n).toTicks()
                        });
                        return this._addEvent(i, this._timeline)
                    }
                    scheduleRepeat(t, n, i, s=1 / 0) {
                        const r = new z7(this,{
                            callback: t,
                            duration: new Wf(this.context,s).toTicks(),
                            interval: new Wf(this.context,n).toTicks(),
                            time: new lm(this.context,i).toTicks()
                        });
                        return this._addEvent(r, this._repeatedEvents)
                    }
                    scheduleOnce(t, n) {
                        const i = new e0(this,{
                            callback: t,
                            once: !0,
                            time: new lm(this.context,n).toTicks()
                        });
                        return this._addEvent(i, this._timeline)
                    }
                    clear(t) {
                        if (this._scheduledEvents.hasOwnProperty(t)) {
                            const n = this._scheduledEvents[t.toString()];
                            n.timeline.remove(n.event),
                            n.event.dispose(),
                            delete this._scheduledEvents[t.toString()]
                        }
                        return this
                    }
                    _addEvent(t, n) {
                        return this._scheduledEvents[t.id.toString()] = {
                            event: t,
                            timeline: n
                        },
                        n.add(t),
                        t.id
                    }
                    cancel(t=0) {
                        const n = this.toTicks(t);
                        return this._timeline.forEachFrom(n, i => this.clear(i.id)),
                        this._repeatedEvents.forEachFrom(n, i => this.clear(i.id)),
                        this
                    }
                    _bindClockEvents() {
                        this._clock.on("start", (t, n) => {
                            n = new Gi(this.context,n).toSeconds(),
                            this.emit("start", t, n)
                        }
                        ),
                        this._clock.on("stop", t => {
                            this.emit("stop", t)
                        }
                        ),
                        this._clock.on("pause", t => {
                            this.emit("pause", t)
                        }
                        )
                    }
                    get state() {
                        return this._clock.getStateAtTime(this.now())
                    }
                    start(t, n) {
                        this.context.resume();
                        let i;
                        return fn(n) && (i = this.toTicks(n)),
                        this._clock.start(t, i),
                        this
                    }
                    stop(t) {
                        return this._clock.stop(t),
                        this
                    }
                    pause(t) {
                        return this._clock.pause(t),
                        this
                    }
                    toggle(t) {
                        return t = this.toSeconds(t),
                        this._clock.getStateAtTime(t) !== "started" ? this.start(t) : this.stop(t),
                        this
                    }
                    get timeSignature() {
                        return this._timeSignature
                    }
                    set timeSignature(t) {
                        ha(t) && (t = t[0] / t[1] * 4),
                        this._timeSignature = t
                    }
                    get loopStart() {
                        return new Wf(this.context,this._loopStart,"i").toSeconds()
                    }
                    set loopStart(t) {
                        this._loopStart = this.toTicks(t)
                    }
                    get loopEnd() {
                        return new Wf(this.context,this._loopEnd,"i").toSeconds()
                    }
                    set loopEnd(t) {
                        this._loopEnd = this.toTicks(t)
                    }
                    get loop() {
                        return this._loop.get(this.now())
                    }
                    set loop(t) {
                        this._loop.set(t, this.now())
                    }
                    setLoopPoints(t, n) {
                        return this.loopStart = t,
                        this.loopEnd = n,
                        this
                    }
                    get swing() {
                        return this._swingAmount
                    }
                    set swing(t) {
                        this._swingAmount = t
                    }
                    get swingSubdivision() {
                        return new Gi(this.context,this._swingTicks).toNotation()
                    }
                    set swingSubdivision(t) {
                        this._swingTicks = this.toTicks(t)
                    }
                    get position() {
                        const t = this.now()
                          , n = this._clock.getTicksAtTime(t);
                        return new Gi(this.context,n).toBarsBeatsSixteenths()
                    }
                    set position(t) {
                        this.ticks = this.toTicks(t)
                    }
                    get seconds() {
                        return this._clock.seconds
                    }
                    set seconds(t) {
                        const n = this.now();
                        this.ticks = this._clock.frequency.timeToTicks(t, n)
                    }
                    get progress() {
                        if (this.loop) {
                            const t = this.now();
                            return (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart)
                        } else
                            return 0
                    }
                    get ticks() {
                        return this._clock.ticks
                    }
                    set ticks(t) {
                        if (this._clock.ticks !== t) {
                            const n = this.now();
                            if (this.state === "started") {
                                const i = this._clock.getTicksAtTime(n)
                                  , s = this._clock.frequency.getDurationOfTicks(Math.ceil(i) - i, n)
                                  , r = n + s;
                                this.emit("stop", r),
                                this._clock.setTicksAtTime(t, r),
                                this.emit("start", r, this._clock.getSecondsAtTime(r))
                            } else
                                this.emit("ticks", n),
                                this._clock.setTicksAtTime(t, n)
                        }
                    }
                    getTicksAtTime(t) {
                        return this._clock.getTicksAtTime(t)
                    }
                    getSecondsAtTime(t) {
                        return this._clock.getSecondsAtTime(t)
                    }
                    get PPQ() {
                        return this._clock.frequency.multiplier
                    }
                    set PPQ(t) {
                        this._clock.frequency.multiplier = t
                    }
                    nextSubdivision(t) {
                        if (t = this.toTicks(t),
                        this.state !== "started")
                            return 0;
                        {
                            const n = this.now()
                              , i = this.getTicksAtTime(n)
                              , s = t - i % t;
                            return this._clock.nextTickTime(s, n)
                        }
                    }
                    syncSignal(t, n) {
                        const i = this.now();
                        let s = this.bpm
                          , r = 1 / (60 / s.getValueAtTime(i) / this.PPQ)
                          , l = [];
                        if (t.units === "time") {
                            const d = .015625 / r
                              , p = new Ui(d)
                              , m = new L7(-1)
                              , v = new Ui(d);
                            s.chain(p, m, v),
                            s = v,
                            r = 1 / r,
                            l = [p, m, v]
                        }
                        n || (t.getValueAtTime(i) !== 0 ? n = t.getValueAtTime(i) / r : n = 0);
                        const h = new Ui(n);
                        return s.connect(h),
                        h.connect(t._param),
                        l.push(h),
                        this._syncedSignals.push({
                            initial: t.value,
                            nodes: l,
                            signal: t
                        }),
                        t.value = 0,
                        this
                    }
                    unsyncSignal(t) {
                        for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
                            const i = this._syncedSignals[n];
                            i.signal === t && (i.nodes.forEach(s => s.dispose()),
                            i.signal.value = i.initial,
                            this._syncedSignals.splice(n, 1))
                        }
                        return this
                    }
                    dispose() {
                        return super.dispose(),
                        this._clock.dispose(),
                        Z2(this, "bpm"),
                        this._timeline.dispose(),
                        this._repeatedEvents.dispose(),
                        this
                    }
                }
                ;
                sb.mixin(iO),
                lS(e => {
                    e.transport = new iO({
                        context: e
                    })
                }
                ),
                cS(e => {
                    e.transport.dispose()
                }
                );
                var js = class extends tn {
                    constructor(e) {
                        super(e),
                        this.input = void 0,
                        this._state = new Jv("stopped"),
                        this._synced = !1,
                        this._scheduled = [],
                        this._syncedStart = Vn,
                        this._syncedStop = Vn,
                        this._state.memory = 100,
                        this._state.increasing = !0,
                        this._volume = this.output = new fS({
                            context: this.context,
                            mute: e.mute,
                            volume: e.volume
                        }),
                        this.volume = this._volume.volume,
                        ii(this, "volume"),
                        this.onstop = e.onstop
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            mute: !1,
                            onstop: Vn,
                            volume: 0
                        })
                    }
                    get state() {
                        return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now())
                    }
                    get mute() {
                        return this._volume.mute
                    }
                    set mute(e) {
                        this._volume.mute = e
                    }
                    _clampToCurrentTime(e) {
                        return this._synced ? e : Math.max(e, this.context.currentTime)
                    }
                    start(e, t, n) {
                        let i = Nr(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
                        if (i = this._clampToCurrentTime(i),
                        !this._synced && this._state.getValueAtTime(i) === "started")
                            Wt(om(i, this._state.get(i).time), "Start time must be strictly greater than previous start time"),
                            this._state.cancel(i),
                            this._state.setStateAtTime("started", i),
                            this.log("restart", i),
                            this.restart(i, t, n);
                        else if (this.log("start", i),
                        this._state.setStateAtTime("started", i),
                        this._synced) {
                            const s = this._state.get(i);
                            s && (s.offset = this.toSeconds(jl(t, 0)),
                            s.duration = n ? this.toSeconds(n) : void 0);
                            const r = this.context.transport.schedule(l => {
                                this._start(l, t, n)
                            }
                            , i);
                            this._scheduled.push(r),
                            this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > i && this._syncedStart(this.now(), this.context.transport.seconds)
                        } else
                            G2(this.context),
                            this._start(i, t, n);
                        return this
                    }
                    stop(e) {
                        let t = Nr(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
                        if (t = this._clampToCurrentTime(t),
                        this._state.getValueAtTime(t) === "started" || fn(this._state.getNextState("started", t))) {
                            if (this.log("stop", t),
                            !this._synced)
                                this._stop(t);
                            else {
                                const n = this.context.transport.schedule(this._stop.bind(this), t);
                                this._scheduled.push(n)
                            }
                            this._state.cancel(t),
                            this._state.setStateAtTime("stopped", t)
                        }
                        return this
                    }
                    restart(e, t, n) {
                        return e = this.toSeconds(e),
                        this._state.getValueAtTime(e) === "started" && (this._state.cancel(e),
                        this._restart(e, t, n)),
                        this
                    }
                    sync() {
                        return this._synced || (this._synced = !0,
                        this._syncedStart = (e, t) => {
                            if (om(t, 0)) {
                                const n = this._state.get(t);
                                if (n && n.state === "started" && n.time !== t) {
                                    const i = t - this.toSeconds(n.time);
                                    let s;
                                    n.duration && (s = this.toSeconds(n.duration) - i),
                                    this._start(e, this.toSeconds(n.offset) + i, s)
                                }
                            }
                        }
                        ,
                        this._syncedStop = e => {
                            const t = this.context.transport.getSecondsAtTime(Math.max(e - this.sampleTime, 0));
                            this._state.getValueAtTime(t) === "started" && this._stop(e)
                        }
                        ,
                        this.context.transport.on("start", this._syncedStart),
                        this.context.transport.on("loopStart", this._syncedStart),
                        this.context.transport.on("stop", this._syncedStop),
                        this.context.transport.on("pause", this._syncedStop),
                        this.context.transport.on("loopEnd", this._syncedStop)),
                        this
                    }
                    unsync() {
                        return this._synced && (this.context.transport.off("stop", this._syncedStop),
                        this.context.transport.off("pause", this._syncedStop),
                        this.context.transport.off("loopEnd", this._syncedStop),
                        this.context.transport.off("start", this._syncedStart),
                        this.context.transport.off("loopStart", this._syncedStart)),
                        this._synced = !1,
                        this._scheduled.forEach(e => this.context.transport.clear(e)),
                        this._scheduled = [],
                        this._state.cancel(0),
                        this._stop(0),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this.onstop = Vn,
                        this.unsync(),
                        this._volume.dispose(),
                        this._state.dispose(),
                        this
                    }
                }
                  , lb = class TN extends cm {
                    constructor() {
                        const t = Pt(TN.getDefaults(), arguments, ["url", "onload"]);
                        super(t),
                        this.name = "ToneBufferSource",
                        this._source = this.context.createBufferSource(),
                        this._internalChannels = [this._source],
                        this._sourceStarted = !1,
                        this._sourceStopped = !1,
                        sh(this._source, this._gainNode),
                        this._source.onended = () => this._stopSource(),
                        this.playbackRate = new Ji({
                            context: this.context,
                            param: this._source.playbackRate,
                            units: "positive",
                            value: t.playbackRate
                        }),
                        this.loop = t.loop,
                        this.loopStart = t.loopStart,
                        this.loopEnd = t.loopEnd,
                        this._buffer = new Jo(t.url,t.onload,t.onerror),
                        this._internalChannels.push(this._source)
                    }
                    static getDefaults() {
                        return Object.assign(cm.getDefaults(), {
                            url: new Jo,
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            onload: Vn,
                            onerror: Vn,
                            playbackRate: 1
                        })
                    }
                    get fadeIn() {
                        return this._fadeIn
                    }
                    set fadeIn(t) {
                        this._fadeIn = t
                    }
                    get fadeOut() {
                        return this._fadeOut
                    }
                    set fadeOut(t) {
                        this._fadeOut = t
                    }
                    get curve() {
                        return this._curve
                    }
                    set curve(t) {
                        this._curve = t
                    }
                    start(t, n, i, s=1) {
                        Wt(this.buffer.loaded, "buffer is either not set or not loaded");
                        const r = this.toSeconds(t);
                        this._startGain(r, s),
                        this.loop ? n = jl(n, this.loopStart) : n = jl(n, 0);
                        let l = Math.max(this.toSeconds(n), 0);
                        if (this.loop) {
                            const h = this.toSeconds(this.loopEnd) || this.buffer.duration
                              , d = this.toSeconds(this.loopStart)
                              , p = h - d;
                            ib(l, h) && (l = (l - d) % p + d),
                            Ko(l, this.buffer.duration) && (l = 0)
                        }
                        if (this._source.buffer = this.buffer.get(),
                        this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration,
                        oS(l, this.buffer.duration) && (this._sourceStarted = !0,
                        this._source.start(r, l)),
                        fn(i)) {
                            let h = this.toSeconds(i);
                            h = Math.max(h, 0),
                            this.stop(r + h)
                        }
                        return this
                    }
                    _stopSource(t) {
                        !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0,
                        this._source.stop(this.toSeconds(t)),
                        this._onended())
                    }
                    get loopStart() {
                        return this._source.loopStart
                    }
                    set loopStart(t) {
                        this._source.loopStart = this.toSeconds(t)
                    }
                    get loopEnd() {
                        return this._source.loopEnd
                    }
                    set loopEnd(t) {
                        this._source.loopEnd = this.toSeconds(t)
                    }
                    get buffer() {
                        return this._buffer
                    }
                    set buffer(t) {
                        this._buffer.set(t)
                    }
                    get loop() {
                        return this._source.loop
                    }
                    set loop(t) {
                        this._source.loop = t,
                        this._sourceStarted && this.cancelStop()
                    }
                    dispose() {
                        return super.dispose(),
                        this._source.onended = null,
                        this._source.disconnect(),
                        this._buffer.dispose(),
                        this.playbackRate.dispose(),
                        this
                    }
                }
                  , sO = class MN extends js {
                    constructor() {
                        const t = Pt(MN.getDefaults(), arguments, ["type"]);
                        super(t),
                        this.name = "Noise",
                        this._source = null,
                        this._playbackRate = t.playbackRate,
                        this.type = t.type,
                        this._fadeIn = t.fadeIn,
                        this._fadeOut = t.fadeOut
                    }
                    static getDefaults() {
                        return Object.assign(js.getDefaults(), {
                            fadeIn: 0,
                            fadeOut: 0,
                            playbackRate: 1,
                            type: "white"
                        })
                    }
                    get type() {
                        return this._type
                    }
                    set type(t) {
                        if (Wt(t in aO, "Noise: invalid type: " + t),
                        this._type !== t && (this._type = t,
                        this.state === "started")) {
                            const n = this.now();
                            this._stop(n),
                            this._start(n)
                        }
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(t) {
                        this._playbackRate = t,
                        this._source && (this._source.playbackRate.value = t)
                    }
                    _start(t) {
                        const n = aO[this._type];
                        this._source = new lb({
                            url: n,
                            context: this.context,
                            fadeIn: this._fadeIn,
                            fadeOut: this._fadeOut,
                            loop: !0,
                            onended: () => this.onstop(this),
                            playbackRate: this._playbackRate
                        }).connect(this.output),
                        this._source.start(this.toSeconds(t), Math.random() * (n.duration - .001))
                    }
                    _stop(t) {
                        this._source && (this._source.stop(this.toSeconds(t)),
                        this._source = null)
                    }
                    get fadeIn() {
                        return this._fadeIn
                    }
                    set fadeIn(t) {
                        this._fadeIn = t,
                        this._source && (this._source.fadeIn = this._fadeIn)
                    }
                    get fadeOut() {
                        return this._fadeOut
                    }
                    set fadeOut(t) {
                        this._fadeOut = t,
                        this._source && (this._source.fadeOut = this._fadeOut)
                    }
                    _restart(t) {
                        this._stop(t),
                        this._start(t)
                    }
                    dispose() {
                        return super.dispose(),
                        this._source && this._source.disconnect(),
                        this
                    }
                }
                ;
                const um = 44100 * 5
                  , cb = 2
                  , Lc = {
                    brown: null,
                    pink: null,
                    white: null
                }
                  , aO = {
                    get brown() {
                        if (!Lc.brown) {
                            const e = [];
                            for (let t = 0; t < cb; t++) {
                                const n = new Float32Array(um);
                                e[t] = n;
                                let i = 0;
                                for (let s = 0; s < um; s++) {
                                    const r = Math.random() * 2 - 1;
                                    n[s] = (i + .02 * r) / 1.02,
                                    i = n[s],
                                    n[s] *= 3.5
                                }
                            }
                            Lc.brown = new Jo().fromArray(e)
                        }
                        return Lc.brown
                    },
                    get pink() {
                        if (!Lc.pink) {
                            const e = [];
                            for (let t = 0; t < cb; t++) {
                                const n = new Float32Array(um);
                                e[t] = n;
                                let i, s, r, l, h, d, p;
                                i = s = r = l = h = d = p = 0;
                                for (let m = 0; m < um; m++) {
                                    const v = Math.random() * 2 - 1;
                                    i = .99886 * i + v * .0555179,
                                    s = .99332 * s + v * .0750759,
                                    r = .969 * r + v * .153852,
                                    l = .8665 * l + v * .3104856,
                                    h = .55 * h + v * .5329522,
                                    d = -.7616 * d - v * .016898,
                                    n[m] = i + s + r + l + h + d + p + v * .5362,
                                    n[m] *= .11,
                                    p = v * .115926
                                }
                            }
                            Lc.pink = new Jo().fromArray(e)
                        }
                        return Lc.pink
                    },
                    get white() {
                        if (!Lc.white) {
                            const e = [];
                            for (let t = 0; t < cb; t++) {
                                const n = new Float32Array(um);
                                e[t] = n;
                                for (let i = 0; i < um; i++)
                                    n[i] = Math.random() * 2 - 1
                            }
                            Lc.white = new Jo().fromArray(e)
                        }
                        return Lc.white
                    }
                };
                function jf(e, t) {
                    return Ki(this, void 0, void 0, function*() {
                        const n = t / e.context.sampleRate
                          , i = new uS(1,n,e.context.sampleRate);
                        return new e.constructor(Object.assign(e.get(), {
                            frequency: 2 / n,
                            detune: 0,
                            context: i
                        })).toDestination().start(0),
                        (yield i.render()).getChannelData(0)
                    })
                }
                var F7 = class bN extends cm {
                    constructor() {
                        const t = Pt(bN.getDefaults(), arguments, ["frequency", "type"]);
                        super(t),
                        this.name = "ToneOscillatorNode",
                        this._oscillator = this.context.createOscillator(),
                        this._internalChannels = [this._oscillator],
                        sh(this._oscillator, this._gainNode),
                        this.type = t.type,
                        this.frequency = new Ji({
                            context: this.context,
                            param: this._oscillator.frequency,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this.detune = new Ji({
                            context: this.context,
                            param: this._oscillator.detune,
                            units: "cents",
                            value: t.detune
                        }),
                        ii(this, ["frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(cm.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            type: "sine"
                        })
                    }
                    start(t) {
                        const n = this.toSeconds(t);
                        return this.log("start", n),
                        this._startGain(n),
                        this._oscillator.start(n),
                        this
                    }
                    _stopSource(t) {
                        this._oscillator.stop(t)
                    }
                    setPeriodicWave(t) {
                        return this._oscillator.setPeriodicWave(t),
                        this
                    }
                    get type() {
                        return this._oscillator.type
                    }
                    set type(t) {
                        this._oscillator.type = t
                    }
                    dispose() {
                        return super.dispose(),
                        this.state === "started" && this.stop(),
                        this._oscillator.disconnect(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this
                    }
                }
                  , Br = class Zf extends js {
                    constructor() {
                        const t = Pt(Zf.getDefaults(), arguments, ["frequency", "type"]);
                        super(t),
                        this.name = "Oscillator",
                        this._oscillator = null,
                        this.frequency = new Ms({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        ii(this, "frequency"),
                        this.detune = new Ms({
                            context: this.context,
                            units: "cents",
                            value: t.detune
                        }),
                        ii(this, "detune"),
                        this._partials = t.partials,
                        this._partialCount = t.partialCount,
                        this._type = t.type,
                        t.partialCount && t.type !== "custom" && (this._type = this.baseType + t.partialCount.toString()),
                        this.phase = t.phase
                    }
                    static getDefaults() {
                        return Object.assign(js.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            partialCount: 0,
                            partials: [],
                            phase: 0,
                            type: "sine"
                        })
                    }
                    _start(t) {
                        const n = this.toSeconds(t);
                        this._oscillator = new F7({
                            context: this.context,
                            onended: () => this.onstop(this)
                        }),
                        this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type,
                        this._oscillator.connect(this.output),
                        this.frequency.connect(this._oscillator.frequency),
                        this.detune.connect(this._oscillator.detune),
                        this._oscillator.start(n)
                    }
                    _stop(t) {
                        const n = this.toSeconds(t);
                        this._oscillator && this._oscillator.stop(n)
                    }
                    _restart(t) {
                        const n = this.toSeconds(t);
                        return this.log("restart", n),
                        this._oscillator && this._oscillator.cancelStop(),
                        this._state.cancel(n),
                        this
                    }
                    syncFrequency() {
                        return this.context.transport.syncSignal(this.frequency),
                        this
                    }
                    unsyncFrequency() {
                        return this.context.transport.unsyncSignal(this.frequency),
                        this
                    }
                    _getCachedPeriodicWave() {
                        if (this._type === "custom")
                            return Zf._periodicWaveCache.find(t => t.phase === this._phase && c7(t.partials, this._partials));
                        {
                            const t = Zf._periodicWaveCache.find(n => n.type === this._type && n.phase === this._phase);
                            return this._partialCount = t ? t.partialCount : this._partialCount,
                            t
                        }
                    }
                    get type() {
                        return this._type
                    }
                    set type(t) {
                        this._type = t;
                        const n = ["sine", "square", "sawtooth", "triangle"].indexOf(t) !== -1;
                        if (this._phase === 0 && n)
                            this._wave = void 0,
                            this._partialCount = 0,
                            this._oscillator !== null && (this._oscillator.type = t);
                        else {
                            const i = this._getCachedPeriodicWave();
                            if (fn(i)) {
                                const {partials: s, wave: r} = i;
                                this._wave = r,
                                this._partials = s,
                                this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave)
                            } else {
                                const [s,r] = this._getRealImaginary(t, this._phase);
                                this._wave = this.context.createPeriodicWave(s, r),
                                this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave),
                                Zf._periodicWaveCache.push({
                                    imag: r,
                                    partialCount: this._partialCount,
                                    partials: this._partials,
                                    phase: this._phase,
                                    real: s,
                                    type: this._type,
                                    wave: this._wave
                                }),
                                Zf._periodicWaveCache.length > 100 && Zf._periodicWaveCache.shift()
                            }
                        }
                    }
                    get baseType() {
                        return this._type.replace(this.partialCount.toString(), "")
                    }
                    set baseType(t) {
                        this.partialCount && this._type !== "custom" && t !== "custom" ? this.type = t + this.partialCount : this.type = t
                    }
                    get partialCount() {
                        return this._partialCount
                    }
                    set partialCount(t) {
                        lo(t, 0);
                        let n = this._type;
                        const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
                        if (i && (n = i[1]),
                        this._type !== "custom")
                            t === 0 ? this.type = n : this.type = n + t.toString();
                        else {
                            const s = new Float32Array(t);
                            this._partials.forEach( (r, l) => s[l] = r),
                            this._partials = Array.from(s),
                            this.type = this._type
                        }
                    }
                    _getRealImaginary(t, n) {
                        let i = 2048;
                        const s = new Float32Array(i)
                          , r = new Float32Array(i);
                        let l = 1;
                        if (t === "custom") {
                            if (l = this._partials.length + 1,
                            this._partialCount = this._partials.length,
                            i = l,
                            this._partials.length === 0)
                                return [s, r]
                        } else {
                            const h = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
                            h ? (l = parseInt(h[2], 10) + 1,
                            this._partialCount = parseInt(h[2], 10),
                            t = h[1],
                            l = Math.max(l, 2),
                            i = l) : this._partialCount = 0,
                            this._partials = []
                        }
                        for (let h = 1; h < i; ++h) {
                            const d = 2 / (h * Math.PI);
                            let p;
                            switch (t) {
                            case "sine":
                                p = h <= l ? 1 : 0,
                                this._partials[h - 1] = p;
                                break;
                            case "square":
                                p = h & 1 ? 2 * d : 0,
                                this._partials[h - 1] = p;
                                break;
                            case "sawtooth":
                                p = d * (h & 1 ? 1 : -1),
                                this._partials[h - 1] = p;
                                break;
                            case "triangle":
                                h & 1 ? p = 2 * (d * d) * (h - 1 >> 1 & 1 ? -1 : 1) : p = 0,
                                this._partials[h - 1] = p;
                                break;
                            case "custom":
                                p = this._partials[h - 1];
                                break;
                            default:
                                throw new TypeError("Oscillator: invalid type: " + t)
                            }
                            p !== 0 ? (s[h] = -p * Math.sin(n * h),
                            r[h] = p * Math.cos(n * h)) : (s[h] = 0,
                            r[h] = 0)
                        }
                        return [s, r]
                    }
                    _inverseFFT(t, n, i) {
                        let s = 0;
                        const r = t.length;
                        for (let l = 0; l < r; l++)
                            s += t[l] * Math.cos(l * i) + n[l] * Math.sin(l * i);
                        return s
                    }
                    getInitialValue() {
                        const [t,n] = this._getRealImaginary(this._type, 0);
                        let i = 0;
                        const s = Math.PI * 2
                          , r = 32;
                        for (let l = 0; l < r; l++)
                            i = Math.max(this._inverseFFT(t, n, l / r * s), i);
                        return h7(-this._inverseFFT(t, n, this._phase) / i, -1, 1)
                    }
                    get partials() {
                        return this._partials.slice(0, this.partialCount)
                    }
                    set partials(t) {
                        this._partials = t,
                        this._partialCount = this._partials.length,
                        t.length && (this.type = "custom")
                    }
                    get phase() {
                        return this._phase * (180 / Math.PI)
                    }
                    set phase(t) {
                        this._phase = t * Math.PI / 180,
                        this.type = this._type
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._oscillator !== null && this._oscillator.dispose(),
                        this._wave = void 0,
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this
                    }
                }
                ;
                Br._periodicWaveCache = [];
                var rO = class extends $v {
                    constructor() {
                        super(...arguments),
                        this.name = "AudioToGain",
                        this._norm = new dS({
                            context: this.context,
                            mapping: e => (e + 1) / 2
                        }),
                        this.input = this._norm,
                        this.output = this._norm
                    }
                    dispose() {
                        return super.dispose(),
                        this._norm.dispose(),
                        this
                    }
                }
                  , hm = class EN extends Ms {
                    constructor() {
                        const t = Pt(EN.getDefaults(), arguments, ["value"]);
                        super(t),
                        this.name = "Multiply",
                        this.override = !1,
                        this._mult = this.input = this.output = new Ui({
                            context: this.context,
                            minValue: t.minValue,
                            maxValue: t.maxValue
                        }),
                        this.factor = this._param = this._mult.gain,
                        this.factor.setValueAtTime(t.value, 0)
                    }
                    static getDefaults() {
                        return Object.assign(Ms.getDefaults(), {
                            value: 0
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._mult.dispose(),
                        this
                    }
                }
                  , oO = class wN extends js {
                    constructor() {
                        const t = Pt(wN.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
                        super(t),
                        this.name = "AMOscillator",
                        this._modulationScale = new rO({
                            context: this.context
                        }),
                        this._modulationNode = new Ui({
                            context: this.context
                        }),
                        this._carrier = new Br({
                            context: this.context,
                            detune: t.detune,
                            frequency: t.frequency,
                            onstop: () => this.onstop(this),
                            phase: t.phase,
                            type: t.type
                        }),
                        this.frequency = this._carrier.frequency,
                        this.detune = this._carrier.detune,
                        this._modulator = new Br({
                            context: this.context,
                            phase: t.phase,
                            type: t.modulationType
                        }),
                        this.harmonicity = new hm({
                            context: this.context,
                            units: "positive",
                            value: t.harmonicity
                        }),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this._modulator.chain(this._modulationScale, this._modulationNode.gain),
                        this._carrier.chain(this._modulationNode, this.output),
                        ii(this, ["frequency", "detune", "harmonicity"])
                    }
                    static getDefaults() {
                        return Object.assign(Br.getDefaults(), {
                            harmonicity: 1,
                            modulationType: "square"
                        })
                    }
                    _start(t) {
                        this._modulator.start(t),
                        this._carrier.start(t)
                    }
                    _stop(t) {
                        this._modulator.stop(t),
                        this._carrier.stop(t)
                    }
                    _restart(t) {
                        this._modulator.restart(t),
                        this._carrier.restart(t)
                    }
                    get type() {
                        return this._carrier.type
                    }
                    set type(t) {
                        this._carrier.type = t
                    }
                    get baseType() {
                        return this._carrier.baseType
                    }
                    set baseType(t) {
                        this._carrier.baseType = t
                    }
                    get partialCount() {
                        return this._carrier.partialCount
                    }
                    set partialCount(t) {
                        this._carrier.partialCount = t
                    }
                    get modulationType() {
                        return this._modulator.type
                    }
                    set modulationType(t) {
                        this._modulator.type = t
                    }
                    get phase() {
                        return this._carrier.phase
                    }
                    set phase(t) {
                        this._carrier.phase = t,
                        this._modulator.phase = t
                    }
                    get partials() {
                        return this._carrier.partials
                    }
                    set partials(t) {
                        this._carrier.partials = t
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this.harmonicity.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this._modulationNode.dispose(),
                        this._modulationScale.dispose(),
                        this
                    }
                }
                  , lO = class CN extends js {
                    constructor() {
                        const t = Pt(CN.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
                        super(t),
                        this.name = "FMOscillator",
                        this._modulationNode = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        this._carrier = new Br({
                            context: this.context,
                            detune: t.detune,
                            frequency: 0,
                            onstop: () => this.onstop(this),
                            phase: t.phase,
                            type: t.type
                        }),
                        this.detune = this._carrier.detune,
                        this.frequency = new Ms({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this._modulator = new Br({
                            context: this.context,
                            phase: t.phase,
                            type: t.modulationType
                        }),
                        this.harmonicity = new hm({
                            context: this.context,
                            units: "positive",
                            value: t.harmonicity
                        }),
                        this.modulationIndex = new hm({
                            context: this.context,
                            units: "positive",
                            value: t.modulationIndex
                        }),
                        this.frequency.connect(this._carrier.frequency),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this.frequency.chain(this.modulationIndex, this._modulationNode),
                        this._modulator.connect(this._modulationNode.gain),
                        this._modulationNode.connect(this._carrier.frequency),
                        this._carrier.connect(this.output),
                        this.detune.connect(this._modulator.detune),
                        ii(this, ["modulationIndex", "frequency", "detune", "harmonicity"])
                    }
                    static getDefaults() {
                        return Object.assign(Br.getDefaults(), {
                            harmonicity: 1,
                            modulationIndex: 2,
                            modulationType: "square"
                        })
                    }
                    _start(t) {
                        this._modulator.start(t),
                        this._carrier.start(t)
                    }
                    _stop(t) {
                        this._modulator.stop(t),
                        this._carrier.stop(t)
                    }
                    _restart(t) {
                        return this._modulator.restart(t),
                        this._carrier.restart(t),
                        this
                    }
                    get type() {
                        return this._carrier.type
                    }
                    set type(t) {
                        this._carrier.type = t
                    }
                    get baseType() {
                        return this._carrier.baseType
                    }
                    set baseType(t) {
                        this._carrier.baseType = t
                    }
                    get partialCount() {
                        return this._carrier.partialCount
                    }
                    set partialCount(t) {
                        this._carrier.partialCount = t
                    }
                    get modulationType() {
                        return this._modulator.type
                    }
                    set modulationType(t) {
                        this._modulator.type = t
                    }
                    get phase() {
                        return this._carrier.phase
                    }
                    set phase(t) {
                        this._carrier.phase = t,
                        this._modulator.phase = t
                    }
                    get partials() {
                        return this._carrier.partials
                    }
                    set partials(t) {
                        this._carrier.partials = t
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.harmonicity.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this._modulationNode.dispose(),
                        this.modulationIndex.dispose(),
                        this
                    }
                }
                  , ub = class RN extends js {
                    constructor() {
                        const t = Pt(RN.getDefaults(), arguments, ["frequency", "width"]);
                        super(t),
                        this.name = "PulseOscillator",
                        this._widthGate = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        this._thresh = new dS({
                            context: this.context,
                            mapping: n => n <= 0 ? -1 : 1
                        }),
                        this.width = new Ms({
                            context: this.context,
                            units: "audioRange",
                            value: t.width
                        }),
                        this._triangle = new Br({
                            context: this.context,
                            detune: t.detune,
                            frequency: t.frequency,
                            onstop: () => this.onstop(this),
                            phase: t.phase,
                            type: "triangle"
                        }),
                        this.frequency = this._triangle.frequency,
                        this.detune = this._triangle.detune,
                        this._triangle.chain(this._thresh, this.output),
                        this.width.chain(this._widthGate, this._thresh),
                        ii(this, ["width", "frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(js.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            phase: 0,
                            type: "pulse",
                            width: .2
                        })
                    }
                    _start(t) {
                        t = this.toSeconds(t),
                        this._triangle.start(t),
                        this._widthGate.gain.setValueAtTime(1, t)
                    }
                    _stop(t) {
                        t = this.toSeconds(t),
                        this._triangle.stop(t),
                        this._widthGate.gain.cancelScheduledValues(t),
                        this._widthGate.gain.setValueAtTime(0, t)
                    }
                    _restart(t) {
                        this._triangle.restart(t),
                        this._widthGate.gain.cancelScheduledValues(t),
                        this._widthGate.gain.setValueAtTime(1, t)
                    }
                    get phase() {
                        return this._triangle.phase
                    }
                    set phase(t) {
                        this._triangle.phase = t
                    }
                    get type() {
                        return "pulse"
                    }
                    get baseType() {
                        return "pulse"
                    }
                    get partials() {
                        return []
                    }
                    get partialCount() {
                        return 0
                    }
                    set carrierType(t) {
                        this._triangle.type = t
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._triangle.dispose(),
                        this.width.dispose(),
                        this._widthGate.dispose(),
                        this._thresh.dispose(),
                        this
                    }
                }
                  , cO = class DN extends js {
                    constructor() {
                        const t = Pt(DN.getDefaults(), arguments, ["frequency", "type", "spread"]);
                        super(t),
                        this.name = "FatOscillator",
                        this._oscillators = [],
                        this.frequency = new Ms({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this.detune = new Ms({
                            context: this.context,
                            units: "cents",
                            value: t.detune
                        }),
                        this._spread = t.spread,
                        this._type = t.type,
                        this._phase = t.phase,
                        this._partials = t.partials,
                        this._partialCount = t.partialCount,
                        this.count = t.count,
                        ii(this, ["frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(Br.getDefaults(), {
                            count: 3,
                            spread: 20,
                            type: "sawtooth"
                        })
                    }
                    _start(t) {
                        t = this.toSeconds(t),
                        this._forEach(n => n.start(t))
                    }
                    _stop(t) {
                        t = this.toSeconds(t),
                        this._forEach(n => n.stop(t))
                    }
                    _restart(t) {
                        this._forEach(n => n.restart(t))
                    }
                    _forEach(t) {
                        for (let n = 0; n < this._oscillators.length; n++)
                            t(this._oscillators[n], n)
                    }
                    get type() {
                        return this._type
                    }
                    set type(t) {
                        this._type = t,
                        this._forEach(n => n.type = t)
                    }
                    get spread() {
                        return this._spread
                    }
                    set spread(t) {
                        if (this._spread = t,
                        this._oscillators.length > 1) {
                            const n = -t / 2
                              , i = t / (this._oscillators.length - 1);
                            this._forEach( (s, r) => s.detune.value = n + i * r)
                        }
                    }
                    get count() {
                        return this._oscillators.length
                    }
                    set count(t) {
                        if (lo(t, 1),
                        this._oscillators.length !== t) {
                            this._forEach(n => n.dispose()),
                            this._oscillators = [];
                            for (let n = 0; n < t; n++) {
                                const i = new Br({
                                    context: this.context,
                                    volume: -6 - t * 1.1,
                                    type: this._type,
                                    phase: this._phase + n / t * 360,
                                    partialCount: this._partialCount,
                                    onstop: n === 0 ? () => this.onstop(this) : Vn
                                });
                                this.type === "custom" && (i.partials = this._partials),
                                this.frequency.connect(i.frequency),
                                this.detune.connect(i.detune),
                                i.detune.overridden = !1,
                                i.connect(this.output),
                                this._oscillators[n] = i
                            }
                            this.spread = this._spread,
                            this.state === "started" && this._forEach(n => n.start())
                        }
                    }
                    get phase() {
                        return this._phase
                    }
                    set phase(t) {
                        this._phase = t,
                        this._forEach( (n, i) => n.phase = this._phase + i / this.count * 360)
                    }
                    get baseType() {
                        return this._oscillators[0].baseType
                    }
                    set baseType(t) {
                        this._forEach(n => n.baseType = t),
                        this._type = this._oscillators[0].type
                    }
                    get partials() {
                        return this._oscillators[0].partials
                    }
                    set partials(t) {
                        this._partials = t,
                        this._partialCount = this._partials.length,
                        t.length && (this._type = "custom",
                        this._forEach(n => n.partials = t))
                    }
                    get partialCount() {
                        return this._oscillators[0].partialCount
                    }
                    set partialCount(t) {
                        this._partialCount = t,
                        this._forEach(n => n.partialCount = t),
                        this._type = this._oscillators[0].type
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this._forEach(t => t.dispose()),
                        this
                    }
                }
                  , uO = class ON extends js {
                    constructor() {
                        const t = Pt(ON.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
                        super(t),
                        this.name = "PWMOscillator",
                        this.sourceType = "pwm",
                        this._scale = new hm({
                            context: this.context,
                            value: 2
                        }),
                        this._pulse = new ub({
                            context: this.context,
                            frequency: t.modulationFrequency
                        }),
                        this._pulse.carrierType = "sine",
                        this.modulationFrequency = this._pulse.frequency,
                        this._modulator = new Br({
                            context: this.context,
                            detune: t.detune,
                            frequency: t.frequency,
                            onstop: () => this.onstop(this),
                            phase: t.phase
                        }),
                        this.frequency = this._modulator.frequency,
                        this.detune = this._modulator.detune,
                        this._modulator.chain(this._scale, this._pulse.width),
                        this._pulse.connect(this.output),
                        ii(this, ["modulationFrequency", "frequency", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(js.getDefaults(), {
                            detune: 0,
                            frequency: 440,
                            modulationFrequency: .4,
                            phase: 0,
                            type: "pwm"
                        })
                    }
                    _start(t) {
                        t = this.toSeconds(t),
                        this._modulator.start(t),
                        this._pulse.start(t)
                    }
                    _stop(t) {
                        t = this.toSeconds(t),
                        this._modulator.stop(t),
                        this._pulse.stop(t)
                    }
                    _restart(t) {
                        this._modulator.restart(t),
                        this._pulse.restart(t)
                    }
                    get type() {
                        return "pwm"
                    }
                    get baseType() {
                        return "pwm"
                    }
                    get partials() {
                        return []
                    }
                    get partialCount() {
                        return 0
                    }
                    get phase() {
                        return this._modulator.phase
                    }
                    set phase(t) {
                        this._modulator.phase = t
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._pulse.dispose(),
                        this._scale.dispose(),
                        this._modulator.dispose(),
                        this
                    }
                }
                ;
                const hO = {
                    am: oO,
                    fat: cO,
                    fm: lO,
                    oscillator: Br,
                    pulse: ub,
                    pwm: uO
                };
                var pS = class NN extends js {
                    constructor() {
                        const t = Pt(NN.getDefaults(), arguments, ["frequency", "type"]);
                        super(t),
                        this.name = "OmniOscillator",
                        this.frequency = new Ms({
                            context: this.context,
                            units: "frequency",
                            value: t.frequency
                        }),
                        this.detune = new Ms({
                            context: this.context,
                            units: "cents",
                            value: t.detune
                        }),
                        ii(this, ["frequency", "detune"]),
                        this.set(t)
                    }
                    static getDefaults() {
                        return Object.assign(Br.getDefaults(), lO.getDefaults(), oO.getDefaults(), cO.getDefaults(), ub.getDefaults(), uO.getDefaults())
                    }
                    _start(t) {
                        this._oscillator.start(t)
                    }
                    _stop(t) {
                        this._oscillator.stop(t)
                    }
                    _restart(t) {
                        return this._oscillator.restart(t),
                        this
                    }
                    get type() {
                        let t = "";
                        return ["am", "fm", "fat"].some(n => this._sourceType === n) && (t = this._sourceType),
                        t + this._oscillator.type
                    }
                    set type(t) {
                        t.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t.substr(2)) : t.substr(0, 2) === "am" ? (this._createNewOscillator("am"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t.substr(2)) : t.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t.substr(3)) : t === "pwm" ? (this._createNewOscillator("pwm"),
                        this._oscillator = this._oscillator) : t === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"),
                        this._oscillator = this._oscillator,
                        this._oscillator.type = t)
                    }
                    get partials() {
                        return this._oscillator.partials
                    }
                    set partials(t) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = t)
                    }
                    get partialCount() {
                        return this._oscillator.partialCount
                    }
                    set partialCount(t) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = t)
                    }
                    set(t) {
                        return Reflect.has(t, "type") && t.type && (this.type = t.type),
                        super.set(t),
                        this
                    }
                    _createNewOscillator(t) {
                        if (t !== this._sourceType) {
                            this._sourceType = t;
                            const n = hO[t]
                              , i = this.now();
                            if (this._oscillator) {
                                const s = this._oscillator;
                                s.stop(i),
                                this.context.setTimeout( () => s.dispose(), this.blockTime)
                            }
                            this._oscillator = new n({
                                context: this.context
                            }),
                            this.frequency.connect(this._oscillator.frequency),
                            this.detune.connect(this._oscillator.detune),
                            this._oscillator.connect(this.output),
                            this._oscillator.onstop = () => this.onstop(this),
                            this.state === "started" && this._oscillator.start(i)
                        }
                    }
                    get phase() {
                        return this._oscillator.phase
                    }
                    set phase(t) {
                        this._oscillator.phase = t
                    }
                    get sourceType() {
                        return this._sourceType
                    }
                    set sourceType(t) {
                        let n = "sine";
                        this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type),
                        t === "fm" ? this.type = "fm" + n : t === "am" ? this.type = "am" + n : t === "fat" ? this.type = "fat" + n : t === "oscillator" ? this.type = n : t === "pulse" ? this.type = "pulse" : t === "pwm" && (this.type = "pwm")
                    }
                    _getOscType(t, n) {
                        return t instanceof hO[n]
                    }
                    get baseType() {
                        return this._oscillator.baseType
                    }
                    set baseType(t) {
                        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && t !== "pulse" && t !== "pwm" && (this._oscillator.baseType = t)
                    }
                    get width() {
                        if (this._getOscType(this._oscillator, "pulse"))
                            return this._oscillator.width
                    }
                    get count() {
                        if (this._getOscType(this._oscillator, "fat"))
                            return this._oscillator.count
                    }
                    set count(t) {
                        this._getOscType(this._oscillator, "fat") && Yl(t) && (this._oscillator.count = t)
                    }
                    get spread() {
                        if (this._getOscType(this._oscillator, "fat"))
                            return this._oscillator.spread
                    }
                    set spread(t) {
                        this._getOscType(this._oscillator, "fat") && Yl(t) && (this._oscillator.spread = t)
                    }
                    get modulationType() {
                        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
                            return this._oscillator.modulationType
                    }
                    set modulationType(t) {
                        (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && Wl(t) && (this._oscillator.modulationType = t)
                    }
                    get modulationIndex() {
                        if (this._getOscType(this._oscillator, "fm"))
                            return this._oscillator.modulationIndex
                    }
                    get harmonicity() {
                        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
                            return this._oscillator.harmonicity
                    }
                    get modulationFrequency() {
                        if (this._getOscType(this._oscillator, "pwm"))
                            return this._oscillator.modulationFrequency
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            return jf(this, t)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.detune.dispose(),
                        this.frequency.dispose(),
                        this._oscillator.dispose(),
                        this
                    }
                }
                ;
                function fO(e, t=1 / 0) {
                    const n = new WeakMap;
                    return function(i, s) {
                        Reflect.defineProperty(i, s, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return n.get(this)
                            },
                            set: function(r) {
                                lo(r, e, t),
                                n.set(this, r)
                            }
                        })
                    }
                }
                function zc(e, t=1 / 0) {
                    const n = new WeakMap;
                    return function(i, s) {
                        Reflect.defineProperty(i, s, {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return n.get(this)
                            },
                            set: function(r) {
                                lo(this.toSeconds(r), e, t),
                                n.set(this, r)
                            }
                        })
                    }
                }
                var dO = class UN extends js {
                    constructor() {
                        const t = Pt(UN.getDefaults(), arguments, ["url", "onload"]);
                        super(t),
                        this.name = "Player",
                        this._activeSources = new Set,
                        this._buffer = new Jo({
                            onload: this._onload.bind(this, t.onload),
                            onerror: t.onerror,
                            reverse: t.reverse,
                            url: t.url
                        }),
                        this.autostart = t.autostart,
                        this._loop = t.loop,
                        this._loopStart = t.loopStart,
                        this._loopEnd = t.loopEnd,
                        this._playbackRate = t.playbackRate,
                        this.fadeIn = t.fadeIn,
                        this.fadeOut = t.fadeOut
                    }
                    static getDefaults() {
                        return Object.assign(js.getDefaults(), {
                            autostart: !1,
                            fadeIn: 0,
                            fadeOut: 0,
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            onload: Vn,
                            onerror: Vn,
                            playbackRate: 1,
                            reverse: !1
                        })
                    }
                    load(t) {
                        return Ki(this, void 0, void 0, function*() {
                            return yield this._buffer.load(t),
                            this._onload(),
                            this
                        })
                    }
                    _onload(t=Vn) {
                        t(),
                        this.autostart && this.start()
                    }
                    _onSourceEnd(t) {
                        this.onstop(this),
                        this._activeSources.delete(t),
                        this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()),
                        this._state.setStateAtTime("stopped", this.now()))
                    }
                    start(t, n, i) {
                        return super.start(t, n, i),
                        this
                    }
                    _start(t, n, i) {
                        this._loop ? n = jl(n, this._loopStart) : n = jl(n, 0);
                        const s = this.toSeconds(n)
                          , r = i;
                        i = jl(i, Math.max(this._buffer.duration - s, 0));
                        let l = this.toSeconds(i);
                        l = l / this._playbackRate,
                        t = this.toSeconds(t);
                        const h = new lb({
                            url: this._buffer,
                            context: this.context,
                            fadeIn: this.fadeIn,
                            fadeOut: this.fadeOut,
                            loop: this._loop,
                            loopEnd: this._loopEnd,
                            loopStart: this._loopStart,
                            onended: this._onSourceEnd.bind(this),
                            playbackRate: this._playbackRate
                        }).connect(this.output);
                        !this._loop && !this._synced && (this._state.cancel(t + l),
                        this._state.setStateAtTime("stopped", t + l, {
                            implicitEnd: !0
                        })),
                        this._activeSources.add(h),
                        this._loop && Nr(r) ? h.start(t, s) : h.start(t, s, l - this.toSeconds(this.fadeOut))
                    }
                    _stop(t) {
                        const n = this.toSeconds(t);
                        this._activeSources.forEach(i => i.stop(n))
                    }
                    restart(t, n, i) {
                        return super.restart(t, n, i),
                        this
                    }
                    _restart(t, n, i) {
                        var s;
                        (s = [...this._activeSources].pop()) === null || s === void 0 || s.stop(t),
                        this._start(t, n, i)
                    }
                    seek(t, n) {
                        const i = this.toSeconds(n);
                        if (this._state.getValueAtTime(i) === "started") {
                            const s = this.toSeconds(t);
                            this._stop(i),
                            this._start(i, s)
                        }
                        return this
                    }
                    setLoopPoints(t, n) {
                        return this.loopStart = t,
                        this.loopEnd = n,
                        this
                    }
                    get loopStart() {
                        return this._loopStart
                    }
                    set loopStart(t) {
                        this._loopStart = t,
                        this.buffer.loaded && lo(this.toSeconds(t), 0, this.buffer.duration),
                        this._activeSources.forEach(n => {
                            n.loopStart = t
                        }
                        )
                    }
                    get loopEnd() {
                        return this._loopEnd
                    }
                    set loopEnd(t) {
                        this._loopEnd = t,
                        this.buffer.loaded && lo(this.toSeconds(t), 0, this.buffer.duration),
                        this._activeSources.forEach(n => {
                            n.loopEnd = t
                        }
                        )
                    }
                    get buffer() {
                        return this._buffer
                    }
                    set buffer(t) {
                        this._buffer.set(t)
                    }
                    get loop() {
                        return this._loop
                    }
                    set loop(t) {
                        if (this._loop !== t && (this._loop = t,
                        this._activeSources.forEach(n => {
                            n.loop = t
                        }
                        ),
                        t)) {
                            const n = this._state.getNextState("stopped", this.now());
                            n && this._state.cancel(n.time)
                        }
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(t) {
                        this._playbackRate = t;
                        const n = this.now()
                          , i = this._state.getNextState("stopped", n);
                        i && i.implicitEnd && (this._state.cancel(i.time),
                        this._activeSources.forEach(s => s.cancelStop())),
                        this._activeSources.forEach(s => {
                            s.playbackRate.setValueAtTime(t, n)
                        }
                        )
                    }
                    get reverse() {
                        return this._buffer.reverse
                    }
                    set reverse(t) {
                        this._buffer.reverse = t
                    }
                    get loaded() {
                        return this._buffer.loaded
                    }
                    dispose() {
                        return super.dispose(),
                        this._activeSources.forEach(t => t.dispose()),
                        this._activeSources.clear(),
                        this._buffer.dispose(),
                        this
                    }
                }
                ;
                Zo([zc(0)], dO.prototype, "fadeIn", void 0),
                Zo([zc(0)], dO.prototype, "fadeOut", void 0);
                var H7 = class extends $v {
                    constructor() {
                        super(...arguments),
                        this.name = "GainToAudio",
                        this._norm = new dS({
                            context: this.context,
                            mapping: e => Math.abs(e) * 2 - 1
                        }),
                        this.input = this._norm,
                        this.output = this._norm
                    }
                    dispose() {
                        return super.dispose(),
                        this._norm.dispose(),
                        this
                    }
                }
                  , ah = class BN extends tn {
                    constructor() {
                        const t = Pt(BN.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
                        super(t),
                        this.name = "Envelope",
                        this._sig = new Ms({
                            context: this.context,
                            value: 0
                        }),
                        this.output = this._sig,
                        this.input = void 0,
                        this.attack = t.attack,
                        this.decay = t.decay,
                        this.sustain = t.sustain,
                        this.release = t.release,
                        this.attackCurve = t.attackCurve,
                        this.releaseCurve = t.releaseCurve,
                        this.decayCurve = t.decayCurve
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            attack: .01,
                            attackCurve: "linear",
                            decay: .1,
                            decayCurve: "exponential",
                            release: 1,
                            releaseCurve: "exponential",
                            sustain: .5
                        })
                    }
                    get value() {
                        return this.getValueAtTime(this.now())
                    }
                    _getCurve(t, n) {
                        if (Wl(t))
                            return t;
                        {
                            let i;
                            for (i in mS)
                                if (mS[i][n] === t)
                                    return i;
                            return t
                        }
                    }
                    _setCurve(t, n, i) {
                        if (Wl(i) && Reflect.has(mS, i)) {
                            const s = mS[i];
                            eh(s) ? t !== "_decayCurve" && (this[t] = s[n]) : this[t] = s
                        } else if (ha(i) && t !== "_decayCurve")
                            this[t] = i;
                        else
                            throw new Error("Envelope: invalid curve: " + i)
                    }
                    get attackCurve() {
                        return this._getCurve(this._attackCurve, "In")
                    }
                    set attackCurve(t) {
                        this._setCurve("_attackCurve", "In", t)
                    }
                    get releaseCurve() {
                        return this._getCurve(this._releaseCurve, "Out")
                    }
                    set releaseCurve(t) {
                        this._setCurve("_releaseCurve", "Out", t)
                    }
                    get decayCurve() {
                        return this._getCurve(this._decayCurve, "Out")
                    }
                    set decayCurve(t) {
                        this._setCurve("_decayCurve", "Out", t)
                    }
                    triggerAttack(t, n=1) {
                        this.log("triggerAttack", t, n),
                        t = this.toSeconds(t);
                        let i = this.toSeconds(this.attack);
                        const s = this.toSeconds(this.decay)
                          , r = this.getValueAtTime(t);
                        if (r > 0) {
                            const l = 1 / i;
                            i = (1 - r) / l
                        }
                        if (i < this.sampleTime)
                            this._sig.cancelScheduledValues(t),
                            this._sig.setValueAtTime(n, t);
                        else if (this._attackCurve === "linear")
                            this._sig.linearRampTo(n, i, t);
                        else if (this._attackCurve === "exponential")
                            this._sig.targetRampTo(n, i, t);
                        else {
                            this._sig.cancelAndHoldAtTime(t);
                            let l = this._attackCurve;
                            for (let h = 1; h < l.length; h++)
                                if (l[h - 1] <= r && r <= l[h]) {
                                    l = this._attackCurve.slice(h),
                                    l[0] = r;
                                    break
                                }
                            this._sig.setValueCurveAtTime(l, t, i, n)
                        }
                        if (s && this.sustain < 1) {
                            const l = n * this.sustain
                              , h = t + i;
                            this.log("decay", h),
                            this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(l, s + h) : this._sig.exponentialApproachValueAtTime(l, h, s)
                        }
                        return this
                    }
                    triggerRelease(t) {
                        this.log("triggerRelease", t),
                        t = this.toSeconds(t);
                        const n = this.getValueAtTime(t);
                        if (n > 0) {
                            const i = this.toSeconds(this.release);
                            i < this.sampleTime ? this._sig.setValueAtTime(0, t) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, i, t) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, i, t) : (Wt(ha(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"),
                            this._sig.cancelAndHoldAtTime(t),
                            this._sig.setValueCurveAtTime(this._releaseCurve, t, i, n))
                        }
                        return this
                    }
                    getValueAtTime(t) {
                        return this._sig.getValueAtTime(t)
                    }
                    triggerAttackRelease(t, n, i=1) {
                        return n = this.toSeconds(n),
                        this.triggerAttack(n, i),
                        this.triggerRelease(n + this.toSeconds(t)),
                        this
                    }
                    cancel(t) {
                        return this._sig.cancelScheduledValues(this.toSeconds(t)),
                        this
                    }
                    connect(t, n=0, i=0) {
                        return ob(this, t, n, i),
                        this
                    }
                    asArray() {
                        return Ki(this, arguments, void 0, function*(t=1024) {
                            const n = t / this.context.sampleRate
                              , i = new uS(1,n,this.context.sampleRate)
                              , s = this.toSeconds(this.attack) + this.toSeconds(this.decay)
                              , r = s + this.toSeconds(this.release)
                              , l = r * .1
                              , h = r + l
                              , d = new this.constructor(Object.assign(this.get(), {
                                attack: n * this.toSeconds(this.attack) / h,
                                decay: n * this.toSeconds(this.decay) / h,
                                release: n * this.toSeconds(this.release) / h,
                                context: i
                            }));
                            return d._sig.toDestination(),
                            d.triggerAttackRelease(n * (s + l) / h, 0),
                            (yield i.render()).getChannelData(0)
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._sig.dispose(),
                        this
                    }
                }
                ;
                Zo([zc(0)], ah.prototype, "attack", void 0),
                Zo([zc(0)], ah.prototype, "decay", void 0),
                Zo([fO(0, 1)], ah.prototype, "sustain", void 0),
                Zo([zc(0)], ah.prototype, "release", void 0);
                const mS = ( () => {
                    let t, n;
                    const i = [];
                    for (t = 0; t < 128; t++)
                        i[t] = Math.sin(t / 127 * (Math.PI / 2));
                    const s = []
                      , r = 6.4;
                    for (t = 0; t < 127; t++)
                        n = t / 127,
                        s[t] = (Math.sin(n * (Math.PI * 2) * r - Math.PI / 2) + 1) / 10 + n * .83;
                    s[127] = 1;
                    const l = []
                      , h = 5;
                    for (t = 0; t < 128; t++)
                        l[t] = Math.ceil(t / 127 * h) / h;
                    const d = [];
                    for (t = 0; t < 128; t++)
                        n = t / 127,
                        d[t] = .5 * (1 - Math.cos(Math.PI * n));
                    const p = [];
                    for (t = 0; t < 128; t++) {
                        n = t / 127;
                        const _ = Math.pow(n, 3) * 4 + .2
                          , x = Math.cos(_ * Math.PI * 2 * n);
                        p[t] = Math.abs(x * (1 - n))
                    }
                    function m(_) {
                        const x = new Array(_.length);
                        for (let b = 0; b < _.length; b++)
                            x[b] = 1 - _[b];
                        return x
                    }
                    function v(_) {
                        return _.slice(0).reverse()
                    }
                    return {
                        bounce: {
                            In: m(p),
                            Out: p
                        },
                        cosine: {
                            In: i,
                            Out: v(i)
                        },
                        exponential: "exponential",
                        linear: "linear",
                        ripple: {
                            In: s,
                            Out: m(s)
                        },
                        sine: {
                            In: d,
                            Out: m(d)
                        },
                        step: {
                            In: l,
                            Out: m(l)
                        }
                    }
                }
                )();
                var fm = class PN extends tn {
                    constructor() {
                        const t = Pt(PN.getDefaults(), arguments);
                        super(t),
                        this._scheduledEvents = [],
                        this._synced = !1,
                        this._original_triggerAttack = this.triggerAttack,
                        this._original_triggerRelease = this.triggerRelease,
                        this._syncedRelease = n => this._original_triggerRelease(n),
                        this._volume = this.output = new fS({
                            context: this.context,
                            volume: t.volume
                        }),
                        this.volume = this._volume.volume,
                        ii(this, "volume")
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            volume: 0
                        })
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 0),
                        this.context.transport.on("stop", this._syncedRelease),
                        this.context.transport.on("pause", this._syncedRelease),
                        this.context.transport.on("loopEnd", this._syncedRelease)),
                        this
                    }
                    _syncState() {
                        let t = !1;
                        return this._synced || (this._synced = !0,
                        t = !0),
                        t
                    }
                    _syncMethod(t, n) {
                        const i = this["_original_" + t] = this[t];
                        this[t] = (...s) => {
                            const r = s[n]
                              , l = this.context.transport.schedule(h => {
                                s[n] = h,
                                i.apply(this, s)
                            }
                            , r);
                            this._scheduledEvents.push(l)
                        }
                    }
                    unsync() {
                        return this._scheduledEvents.forEach(t => this.context.transport.clear(t)),
                        this._scheduledEvents = [],
                        this._synced && (this._synced = !1,
                        this.triggerAttack = this._original_triggerAttack,
                        this.triggerRelease = this._original_triggerRelease,
                        this.context.transport.off("stop", this._syncedRelease),
                        this.context.transport.off("pause", this._syncedRelease),
                        this.context.transport.off("loopEnd", this._syncedRelease)),
                        this
                    }
                    triggerAttackRelease(t, n, i, s) {
                        const r = this.toSeconds(i)
                          , l = this.toSeconds(n);
                        return this.triggerAttack(t, r, s),
                        this.triggerRelease(r + l),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._volume.dispose(),
                        this.unsync(),
                        this._scheduledEvents = [],
                        this
                    }
                }
                  , Qf = class IN extends fm {
                    constructor() {
                        const t = Pt(IN.getDefaults(), arguments);
                        super(t),
                        this.portamento = t.portamento,
                        this.onsilence = t.onsilence
                    }
                    static getDefaults() {
                        return Object.assign(fm.getDefaults(), {
                            detune: 0,
                            onsilence: Vn,
                            portamento: 0
                        })
                    }
                    triggerAttack(t, n, i=1) {
                        this.log("triggerAttack", t, n, i);
                        const s = this.toSeconds(n);
                        return this._triggerEnvelopeAttack(s, i),
                        this.setNote(t, s),
                        this
                    }
                    triggerRelease(t) {
                        this.log("triggerRelease", t);
                        const n = this.toSeconds(t);
                        return this._triggerEnvelopeRelease(n),
                        this
                    }
                    setNote(t, n) {
                        const i = this.toSeconds(n)
                          , s = t instanceof ih ? t.toFrequency() : t;
                        if (this.portamento > 0 && this.getLevelAtTime(i) > .05) {
                            const r = this.toSeconds(this.portamento);
                            this.frequency.exponentialRampTo(s, r, i)
                        } else
                            this.frequency.setValueAtTime(s, i);
                        return this
                    }
                }
                ;
                Zo([zc(0)], Qf.prototype, "portamento", void 0);
                var V7 = class LN extends ah {
                    constructor() {
                        super(Pt(LN.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])),
                        this.name = "AmplitudeEnvelope",
                        this._gainNode = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        this.output = this._gainNode,
                        this.input = this._gainNode,
                        this._sig.connect(this._gainNode.gain),
                        this.output = this._gainNode,
                        this.input = this._gainNode
                    }
                    dispose() {
                        return super.dispose(),
                        this._gainNode.dispose(),
                        this
                    }
                }
                  , t0 = class zN extends Qf {
                    constructor() {
                        const t = Pt(zN.getDefaults(), arguments);
                        super(t),
                        this.name = "Synth",
                        this.oscillator = new pS(Object.assign({
                            context: this.context,
                            detune: t.detune,
                            onstop: () => this.onsilence(this)
                        }, t.oscillator)),
                        this.frequency = this.oscillator.frequency,
                        this.detune = this.oscillator.detune,
                        this.envelope = new V7(Object.assign({
                            context: this.context
                        }, t.envelope)),
                        this.oscillator.chain(this.envelope, this.output),
                        ii(this, ["oscillator", "frequency", "detune", "envelope"])
                    }
                    static getDefaults() {
                        return Object.assign(Qf.getDefaults(), {
                            envelope: Object.assign(nh(ah.getDefaults(), Object.keys(tn.getDefaults())), {
                                attack: .005,
                                decay: .1,
                                release: 1,
                                sustain: .3
                            }),
                            oscillator: Object.assign(nh(pS.getDefaults(), [...Object.keys(js.getDefaults()), "frequency", "detune"]), {
                                type: "triangle"
                            })
                        })
                    }
                    _triggerEnvelopeAttack(t, n) {
                        if (this.envelope.triggerAttack(t, n),
                        this.oscillator.start(t),
                        this.envelope.sustain === 0) {
                            const i = this.toSeconds(this.envelope.attack)
                              , s = this.toSeconds(this.envelope.decay);
                            this.oscillator.stop(t + i + s)
                        }
                    }
                    _triggerEnvelopeRelease(t) {
                        this.envelope.triggerRelease(t),
                        this.oscillator.stop(t + this.toSeconds(this.envelope.release))
                    }
                    getLevelAtTime(t) {
                        return t = this.toSeconds(t),
                        this.envelope.getValueAtTime(t)
                    }
                    dispose() {
                        return super.dispose(),
                        this.oscillator.dispose(),
                        this.envelope.dispose(),
                        this
                    }
                }
                  , hb = class FN extends Qf {
                    constructor() {
                        const t = Pt(FN.getDefaults(), arguments);
                        super(t),
                        this.name = "ModulationSynth",
                        this._carrier = new t0({
                            context: this.context,
                            oscillator: t.oscillator,
                            envelope: t.envelope,
                            onsilence: () => this.onsilence(this),
                            volume: -10
                        }),
                        this._modulator = new t0({
                            context: this.context,
                            oscillator: t.modulation,
                            envelope: t.modulationEnvelope,
                            volume: -10
                        }),
                        this.oscillator = this._carrier.oscillator,
                        this.envelope = this._carrier.envelope,
                        this.modulation = this._modulator.oscillator,
                        this.modulationEnvelope = this._modulator.envelope,
                        this.frequency = new Ms({
                            context: this.context,
                            units: "frequency"
                        }),
                        this.detune = new Ms({
                            context: this.context,
                            value: t.detune,
                            units: "cents"
                        }),
                        this.harmonicity = new hm({
                            context: this.context,
                            value: t.harmonicity,
                            minValue: 0
                        }),
                        this._modulationNode = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        ii(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"])
                    }
                    static getDefaults() {
                        return Object.assign(Qf.getDefaults(), {
                            harmonicity: 3,
                            oscillator: Object.assign(nh(pS.getDefaults(), [...Object.keys(js.getDefaults()), "frequency", "detune"]), {
                                type: "sine"
                            }),
                            envelope: Object.assign(nh(ah.getDefaults(), Object.keys(tn.getDefaults())), {
                                attack: .01,
                                decay: .01,
                                sustain: 1,
                                release: .5
                            }),
                            modulation: Object.assign(nh(pS.getDefaults(), [...Object.keys(js.getDefaults()), "frequency", "detune"]), {
                                type: "square"
                            }),
                            modulationEnvelope: Object.assign(nh(ah.getDefaults(), Object.keys(tn.getDefaults())), {
                                attack: .5,
                                decay: 0,
                                sustain: 1,
                                release: .5
                            })
                        })
                    }
                    _triggerEnvelopeAttack(t, n) {
                        this._carrier._triggerEnvelopeAttack(t, n),
                        this._modulator._triggerEnvelopeAttack(t, n)
                    }
                    _triggerEnvelopeRelease(t) {
                        return this._carrier._triggerEnvelopeRelease(t),
                        this._modulator._triggerEnvelopeRelease(t),
                        this
                    }
                    getLevelAtTime(t) {
                        return t = this.toSeconds(t),
                        this.envelope.getValueAtTime(t)
                    }
                    dispose() {
                        return super.dispose(),
                        this._carrier.dispose(),
                        this._modulator.dispose(),
                        this.frequency.dispose(),
                        this.detune.dispose(),
                        this.harmonicity.dispose(),
                        this._modulationNode.dispose(),
                        this
                    }
                }
                  , G7 = class HN extends hb {
                    constructor() {
                        super(Pt(HN.getDefaults(), arguments)),
                        this.name = "AMSynth",
                        this._modulationScale = new rO({
                            context: this.context
                        }),
                        this.frequency.connect(this._carrier.frequency),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this.detune.fan(this._carrier.detune, this._modulator.detune),
                        this._modulator.chain(this._modulationScale, this._modulationNode.gain),
                        this._carrier.chain(this._modulationNode, this.output)
                    }
                    dispose() {
                        return super.dispose(),
                        this._modulationScale.dispose(),
                        this
                    }
                }
                  , k7 = class VN extends hb {
                    constructor() {
                        const t = Pt(VN.getDefaults(), arguments);
                        super(t),
                        this.name = "FMSynth",
                        this.modulationIndex = new hm({
                            context: this.context,
                            value: t.modulationIndex
                        }),
                        this.frequency.connect(this._carrier.frequency),
                        this.frequency.chain(this.harmonicity, this._modulator.frequency),
                        this.frequency.chain(this.modulationIndex, this._modulationNode),
                        this.detune.fan(this._carrier.detune, this._modulator.detune),
                        this._modulator.connect(this._modulationNode.gain),
                        this._modulationNode.connect(this._carrier.frequency),
                        this._carrier.connect(this.output)
                    }
                    static getDefaults() {
                        return Object.assign(hb.getDefaults(), {
                            modulationIndex: 10
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.modulationIndex.dispose(),
                        this
                    }
                }
                  , pO = class GN extends t0 {
                    constructor() {
                        const t = Pt(GN.getDefaults(), arguments);
                        super(t),
                        this.name = "MembraneSynth",
                        this.portamento = 0,
                        this.pitchDecay = t.pitchDecay,
                        this.octaves = t.octaves,
                        ii(this, ["oscillator", "envelope"])
                    }
                    static getDefaults() {
                        return Xf(Qf.getDefaults(), t0.getDefaults(), {
                            envelope: {
                                attack: .001,
                                attackCurve: "exponential",
                                decay: .4,
                                release: 1.4,
                                sustain: .01
                            },
                            octaves: 10,
                            oscillator: {
                                type: "sine"
                            },
                            pitchDecay: .05
                        })
                    }
                    setNote(t, n) {
                        const i = this.toSeconds(n)
                          , s = this.toFrequency(t instanceof ih ? t.toFrequency() : t)
                          , r = s * this.octaves;
                        return this.oscillator.frequency.setValueAtTime(r, i),
                        this.oscillator.frequency.exponentialRampToValueAtTime(s, i + this.toSeconds(this.pitchDecay)),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this
                    }
                }
                ;
                Zo([fO(0)], pO.prototype, "octaves", void 0),
                Zo([zc(0)], pO.prototype, "pitchDecay", void 0);
                const mO = new Set;
                function fb(e) {
                    mO.add(e)
                }
                function gO(e, t) {
                    const n = `registerProcessor("${e}", ${t})`;
                    mO.add(n)
                }
                fb(`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`);
                const X7 = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
                fb(X7),
                fb(`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`);
                const q7 = "feedback-comb-filter";
                gO(q7, `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`);
                var vO = class kN extends fm {
                    constructor() {
                        const t = Pt(kN.getDefaults(), arguments, ["voice", "options"]);
                        super(t),
                        this.name = "PolySynth",
                        this._availableVoices = [],
                        this._activeVoices = [],
                        this._voices = [],
                        this._gcTimeout = -1,
                        this._averageActiveVoices = 0,
                        this._syncedRelease = s => this.releaseAll(s),
                        Wt(!Yl(t.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
                        const n = t.voice.getDefaults();
                        this.options = Object.assign(n, t.options),
                        this.voice = t.voice,
                        this.maxPolyphony = t.maxPolyphony,
                        this._dummyVoice = this._getNextAvailableVoice();
                        const i = this._voices.indexOf(this._dummyVoice);
                        this._voices.splice(i, 1),
                        this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1)
                    }
                    static getDefaults() {
                        return Object.assign(fm.getDefaults(), {
                            maxPolyphony: 32,
                            options: {},
                            voice: t0
                        })
                    }
                    get activeVoices() {
                        return this._activeVoices.length
                    }
                    _makeVoiceAvailable(t) {
                        this._availableVoices.push(t);
                        const n = this._activeVoices.findIndex(i => i.voice === t);
                        this._activeVoices.splice(n, 1)
                    }
                    _getNextAvailableVoice() {
                        if (this._availableVoices.length)
                            return this._availableVoices.shift();
                        if (this._voices.length < this.maxPolyphony) {
                            const t = new this.voice(Object.assign(this.options, {
                                context: this.context,
                                onsilence: this._makeVoiceAvailable.bind(this)
                            }));
                            return Wt(t instanceof Qf, "Voice must extend Monophonic class"),
                            t.connect(this.output),
                            this._voices.push(t),
                            t
                        } else
                            aS("Max polyphony exceeded. Note dropped.")
                    }
                    _collectGarbage() {
                        if (this._averageActiveVoices = Math.max(this._averageActiveVoices * .95, this.activeVoices),
                        this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
                            const t = this._availableVoices.shift()
                              , n = this._voices.indexOf(t);
                            this._voices.splice(n, 1),
                            this.context.isOffline || t.dispose()
                        }
                    }
                    _triggerAttack(t, n, i) {
                        t.forEach(s => {
                            const r = new nO(this.context,s).toMidi()
                              , l = this._getNextAvailableVoice();
                            l && (l.triggerAttack(s, n, i),
                            this._activeVoices.push({
                                midi: r,
                                voice: l,
                                released: !1
                            }),
                            this.log("triggerAttack", s, n))
                        }
                        )
                    }
                    _triggerRelease(t, n) {
                        t.forEach(i => {
                            const s = new nO(this.context,i).toMidi()
                              , r = this._activeVoices.find( ({midi: l, released: h}) => l === s && !h);
                            r && (r.voice.triggerRelease(n),
                            r.released = !0,
                            this.log("triggerRelease", i, n))
                        }
                        )
                    }
                    _scheduleEvent(t, n, i, s) {
                        Wt(!this.disposed, "Synth was already disposed"),
                        i <= this.now() ? t === "attack" ? this._triggerAttack(n, i, s) : this._triggerRelease(n, i) : this.context.setTimeout( () => {
                            this.disposed || this._scheduleEvent(t, n, i, s)
                        }
                        , i - this.now())
                    }
                    triggerAttack(t, n, i) {
                        Array.isArray(t) || (t = [t]);
                        const s = this.toSeconds(n);
                        return this._scheduleEvent("attack", t, s, i),
                        this
                    }
                    triggerRelease(t, n) {
                        Array.isArray(t) || (t = [t]);
                        const i = this.toSeconds(n);
                        return this._scheduleEvent("release", t, i),
                        this
                    }
                    triggerAttackRelease(t, n, i, s) {
                        const r = this.toSeconds(i);
                        if (this.triggerAttack(t, r, s),
                        ha(n)) {
                            Wt(ha(t), "If the duration is an array, the notes must also be an array"),
                            t = t;
                            for (let l = 0; l < t.length; l++) {
                                const h = n[Math.min(l, n.length - 1)]
                                  , d = this.toSeconds(h);
                                Wt(d > 0, "The duration must be greater than 0"),
                                this.triggerRelease(t[l], r + d)
                            }
                        } else {
                            const l = this.toSeconds(n);
                            Wt(l > 0, "The duration must be greater than 0"),
                            this.triggerRelease(t, r + l)
                        }
                        return this
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 1),
                        this.context.transport.on("stop", this._syncedRelease),
                        this.context.transport.on("pause", this._syncedRelease),
                        this.context.transport.on("loopEnd", this._syncedRelease)),
                        this
                    }
                    set(t) {
                        const n = nh(t, ["onsilence", "context"]);
                        return this.options = Xf(this.options, n),
                        this._voices.forEach(i => i.set(n)),
                        this._dummyVoice.set(n),
                        this
                    }
                    get() {
                        return this._dummyVoice.get()
                    }
                    releaseAll(t) {
                        const n = this.toSeconds(t);
                        return this._activeVoices.forEach( ({voice: i}) => {
                            i.triggerRelease(n)
                        }
                        ),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._dummyVoice.dispose(),
                        this._voices.forEach(t => t.dispose()),
                        this._activeVoices = [],
                        this._availableVoices = [],
                        this.context.clearInterval(this._gcTimeout),
                        this
                    }
                }
                  , yO = class XN extends fm {
                    constructor() {
                        const t = Pt(XN.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
                        super(t),
                        this.name = "Sampler",
                        this._activeSources = new Map;
                        const n = {};
                        Object.keys(t.urls).forEach(i => {
                            const s = parseInt(i, 10);
                            if (Wt(sS(i) || Yl(s) && isFinite(s), `url key is neither a note or midi pitch: ${i}`),
                            sS(i)) {
                                const r = new ih(this.context,i).toMidi();
                                n[r] = t.urls[i]
                            } else
                                Yl(s) && isFinite(s) && (n[s] = t.urls[s])
                        }
                        ),
                        this._buffers = new N7({
                            urls: n,
                            onload: t.onload,
                            baseUrl: t.baseUrl,
                            onerror: t.onerror
                        }),
                        this.attack = t.attack,
                        this.release = t.release,
                        this.curve = t.curve,
                        this._buffers.loaded && Promise.resolve().then(t.onload)
                    }
                    static getDefaults() {
                        return Object.assign(fm.getDefaults(), {
                            attack: 0,
                            baseUrl: "",
                            curve: "exponential",
                            onload: Vn,
                            onerror: Vn,
                            release: .1,
                            urls: {}
                        })
                    }
                    _findClosest(t) {
                        let i = 0;
                        for (; i < 96; ) {
                            if (this._buffers.has(t + i))
                                return -i;
                            if (this._buffers.has(t - i))
                                return i;
                            i++
                        }
                        throw new Error(`No available buffers for note: ${t}`)
                    }
                    triggerAttack(t, n, i=1) {
                        return this.log("triggerAttack", t, n, i),
                        Array.isArray(t) || (t = [t]),
                        t.forEach(s => {
                            const r = $2(new ih(this.context,s).toFrequency())
                              , l = Math.round(r)
                              , h = r - l
                              , d = this._findClosest(l)
                              , p = l - d
                              , m = this._buffers.get(p)
                              , v = J2(d + h)
                              , _ = new lb({
                                url: m,
                                context: this.context,
                                curve: this.curve,
                                fadeIn: this.attack,
                                fadeOut: this.release,
                                playbackRate: v
                            }).connect(this.output);
                            _.start(n, 0, m.duration / v, i),
                            ha(this._activeSources.get(l)) || this._activeSources.set(l, []),
                            this._activeSources.get(l).push(_),
                            _.onended = () => {
                                if (this._activeSources && this._activeSources.has(l)) {
                                    const x = this._activeSources.get(l)
                                      , b = x.indexOf(_);
                                    b !== -1 && x.splice(b, 1)
                                }
                            }
                        }
                        ),
                        this
                    }
                    triggerRelease(t, n) {
                        return this.log("triggerRelease", t, n),
                        Array.isArray(t) || (t = [t]),
                        t.forEach(i => {
                            const s = new ih(this.context,i).toMidi();
                            if (this._activeSources.has(s) && this._activeSources.get(s).length) {
                                const r = this._activeSources.get(s);
                                n = this.toSeconds(n),
                                r.forEach(l => {
                                    l.stop(n)
                                }
                                ),
                                this._activeSources.set(s, [])
                            }
                        }
                        ),
                        this
                    }
                    releaseAll(t) {
                        const n = this.toSeconds(t);
                        return this._activeSources.forEach(i => {
                            for (; i.length; )
                                i.shift().stop(n)
                        }
                        ),
                        this
                    }
                    sync() {
                        return this._syncState() && (this._syncMethod("triggerAttack", 1),
                        this._syncMethod("triggerRelease", 1)),
                        this
                    }
                    triggerAttackRelease(t, n, i, s=1) {
                        const r = this.toSeconds(i);
                        return this.triggerAttack(t, r, s),
                        ha(n) ? (Wt(ha(t), "notes must be an array when duration is array"),
                        t.forEach( (l, h) => {
                            const d = n[Math.min(h, n.length - 1)];
                            this.triggerRelease(l, r + this.toSeconds(d))
                        }
                        )) : this.triggerRelease(t, r + this.toSeconds(n)),
                        this
                    }
                    add(t, n, i) {
                        if (Wt(sS(t) || isFinite(t), `note must be a pitch or midi: ${t}`),
                        sS(t)) {
                            const s = new ih(this.context,t).toMidi();
                            this._buffers.add(s, n, i)
                        } else
                            this._buffers.add(t, n, i);
                        return this
                    }
                    get loaded() {
                        return this._buffers.loaded
                    }
                    dispose() {
                        return super.dispose(),
                        this._buffers.dispose(),
                        this._activeSources.forEach(t => {
                            t.forEach(n => n.dispose())
                        }
                        ),
                        this._activeSources.clear(),
                        this
                    }
                }
                ;
                Zo([zc(0)], yO.prototype, "attack", void 0),
                Zo([zc(0)], yO.prototype, "release", void 0);
                var dm = class qN extends uo {
                    constructor() {
                        const t = Pt(qN.getDefaults(), arguments, ["callback", "value"]);
                        super(t),
                        this.name = "ToneEvent",
                        this._state = new Jv("stopped"),
                        this._startOffset = 0,
                        this._loop = t.loop,
                        this.callback = t.callback,
                        this.value = t.value,
                        this._loopStart = this.toTicks(t.loopStart),
                        this._loopEnd = this.toTicks(t.loopEnd),
                        this._playbackRate = t.playbackRate,
                        this._probability = t.probability,
                        this._humanize = t.humanize,
                        this.mute = t.mute,
                        this._playbackRate = t.playbackRate,
                        this._state.increasing = !0,
                        this._rescheduleEvents()
                    }
                    static getDefaults() {
                        return Object.assign(uo.getDefaults(), {
                            callback: Vn,
                            humanize: !1,
                            loop: !1,
                            loopEnd: "1m",
                            loopStart: 0,
                            mute: !1,
                            playbackRate: 1,
                            probability: 1,
                            value: null
                        })
                    }
                    _rescheduleEvents(t=-1) {
                        this._state.forEachFrom(t, n => {
                            let i;
                            if (n.state === "started") {
                                n.id !== -1 && this.context.transport.clear(n.id);
                                const s = n.time + Math.round(this.startOffset / this._playbackRate);
                                if (this._loop === !0 || Yl(this._loop) && this._loop > 1) {
                                    i = 1 / 0,
                                    Yl(this._loop) && (i = this._loop * this._getLoopDuration());
                                    const r = this._state.getAfter(s);
                                    r !== null && (i = Math.min(i, r.time - s)),
                                    i !== 1 / 0 && (i = new Gi(this.context,i));
                                    const l = new Gi(this.context,this._getLoopDuration());
                                    n.id = this.context.transport.scheduleRepeat(this._tick.bind(this), l, new Gi(this.context,s), i)
                                } else
                                    n.id = this.context.transport.schedule(this._tick.bind(this), new Gi(this.context,s))
                            }
                        }
                        )
                    }
                    get state() {
                        return this._state.getValueAtTime(this.context.transport.ticks)
                    }
                    get startOffset() {
                        return this._startOffset
                    }
                    set startOffset(t) {
                        this._startOffset = t
                    }
                    get probability() {
                        return this._probability
                    }
                    set probability(t) {
                        this._probability = t
                    }
                    get humanize() {
                        return this._humanize
                    }
                    set humanize(t) {
                        this._humanize = t
                    }
                    start(t) {
                        const n = this.toTicks(t);
                        return this._state.getValueAtTime(n) === "stopped" && (this._state.add({
                            id: -1,
                            state: "started",
                            time: n
                        }),
                        this._rescheduleEvents(n)),
                        this
                    }
                    stop(t) {
                        this.cancel(t);
                        const n = this.toTicks(t);
                        if (this._state.getValueAtTime(n) === "started") {
                            this._state.setStateAtTime("stopped", n, {
                                id: -1
                            });
                            const i = this._state.getBefore(n);
                            let s = n;
                            i !== null && (s = i.time),
                            this._rescheduleEvents(s)
                        }
                        return this
                    }
                    cancel(t) {
                        t = jl(t, -1 / 0);
                        const n = this.toTicks(t);
                        return this._state.forEachFrom(n, i => {
                            this.context.transport.clear(i.id)
                        }
                        ),
                        this._state.cancel(n),
                        this
                    }
                    _tick(t) {
                        const n = this.context.transport.getTicksAtTime(t);
                        if (!this.mute && this._state.getValueAtTime(n) === "started") {
                            if (this.probability < 1 && Math.random() > this.probability)
                                return;
                            if (this.humanize) {
                                let i = .02;
                                V2(this.humanize) || (i = this.toSeconds(this.humanize)),
                                t += (Math.random() * 2 - 1) * i
                            }
                            this.callback(t, this.value)
                        }
                    }
                    _getLoopDuration() {
                        return (this._loopEnd - this._loopStart) / this._playbackRate
                    }
                    get loop() {
                        return this._loop
                    }
                    set loop(t) {
                        this._loop = t,
                        this._rescheduleEvents()
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(t) {
                        this._playbackRate = t,
                        this._rescheduleEvents()
                    }
                    get loopEnd() {
                        return new Gi(this.context,this._loopEnd).toSeconds()
                    }
                    set loopEnd(t) {
                        this._loopEnd = this.toTicks(t),
                        this._loop && this._rescheduleEvents()
                    }
                    get loopStart() {
                        return new Gi(this.context,this._loopStart).toSeconds()
                    }
                    set loopStart(t) {
                        this._loopStart = this.toTicks(t),
                        this._loop && this._rescheduleEvents()
                    }
                    get progress() {
                        if (this._loop) {
                            const t = this.context.transport.ticks
                              , n = this._state.get(t);
                            if (n !== null && n.state === "started") {
                                const i = this._getLoopDuration();
                                return (t - n.time) % i / i
                            } else
                                return 0
                        } else
                            return 0
                    }
                    dispose() {
                        return super.dispose(),
                        this.cancel(),
                        this._state.dispose(),
                        this
                    }
                }
                  , Y7 = class yb extends dm {
                    constructor() {
                        const t = Pt(yb.getDefaults(), arguments, ["callback", "events"]);
                        super(t),
                        this.name = "Part",
                        this._state = new Jv("stopped"),
                        this._events = new Set,
                        this._state.increasing = !0,
                        t.events.forEach(n => {
                            ha(n) ? this.add(n[0], n[1]) : this.add(n)
                        }
                        )
                    }
                    static getDefaults() {
                        return Object.assign(dm.getDefaults(), {
                            events: []
                        })
                    }
                    start(t, n) {
                        const i = this.toTicks(t);
                        if (this._state.getValueAtTime(i) !== "started") {
                            n = jl(n, this._loop ? this._loopStart : 0),
                            this._loop ? n = jl(n, this._loopStart) : n = jl(n, 0);
                            const s = this.toTicks(n);
                            this._state.add({
                                id: -1,
                                offset: s,
                                state: "started",
                                time: i
                            }),
                            this._forEach(r => {
                                this._startNote(r, i, s)
                            }
                            )
                        }
                        return this
                    }
                    _startNote(t, n, i) {
                        n -= i,
                        this._loop ? t.startOffset >= this._loopStart && t.startOffset < this._loopEnd ? (t.startOffset < i && (n += this._getLoopDuration()),
                        t.start(new Gi(this.context,n))) : t.startOffset < this._loopStart && t.startOffset >= i && (t.loop = !1,
                        t.start(new Gi(this.context,n))) : t.startOffset >= i && t.start(new Gi(this.context,n))
                    }
                    get startOffset() {
                        return this._startOffset
                    }
                    set startOffset(t) {
                        this._startOffset = t,
                        this._forEach(n => {
                            n.startOffset += this._startOffset
                        }
                        )
                    }
                    stop(t) {
                        const n = this.toTicks(t);
                        return this._state.cancel(n),
                        this._state.setStateAtTime("stopped", n),
                        this._forEach(i => {
                            i.stop(t)
                        }
                        ),
                        this
                    }
                    at(t, n) {
                        const i = new lm(this.context,t).toTicks()
                          , s = new Gi(this.context,1).toSeconds()
                          , r = this._events.values();
                        let l = r.next();
                        for (; !l.done; ) {
                            const h = l.value;
                            if (Math.abs(i - h.startOffset) < s)
                                return fn(n) && (h.value = n),
                                h;
                            l = r.next()
                        }
                        return fn(n) ? (this.add(t, n),
                        this.at(t)) : null
                    }
                    add(t, n) {
                        t instanceof Object && Reflect.has(t, "time") && (n = t,
                        t = n.time);
                        const i = this.toTicks(t);
                        let s;
                        return n instanceof dm ? (s = n,
                        s.callback = this._tick.bind(this)) : s = new dm({
                            callback: this._tick.bind(this),
                            context: this.context,
                            value: n
                        }),
                        s.startOffset = i,
                        s.set({
                            humanize: this.humanize,
                            loop: this.loop,
                            loopEnd: this.loopEnd,
                            loopStart: this.loopStart,
                            playbackRate: this.playbackRate,
                            probability: this.probability
                        }),
                        this._events.add(s),
                        this._restartEvent(s),
                        this
                    }
                    _restartEvent(t) {
                        this._state.forEach(n => {
                            n.state === "started" ? this._startNote(t, n.time, n.offset) : t.stop(new Gi(this.context,n.time))
                        }
                        )
                    }
                    remove(t, n) {
                        return eh(t) && t.hasOwnProperty("time") && (n = t,
                        t = n.time),
                        t = this.toTicks(t),
                        this._events.forEach(i => {
                            i.startOffset === t && (Nr(n) || fn(n) && i.value === n) && (this._events.delete(i),
                            i.dispose())
                        }
                        ),
                        this
                    }
                    clear() {
                        return this._forEach(t => t.dispose()),
                        this._events.clear(),
                        this
                    }
                    cancel(t) {
                        return this._forEach(n => n.cancel(t)),
                        this._state.cancel(this.toTicks(t)),
                        this
                    }
                    _forEach(t) {
                        return this._events && this._events.forEach(n => {
                            n instanceof yb ? n._forEach(t) : t(n)
                        }
                        ),
                        this
                    }
                    _setAll(t, n) {
                        this._forEach(i => {
                            i[t] = n
                        }
                        )
                    }
                    _tick(t, n) {
                        this.mute || this.callback(t, n)
                    }
                    _testLoopBoundries(t) {
                        this._loop && (t.startOffset < this._loopStart || t.startOffset >= this._loopEnd) ? t.cancel(0) : t.state === "stopped" && this._restartEvent(t)
                    }
                    get probability() {
                        return this._probability
                    }
                    set probability(t) {
                        this._probability = t,
                        this._setAll("probability", t)
                    }
                    get humanize() {
                        return this._humanize
                    }
                    set humanize(t) {
                        this._humanize = t,
                        this._setAll("humanize", t)
                    }
                    get loop() {
                        return this._loop
                    }
                    set loop(t) {
                        this._loop = t,
                        this._forEach(n => {
                            n.loopStart = this.loopStart,
                            n.loopEnd = this.loopEnd,
                            n.loop = t,
                            this._testLoopBoundries(n)
                        }
                        )
                    }
                    get loopEnd() {
                        return new Gi(this.context,this._loopEnd).toSeconds()
                    }
                    set loopEnd(t) {
                        this._loopEnd = this.toTicks(t),
                        this._loop && this._forEach(n => {
                            n.loopEnd = t,
                            this._testLoopBoundries(n)
                        }
                        )
                    }
                    get loopStart() {
                        return new Gi(this.context,this._loopStart).toSeconds()
                    }
                    set loopStart(t) {
                        this._loopStart = this.toTicks(t),
                        this._loop && this._forEach(n => {
                            n.loopStart = this.loopStart,
                            this._testLoopBoundries(n)
                        }
                        )
                    }
                    get playbackRate() {
                        return this._playbackRate
                    }
                    set playbackRate(t) {
                        this._playbackRate = t,
                        this._setAll("playbackRate", t)
                    }
                    get length() {
                        return this._events.size
                    }
                    dispose() {
                        return super.dispose(),
                        this.clear(),
                        this
                    }
                }
                  , W7 = class YN extends dm {
                    constructor() {
                        const t = Pt(YN.getDefaults(), arguments, ["callback", "events", "subdivision"]);
                        super(t),
                        this.name = "Sequence",
                        this._part = new Y7({
                            callback: this._seqCallback.bind(this),
                            context: this.context
                        }),
                        this._events = [],
                        this._eventsArray = [],
                        this._subdivision = this.toTicks(t.subdivision),
                        this.events = t.events,
                        this.loop = t.loop,
                        this.loopStart = t.loopStart,
                        this.loopEnd = t.loopEnd,
                        this.playbackRate = t.playbackRate,
                        this.probability = t.probability,
                        this.humanize = t.humanize,
                        this.mute = t.mute,
                        this.playbackRate = t.playbackRate
                    }
                    static getDefaults() {
                        return Object.assign(nh(dm.getDefaults(), ["value"]), {
                            events: [],
                            loop: !0,
                            loopEnd: 0,
                            loopStart: 0,
                            subdivision: "8n"
                        })
                    }
                    _seqCallback(t, n) {
                        n !== null && !this.mute && this.callback(t, n)
                    }
                    get events() {
                        return this._events
                    }
                    set events(t) {
                        this.clear(),
                        this._eventsArray = t,
                        this._events = this._createSequence(this._eventsArray),
                        this._eventsUpdated()
                    }
                    start(t, n) {
                        return this._part.start(t, n && this._indexTime(n)),
                        this
                    }
                    stop(t) {
                        return this._part.stop(t),
                        this
                    }
                    get subdivision() {
                        return new Gi(this.context,this._subdivision).toSeconds()
                    }
                    _createSequence(t) {
                        return new Proxy(t,{
                            get: (n, i) => n[i],
                            set: (n, i, s) => (Wl(i) && isFinite(parseInt(i, 10)) && ha(s) ? n[i] = this._createSequence(s) : n[i] = s,
                            this._eventsUpdated(),
                            !0)
                        })
                    }
                    _eventsUpdated() {
                        this._part.clear(),
                        this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset),
                        this.loopEnd = this.loopEnd
                    }
                    _rescheduleSequence(t, n, i) {
                        t.forEach( (s, r) => {
                            const l = r * n + i;
                            if (ha(s))
                                this._rescheduleSequence(s, n / s.length, l);
                            else {
                                const h = new Gi(this.context,l,"i").toSeconds();
                                this._part.add(h, s)
                            }
                        }
                        )
                    }
                    _indexTime(t) {
                        return new Gi(this.context,t * this._subdivision + this.startOffset).toSeconds()
                    }
                    clear() {
                        return this._part.clear(),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._part.dispose(),
                        this
                    }
                    get loop() {
                        return this._part.loop
                    }
                    set loop(t) {
                        this._part.loop = t
                    }
                    get loopStart() {
                        return this._loopStart
                    }
                    set loopStart(t) {
                        this._loopStart = t,
                        this._part.loopStart = this._indexTime(t)
                    }
                    get loopEnd() {
                        return this._loopEnd
                    }
                    set loopEnd(t) {
                        this._loopEnd = t,
                        t === 0 ? this._part.loopEnd = this._indexTime(this._eventsArray.length) : this._part.loopEnd = this._indexTime(t)
                    }
                    get startOffset() {
                        return this._part.startOffset
                    }
                    set startOffset(t) {
                        this._part.startOffset = t
                    }
                    get playbackRate() {
                        return this._part.playbackRate
                    }
                    set playbackRate(t) {
                        this._part.playbackRate = t
                    }
                    get probability() {
                        return this._part.probability
                    }
                    set probability(t) {
                        this._part.probability = t
                    }
                    get progress() {
                        return this._part.progress
                    }
                    get humanize() {
                        return this._part.humanize
                    }
                    set humanize(t) {
                        this._part.humanize = t
                    }
                    get length() {
                        return this._part.length
                    }
                }
                  , j7 = class WN extends tn {
                    constructor() {
                        const t = Pt(WN.getDefaults(), arguments, ["fade"]);
                        super(t),
                        this.name = "CrossFade",
                        this._panner = this.context.createStereoPanner(),
                        this._split = this.context.createChannelSplitter(2),
                        this._g2a = new H7({
                            context: this.context
                        }),
                        this.a = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        this.b = new Ui({
                            context: this.context,
                            gain: 0
                        }),
                        this.output = new Ui({
                            context: this.context
                        }),
                        this._internalChannels = [this.a, this.b],
                        this.fade = new Ms({
                            context: this.context,
                            units: "normalRange",
                            value: t.fade
                        }),
                        ii(this, "fade"),
                        this.context.getConstant(1).connect(this._panner),
                        this._panner.connect(this._split),
                        this._panner.channelCount = 1,
                        this._panner.channelCountMode = "explicit",
                        sh(this._split, this.a.gain, 0),
                        sh(this._split, this.b.gain, 1),
                        this.fade.chain(this._g2a, this._panner.pan),
                        this.a.connect(this.output),
                        this.b.connect(this.output)
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            fade: .5
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this.a.dispose(),
                        this.b.dispose(),
                        this.output.dispose(),
                        this.fade.dispose(),
                        this._g2a.dispose(),
                        this._panner.disconnect(),
                        this._split.disconnect(),
                        this
                    }
                }
                  , gS = class extends tn {
                    constructor(e) {
                        super(e),
                        this.name = "Effect",
                        this._dryWet = new j7({
                            context: this.context
                        }),
                        this.wet = this._dryWet.fade,
                        this.effectSend = new Ui({
                            context: this.context
                        }),
                        this.effectReturn = new Ui({
                            context: this.context
                        }),
                        this.input = new Ui({
                            context: this.context
                        }),
                        this.output = this._dryWet,
                        this.input.fan(this._dryWet.a, this.effectSend),
                        this.effectReturn.connect(this._dryWet.b),
                        this.wet.setValueAtTime(e.wet, 0),
                        this._internalChannels = [this.effectReturn, this.effectSend],
                        ii(this, "wet")
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            wet: 1
                        })
                    }
                    connectEffect(e) {
                        return this._internalChannels.push(e),
                        this.effectSend.chain(e, this.effectReturn),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._dryWet.dispose(),
                        this.effectSend.dispose(),
                        this.effectReturn.dispose(),
                        this.wet.dispose(),
                        this
                    }
                }
                  , Q7 = class jN extends tn {
                    constructor() {
                        const t = Pt(jN.getDefaults(), arguments, ["pan"]);
                        super(t),
                        this.name = "Panner",
                        this._panner = this.context.createStereoPanner(),
                        this.input = this._panner,
                        this.output = this._panner,
                        this.pan = new Ji({
                            context: this.context,
                            param: this._panner.pan,
                            value: t.pan,
                            minValue: -1,
                            maxValue: 1
                        }),
                        this._panner.channelCount = t.channelCount,
                        this._panner.channelCountMode = "explicit",
                        ii(this, "pan")
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            pan: 0,
                            channelCount: 1
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._panner.disconnect(),
                        this.pan.dispose(),
                        this
                    }
                }
                ;
                const Z7 = "bit-crusher"
                  , K7 = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
                gO(Z7, K7);
                var J7 = class QN extends tn {
                    constructor() {
                        const t = Pt(QN.getDefaults(), arguments, ["channels"]);
                        super(t),
                        this.name = "Merge",
                        this._merger = this.output = this.input = this.context.createChannelMerger(t.channels)
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            channels: 2
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._merger.disconnect(),
                        this
                    }
                }
                  , _O = class extends gS {
                    constructor(e) {
                        super(e),
                        this.name = "FeedbackEffect",
                        this._feedbackGain = new Ui({
                            context: this.context,
                            gain: e.feedback,
                            units: "normalRange"
                        }),
                        this.feedback = this._feedbackGain.gain,
                        ii(this, "feedback"),
                        this.effectReturn.chain(this._feedbackGain, this.effectSend)
                    }
                    static getDefaults() {
                        return Object.assign(gS.getDefaults(), {
                            feedback: .125
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._feedbackGain.dispose(),
                        this.feedback.dispose(),
                        this
                    }
                }
                  , $7 = class ZN extends _O {
                    constructor() {
                        const t = Pt(ZN.getDefaults(), arguments, ["delayTime", "feedback"]);
                        super(t),
                        this.name = "FeedbackDelay",
                        this._delayNode = new R7({
                            context: this.context,
                            delayTime: t.delayTime,
                            maxDelay: t.maxDelay
                        }),
                        this.delayTime = this._delayNode.delayTime,
                        this.connectEffect(this._delayNode),
                        ii(this, "delayTime")
                    }
                    static getDefaults() {
                        return Object.assign(_O.getDefaults(), {
                            delayTime: .25,
                            maxDelay: 1
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._delayNode.dispose(),
                        this.delayTime.dispose(),
                        this
                    }
                }
                ;
                const LX = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100]
                  , zX = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];
                var e9 = class KN extends gS {
                    constructor() {
                        const t = Pt(KN.getDefaults(), arguments, ["decay"]);
                        super(t),
                        this.name = "Reverb",
                        this._convolver = this.context.createConvolver(),
                        this.ready = Promise.resolve();
                        const n = this.toSeconds(t.decay);
                        lo(n, .001),
                        this._decay = n;
                        const i = this.toSeconds(t.preDelay);
                        lo(i, 0),
                        this._preDelay = i,
                        this.generate(),
                        this.connectEffect(this._convolver)
                    }
                    static getDefaults() {
                        return Object.assign(gS.getDefaults(), {
                            decay: 1.5,
                            preDelay: .01
                        })
                    }
                    get decay() {
                        return this._decay
                    }
                    set decay(t) {
                        t = this.toSeconds(t),
                        lo(t, .001),
                        this._decay = t,
                        this.generate()
                    }
                    get preDelay() {
                        return this._preDelay
                    }
                    set preDelay(t) {
                        t = this.toSeconds(t),
                        lo(t, 0),
                        this._preDelay = t,
                        this.generate()
                    }
                    generate() {
                        return Ki(this, void 0, void 0, function*() {
                            const t = this.ready
                              , n = new uS(2,this._decay + this._preDelay,this.context.sampleRate)
                              , i = new sO({
                                context: n
                            })
                              , s = new sO({
                                context: n
                            })
                              , r = new J7({
                                context: n
                            });
                            i.connect(r, 0, 0),
                            s.connect(r, 0, 1);
                            const l = new Ui({
                                context: n
                            }).toDestination();
                            r.connect(l),
                            i.start(0),
                            s.start(0),
                            l.gain.setValueAtTime(0, 0),
                            l.gain.setValueAtTime(1, this._preDelay),
                            l.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
                            const h = n.render();
                            return this.ready = h.then(Vn),
                            yield t,
                            this._convolver.buffer = (yield h).get(),
                            this
                        })
                    }
                    dispose() {
                        return super.dispose(),
                        this._convolver.disconnect(),
                        this
                    }
                }
                  , db = class Qs extends tn {
                    constructor() {
                        const t = Pt(Qs.getDefaults(), arguments, ["solo"]);
                        super(t),
                        this.name = "Solo",
                        this.input = this.output = new Ui({
                            context: this.context
                        }),
                        Qs._allSolos.has(this.context) || Qs._allSolos.set(this.context, new Set),
                        Qs._allSolos.get(this.context).add(this),
                        this.solo = t.solo
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            solo: !1
                        })
                    }
                    get solo() {
                        return this._isSoloed()
                    }
                    set solo(t) {
                        t ? this._addSolo() : this._removeSolo(),
                        Qs._allSolos.get(this.context).forEach(n => n._updateSolo())
                    }
                    get muted() {
                        return this.input.gain.value === 0
                    }
                    _addSolo() {
                        Qs._soloed.has(this.context) || Qs._soloed.set(this.context, new Set),
                        Qs._soloed.get(this.context).add(this)
                    }
                    _removeSolo() {
                        Qs._soloed.has(this.context) && Qs._soloed.get(this.context).delete(this)
                    }
                    _isSoloed() {
                        return Qs._soloed.has(this.context) && Qs._soloed.get(this.context).has(this)
                    }
                    _noSolos() {
                        return !Qs._soloed.has(this.context) || Qs._soloed.has(this.context) && Qs._soloed.get(this.context).size === 0
                    }
                    _updateSolo() {
                        this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0
                    }
                    dispose() {
                        return super.dispose(),
                        Qs._allSolos.get(this.context).delete(this),
                        this._removeSolo(),
                        this
                    }
                }
                ;
                db._allSolos = new Map,
                db._soloed = new Map;
                var t9 = class JN extends tn {
                    constructor() {
                        const t = Pt(JN.getDefaults(), arguments, ["pan", "volume"]);
                        super(t),
                        this.name = "PanVol",
                        this._panner = this.input = new Q7({
                            context: this.context,
                            pan: t.pan,
                            channelCount: t.channelCount
                        }),
                        this.pan = this._panner.pan,
                        this._volume = this.output = new fS({
                            context: this.context,
                            volume: t.volume
                        }),
                        this.volume = this._volume.volume,
                        this._panner.connect(this._volume),
                        this.mute = t.mute,
                        ii(this, ["pan", "volume"])
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            mute: !1,
                            pan: 0,
                            volume: 0,
                            channelCount: 1
                        })
                    }
                    get mute() {
                        return this._volume.mute
                    }
                    set mute(t) {
                        this._volume.mute = t
                    }
                    dispose() {
                        return super.dispose(),
                        this._panner.dispose(),
                        this.pan.dispose(),
                        this._volume.dispose(),
                        this.volume.dispose(),
                        this
                    }
                }
                  , n9 = class i0 extends tn {
                    constructor() {
                        const t = Pt(i0.getDefaults(), arguments, ["volume", "pan"]);
                        super(t),
                        this.name = "Channel",
                        this._solo = this.input = new db({
                            solo: t.solo,
                            context: this.context
                        }),
                        this._panVol = this.output = new t9({
                            context: this.context,
                            pan: t.pan,
                            volume: t.volume,
                            mute: t.mute,
                            channelCount: t.channelCount
                        }),
                        this.pan = this._panVol.pan,
                        this.volume = this._panVol.volume,
                        this._solo.connect(this._panVol),
                        ii(this, ["pan", "volume"])
                    }
                    static getDefaults() {
                        return Object.assign(tn.getDefaults(), {
                            pan: 0,
                            volume: 0,
                            mute: !1,
                            solo: !1,
                            channelCount: 1
                        })
                    }
                    get solo() {
                        return this._solo.solo
                    }
                    set solo(t) {
                        this._solo.solo = t
                    }
                    get muted() {
                        return this._solo.muted || this.mute
                    }
                    get mute() {
                        return this._panVol.mute
                    }
                    set mute(t) {
                        this._panVol.mute = t
                    }
                    _getBus(t) {
                        return i0.buses.has(t) || i0.buses.set(t, new Ui({
                            context: this.context
                        })),
                        i0.buses.get(t)
                    }
                    send(t, n=0) {
                        const i = this._getBus(t)
                          , s = new Ui({
                            context: this.context,
                            units: "decibels",
                            gain: n
                        });
                        return this.connect(s),
                        s.connect(i),
                        s
                    }
                    receive(t) {
                        return this._getBus(t).connect(this),
                        this
                    }
                    dispose() {
                        return super.dispose(),
                        this._panVol.dispose(),
                        this.pan.dispose(),
                        this.volume.dispose(),
                        this._solo.dispose(),
                        this
                    }
                }
                ;
                n9.buses = new Map;
                function i9() {
                    return co().now()
                }
                const vS = co().transport
                  , s9 = co().destination
                  , FX = co().destination
                  , HX = co().listener
                  , VX = co().draw
                  , a9 = co()
                  , fa = oE.gizmoRuntime.tweaks({
                    backgroundColor: {
                        index: 0,
                        name: "Background",
                        type: "color",
                        value: "#000814"
                    },
                    centerColor: {
                        index: 1,
                        name: "Flower Center",
                        type: "color",
                        value: "#00B4D8"
                    },
                    petalColorStart: {
                        index: 2,
                        name: "Inner Petal",
                        type: "color",
                        value: "#0077B6"
                    },
                    petalColorEnd: {
                        index: 3,
                        name: "Outer Petal",
                        type: "color",
                        value: "#90E0EF"
                    },
                    particleCount: {
                        index: 4,
                        name: "Flower Particles",
                        type: "slider",
                        value: 15e3,
                        min: 1e3,
                        max: 3e4,
                        step: 100
                    },
                    flowerSize: {
                        index: 5,
                        name: "Flower Size",
                        type: "slider",
                        value: 5.3,
                        min: 1,
                        max: 12,
                        step: .1
                    },
                    rotationSpeed: {
                        index: 6,
                        name: "Rotation Speed",
                        type: "slider",
                        value: .05,
                        min: 0,
                        max: .5,
                        step: .01
                    },
                    waveStrength: {
                        index: 7,
                        name: "Wave Strength",
                        type: "slider",
                        value: .19,
                        min: 0,
                        max: .5,
                        step: .01
                    },
                    numLayers: {
                        index: 8,
                        name: "Layers",
                        type: "slider",
                        value: 7,
                        min: 1,
                        max: 8,
                        step: 1
                    },
                    numPetals: {
                        index: 9,
                        name: "Petals Per Layer",
                        type: "slider",
                        value: 7,
                        min: 3,
                        max: 15,
                        step: 1
                    },
                    petalCurve: {
                        index: 10,
                        name: "Petal Curve",
                        type: "slider",
                        value: .6,
                        min: 0,
                        max: 2,
                        step: .1
                    },
                    layerSeparation: {
                        index: 11,
                        name: "Layer Separation",
                        type: "slider",
                        value: .3,
                        min: 0,
                        max: 1,
                        step: .05
                    },
                    musicVolume: {
                        index: 12,
                        name: "Music Volume",
                        type: "slider",
                        value: -12,
                        min: -48,
                        max: 0,
                        step: 1
                    },
                    reverbAmount: {
                        index: 13,
                        name: "Reverb",
                        type: "slider",
                        value: .5,
                        min: 0,
                        max: 1,
                        step: .05
                    },
                    delayFeedback: {
                        index: 14,
                        name: "Delay",
                        type: "slider",
                        value: .4,
                        min: 0,
                        max: .9,
                        step: .05
                    },
                    musicTempo: {
                        index: 15,
                        name: "Tempo",
                        type: "slider",
                        value: 90,
                        min: 60,
                        max: 140,
                        step: 5
                    }
                });
                function r9({flowerKey: e, positionOffset: t=[0, 0, 0]}) {
                    const n = (0,
                    Le.useRef)()
                      , i = fa.centerColor.useState()
                      , s = fa.petalColorStart.useState()
                      , r = fa.petalColorEnd.useState()
                      , l = fa.particleCount.useState()
                      , h = fa.flowerSize.useState()
                      , d = fa.rotationSpeed.useState()
                      , p = fa.waveStrength.useState()
                      , m = fa.numLayers.useState()
                      , v = fa.numPetals.useState()
                      , _ = fa.petalCurve.useState()
                      , x = fa.layerSeparation.useState()
                      , {positions: b, colors: E} = (0,
                    Le.useMemo)( () => {
                        const T = l
                          , M = new Float32Array(T * 3)
                          , D = new Float32Array(T * 3)
                          , R = new at(i)
                          , O = new at(s)
                          , U = new at(r)
                          , B = Math.PI * (3 - Math.sqrt(5));
                        for (let I = 0; I < T; I++) {
                            const F = I * 3
                              , P = I / T
                              , L = Math.sqrt(P) * h
                              , H = I * B
                              , Z = Math.floor(P * m)
                              , K = P * m % 1
                              , te = Z % 2 * (Math.PI / v)
                              , ce = (H + te) * v
                              , G = Math.pow(Math.sin(ce * .5), 8) * .8 + .2
                              , V = L * G
                              , q = V * Math.cos(H)
                              , ee = V * Math.sin(H)
                              , se = -Z * x + Math.pow(L / h, 2) * _ * h;
                            M[F] = q,
                            M[F + 1] = ee,
                            M[F + 2] = se;
                            const X = Math.sqrt(I / T)
                              , J = O.clone().lerp(U, K);
                            let ze = R.clone().lerp(J, Math.min(X * 1.5, 1));
                            if (e === 0 && I < T * .1) {
                                const xe = new at("#FFD700");
                                ze = ze.lerp(xe, .5)
                            }
                            D[F] = ze.r,
                            D[F + 1] = ze.g,
                            D[F + 2] = ze.b
                        }
                        return {
                            positions: M,
                            colors: D
                        }
                    }
                    , [l, h, i, s, r, m, v, _, x, e]);
                    return Nv( ({clock: T}) => {
                        if (n.current) {
                            n.current.rotation.z = T.getElapsedTime() * d;
                            const M = T.getElapsedTime()
                              , D = n.current.geometry.attributes.position.array
                              , R = l;
                            for (let O = 0; O < R; O++) {
                                const U = O * 3
                                  , B = b[U]
                                  , I = b[U + 1]
                                  , F = Math.sqrt(B * B + I * I);
                                D[U + 2] = b[U + 2] + Math.sin(F * 1.5 - M * 2) * p
                            }
                            n.current.geometry.attributes.position.needsUpdate = !0
                        }
                    }
                    ),
                    (0,
                    Ut.jsxs)("points", {
                        ref: n,
                        position: t,
                        rotation: [-Math.PI / 2, 0, 0],
                        children: [(0,
                        Ut.jsxs)("bufferGeometry", {
                            children: [(0,
                            Ut.jsx)("bufferAttribute", {
                                attach: "attributes-position",
                                count: b.length / 3,
                                array: b,
                                itemSize: 3
                            }), (0,
                            Ut.jsx)("bufferAttribute", {
                                attach: "attributes-color",
                                count: E.length / 3,
                                array: E,
                                itemSize: 3
                            })]
                        }), (0,
                        Ut.jsx)("pointsMaterial", {
                            size: .07,
                            vertexColors: !0,
                            blending: Ny,
                            transparent: !0,
                            depthWrite: !1,
                            sizeAttenuation: !0
                        })]
                    }, `${l}-${e}`)
                }
                const o9 = ["C3", "Eb3", "F3", "G3", "Bb3", "C4", "Eb4", "F4"];
                function l9() {
                    const e = fa.backgroundColor.useState()
                      , [t,n] = Le.useState(0)
                      , i = fa.musicVolume.useState()
                      , s = fa.reverbAmount.useState()
                      , r = fa.delayFeedback.useState()
                      , l = fa.musicTempo.useState()
                      , [h,d] = (0,
                    Le.useState)(!1)
                      , p = (0,
                    Le.useRef)(null)
                      , m = (0,
                    Le.useRef)(null)
                      , v = (0,
                    Le.useCallback)( () => {
                        n(E => E + 1),
                        oE.gizmoRuntime.performHaptic("heavy")
                    }
                    , [])
                      , _ = () => {
                        m.current = setTimeout( () => {
                            v()
                        }
                        , 800)
                    }
                      , x = () => {
                        m.current && clearTimeout(m.current)
                    }
                      , b = (0,
                    Le.useMemo)( () => {
                        const E = [[0, 0, 0]]
                          , T = 7
                          , M = 6;
                        for (let O = 0; O < T; O++) {
                            const U = O / T * Math.PI * 2;
                            E.push([Math.cos(U) * M, 0, Math.sin(U) * M])
                        }
                        const D = 13
                          , R = 12;
                        for (let O = 0; O < D; O++) {
                            const U = O / D * Math.PI * 2;
                            E.push([Math.cos(U) * R, 0, Math.sin(U) * R])
                        }
                        return E
                    }
                    , []);
                    return (0,
                    Le.useEffect)( () => {
                        (async () => {
                            a9.state !== "running" && await g7(),
                            vS.start(),
                            d(!0),
                            console.log("Audio ready and transport started.")
                        }
                        )();
                        const T = new e9().toDestination()
                          , M = new $7("8n",.5).connect(T)
                          , D = new vO(k7,{
                            harmonicity: 1.5,
                            modulationIndex: 10,
                            envelope: {
                                attack: 4,
                                decay: 2,
                                sustain: .8,
                                release: 8
                            },
                            volume: -10
                        }).connect(M)
                          , R = new vO(G7,{
                            harmonicity: 2,
                            envelope: {
                                attack: .5,
                                decay: 1,
                                sustain: .5,
                                release: 2
                            },
                            volume: -15
                        }).connect(M)
                          , O = new W7( (U, B) => {
                            R.triggerAttackRelease(B, "2n", U)
                        }
                        ,o9,"2n").start(0);
                        return p.current = {
                            padSynth: D,
                            arpSynth: R,
                            reverb: T,
                            delay: M,
                            sequence: O
                        },
                        D.triggerAttack(["C3", "G3", "C4"], i9()),
                        () => {
                            Object.values(p.current).forEach(U => U.dispose()),
                            vS.stop(),
                            vS.cancel()
                        }
                    }
                    , []),
                    (0,
                    Le.useEffect)( () => {
                        if (p.current)
                            try {
                                s9.volume.value = i,
                                p.current.reverb.wet.value = s,
                                p.current.delay.feedback.value = r,
                                vS.bpm.value = l
                            } catch (E) {
                                console.error("Error updating audio params", E)
                            }
                    }
                    , [i, s, r, l, h]),
                    (0,
                    Ut.jsxs)(Ut.Fragment, {
                        children: [(0,
                        Ut.jsx)("div", {
                            "aria-hidden": !0,
                            className: "fixed inset-0 -z-10",
                            style: {
                                background: e
                            },
                            onTouchStart: _,
                            onTouchEnd: x,
                            onMouseDown: _,
                            onMouseUp: x
                        }), (0,
                        Ut.jsxs)($z, {
                            camera: {
                                position: [0, 18, 0],
                                fov: 75
                            },
                            className: "touch-none",
                            style: {
                                position: "absolute",
                                top: "50%",
                                left: "50%",
                                transform: "translate(-50%, -50%)"
                            },
                            children: [b.map( (E, T) => (0,
                            Ut.jsx)(r9, {
                                flowerKey: t,
                                positionOffset: E
                            }, `flower-${t}-${T}`)), (0,
                            Ut.jsx)(L5, {
                                children: (0,
                                Ut.jsx)(k5, {
                                    luminanceThreshold: .2,
                                    luminanceSmoothing: .9,
                                    height: 300
                                })
                            }), (0,
                            Ut.jsx)(lF, {
                                enableZoom: !0,
                                enablePan: !0,
                                minDistance: 5,
                                maxDistance: 40,
                                rotateSpeed: .5
                            })]
                        })]
                    })
                }
                var c9 = tr(aE());
                window.React = Le.default,
                window.gizmoRuntime = c9.gizmoRuntime;
                var u9 = class extends Le.Component {
                    render() {
                        return (0,
                        Ut.jsx)(l9, {})
                    }
                }
                ;
                iU.createRoot(document.getElementById("application")).render((0,
                Ut.jsx)(u9, {}));

                //# sourceMappingURL=app.js.map
            </script>
        </div>
    </body>
</html>
