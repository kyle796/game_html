<!DOCTYPE html>
<html lang="en">
    <head>
        <script>
            !function(e, t, n, o) {
                "use strict";
                var i, r, c = !1, u = {};
                function s(e, t, n, o, i) {
                    o = o || 0,
                    i = i || 0,
                    this.identifier = t,
                    this.target = e,
                    this.clientX = n.clientX + o,
                    this.clientY = n.clientY + i,
                    this.screenX = n.screenX + o,
                    this.screenY = n.screenY + i,
                    this.pageX = n.pageX + o,
                    this.pageY = n.pageY + i
                }
                function a() {
                    var e = [];
                    return e.item = function(e) {
                        return this[e] || null
                    }
                    ,
                    e.identifiedTouch = function(e) {
                        return this[e + 1] || null
                    }
                    ,
                    e
                }
                function d(e) {
                    e.preventDefault(),
                    e.stopPropagation()
                }
                function h(e) {
                    return function(t) {
                        d(t),
                        1 === t.which && (("mousedown" == t.type || !r || r && !r.dispatchEvent) && (r = t.target),
                        c && !t.shiftKey && (l("touchend", t),
                        c = !1),
                        l(e, t),
                        !c && t.shiftKey && (c = !0,
                        i = {
                            pageX: t.pageX,
                            pageY: t.pageY,
                            clientX: t.clientX,
                            clientY: t.clientY,
                            screenX: t.screenX,
                            screenY: t.screenY
                        },
                        l("touchstart", t)),
                        "mouseup" == t.type && (i = null,
                        c = !1,
                        r = null))
                    }
                }
                function l(e, n) {
                    var o = t.createEvent("Event");
                    o.initEvent(e, !0, !0),
                    o.altKey = n.altKey,
                    o.ctrlKey = n.ctrlKey,
                    o.metaKey = n.metaKey,
                    o.shiftKey = n.shiftKey,
                    o.touches = p(n, e),
                    o.targetTouches = p(n, e),
                    o.changedTouches = function(e, t) {
                        var n = f(e);
                        !c || "mouseup" == e.type || "touchstart" != t && "touchend" != t || n.splice(0, 1);
                        return n
                    }(n, e),
                    r.dispatchEvent(o)
                }
                function f(e) {
                    var t = new a;
                    if (c) {
                        var n = m.multiTouchOffset
                          , o = i.pageX - e.pageX
                          , u = i.pageY - e.pageY;
                        t.push(new s(r,1,i,-1 * o - n,-1 * u + n)),
                        t.push(new s(r,2,i,o + n,u - n))
                    } else
                        t.push(new s(r,1,e,0,0));
                    return t
                }
                function p(e, t) {
                    if ("mouseup" == e.type)
                        return new a;
                    var n = f(e);
                    return c && "mouseup" != e.type && "touchend" == t && n.splice(1, 1),
                    n
                }
                function v(e) {
                    var n, o, i, r;
                    for (o = 0; o < e.touches.length; o++)
                        for (var c in n = e.touches[o],
                        (i = u[n.identifier]) || (i = u[n.identifier] = t.createElement("div"),
                        t.body.appendChild(i)),
                        r = m.template(n))
                            i.style[c] = r[c];
                    if ("touchend" == e.type || "touchcancel" == e.type)
                        for (o = 0; o < e.changedTouches.length; o++)
                            n = e.changedTouches[o],
                            (i = u[n.identifier]) && (i.parentNode.removeChild(i),
                            delete u[n.identifier])
                }
                function m() {
                    "ontouchstart"in e || e.Modernizr && e.Modernizr.touch || (navigator.msMaxTouchPoints || navigator.maxTouchPoints) > 2 || (!function() {
                        for (var n = [e, t.documentElement], i = ["ontouchstart", "ontouchmove", "ontouchcancel", "ontouchend"], r = 0; r < n.length; r++)
                            for (var c = 0; c < i.length; c++)
                                n[r] && n[r][i[c]] == o && (n[r][i[c]] = null)
                    }(),
                    e.addEventListener("mousedown", h("touchstart"), !0),
                    e.addEventListener("mousemove", h("touchmove"), !0),
                    e.addEventListener("mouseup", h("touchend"), !0),
                    e.addEventListener("mouseenter", d, !0),
                    e.addEventListener("mouseleave", d, !0),
                    e.addEventListener("mouseout", d, !0),
                    e.addEventListener("mouseover", d, !0),
                    e.addEventListener("touchstart", v, !1),
                    e.addEventListener("touchmove", v, !1),
                    e.addEventListener("touchend", v, !1),
                    e.addEventListener("touchcancel", v, !1))
                }
                t.createTouch || (t.createTouch = function(t, n, i, r, c, u, a, d, h) {
                    return d != o && h != o || (d = r - e.pageXOffset,
                    h = c - e.pageYOffset),
                    new s(n,i,{
                        pageX: r,
                        pageY: c,
                        screenX: u,
                        screenY: a,
                        clientX: d,
                        clientY: h
                    })
                }
                ),
                t.createTouchList || (t.createTouchList = function() {
                    for (var e = new a, t = 0; t < arguments.length; t++)
                        e[t] = arguments[t];
                    return e.length = arguments.length,
                    e
                }
                ),
                m.multiTouchOffset = 75,
                m.template = function(e) {
                    var t = "translate(" + (e.clientX - 15) + "px, " + (e.clientY - 15) + "px)";
                    return {
                        position: "fixed",
                        left: 0,
                        top: 0,
                        background: "#fff",
                        border: "solid 1px #999",
                        opacity: .6,
                        borderRadius: "100%",
                        height: "30px",
                        width: "30px",
                        padding: 0,
                        margin: 0,
                        display: "block",
                        overflow: "hidden",
                        pointerEvents: "none",
                        webkitUserSelect: "none",
                        mozUserSelect: "none",
                        userSelect: "none",
                        webkitTransform: t,
                        mozTransform: t,
                        transform: t
                    }
                }
                ,
                "function" == typeof define && define.amd ? define((function() {
                    return m
                }
                )) : "undefined" != typeof module && module.exports ? module.exports = m : e.TouchEmulator = m
            }(window, document);
            TouchEmulator();
        </script>
        <meta charset="utf-8">
        <meta content="width=device-width,minimum-scale=1.0" name="viewport">
        <title>Gizmo</title>
        <style>
            *,:after,:before {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            ::backdrop {
                --tw-border-spacing-x: 0;
                --tw-border-spacing-y: 0;
                --tw-translate-x: 0;
                --tw-translate-y: 0;
                --tw-rotate: 0;
                --tw-skew-x: 0;
                --tw-skew-y: 0;
                --tw-scale-x: 1;
                --tw-scale-y: 1;
                --tw-pan-x: ;
                --tw-pan-y: ;
                --tw-pinch-zoom: ;
                --tw-scroll-snap-strictness: proximity;
                --tw-gradient-from-position: ;
                --tw-gradient-via-position: ;
                --tw-gradient-to-position: ;
                --tw-ordinal: ;
                --tw-slashed-zero: ;
                --tw-numeric-figure: ;
                --tw-numeric-spacing: ;
                --tw-numeric-fraction: ;
                --tw-ring-inset: ;
                --tw-ring-offset-width: 0px;
                --tw-ring-offset-color: #fff;
                --tw-ring-color: rgba(59,130,246,.5);
                --tw-ring-offset-shadow: 0 0 #0000;
                --tw-ring-shadow: 0 0 #0000;
                --tw-shadow: 0 0 #0000;
                --tw-shadow-colored: 0 0 #0000;
                --tw-blur: ;
                --tw-brightness: ;
                --tw-contrast: ;
                --tw-grayscale: ;
                --tw-hue-rotate: ;
                --tw-invert: ;
                --tw-saturate: ;
                --tw-sepia: ;
                --tw-drop-shadow: ;
                --tw-backdrop-blur: ;
                --tw-backdrop-brightness: ;
                --tw-backdrop-contrast: ;
                --tw-backdrop-grayscale: ;
                --tw-backdrop-hue-rotate: ;
                --tw-backdrop-invert: ;
                --tw-backdrop-opacity: ;
                --tw-backdrop-saturate: ;
                --tw-backdrop-sepia: ;
                --tw-contain-size: ;
                --tw-contain-layout: ;
                --tw-contain-paint: ;
                --tw-contain-style:
            }

            /*
! tailwindcss v3.4.19 | MIT License | https://tailwindcss.com
*/
            *,:after,:before {
                border: 0 solid #e5e7eb;
                box-sizing: border-box
            }

            :after,:before {
                --tw-content: ""
            }

            :host,html {
                line-height: 1.5;
                -webkit-text-size-adjust: 100%;
                font-family: ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;
                font-feature-settings: normal;
                font-variation-settings: normal;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
                -webkit-tap-highlight-color: transparent
            }

            body {
                line-height: inherit;
                margin: 0
            }

            hr {
                border-top-width: 1px;
                color: inherit;
                height: 0
            }

            abbr:where([title]) {
                -webkit-text-decoration: underline dotted;
                text-decoration: underline dotted
            }

            h1,h2,h3,h4,h5,h6 {
                font-size: inherit;
                font-weight: inherit
            }

            a {
                color: inherit;
                text-decoration: inherit
            }

            b,strong {
                font-weight: bolder
            }

            code,kbd,pre,samp {
                font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;
                font-feature-settings: normal;
                font-size: 1em;
                font-variation-settings: normal
            }

            small {
                font-size: 80%
            }

            sub,sup {
                font-size: 75%;
                line-height: 0;
                position: relative;
                vertical-align: baseline
            }

            sub {
                bottom: -.25em
            }

            sup {
                top: -.5em
            }

            table {
                border-collapse: collapse;
                border-color: inherit;
                text-indent: 0
            }

            button,input,optgroup,select,textarea {
                color: inherit;
                font-family: inherit;
                font-feature-settings: inherit;
                font-size: 100%;
                font-variation-settings: inherit;
                font-weight: inherit;
                letter-spacing: inherit;
                line-height: inherit;
                margin: 0;
                padding: 0
            }

            button,select {
                text-transform: none
            }

            button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]) {
                -webkit-appearance: button;
                background-color: transparent;
                background-image: none
            }

            :-moz-focusring {
                outline: auto
            }

            :-moz-ui-invalid {
                box-shadow: none
            }

            progress {
                vertical-align: baseline
            }

            ::-webkit-inner-spin-button,::-webkit-outer-spin-button {
                height: auto
            }

            [type=search] {
                -webkit-appearance: textfield;
                outline-offset: -2px
            }

            ::-webkit-search-decoration {
                -webkit-appearance: none
            }

            ::-webkit-file-upload-button {
                -webkit-appearance: button;
                font: inherit
            }

            summary {
                display: list-item
            }

            blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre {
                margin: 0
            }

            fieldset {
                margin: 0
            }

            fieldset,legend {
                padding: 0
            }

            menu,ol,ul {
                list-style: none;
                margin: 0;
                padding: 0
            }

            dialog {
                padding: 0
            }

            textarea {
                resize: vertical
            }

            input::-moz-placeholder,textarea::-moz-placeholder {
                color: #9ca3af;
                opacity: 1
            }

            input::placeholder,textarea::placeholder {
                color: #9ca3af;
                opacity: 1
            }

            [role=button],button {
                cursor: pointer
            }

            :disabled {
                cursor: default
            }

            audio,canvas,embed,iframe,img,object,svg,video {
                display: block;
                vertical-align: middle
            }

            img,video {
                height: auto;
                max-width: 100%
            }

            [hidden]:where(:not([hidden=until-found])) {
                display: none
            }

            .pointer-events-none {
                pointer-events: none
            }

            .absolute {
                position: absolute
            }

            .relative {
                position: relative
            }

            .bottom-8 {
                bottom: 2rem
            }

            .left-0 {
                left: 0
            }

            .left-8 {
                left: 2rem
            }

            .right-8 {
                right: 2rem
            }

            .top-12 {
                top: 3rem
            }

            .top-8 {
                top: 2rem
            }

            .z-10 {
                z-index: 10
            }

            .z-50 {
                z-index: 50
            }

            .my-1 {
                margin-bottom: .25rem;
                margin-top: .25rem
            }

            .flex {
                display: flex
            }

            .h-10 {
                height: 2.5rem
            }

            .h-screen {
                height: 100vh
            }

            .min-h-fit {
                min-height: -moz-fit-content;
                min-height: fit-content
            }

            .w-10 {
                width: 2.5rem
            }

            .w-screen {
                width: 100vw
            }

            .flex-col {
                flex-direction: column
            }

            .items-center {
                align-items: center
            }

            .justify-center {
                justify-content: center
            }

            .gap-1 {
                gap: .25rem
            }

            .overflow-hidden {
                overflow: hidden
            }

            .rounded {
                border-radius: .25rem
            }

            .rounded-full {
                border-radius: 9999px
            }

            .rounded-lg {
                border-radius: .5rem
            }

            .border {
                border-width: 1px
            }

            .border-t {
                border-top-width: 1px
            }

            .border-white {
                --tw-border-opacity: 1;
                border-color: rgb(255 255 255/var(--tw-border-opacity,1))
            }

            .border-opacity-20 {
                --tw-border-opacity: 0.2
            }

            .bg-black {
                --tw-bg-opacity: 1;
                background-color: rgb(0 0 0/var(--tw-bg-opacity,1))
            }

            .bg-opacity-90 {
                --tw-bg-opacity: 0.9
            }

            .p-2 {
                padding: .5rem
            }

            .px-2 {
                padding-left: .5rem;
                padding-right: .5rem
            }

            .py-1 {
                padding-bottom: .25rem;
                padding-top: .25rem
            }

            .text-left {
                text-align: left
            }

            .text-xs {
                font-size: .75rem;
                line-height: 1rem
            }

            .lowercase {
                text-transform: lowercase
            }

            .text-white {
                --tw-text-opacity: 1;
                color: rgb(255 255 255/var(--tw-text-opacity,1))
            }

            .outline {
                outline-style: solid
            }

            .filter {
                filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
            }

            .ease-in {
                transition-timing-function: cubic-bezier(.4,0,1,1)
            }

            * {
                -webkit-user-select: none;
                -moz-user-select: none;
                user-select: none
            }

            img {
                pointer-events: none;
                -webkit-touch-callout: none
            }

            .hover\:bg-white:hover {
                --tw-bg-opacity: 1;
                background-color: rgb(255 255 255/var(--tw-bg-opacity,1))
            }

            .hover\:bg-opacity-10:hover {
                --tw-bg-opacity: 0.1
            }

            /*# sourceMappingURL=app.css.map */
        </style>
        <meta content="https://content.gizmo.party/a7d9b155-7143-4f11-a5ac-b56fed4b60b4" name="gizmo-preload">
        <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' blob: data: *.gizmo.party *.content.gizmo.party; media-src 'self' data: *.gizmo.party *.content.gizmo.party; connect-src 'self' blob: *.gizmo.party *.content.gizmo.party; script-src 'self' blob: 'unsafe-eval' 'unsafe-inline' runtime.gizmo.party; style-src 'self' 'unsafe-inline'; worker-src 'self' blob:; font-src 'self' data:; object-src 'none'; base-uri 'none'; upgrade-insecure-requests; block-all-mixed-content">
    </head>
    <body>
        <div id="application">
            <script type="module">
                var B2 = Object.create
                  , iv = Object.defineProperty
                  , F2 = Object.getOwnPropertyDescriptor
                  , V2 = Object.getOwnPropertyNames
                  , k2 = Object.getPrototypeOf
                  , H2 = Object.prototype.hasOwnProperty
                  , Ai = (e, t) => () => (t || e((t = {
                    exports: {}
                }).exports, t),
                t.exports)
                  , G2 = (e, t) => {
                    let n = {};
                    for (var a in e)
                        iv(n, a, {
                            get: e[a],
                            enumerable: !0
                        });
                    return t && iv(n, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    n
                }
                  , W2 = (e, t, n, a) => {
                    if (t && typeof t == "object" || typeof t == "function")
                        for (var r = V2(t), c = 0, f = r.length, p; c < f; c++)
                            p = r[c],
                            !H2.call(e, p) && p !== n && iv(e, p, {
                                get: (m => t[m]).bind(null, p),
                                enumerable: !(a = F2(t, p)) || a.enumerable
                            });
                    return e
                }
                  , av = (e, t, n) => (n = e != null ? B2(k2(e)) : {},
                W2(t || !e || !e.__esModule ? iv(n, "default", {
                    value: e,
                    enumerable: !0
                }) : n, e))
                  , n_ = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.Cancellable = void 0,
                    e.setTimeoutCancellable = n;
                    var t = class {
                        callback;
                        _cancelled = !1;
                        constructor(a) {
                            this.callback = a
                        }
                        cancel = () => {
                            if (this._cancelled)
                                return;
                            this._cancelled = !0;
                            const a = this.callback;
                            this.callback = void 0,
                            a?.()
                        }
                        ;
                        get isCancelled() {
                            return this._cancelled
                        }
                    }
                    ;
                    e.Cancellable = t;
                    function n(a, r) {
                        const c = setTimeout(a, r);
                        return new t( () => {
                            clearTimeout(c)
                        }
                        )
                    }
                }
                ))
                  , $x = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.EventEmitterEvent = e.EventEmitter = void 0;
                    var t = class extends EventTarget {
                        emit(a, r) {
                            this.dispatchEvent(new n(a,r))
                        }
                    }
                    ;
                    e.EventEmitter = t;
                    var n = class extends Event {
                        payload;
                        constructor(a, r) {
                            super(a),
                            this.payload = r
                        }
                    }
                    ;
                    e.EventEmitterEvent = n
                }
                ))
                  , X2 = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.ReceiveChannel = void 0;
                    const t = n_()
                      , n = $x();
                    var a = class {
                        emitter = new n.EventEmitter;
                        emit(r) {
                            this.emitter.emit(r.endpoint, r.payload)
                        }
                        subscribe(r, c) {
                            const f = p => {
                                const m = p.payload;
                                c(m)
                            }
                            ;
                            return this.emitter.addEventListener(r, f),
                            new t.Cancellable( () => {
                                this.emitter.removeEventListener(r, f)
                            }
                            )
                        }
                        once(r, c) {
                            const f = this.subscribe(r, p => {
                                f.cancel(),
                                c(p)
                            }
                            );
                            return f
                        }
                    }
                    ;
                    e.ReceiveChannel = a
                }
                ))
                  , eb = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.PassthroughSubject = void 0;
                    const t = n_()
                      , n = $x();
                    var a = class {
                        emitter = new n.EventEmitter;
                        send(r) {
                            this.emitter.emit("value", r)
                        }
                        subscribe(r) {
                            const c = f => {
                                const p = f.payload;
                                r(p)
                            }
                            ;
                            return this.emitter.addEventListener("value", c),
                            new t.Cancellable( () => {
                                this.emitter.removeEventListener("value", c)
                            }
                            )
                        }
                    }
                    ;
                    e.PassthroughSubject = a
                }
                ))
                  , tb = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.colorToHexString = t,
                    e.colorFromString = n;
                    function t(v) {
                        return v.a === 1 ? `#${c(v).toString(16).padStart(6, "0").toUpperCase()}` : `#${f(v).toString(16).padStart(8, "0").toUpperCase()}`
                    }
                    function n(v) {
                        if (v) {
                            if (v.startsWith("rgb(") || v.startsWith("rgba("))
                                return p(v);
                            if (v.startsWith("#") && (v = v.slice(1)),
                            v.length === 6)
                                return a(parseInt(v, 16));
                            if (v.length === 8)
                                return r(parseInt(v, 16))
                        }
                    }
                    function a(v) {
                        return v >>>= 0,
                        {
                            r: (v & 16711680) >>> 16,
                            g: (v & 65280) >>> 8,
                            b: v & 255,
                            a: 1
                        }
                    }
                    function r(v) {
                        return v >>>= 0,
                        {
                            r: (v & 4278190080) >>> 24,
                            g: (v & 16711680) >>> 16,
                            b: (v & 65280) >>> 8,
                            a: (v & 255) / 255
                        }
                    }
                    function c(v) {
                        let _ = (v.r & 255) << 16;
                        return _ = _ | (v.g & 255) << 8,
                        _ = _ | v.b & 255,
                        _ >>> 0
                    }
                    function f(v) {
                        let _ = (v.r & 255) << 24;
                        return _ = _ | (v.g & 255) << 16,
                        _ = _ | (v.b & 255) << 8,
                        _ = _ | v.a * 255 & 255,
                        _ >>> 0
                    }
                    function p(v) {
                        if (v) {
                            if (v.startsWith("rgb(") && v.endsWith(")")) {
                                const _ = v.substring(4, v.length - 1).split(", ");
                                return g(+(_[0] ?? 0), +(_[1] ?? 0), +(_[2] ?? 0), 1)
                            }
                            if (v.startsWith("rgba(") && v.endsWith(")")) {
                                const _ = v.substring(5, v.length - 1).split(", ");
                                return g(+(_[0] ?? 0), +(_[1] ?? 0), +(_[2] ?? 0), +(_[3] ?? 1))
                            }
                        }
                    }
                    function m(v, _, x) {
                        return Math.max(Math.min(v, x), _)
                    }
                    function g(v, _, x, M) {
                        return {
                            r: m(v, 0, 255),
                            g: m(_, 0, 255),
                            b: m(x, 0, 255),
                            a: m(M, 0, 1)
                        }
                    }
                }
                ))
                  , q2 = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.processConfig = n;
                    const t = tb();
                    function n(_) {
                        const x = {};
                        for (const [M,C] of Object.entries(_))
                            try {
                                x[M] = a(M, C)
                            } catch (R) {
                                console.error("Error validating tweaks config:", R)
                            }
                        return x
                    }
                    function a(_, x) {
                        switch (g(x, _, "name", "string"),
                        g(x, _, "index", "number"),
                        g(x, _, "group", "string"),
                        x.type) {
                        case "slider":
                            return r(_, x);
                        case "toggle":
                            return c(_, x);
                        case "color":
                            return f(_, x);
                        case "text":
                            return p(_, x);
                        default:
                            throw new Error(`Invalid config type: ${x.type}`)
                        }
                    }
                    function r(_, x) {
                        if (m(x, _, "value", "number"),
                        m(x, _, "min", "number"),
                        m(x, _, "max", "number"),
                        m(x, _, "step", "number"),
                        x.min >= x.max)
                            throw new Error(`Invalid slider config for "${_}", expected min (${x.min}) < max (${x.max})`);
                        if (x.step <= 0)
                            throw new Error(`Invalid slider config for "${_}", expected step (${x.step}) > 0`);
                        if (x.value < x.min)
                            throw new Error(`Invalid slider config for "${_}", expected value (${x.value}) >= min (${x.min})`);
                        if (x.value > x.max)
                            throw new Error(`Invalid slider config for "${_}", expected value (${x.value}) <= max (${x.max})`);
                        return x
                    }
                    function c(_, x) {
                        return m(x, _, "value", "boolean"),
                        x
                    }
                    function f(_, x) {
                        m(x, _, "value", "string");
                        const M = (0,
                        t.colorFromString)(x.value);
                        if (!M)
                            throw new Error(`Tweaks config has incorrect color value for ${_}, got ${x.value} but expected color hex, rgb(), rgba()`);
                        return {
                            ...x,
                            value: (0,
                            t.colorToHexString)(M)
                        }
                    }
                    function p(_, x) {
                        return m(x, _, "value", "string"),
                        m(x, _, "group", "string"),
                        x
                    }
                    function m(_, x, M, C) {
                        const R = _[M];
                        if (typeof R !== C)
                            throw new v(x,M,C,R)
                    }
                    function g(_, x, M, C) {
                        const R = _[M];
                        if (R !== void 0 && typeof R !== C)
                            throw new v(x,M,C,R)
                    }
                    var v = class extends Error {
                        constructor(_, x, M, C) {
                            super(`Tweaks config has incorrect value type for ${_} ${x}, expected ${M} got ${typeof C}`)
                        }
                    }
                }
                ))
                  , Y2 = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.createTweaks = r;
                    const t = eb()
                      , n = tb()
                      , a = q2();
                    function r(m, g) {
                        const v = (0,
                        a.processConfig)(m)
                          , _ = new c(g,v)
                          , x = {};
                        for (const M of Object.keys(m))
                            x[M] = {
                                useState: () => _.useState(M)
                            };
                        return [x, v]
                    }
                    var c = class {
                        observable;
                        values;
                        subject = new t.PassthroughSubject;
                        constructor(m, g) {
                            this.observable = m,
                            this.values = f(g),
                            this.observable.subscribe(v => {
                                for (const [_,x] of Object.entries(v.values)) {
                                    const M = g[_];
                                    if (M === void 0)
                                        return;
                                    const C = p(M, x);
                                    if (C === void 0)
                                        return;
                                    this.values[_] !== C && (this.values[_] = C,
                                    this.subject.send(_))
                                }
                            }
                            )
                        }
                        getValue(m) {
                            const g = this.values[m];
                            if (g === void 0)
                                throw new Error(`Tweak key not found in values: ${m}`);
                            return g
                        }
                        useState(m) {
                            const g = window.React;
                            if (!g || !g.useReducer || !g.useEffect)
                                return console.warn("React not found on window"),
                                this.getValue(m);
                            const [v,_] = g.useReducer( () => this.getValue(m), this.getValue(m));
                            return g.useEffect( () => {
                                const x = this.subject.subscribe(M => {
                                    M === m && _()
                                }
                                );
                                return () => {
                                    x.cancel()
                                }
                            }
                            ),
                            v
                        }
                    }
                    ;
                    function f(m) {
                        const g = {};
                        for (const v of Object.entries(m))
                            g[v[0]] = v[1].value;
                        return g
                    }
                    function p(m, g) {
                        switch (m.type) {
                        case "slider":
                            {
                                const v = parseFloat(g);
                                return isNaN(v) ? void 0 : v
                            }
                        case "toggle":
                            return g === "true";
                        case "color":
                            {
                                const v = (0,
                                n.colorFromString)(g);
                                return v ? (0,
                                n.colorToHexString)(v) : void 0
                            }
                        case "text":
                            return g
                        }
                    }
                }
                ))
                  , j2 = Ai((e => {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }),
                    e.gizmoRuntime = void 0;
                    const t = X2()
                      , n = Y2()
                      , a = n_()
                      , r = eb();
                    var c = class {
                        receiveChannel = new t.ReceiveChannel;
                        seq = 0;
                        tweaksListener = void 0;
                        tweaksInstance = void 0;
                        tweaksDidWarn = !1;
                        tweaks(f) {
                            if (this.tweaksInstance)
                                return this.tweaksDidWarn || (this.tweaksDidWarn = !0,
                                console.warn("tweaks() is expected to only be called once, returning previous value")),
                                this.tweaksInstance;
                            const p = new r.PassthroughSubject
                              , [m,g] = (0,
                            n.createTweaks)(f, p);
                            return this.tweaksInstance = m,
                            this.tweaksListener?.cancel(),
                            this.tweaksListener = this.addTweaksListener(g, v => {
                                p.send(v)
                            }
                            ),
                            m
                        }
                        receiveMessage(f) {
                            return this.receiveChannel.emit(f),
                            Promise.resolve()
                        }
                        performHaptic(f) {
                            typeof f == "object" && "style"in f && typeof f.style == "string" && (f = f.style),
                            window.webkit?.messageHandlers?.hapticHandler?.postMessage(this.makeMessage({
                                kind: "impact",
                                style: f
                            }))
                        }
                        generateText(f) {
                            const p = window.webkit?.messageHandlers?.textGenerationHandler;
                            return p ? this.performHandlerRequest(p, {
                                prompt: f.prompt,
                                imageData: f.imageData
                            }, 3e4) : Promise.reject(new Error("Not available"))
                        }
                        generateImage(f) {
                            const p = window.webkit?.messageHandlers?.imageGenerationHandler;
                            return p ? this.performHandlerRequest(p, {
                                prompt: f.prompt,
                                imageData: f.imageData,
                                targetAspectRatio: f.targetAspectRatio
                            }, 3e4) : Promise.reject(new Error("Not available"))
                        }
                        addShakeListener(f) {
                            const p = window.webkit?.messageHandlers?.deviceMotionHandler;
                            if (!p)
                                return console.warn("Shake handler not available"),
                                () => {}
                                ;
                            const m = this.createSubscription(p, {
                                type: "shake"
                            }, () => {
                                f()
                            }
                            );
                            return () => {
                                m.cancel()
                            }
                        }
                        addMotionListener(f) {
                            const p = window.webkit?.messageHandlers?.deviceMotionHandler;
                            if (!p)
                                return console.warn("Motion handler not available"),
                                () => {}
                                ;
                            const m = this.createSubscription(p, {
                                type: "motion"
                            }, g => {
                                g.motion && f(g.motion)
                            }
                            );
                            return () => {
                                m.cancel()
                            }
                        }
                        addTweaksListener(f, p) {
                            const m = window.webkit?.messageHandlers?.tweaksHandler;
                            return m ? this.createSubscription(m, {
                                type: "initialize",
                                config: JSON.stringify(f)
                            }, g => {
                                p(g)
                            }
                            ) : new a.Cancellable(void 0)
                        }
                        createSubscription(f, p, m) {
                            const g = this.makeSubscriptionMessage(p)
                              , v = this.receiveChannel.subscribe(g.endpoint, _ => {
                                if (_.error !== void 0) {
                                    console.error(`Subscription error: ${_.error}`);
                                    return
                                }
                                m(_)
                            }
                            );
                            return f.postMessage(g),
                            new a.Cancellable( () => {
                                v.cancel(),
                                f.postMessage({
                                    endpoint: g.endpoint,
                                    payload: "unsubscribe"
                                })
                            }
                            )
                        }
                        performHandlerRequest(f, p, m) {
                            return new Promise( (g, v) => {
                                const _ = this.makeMessage(p)
                                  , x = this.receiveChannel.once(_.endpoint, C => {
                                    M.cancel(),
                                    C.error !== void 0 ? v(new Error(`Error: ${C.error}`)) : g(C)
                                }
                                )
                                  , M = (0,
                                a.setTimeoutCancellable)( () => {
                                    x.cancel(),
                                    v(new Error("Request timed out"))
                                }
                                , m);
                                f.postMessage(_)
                            }
                            )
                        }
                        makeMessage(f) {
                            return {
                                endpoint: (this.seq++).toString(),
                                payload: f
                            }
                        }
                        makeSubscriptionMessage(f) {
                            return {
                                endpoint: (this.seq++).toString(),
                                payload: {
                                    subscribe: f
                                }
                            }
                        }
                    }
                    ;
                    e.gizmoRuntime = new c
                }
                ));
                var Z2 = Ai((e => {
                    var t = Symbol.for("react.transitional.element")
                      , n = Symbol.for("react.portal")
                      , a = Symbol.for("react.fragment")
                      , r = Symbol.for("react.strict_mode")
                      , c = Symbol.for("react.profiler")
                      , f = Symbol.for("react.consumer")
                      , p = Symbol.for("react.context")
                      , m = Symbol.for("react.forward_ref")
                      , g = Symbol.for("react.suspense")
                      , v = Symbol.for("react.memo")
                      , _ = Symbol.for("react.lazy")
                      , x = Symbol.for("react.activity")
                      , M = Symbol.iterator;
                    function C(j) {
                        return j === null || typeof j != "object" ? null : (j = M && j[M] || j["@@iterator"],
                        typeof j == "function" ? j : null)
                    }
                    var R = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    }
                      , A = Object.assign
                      , E = {};
                    function N(j, ve, Re) {
                        this.props = j,
                        this.context = ve,
                        this.refs = E,
                        this.updater = Re || R
                    }
                    N.prototype.isReactComponent = {},
                    N.prototype.setState = function(j, ve) {
                        if (typeof j != "object" && typeof j != "function" && j != null)
                            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
                        this.updater.enqueueSetState(this, j, ve, "setState")
                    }
                    ,
                    N.prototype.forceUpdate = function(j) {
                        this.updater.enqueueForceUpdate(this, j, "forceUpdate")
                    }
                    ;
                    function I() {}
                    I.prototype = N.prototype;
                    function L(j, ve, Re) {
                        this.props = j,
                        this.context = ve,
                        this.refs = E,
                        this.updater = Re || R
                    }
                    var k = L.prototype = new I;
                    k.constructor = L,
                    A(k, N.prototype),
                    k.isPureReactComponent = !0;
                    var B = Array.isArray;
                    function X() {}
                    var G = {
                        H: null,
                        A: null,
                        T: null,
                        S: null
                    }
                      , P = Object.prototype.hasOwnProperty;
                    function U(j, ve, Re) {
                        var le = Re.ref;
                        return {
                            $$typeof: t,
                            type: j,
                            key: ve,
                            ref: le !== void 0 ? le : null,
                            props: Re
                        }
                    }
                    function W(j, ve) {
                        return U(j.type, ve, j.props)
                    }
                    function K(j) {
                        return typeof j == "object" && j !== null && j.$$typeof === t
                    }
                    function q(j) {
                        var ve = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + j.replace(/[=:]/g, function(Re) {
                            return ve[Re]
                        })
                    }
                    var te = /\/+/g;
                    function ce(j, ve) {
                        return typeof j == "object" && j !== null && j.key != null ? q("" + j.key) : ve.toString(36)
                    }
                    function J(j) {
                        switch (j.status) {
                        case "fulfilled":
                            return j.value;
                        case "rejected":
                            throw j.reason;
                        default:
                            switch (typeof j.status == "string" ? j.then(X, X) : (j.status = "pending",
                            j.then(function(ve) {
                                j.status === "pending" && (j.status = "fulfilled",
                                j.value = ve)
                            }, function(ve) {
                                j.status === "pending" && (j.status = "rejected",
                                j.reason = ve)
                            })),
                            j.status) {
                            case "fulfilled":
                                return j.value;
                            case "rejected":
                                throw j.reason
                            }
                        }
                        throw j
                    }
                    function Q(j, ve, Re, le, Ae) {
                        var Ne = typeof j;
                        (Ne === "undefined" || Ne === "boolean") && (j = null);
                        var ke = !1;
                        if (j === null)
                            ke = !0;
                        else
                            switch (Ne) {
                            case "bigint":
                            case "string":
                            case "number":
                                ke = !0;
                                break;
                            case "object":
                                switch (j.$$typeof) {
                                case t:
                                case n:
                                    ke = !0;
                                    break;
                                case _:
                                    return ke = j._init,
                                    Q(ke(j._payload), ve, Re, le, Ae)
                                }
                            }
                        if (ke)
                            return Ae = Ae(j),
                            ke = le === "" ? "." + ce(j, 0) : le,
                            B(Ae) ? (Re = "",
                            ke != null && (Re = ke.replace(te, "$&/") + "/"),
                            Q(Ae, ve, Re, "", function(Ft) {
                                return Ft
                            })) : Ae != null && (K(Ae) && (Ae = W(Ae, Re + (Ae.key == null || j && j.key === Ae.key ? "" : ("" + Ae.key).replace(te, "$&/") + "/") + ke)),
                            ve.push(Ae)),
                            1;
                        ke = 0;
                        var at = le === "" ? "." : le + ":";
                        if (B(j))
                            for (var Je = 0; Je < j.length; Je++)
                                le = j[Je],
                                Ne = at + ce(le, Je),
                                ke += Q(le, ve, Re, Ne, Ae);
                        else if (Je = C(j),
                        typeof Je == "function")
                            for (j = Je.call(j),
                            Je = 0; !(le = j.next()).done; )
                                le = le.value,
                                Ne = at + ce(le, Je++),
                                ke += Q(le, ve, Re, Ne, Ae);
                        else if (Ne === "object") {
                            if (typeof j.then == "function")
                                return Q(J(j), ve, Re, le, Ae);
                            throw ve = String(j),
                            Error("Objects are not valid as a React child (found: " + (ve === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : ve) + "). If you meant to render a collection of children, use an array instead.")
                        }
                        return ke
                    }
                    function se(j, ve, Re) {
                        if (j == null)
                            return j;
                        var le = []
                          , Ae = 0;
                        return Q(j, le, "", "", function(Ne) {
                            return ve.call(Re, Ne, Ae++)
                        }),
                        le
                    }
                    function Te(j) {
                        if (j._status === -1) {
                            var ve = j._result;
                            ve = ve(),
                            ve.then(function(Re) {
                                (j._status === 0 || j._status === -1) && (j._status = 1,
                                j._result = Re)
                            }, function(Re) {
                                (j._status === 0 || j._status === -1) && (j._status = 2,
                                j._result = Re)
                            }),
                            j._status === -1 && (j._status = 0,
                            j._result = ve)
                        }
                        if (j._status === 1)
                            return j._result.default;
                        throw j._result
                    }
                    var Ee = typeof reportError == "function" ? reportError : function(j) {
                        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                            var ve = new window.ErrorEvent("error",{
                                bubbles: !0,
                                cancelable: !0,
                                message: typeof j == "object" && j !== null && typeof j.message == "string" ? String(j.message) : String(j),
                                error: j
                            });
                            if (!window.dispatchEvent(ve))
                                return
                        } else if (typeof process == "object" && typeof process.emit == "function") {
                            process.emit("uncaughtException", j);
                            return
                        }
                        console.error(j)
                    }
                      , Be = {
                        map: se,
                        forEach: function(j, ve, Re) {
                            se(j, function() {
                                ve.apply(this, arguments)
                            }, Re)
                        },
                        count: function(j) {
                            var ve = 0;
                            return se(j, function() {
                                ve++
                            }),
                            ve
                        },
                        toArray: function(j) {
                            return se(j, function(ve) {
                                return ve
                            }) || []
                        },
                        only: function(j) {
                            if (!K(j))
                                throw Error("React.Children.only expected to receive a single React element child.");
                            return j
                        }
                    };
                    e.Activity = x,
                    e.Children = Be,
                    e.Component = N,
                    e.Fragment = a,
                    e.Profiler = c,
                    e.PureComponent = L,
                    e.StrictMode = r,
                    e.Suspense = g,
                    e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = G,
                    e.__COMPILER_RUNTIME = {
                        __proto__: null,
                        c: function(j) {
                            return G.H.useMemoCache(j)
                        }
                    },
                    e.cache = function(j) {
                        return function() {
                            return j.apply(null, arguments)
                        }
                    }
                    ,
                    e.cacheSignal = function() {
                        return null
                    }
                    ,
                    e.cloneElement = function(j, ve, Re) {
                        if (j == null)
                            throw Error("The argument must be a React element, but you passed " + j + ".");
                        var le = A({}, j.props)
                          , Ae = j.key;
                        if (ve != null)
                            for (Ne in ve.key !== void 0 && (Ae = "" + ve.key),
                            ve)
                                !P.call(ve, Ne) || Ne === "key" || Ne === "__self" || Ne === "__source" || Ne === "ref" && ve.ref === void 0 || (le[Ne] = ve[Ne]);
                        var Ne = arguments.length - 2;
                        if (Ne === 1)
                            le.children = Re;
                        else if (1 < Ne) {
                            for (var ke = Array(Ne), at = 0; at < Ne; at++)
                                ke[at] = arguments[at + 2];
                            le.children = ke
                        }
                        return U(j.type, Ae, le)
                    }
                    ,
                    e.createContext = function(j) {
                        return j = {
                            $$typeof: p,
                            _currentValue: j,
                            _currentValue2: j,
                            _threadCount: 0,
                            Provider: null,
                            Consumer: null
                        },
                        j.Provider = j,
                        j.Consumer = {
                            $$typeof: f,
                            _context: j
                        },
                        j
                    }
                    ,
                    e.createElement = function(j, ve, Re) {
                        var le, Ae = {}, Ne = null;
                        if (ve != null)
                            for (le in ve.key !== void 0 && (Ne = "" + ve.key),
                            ve)
                                P.call(ve, le) && le !== "key" && le !== "__self" && le !== "__source" && (Ae[le] = ve[le]);
                        var ke = arguments.length - 2;
                        if (ke === 1)
                            Ae.children = Re;
                        else if (1 < ke) {
                            for (var at = Array(ke), Je = 0; Je < ke; Je++)
                                at[Je] = arguments[Je + 2];
                            Ae.children = at
                        }
                        if (j && j.defaultProps)
                            for (le in ke = j.defaultProps,
                            ke)
                                Ae[le] === void 0 && (Ae[le] = ke[le]);
                        return U(j, Ne, Ae)
                    }
                    ,
                    e.createRef = function() {
                        return {
                            current: null
                        }
                    }
                    ,
                    e.forwardRef = function(j) {
                        return {
                            $$typeof: m,
                            render: j
                        }
                    }
                    ,
                    e.isValidElement = K,
                    e.lazy = function(j) {
                        return {
                            $$typeof: _,
                            _payload: {
                                _status: -1,
                                _result: j
                            },
                            _init: Te
                        }
                    }
                    ,
                    e.memo = function(j, ve) {
                        return {
                            $$typeof: v,
                            type: j,
                            compare: ve === void 0 ? null : ve
                        }
                    }
                    ,
                    e.startTransition = function(j) {
                        var ve = G.T
                          , Re = {};
                        G.T = Re;
                        try {
                            var le = j()
                              , Ae = G.S;
                            Ae !== null && Ae(Re, le),
                            typeof le == "object" && le !== null && typeof le.then == "function" && le.then(X, Ee)
                        } catch (Ne) {
                            Ee(Ne)
                        } finally {
                            ve !== null && Re.types !== null && (ve.types = Re.types),
                            G.T = ve
                        }
                    }
                    ,
                    e.unstable_useCacheRefresh = function() {
                        return G.H.useCacheRefresh()
                    }
                    ,
                    e.use = function(j) {
                        return G.H.use(j)
                    }
                    ,
                    e.useActionState = function(j, ve, Re) {
                        return G.H.useActionState(j, ve, Re)
                    }
                    ,
                    e.useCallback = function(j, ve) {
                        return G.H.useCallback(j, ve)
                    }
                    ,
                    e.useContext = function(j) {
                        return G.H.useContext(j)
                    }
                    ,
                    e.useDebugValue = function() {}
                    ,
                    e.useDeferredValue = function(j, ve) {
                        return G.H.useDeferredValue(j, ve)
                    }
                    ,
                    e.useEffect = function(j, ve) {
                        return G.H.useEffect(j, ve)
                    }
                    ,
                    e.useEffectEvent = function(j) {
                        return G.H.useEffectEvent(j)
                    }
                    ,
                    e.useId = function() {
                        return G.H.useId()
                    }
                    ,
                    e.useImperativeHandle = function(j, ve, Re) {
                        return G.H.useImperativeHandle(j, ve, Re)
                    }
                    ,
                    e.useInsertionEffect = function(j, ve) {
                        return G.H.useInsertionEffect(j, ve)
                    }
                    ,
                    e.useLayoutEffect = function(j, ve) {
                        return G.H.useLayoutEffect(j, ve)
                    }
                    ,
                    e.useMemo = function(j, ve) {
                        return G.H.useMemo(j, ve)
                    }
                    ,
                    e.useOptimistic = function(j, ve) {
                        return G.H.useOptimistic(j, ve)
                    }
                    ,
                    e.useReducer = function(j, ve, Re) {
                        return G.H.useReducer(j, ve, Re)
                    }
                    ,
                    e.useRef = function(j) {
                        return G.H.useRef(j)
                    }
                    ,
                    e.useState = function(j) {
                        return G.H.useState(j)
                    }
                    ,
                    e.useSyncExternalStore = function(j, ve, Re) {
                        return G.H.useSyncExternalStore(j, ve, Re)
                    }
                    ,
                    e.useTransition = function() {
                        return G.H.useTransition()
                    }
                    ,
                    e.version = "19.2.3"
                }
                ))
                  , wp = Ai(( (e, t) => {
                    t.exports = Z2()
                }
                ));
                var Q2 = Ai((e => {
                    function t(J, Q) {
                        var se = J.length;
                        J.push(Q);
                        e: for (; 0 < se; ) {
                            var Te = se - 1 >>> 1
                              , Ee = J[Te];
                            if (0 < r(Ee, Q))
                                J[Te] = Q,
                                J[se] = Ee,
                                se = Te;
                            else
                                break e
                        }
                    }
                    function n(J) {
                        return J.length === 0 ? null : J[0]
                    }
                    function a(J) {
                        if (J.length === 0)
                            return null;
                        var Q = J[0]
                          , se = J.pop();
                        if (se !== Q) {
                            J[0] = se;
                            e: for (var Te = 0, Ee = J.length, Be = Ee >>> 1; Te < Be; ) {
                                var j = 2 * (Te + 1) - 1
                                  , ve = J[j]
                                  , Re = j + 1
                                  , le = J[Re];
                                if (0 > r(ve, se))
                                    Re < Ee && 0 > r(le, ve) ? (J[Te] = le,
                                    J[Re] = se,
                                    Te = Re) : (J[Te] = ve,
                                    J[j] = se,
                                    Te = j);
                                else if (Re < Ee && 0 > r(le, se))
                                    J[Te] = le,
                                    J[Re] = se,
                                    Te = Re;
                                else
                                    break e
                            }
                        }
                        return Q
                    }
                    function r(J, Q) {
                        var se = J.sortIndex - Q.sortIndex;
                        return se !== 0 ? se : J.id - Q.id
                    }
                    if (e.unstable_now = void 0,
                    typeof performance == "object" && typeof performance.now == "function") {
                        var c = performance;
                        e.unstable_now = function() {
                            return c.now()
                        }
                    } else {
                        var f = Date
                          , p = f.now();
                        e.unstable_now = function() {
                            return f.now() - p
                        }
                    }
                    var m = []
                      , g = []
                      , v = 1
                      , _ = null
                      , x = 3
                      , M = !1
                      , C = !1
                      , R = !1
                      , A = !1
                      , E = typeof setTimeout == "function" ? setTimeout : null
                      , N = typeof clearTimeout == "function" ? clearTimeout : null
                      , I = typeof setImmediate < "u" ? setImmediate : null;
                    function L(J) {
                        for (var Q = n(g); Q !== null; ) {
                            if (Q.callback === null)
                                a(g);
                            else if (Q.startTime <= J)
                                a(g),
                                Q.sortIndex = Q.expirationTime,
                                t(m, Q);
                            else
                                break;
                            Q = n(g)
                        }
                    }
                    function k(J) {
                        if (R = !1,
                        L(J),
                        !C)
                            if (n(m) !== null)
                                C = !0,
                                B || (B = !0,
                                K());
                            else {
                                var Q = n(g);
                                Q !== null && ce(k, Q.startTime - J)
                            }
                    }
                    var B = !1
                      , X = -1
                      , G = 5
                      , P = -1;
                    function U() {
                        return A ? !0 : !(e.unstable_now() - P < G)
                    }
                    function W() {
                        if (A = !1,
                        B) {
                            var J = e.unstable_now();
                            P = J;
                            var Q = !0;
                            try {
                                e: {
                                    C = !1,
                                    R && (R = !1,
                                    N(X),
                                    X = -1),
                                    M = !0;
                                    var se = x;
                                    try {
                                        t: {
                                            for (L(J),
                                            _ = n(m); _ !== null && !(_.expirationTime > J && U()); ) {
                                                var Te = _.callback;
                                                if (typeof Te == "function") {
                                                    _.callback = null,
                                                    x = _.priorityLevel;
                                                    var Ee = Te(_.expirationTime <= J);
                                                    if (J = e.unstable_now(),
                                                    typeof Ee == "function") {
                                                        _.callback = Ee,
                                                        L(J),
                                                        Q = !0;
                                                        break t
                                                    }
                                                    _ === n(m) && a(m),
                                                    L(J)
                                                } else
                                                    a(m);
                                                _ = n(m)
                                            }
                                            if (_ !== null)
                                                Q = !0;
                                            else {
                                                var Be = n(g);
                                                Be !== null && ce(k, Be.startTime - J),
                                                Q = !1
                                            }
                                        }
                                        break e
                                    } finally {
                                        _ = null,
                                        x = se,
                                        M = !1
                                    }
                                    Q = void 0
                                }
                            } finally {
                                Q ? K() : B = !1
                            }
                        }
                    }
                    var K;
                    if (typeof I == "function")
                        K = function() {
                            I(W)
                        }
                        ;
                    else if (typeof MessageChannel < "u") {
                        var q = new MessageChannel
                          , te = q.port2;
                        q.port1.onmessage = W,
                        K = function() {
                            te.postMessage(null)
                        }
                    } else
                        K = function() {
                            E(W, 0)
                        }
                        ;
                    function ce(J, Q) {
                        X = E(function() {
                            J(e.unstable_now())
                        }, Q)
                    }
                    e.unstable_IdlePriority = 5,
                    e.unstable_ImmediatePriority = 1,
                    e.unstable_LowPriority = 4,
                    e.unstable_NormalPriority = 3,
                    e.unstable_Profiling = null,
                    e.unstable_UserBlockingPriority = 2,
                    e.unstable_cancelCallback = function(J) {
                        J.callback = null
                    }
                    ,
                    e.unstable_forceFrameRate = function(J) {
                        0 > J || 125 < J ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : G = 0 < J ? Math.floor(1e3 / J) : 5
                    }
                    ,
                    e.unstable_getCurrentPriorityLevel = function() {
                        return x
                    }
                    ,
                    e.unstable_next = function(J) {
                        switch (x) {
                        case 1:
                        case 2:
                        case 3:
                            var Q = 3;
                            break;
                        default:
                            Q = x
                        }
                        var se = x;
                        x = Q;
                        try {
                            return J()
                        } finally {
                            x = se
                        }
                    }
                    ,
                    e.unstable_requestPaint = function() {
                        A = !0
                    }
                    ,
                    e.unstable_runWithPriority = function(J, Q) {
                        switch (J) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            J = 3
                        }
                        var se = x;
                        x = J;
                        try {
                            return Q()
                        } finally {
                            x = se
                        }
                    }
                    ,
                    e.unstable_scheduleCallback = function(J, Q, se) {
                        var Te = e.unstable_now();
                        switch (typeof se == "object" && se !== null ? (se = se.delay,
                        se = typeof se == "number" && 0 < se ? Te + se : Te) : se = Te,
                        J) {
                        case 1:
                            var Ee = -1;
                            break;
                        case 2:
                            Ee = 250;
                            break;
                        case 5:
                            Ee = 1073741823;
                            break;
                        case 4:
                            Ee = 1e4;
                            break;
                        default:
                            Ee = 5e3
                        }
                        return Ee = se + Ee,
                        J = {
                            id: v++,
                            callback: Q,
                            priorityLevel: J,
                            startTime: se,
                            expirationTime: Ee,
                            sortIndex: -1
                        },
                        se > Te ? (J.sortIndex = se,
                        t(g, J),
                        n(m) === null && J === n(g) && (R ? (N(X),
                        X = -1) : R = !0,
                        ce(k, se - Te))) : (J.sortIndex = Ee,
                        t(m, J),
                        C || M || (C = !0,
                        B || (B = !0,
                        K()))),
                        J
                    }
                    ,
                    e.unstable_shouldYield = U,
                    e.unstable_wrapCallback = function(J) {
                        var Q = x;
                        return function() {
                            var se = x;
                            x = Q;
                            try {
                                return J.apply(this, arguments)
                            } finally {
                                x = se
                            }
                        }
                    }
                }
                ))
                  , nb = Ai(( (e, t) => {
                    t.exports = Q2()
                }
                ));
                var K2 = Ai((e => {
                    var t = wp();
                    function n(g) {
                        var v = "https://react.dev/errors/" + g;
                        if (1 < arguments.length) {
                            v += "?args[]=" + encodeURIComponent(arguments[1]);
                            for (var _ = 2; _ < arguments.length; _++)
                                v += "&args[]=" + encodeURIComponent(arguments[_])
                        }
                        return "Minified React error #" + g + "; visit " + v + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                    }
                    function a() {}
                    var r = {
                        d: {
                            f: a,
                            r: function() {
                                throw Error(n(522))
                            },
                            D: a,
                            C: a,
                            L: a,
                            m: a,
                            X: a,
                            S: a,
                            M: a
                        },
                        p: 0,
                        findDOMNode: null
                    }
                      , c = Symbol.for("react.portal");
                    function f(g, v, _) {
                        var x = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                        return {
                            $$typeof: c,
                            key: x == null ? null : "" + x,
                            children: g,
                            containerInfo: v,
                            implementation: _
                        }
                    }
                    var p = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
                    function m(g, v) {
                        if (g === "font")
                            return "";
                        if (typeof v == "string")
                            return v === "use-credentials" ? v : ""
                    }
                    e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r,
                    e.createPortal = function(g, v) {
                        var _ = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
                        if (!v || v.nodeType !== 1 && v.nodeType !== 9 && v.nodeType !== 11)
                            throw Error(n(299));
                        return f(g, v, null, _)
                    }
                    ,
                    e.flushSync = function(g) {
                        var v = p.T
                          , _ = r.p;
                        try {
                            if (p.T = null,
                            r.p = 2,
                            g)
                                return g()
                        } finally {
                            p.T = v,
                            r.p = _,
                            r.d.f()
                        }
                    }
                    ,
                    e.preconnect = function(g, v) {
                        typeof g == "string" && (v ? (v = v.crossOrigin,
                        v = typeof v == "string" ? v === "use-credentials" ? v : "" : void 0) : v = null,
                        r.d.C(g, v))
                    }
                    ,
                    e.prefetchDNS = function(g) {
                        typeof g == "string" && r.d.D(g)
                    }
                    ,
                    e.preinit = function(g, v) {
                        if (typeof g == "string" && v && typeof v.as == "string") {
                            var _ = v.as
                              , x = m(_, v.crossOrigin)
                              , M = typeof v.integrity == "string" ? v.integrity : void 0
                              , C = typeof v.fetchPriority == "string" ? v.fetchPriority : void 0;
                            _ === "style" ? r.d.S(g, typeof v.precedence == "string" ? v.precedence : void 0, {
                                crossOrigin: x,
                                integrity: M,
                                fetchPriority: C
                            }) : _ === "script" && r.d.X(g, {
                                crossOrigin: x,
                                integrity: M,
                                fetchPriority: C,
                                nonce: typeof v.nonce == "string" ? v.nonce : void 0
                            })
                        }
                    }
                    ,
                    e.preinitModule = function(g, v) {
                        if (typeof g == "string")
                            if (typeof v == "object" && v !== null) {
                                if (v.as == null || v.as === "script") {
                                    var _ = m(v.as, v.crossOrigin);
                                    r.d.M(g, {
                                        crossOrigin: _,
                                        integrity: typeof v.integrity == "string" ? v.integrity : void 0,
                                        nonce: typeof v.nonce == "string" ? v.nonce : void 0
                                    })
                                }
                            } else
                                v ?? r.d.M(g)
                    }
                    ,
                    e.preload = function(g, v) {
                        if (typeof g == "string" && typeof v == "object" && v !== null && typeof v.as == "string") {
                            var _ = v.as
                              , x = m(_, v.crossOrigin);
                            r.d.L(g, _, {
                                crossOrigin: x,
                                integrity: typeof v.integrity == "string" ? v.integrity : void 0,
                                nonce: typeof v.nonce == "string" ? v.nonce : void 0,
                                type: typeof v.type == "string" ? v.type : void 0,
                                fetchPriority: typeof v.fetchPriority == "string" ? v.fetchPriority : void 0,
                                referrerPolicy: typeof v.referrerPolicy == "string" ? v.referrerPolicy : void 0,
                                imageSrcSet: typeof v.imageSrcSet == "string" ? v.imageSrcSet : void 0,
                                imageSizes: typeof v.imageSizes == "string" ? v.imageSizes : void 0,
                                media: typeof v.media == "string" ? v.media : void 0
                            })
                        }
                    }
                    ,
                    e.preloadModule = function(g, v) {
                        if (typeof g == "string")
                            if (v) {
                                var _ = m(v.as, v.crossOrigin);
                                r.d.m(g, {
                                    as: typeof v.as == "string" && v.as !== "script" ? v.as : void 0,
                                    crossOrigin: _,
                                    integrity: typeof v.integrity == "string" ? v.integrity : void 0
                                })
                            } else
                                r.d.m(g)
                    }
                    ,
                    e.requestFormReset = function(g) {
                        r.d.r(g)
                    }
                    ,
                    e.unstable_batchedUpdates = function(g, v) {
                        return g(v)
                    }
                    ,
                    e.useFormState = function(g, v, _) {
                        return p.H.useFormState(g, v, _)
                    }
                    ,
                    e.useFormStatus = function() {
                        return p.H.useHostTransitionStatus()
                    }
                    ,
                    e.version = "19.2.3"
                }
                ))
                  , J2 = Ai(( (e, t) => {
                    function n() {
                        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                            try {
                                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                            } catch (a) {
                                console.error(a)
                            }
                    }
                    n(),
                    t.exports = K2()
                }
                ));
                var $2 = Ai((e => {
                    var t = nb()
                      , n = wp()
                      , a = J2();
                    function r(i) {
                        var s = "https://react.dev/errors/" + i;
                        if (1 < arguments.length) {
                            s += "?args[]=" + encodeURIComponent(arguments[1]);
                            for (var u = 2; u < arguments.length; u++)
                                s += "&args[]=" + encodeURIComponent(arguments[u])
                        }
                        return "Minified React error #" + i + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                    }
                    function c(i) {
                        return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11)
                    }
                    function f(i) {
                        var s = i
                          , u = i;
                        if (i.alternate)
                            for (; s.return; )
                                s = s.return;
                        else {
                            i = s;
                            do
                                s = i,
                                (s.flags & 4098) !== 0 && (u = s.return),
                                i = s.return;
                            while (i)
                        }
                        return s.tag === 3 ? u : null
                    }
                    function p(i) {
                        if (i.tag === 13) {
                            var s = i.memoizedState;
                            if (s === null && (i = i.alternate,
                            i !== null && (s = i.memoizedState)),
                            s !== null)
                                return s.dehydrated
                        }
                        return null
                    }
                    function m(i) {
                        if (i.tag === 31) {
                            var s = i.memoizedState;
                            if (s === null && (i = i.alternate,
                            i !== null && (s = i.memoizedState)),
                            s !== null)
                                return s.dehydrated
                        }
                        return null
                    }
                    function g(i) {
                        if (f(i) !== i)
                            throw Error(r(188))
                    }
                    function v(i) {
                        var s = i.alternate;
                        if (!s) {
                            if (s = f(i),
                            s === null)
                                throw Error(r(188));
                            return s !== i ? null : i
                        }
                        for (var u = i, h = s; ; ) {
                            var S = u.return;
                            if (S === null)
                                break;
                            var b = S.alternate;
                            if (b === null) {
                                if (h = S.return,
                                h !== null) {
                                    u = h;
                                    continue
                                }
                                break
                            }
                            if (S.child === b.child) {
                                for (b = S.child; b; ) {
                                    if (b === u)
                                        return g(S),
                                        i;
                                    if (b === h)
                                        return g(S),
                                        s;
                                    b = b.sibling
                                }
                                throw Error(r(188))
                            }
                            if (u.return !== h.return)
                                u = S,
                                h = b;
                            else {
                                for (var D = !1, F = S.child; F; ) {
                                    if (F === u) {
                                        D = !0,
                                        u = S,
                                        h = b;
                                        break
                                    }
                                    if (F === h) {
                                        D = !0,
                                        h = S,
                                        u = b;
                                        break
                                    }
                                    F = F.sibling
                                }
                                if (!D) {
                                    for (F = b.child; F; ) {
                                        if (F === u) {
                                            D = !0,
                                            u = b,
                                            h = S;
                                            break
                                        }
                                        if (F === h) {
                                            D = !0,
                                            h = b,
                                            u = S;
                                            break
                                        }
                                        F = F.sibling
                                    }
                                    if (!D)
                                        throw Error(r(189))
                                }
                            }
                            if (u.alternate !== h)
                                throw Error(r(190))
                        }
                        if (u.tag !== 3)
                            throw Error(r(188));
                        return u.stateNode.current === u ? i : s
                    }
                    function _(i) {
                        var s = i.tag;
                        if (s === 5 || s === 26 || s === 27 || s === 6)
                            return i;
                        for (i = i.child; i !== null; ) {
                            if (s = _(i),
                            s !== null)
                                return s;
                            i = i.sibling
                        }
                        return null
                    }
                    var x = Object.assign
                      , M = Symbol.for("react.element")
                      , C = Symbol.for("react.transitional.element")
                      , R = Symbol.for("react.portal")
                      , A = Symbol.for("react.fragment")
                      , E = Symbol.for("react.strict_mode")
                      , N = Symbol.for("react.profiler")
                      , I = Symbol.for("react.consumer")
                      , L = Symbol.for("react.context")
                      , k = Symbol.for("react.forward_ref")
                      , B = Symbol.for("react.suspense")
                      , X = Symbol.for("react.suspense_list")
                      , G = Symbol.for("react.memo")
                      , P = Symbol.for("react.lazy")
                      , U = Symbol.for("react.activity")
                      , W = Symbol.for("react.memo_cache_sentinel")
                      , K = Symbol.iterator;
                    function q(i) {
                        return i === null || typeof i != "object" ? null : (i = K && i[K] || i["@@iterator"],
                        typeof i == "function" ? i : null)
                    }
                    var te = Symbol.for("react.client.reference");
                    function ce(i) {
                        if (i == null)
                            return null;
                        if (typeof i == "function")
                            return i.$$typeof === te ? null : i.displayName || i.name || null;
                        if (typeof i == "string")
                            return i;
                        switch (i) {
                        case A:
                            return "Fragment";
                        case N:
                            return "Profiler";
                        case E:
                            return "StrictMode";
                        case B:
                            return "Suspense";
                        case X:
                            return "SuspenseList";
                        case U:
                            return "Activity"
                        }
                        if (typeof i == "object")
                            switch (i.$$typeof) {
                            case R:
                                return "Portal";
                            case L:
                                return i.displayName || "Context";
                            case I:
                                return (i._context.displayName || "Context") + ".Consumer";
                            case k:
                                var s = i.render;
                                return i = i.displayName,
                                i || (i = s.displayName || s.name || "",
                                i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"),
                                i;
                            case G:
                                return s = i.displayName || null,
                                s !== null ? s : ce(i.type) || "Memo";
                            case P:
                                s = i._payload,
                                i = i._init;
                                try {
                                    return ce(i(s))
                                } catch {}
                            }
                        return null
                    }
                    var J = Array.isArray
                      , Q = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                      , se = a.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                      , Te = {
                        pending: !1,
                        data: null,
                        method: null,
                        action: null
                    }
                      , Ee = []
                      , Be = -1;
                    function j(i) {
                        return {
                            current: i
                        }
                    }
                    function ve(i) {
                        0 > Be || (i.current = Ee[Be],
                        Ee[Be] = null,
                        Be--)
                    }
                    function Re(i, s) {
                        Be++,
                        Ee[Be] = i.current,
                        i.current = s
                    }
                    var le = j(null)
                      , Ae = j(null)
                      , Ne = j(null)
                      , ke = j(null);
                    function at(i, s) {
                        switch (Re(Ne, s),
                        Re(Ae, i),
                        Re(le, null),
                        s.nodeType) {
                        case 9:
                        case 11:
                            i = (i = s.documentElement) && (i = i.namespaceURI) ? Ex(i) : 0;
                            break;
                        default:
                            if (i = s.tagName,
                            s = s.namespaceURI)
                                s = Ex(s),
                                i = Ax(s, i);
                            else
                                switch (i) {
                                case "svg":
                                    i = 1;
                                    break;
                                case "math":
                                    i = 2;
                                    break;
                                default:
                                    i = 0
                                }
                        }
                        ve(le),
                        Re(le, i)
                    }
                    function Je() {
                        ve(le),
                        ve(Ae),
                        ve(Ne)
                    }
                    function Ft(i) {
                        i.memoizedState !== null && Re(ke, i);
                        var s = le.current
                          , u = Ax(s, i.type);
                        s !== u && (Re(Ae, i),
                        Re(le, u))
                    }
                    function Vt(i) {
                        Ae.current === i && (ve(le),
                        ve(Ae)),
                        ke.current === i && (ve(ke),
                        Mp._currentValue = Te)
                    }
                    var we, Ye;
                    function Ve(i) {
                        if (we === void 0)
                            try {
                                throw Error()
                            } catch (u) {
                                var s = u.stack.trim().match(/\n( *(at )?)/);
                                we = s && s[1] || "",
                                Ye = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : ""
                            }
                        return `
` + we + i + Ye
                    }
                    var tt = !1;
                    function Z(i, s) {
                        if (!i || tt)
                            return "";
                        tt = !0;
                        var u = Error.prepareStackTrace;
                        Error.prepareStackTrace = void 0;
                        try {
                            var h = {
                                DetermineComponentFrameRoot: function() {
                                    try {
                                        if (s) {
                                            var Ie = function() {
                                                throw Error()
                                            };
                                            if (Object.defineProperty(Ie.prototype, "props", {
                                                set: function() {
                                                    throw Error()
                                                }
                                            }),
                                            typeof Reflect == "object" && Reflect.construct) {
                                                try {
                                                    Reflect.construct(Ie, [])
                                                } catch (Se) {
                                                    var ge = Se
                                                }
                                                Reflect.construct(i, [], Ie)
                                            } else {
                                                try {
                                                    Ie.call()
                                                } catch (Se) {
                                                    ge = Se
                                                }
                                                i.call(Ie.prototype)
                                            }
                                        } else {
                                            try {
                                                throw Error()
                                            } catch (Se) {
                                                ge = Se
                                            }
                                            (Ie = i()) && typeof Ie.catch == "function" && Ie.catch(function() {})
                                        }
                                    } catch (Se) {
                                        if (Se && ge && typeof Se.stack == "string")
                                            return [Se.stack, ge.stack]
                                    }
                                    return [null, null]
                                }
                            };
                            h.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                            var S = Object.getOwnPropertyDescriptor(h.DetermineComponentFrameRoot, "name");
                            S && S.configurable && Object.defineProperty(h.DetermineComponentFrameRoot, "name", {
                                value: "DetermineComponentFrameRoot"
                            });
                            var b = h.DetermineComponentFrameRoot()
                              , D = b[0]
                              , F = b[1];
                            if (D && F) {
                                var ee = D.split(`
`)
                                  , pe = F.split(`
`);
                                for (S = h = 0; h < ee.length && !ee[h].includes("DetermineComponentFrameRoot"); )
                                    h++;
                                for (; S < pe.length && !pe[S].includes("DetermineComponentFrameRoot"); )
                                    S++;
                                if (h === ee.length || S === pe.length)
                                    for (h = ee.length - 1,
                                    S = pe.length - 1; 1 <= h && 0 <= S && ee[h] !== pe[S]; )
                                        S--;
                                for (; 1 <= h && 0 <= S; h--,
                                S--)
                                    if (ee[h] !== pe[S]) {
                                        if (h !== 1 || S !== 1)
                                            do
                                                if (h--,
                                                S--,
                                                0 > S || ee[h] !== pe[S]) {
                                                    var De = `
` + ee[h].replace(" at new ", " at ");
                                                    return i.displayName && De.includes("<anonymous>") && (De = De.replace("<anonymous>", i.displayName)),
                                                    De
                                                }
                                            while (1 <= h && 0 <= S);
                                        break
                                    }
                            }
                        } finally {
                            tt = !1,
                            Error.prepareStackTrace = u
                        }
                        return (u = i ? i.displayName || i.name : "") ? Ve(u) : ""
                    }
                    function At(i, s) {
                        switch (i.tag) {
                        case 26:
                        case 27:
                        case 5:
                            return Ve(i.type);
                        case 16:
                            return Ve("Lazy");
                        case 13:
                            return i.child !== s && s !== null ? Ve("Suspense Fallback") : Ve("Suspense");
                        case 19:
                            return Ve("SuspenseList");
                        case 0:
                        case 15:
                            return Z(i.type, !1);
                        case 11:
                            return Z(i.type.render, !1);
                        case 1:
                            return Z(i.type, !0);
                        case 31:
                            return Ve("Activity");
                        default:
                            return ""
                        }
                    }
                    function $e(i) {
                        try {
                            var s = ""
                              , u = null;
                            do
                                s += At(i, u),
                                u = i,
                                i = i.return;
                            while (i);
                            return s
                        } catch (h) {
                            return `
Error generating stack: ` + h.message + `
` + h.stack
                        }
                    }
                    var xt = Object.prototype.hasOwnProperty
                      , Ke = t.unstable_scheduleCallback
                      , wt = t.unstable_cancelCallback
                      , H = t.unstable_shouldYield
                      , O = t.unstable_requestPaint
                      , oe = t.unstable_now
                      , Ce = t.unstable_getCurrentPriorityLevel
                      , Ue = t.unstable_ImmediatePriority
                      , Me = t.unstable_UserBlockingPriority
                      , st = t.unstable_NormalPriority
                      , je = t.unstable_LowPriority
                      , St = t.unstable_IdlePriority
                      , Ct = t.log
                      , He = t.unstable_setDisableYieldValue
                      , We = null
                      , rt = null;
                    function ft(i) {
                        if (typeof Ct == "function" && He(i),
                        rt && typeof rt.setStrictMode == "function")
                            try {
                                rt.setStrictMode(We, i)
                            } catch {}
                    }
                    var et = Math.clz32 ? Math.clz32 : nt
                      , qt = Math.log
                      , ae = Math.LN2;
                    function nt(i) {
                        return i >>>= 0,
                        i === 0 ? 32 : 31 - (qt(i) / ae | 0) | 0
                    }
                    var Ge = 256
                      , ht = 262144
                      , Fe = 4194304;
                    function xe(i) {
                        var s = i & 42;
                        if (s !== 0)
                            return s;
                        switch (i & -i) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                            return 64;
                        case 128:
                            return 128;
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                            return i & 261888;
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return i & 3932160;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            return i & 62914560;
                        case 67108864:
                            return 67108864;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 0;
                        default:
                            return i
                        }
                    }
                    function pt(i, s, u) {
                        var h = i.pendingLanes;
                        if (h === 0)
                            return 0;
                        var S = 0
                          , b = i.suspendedLanes
                          , D = i.pingedLanes;
                        i = i.warmLanes;
                        var F = h & 134217727;
                        return F !== 0 ? (h = F & ~b,
                        h !== 0 ? S = xe(h) : (D &= F,
                        D !== 0 ? S = xe(D) : u || (u = F & ~i,
                        u !== 0 && (S = xe(u))))) : (F = h & ~b,
                        F !== 0 ? S = xe(F) : D !== 0 ? S = xe(D) : u || (u = h & ~i,
                        u !== 0 && (S = xe(u)))),
                        S === 0 ? 0 : s !== 0 && s !== S && (s & b) === 0 && (b = S & -S,
                        u = s & -s,
                        b >= u || b === 32 && (u & 4194048) !== 0) ? s : S
                    }
                    function Mt(i, s) {
                        return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & s) === 0
                    }
                    function In(i, s) {
                        switch (i) {
                        case 1:
                        case 2:
                        case 4:
                        case 8:
                        case 64:
                            return s + 250;
                        case 16:
                        case 32:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return s + 5e3;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            return -1;
                        case 67108864:
                        case 134217728:
                        case 268435456:
                        case 536870912:
                        case 1073741824:
                            return -1;
                        default:
                            return -1
                        }
                    }
                    function xn() {
                        var i = Fe;
                        return Fe <<= 1,
                        (Fe & 62914560) === 0 && (Fe = 4194304),
                        i
                    }
                    function xa(i) {
                        for (var s = [], u = 0; 31 > u; u++)
                            s.push(i);
                        return s
                    }
                    function Gi(i, s) {
                        i.pendingLanes |= s,
                        s !== 268435456 && (i.suspendedLanes = 0,
                        i.pingedLanes = 0,
                        i.warmLanes = 0)
                    }
                    function qr(i, s, u, h, S, b) {
                        var D = i.pendingLanes;
                        i.pendingLanes = u,
                        i.suspendedLanes = 0,
                        i.pingedLanes = 0,
                        i.warmLanes = 0,
                        i.expiredLanes &= u,
                        i.entangledLanes &= u,
                        i.errorRecoveryDisabledLanes &= u,
                        i.shellSuspendCounter = 0;
                        var F = i.entanglements
                          , ee = i.expirationTimes
                          , pe = i.hiddenUpdates;
                        for (u = D & ~u; 0 < u; ) {
                            var De = 31 - et(u)
                              , Ie = 1 << De;
                            F[De] = 0,
                            ee[De] = -1;
                            var ge = pe[De];
                            if (ge !== null)
                                for (pe[De] = null,
                                De = 0; De < ge.length; De++) {
                                    var Se = ge[De];
                                    Se !== null && (Se.lane &= -536870913)
                                }
                            u &= ~Ie
                        }
                        h !== 0 && mr(i, h, 0),
                        b !== 0 && S === 0 && i.tag !== 0 && (i.suspendedLanes |= b & ~(D & ~s))
                    }
                    function mr(i, s, u) {
                        i.pendingLanes |= s,
                        i.suspendedLanes &= ~s;
                        var h = 31 - et(s);
                        i.entangledLanes |= s,
                        i.entanglements[h] = i.entanglements[h] | 1073741824 | u & 261930
                    }
                    function zc(i, s) {
                        var u = i.entangledLanes |= s;
                        for (i = i.entanglements; u; ) {
                            var h = 31 - et(u)
                              , S = 1 << h;
                            S & s | i[h] & s && (i[h] |= s),
                            u &= ~S
                        }
                    }
                    function Yr(i, s) {
                        var u = s & -s;
                        return u = (u & 42) !== 0 ? 1 : jr(u),
                        (u & (i.suspendedLanes | s)) !== 0 ? 0 : u
                    }
                    function jr(i) {
                        switch (i) {
                        case 2:
                            i = 1;
                            break;
                        case 8:
                            i = 4;
                            break;
                        case 32:
                            i = 16;
                            break;
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                            i = 128;
                            break;
                        case 268435456:
                            i = 134217728;
                            break;
                        default:
                            i = 0
                        }
                        return i
                    }
                    function Ua(i) {
                        return i &= -i,
                        2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                    }
                    function ss() {
                        var i = se.p;
                        return i !== 0 ? i : (i = window.event,
                        i === void 0 ? 32 : Yx(i.type))
                    }
                    function Rl(i, s) {
                        var u = se.p;
                        try {
                            return se.p = i,
                            s()
                        } finally {
                            se.p = u
                        }
                    }
                    var ba = Math.random().toString(36).slice(2)
                      , Zn = "__reactFiber$" + ba
                      , Ci = "__reactProps$" + ba
                      , Wi = "__reactContainer$" + ba
                      , Ia = "__reactEvents$" + ba
                      , Zr = "__reactListeners$" + ba
                      , Bc = "__reactHandles$" + ba
                      , Qr = "__reactResources$" + ba
                      , Es = "__reactMarker$" + ba;
                    function Dl(i) {
                        delete i[Zn],
                        delete i[Ci],
                        delete i[Ia],
                        delete i[Zr],
                        delete i[Bc]
                    }
                    function gr(i) {
                        var s = i[Zn];
                        if (s)
                            return s;
                        for (var u = i.parentNode; u; ) {
                            if (s = u[Wi] || u[Zn]) {
                                if (u = s.alternate,
                                s.child !== null || u !== null && u.child !== null)
                                    for (i = Ux(i); i !== null; ) {
                                        if (u = i[Zn])
                                            return u;
                                        i = Ux(i)
                                    }
                                return s
                            }
                            i = u,
                            u = i.parentNode
                        }
                        return null
                    }
                    function vr(i) {
                        if (i = i[Zn] || i[Wi]) {
                            var s = i.tag;
                            if (s === 5 || s === 6 || s === 13 || s === 31 || s === 26 || s === 27 || s === 3)
                                return i
                        }
                        return null
                    }
                    function V(i) {
                        var s = i.tag;
                        if (s === 5 || s === 26 || s === 27 || s === 6)
                            return i.stateNode;
                        throw Error(r(33))
                    }
                    function re(i) {
                        var s = i[Qr];
                        return s || (s = i[Qr] = {
                            hoistableStyles: new Map,
                            hoistableScripts: new Map
                        }),
                        s
                    }
                    function he(i) {
                        i[Es] = !0
                    }
                    var ye = new Set
                      , fe = {};
                    function ze(i, s) {
                        qe(i, s),
                        qe(i + "Capture", s)
                    }
                    function qe(i, s) {
                        for (fe[i] = s,
                        i = 0; i < s.length; i++)
                            ye.add(s[i])
                    }
                    var mt = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
                      , Ze = {}
                      , Rt = {};
                    function Ot(i) {
                        return xt.call(Rt, i) ? !0 : xt.call(Ze, i) ? !1 : mt.test(i) ? Rt[i] = !0 : (Ze[i] = !0,
                        !1)
                    }
                    function Tt(i, s, u) {
                        if (Ot(s))
                            if (u === null)
                                i.removeAttribute(s);
                            else {
                                switch (typeof u) {
                                case "undefined":
                                case "function":
                                case "symbol":
                                    i.removeAttribute(s);
                                    return;
                                case "boolean":
                                    var h = s.toLowerCase().slice(0, 5);
                                    if (h !== "data-" && h !== "aria-") {
                                        i.removeAttribute(s);
                                        return
                                    }
                                }
                                i.setAttribute(s, "" + u)
                            }
                    }
                    function Qt(i, s, u) {
                        if (u === null)
                            i.removeAttribute(s);
                        else {
                            switch (typeof u) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                                i.removeAttribute(s);
                                return
                            }
                            i.setAttribute(s, "" + u)
                        }
                    }
                    function cn(i, s, u, h) {
                        if (h === null)
                            i.removeAttribute(u);
                        else {
                            switch (typeof h) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                                i.removeAttribute(u);
                                return
                            }
                            i.setAttributeNS(s, u, "" + h)
                        }
                    }
                    function nn(i) {
                        switch (typeof i) {
                        case "bigint":
                        case "boolean":
                        case "number":
                        case "string":
                        case "undefined":
                            return i;
                        case "object":
                            return i;
                        default:
                            return ""
                        }
                    }
                    function On(i) {
                        var s = i.type;
                        return (i = i.nodeName) && i.toLowerCase() === "input" && (s === "checkbox" || s === "radio")
                    }
                    function un(i, s, u) {
                        var h = Object.getOwnPropertyDescriptor(i.constructor.prototype, s);
                        if (!i.hasOwnProperty(s) && typeof h < "u" && typeof h.get == "function" && typeof h.set == "function") {
                            var S = h.get
                              , b = h.set;
                            return Object.defineProperty(i, s, {
                                configurable: !0,
                                get: function() {
                                    return S.call(this)
                                },
                                set: function(D) {
                                    u = "" + D,
                                    b.call(this, D)
                                }
                            }),
                            Object.defineProperty(i, s, {
                                enumerable: h.enumerable
                            }),
                            {
                                getValue: function() {
                                    return u
                                },
                                setValue: function(D) {
                                    u = "" + D
                                },
                                stopTracking: function() {
                                    i._valueTracker = null,
                                    delete i[s]
                                }
                            }
                        }
                    }
                    function ut(i) {
                        if (!i._valueTracker) {
                            var s = On(i) ? "checked" : "value";
                            i._valueTracker = un(i, s, "" + i[s])
                        }
                    }
                    function kt(i) {
                        if (!i)
                            return !1;
                        var s = i._valueTracker;
                        if (!s)
                            return !0;
                        var u = s.getValue()
                          , h = "";
                        return i && (h = On(i) ? i.checked ? "true" : "false" : i.value),
                        i = h,
                        i !== u ? (s.setValue(i),
                        !0) : !1
                    }
                    function an(i) {
                        if (i = i || (typeof document < "u" ? document : void 0),
                        typeof i > "u")
                            return null;
                        try {
                            return i.activeElement || i.body
                        } catch {
                            return i.body
                        }
                    }
                    var Xi = /[\n"\\]/g;
                    function ni(i) {
                        return i.replace(Xi, function(s) {
                            return "\\" + s.charCodeAt(0).toString(16) + " "
                        })
                    }
                    function Ri(i, s, u, h, S, b, D, F) {
                        i.name = "",
                        D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? i.type = D : i.removeAttribute("type"),
                        s != null ? D === "number" ? (s === 0 && i.value === "" || i.value != s) && (i.value = "" + nn(s)) : i.value !== "" + nn(s) && (i.value = "" + nn(s)) : D !== "submit" && D !== "reset" || i.removeAttribute("value"),
                        s != null ? bn(i, D, nn(s)) : u != null ? bn(i, D, nn(u)) : h != null && i.removeAttribute("value"),
                        S == null && b != null && (i.defaultChecked = !!b),
                        S != null && (i.checked = S && typeof S != "function" && typeof S != "symbol"),
                        F != null && typeof F != "function" && typeof F != "symbol" && typeof F != "boolean" ? i.name = "" + nn(F) : i.removeAttribute("name")
                    }
                    function Ji(i, s, u, h, S, b, D, F) {
                        if (b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" && (i.type = b),
                        s != null || u != null) {
                            if (!(b !== "submit" && b !== "reset" || s != null)) {
                                ut(i);
                                return
                            }
                            u = u != null ? "" + nn(u) : "",
                            s = s != null ? "" + nn(s) : u,
                            F || s === i.value || (i.value = s),
                            i.defaultValue = s
                        }
                        h = h ?? S,
                        h = typeof h != "function" && typeof h != "symbol" && !!h,
                        i.checked = F ? i.checked : !!h,
                        i.defaultChecked = !!h,
                        D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" && (i.name = D),
                        ut(i)
                    }
                    function bn(i, s, u) {
                        s === "number" && an(i.ownerDocument) === i || i.defaultValue === "" + u || (i.defaultValue = "" + u)
                    }
                    function Jn(i, s, u, h) {
                        if (i = i.options,
                        s) {
                            s = {};
                            for (var S = 0; S < u.length; S++)
                                s["$" + u[S]] = !0;
                            for (u = 0; u < i.length; u++)
                                S = s.hasOwnProperty("$" + i[u].value),
                                i[u].selected !== S && (i[u].selected = S),
                                S && h && (i[u].defaultSelected = !0)
                        } else {
                            for (u = "" + nn(u),
                            s = null,
                            S = 0; S < i.length; S++) {
                                if (i[S].value === u) {
                                    i[S].selected = !0,
                                    h && (i[S].defaultSelected = !0);
                                    return
                                }
                                s !== null || i[S].disabled || (s = i[S])
                            }
                            s !== null && (s.selected = !0)
                        }
                    }
                    function qi(i, s, u) {
                        if (s != null && (s = "" + nn(s),
                        s !== i.value && (i.value = s),
                        u == null)) {
                            i.defaultValue !== s && (i.defaultValue = s);
                            return
                        }
                        i.defaultValue = u != null ? "" + nn(u) : ""
                    }
                    function hi(i, s, u, h) {
                        if (s == null) {
                            if (h != null) {
                                if (u != null)
                                    throw Error(r(92));
                                if (J(h)) {
                                    if (1 < h.length)
                                        throw Error(r(93));
                                    h = h[0]
                                }
                                u = h
                            }
                            u ??= "",
                            s = u
                        }
                        u = nn(s),
                        i.defaultValue = u,
                        h = i.textContent,
                        h === u && h !== "" && h !== null && (i.value = h),
                        ut(i)
                    }
                    function Di(i, s) {
                        if (s) {
                            var u = i.firstChild;
                            if (u && u === i.lastChild && u.nodeType === 3) {
                                u.nodeValue = s;
                                return
                            }
                        }
                        i.textContent = s
                    }
                    var Nl = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
                    function As(i, s, u) {
                        var h = s.indexOf("--") === 0;
                        u == null || typeof u == "boolean" || u === "" ? h ? i.setProperty(s, "") : s === "float" ? i.cssFloat = "" : i[s] = "" : h ? i.setProperty(s, u) : typeof u != "number" || u === 0 || Nl.has(s) ? s === "float" ? i.cssFloat = u : i[s] = ("" + u).trim() : i[s] = u + "px"
                    }
                    function rd(i, s, u) {
                        if (s != null && typeof s != "object")
                            throw Error(r(62));
                        if (i = i.style,
                        u != null) {
                            for (var h in u)
                                !u.hasOwnProperty(h) || s != null && s.hasOwnProperty(h) || (h.indexOf("--") === 0 ? i.setProperty(h, "") : h === "float" ? i.cssFloat = "" : i[h] = "");
                            for (var S in s)
                                h = s[S],
                                s.hasOwnProperty(S) && u[S] !== h && As(i, S, h)
                        } else
                            for (var b in s)
                                s.hasOwnProperty(b) && As(i, b, s[b])
                    }
                    function cf(i) {
                        if (i.indexOf("-") === -1)
                            return !1;
                        switch (i) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                        }
                    }
                    var od = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
                      , Am = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
                    function uf(i) {
                        return Am.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i
                    }
                    function Gs() {}
                    var ff = null;
                    function hf(i) {
                        return i = i.target || i.srcElement || window,
                        i.correspondingUseElement && (i = i.correspondingUseElement),
                        i.nodeType === 3 ? i.parentNode : i
                    }
                    var Kr = null
                      , Fo = null;
                    function ld(i) {
                        var s = vr(i);
                        if (s && (i = s.stateNode)) {
                            var u = i[Ci] || null;
                            e: switch (i = s.stateNode,
                            s.type) {
                            case "input":
                                if (Ri(i, u.value, u.defaultValue, u.defaultValue, u.checked, u.defaultChecked, u.type, u.name),
                                s = u.name,
                                u.type === "radio" && s != null) {
                                    for (u = i; u.parentNode; )
                                        u = u.parentNode;
                                    for (u = u.querySelectorAll('input[name="' + ni("" + s) + '"][type="radio"]'),
                                    s = 0; s < u.length; s++) {
                                        var h = u[s];
                                        if (h !== i && h.form === i.form) {
                                            var S = h[Ci] || null;
                                            if (!S)
                                                throw Error(r(90));
                                            Ri(h, S.value, S.defaultValue, S.defaultValue, S.checked, S.defaultChecked, S.type, S.name)
                                        }
                                    }
                                    for (s = 0; s < u.length; s++)
                                        h = u[s],
                                        h.form === i.form && kt(h)
                                }
                                break e;
                            case "textarea":
                                qi(i, u.value, u.defaultValue);
                                break e;
                            case "select":
                                s = u.value,
                                s != null && Jn(i, !!u.multiple, s, !1)
                            }
                        }
                    }
                    var df = !1;
                    function cd(i, s, u) {
                        if (df)
                            return i(s, u);
                        df = !0;
                        try {
                            return i(s)
                        } finally {
                            if (df = !1,
                            (Kr !== null || Fo !== null) && (dl(),
                            Kr && (s = Kr,
                            i = Fo,
                            Fo = Kr = null,
                            ld(s),
                            i)))
                                for (s = 0; s < i.length; s++)
                                    ld(i[s])
                        }
                    }
                    function Ll(i, s) {
                        var u = i.stateNode;
                        if (u === null)
                            return null;
                        var h = u[Ci] || null;
                        if (h === null)
                            return null;
                        u = h[s];
                        e: switch (s) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (h = !h.disabled) || (i = i.type,
                            h = !(i === "button" || i === "input" || i === "select" || i === "textarea")),
                            i = !h;
                            break e;
                        default:
                            i = !1
                        }
                        if (i)
                            return null;
                        if (u && typeof u != "function")
                            throw Error(r(231, s, typeof u));
                        return u
                    }
                    var yr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
                      , pf = !1;
                    if (yr)
                        try {
                            var Ws = {};
                            Object.defineProperty(Ws, "passive", {
                                get: function() {
                                    pf = !0
                                }
                            }),
                            window.addEventListener("test", Ws, Ws),
                            window.removeEventListener("test", Ws, Ws)
                        } catch {
                            pf = !1
                        }
                    var _r = null
                      , Ul = null
                      , Vo = null;
                    function ud() {
                        if (Vo)
                            return Vo;
                        var i, s = Ul, u = s.length, h, S = "value"in _r ? _r.value : _r.textContent, b = S.length;
                        for (i = 0; i < u && s[i] === S[i]; i++)
                            ;
                        var D = u - i;
                        for (h = 1; h <= D && s[u - h] === S[b - h]; h++)
                            ;
                        return Vo = S.slice(i, 1 < h ? 1 - h : void 0)
                    }
                    function Il(i) {
                        var s = i.keyCode;
                        return "charCode"in i ? (i = i.charCode,
                        i === 0 && s === 13 && (i = 13)) : i = s,
                        i === 10 && (i = 13),
                        32 <= i || i === 13 ? i : 0
                    }
                    function mf() {
                        return !0
                    }
                    function fd() {
                        return !1
                    }
                    function ua(i) {
                        function s(u, h, S, b, D) {
                            this._reactName = u,
                            this._targetInst = S,
                            this.type = h,
                            this.nativeEvent = b,
                            this.target = D,
                            this.currentTarget = null;
                            for (var F in i)
                                i.hasOwnProperty(F) && (u = i[F],
                                this[F] = u ? u(b) : b[F]);
                            return this.isDefaultPrevented = (b.defaultPrevented != null ? b.defaultPrevented : b.returnValue === !1) ? mf : fd,
                            this.isPropagationStopped = fd,
                            this
                        }
                        return x(s.prototype, {
                            preventDefault: function() {
                                this.defaultPrevented = !0;
                                var u = this.nativeEvent;
                                u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1),
                                this.isDefaultPrevented = mf)
                            },
                            stopPropagation: function() {
                                var u = this.nativeEvent;
                                u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0),
                                this.isPropagationStopped = mf)
                            },
                            persist: function() {},
                            isPersistent: mf
                        }),
                        s
                    }
                    var Jr = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(i) {
                            return i.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    }, Fc = ua(Jr), Ol = x({}, Jr, {
                        view: 0,
                        detail: 0
                    }), hd = ua(Ol), gf, vf, ko, Vc = x({}, Ol, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: Pl,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(i) {
                            return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget
                        },
                        movementX: function(i) {
                            return "movementX"in i ? i.movementX : (i !== ko && (ko && i.type === "mousemove" ? (gf = i.screenX - ko.screenX,
                            vf = i.screenY - ko.screenY) : vf = gf = 0,
                            ko = i),
                            gf)
                        },
                        movementY: function(i) {
                            return "movementY"in i ? i.movementY : vf
                        }
                    }), dd = ua(Vc), wm = ua(x({}, Vc, {
                        dataTransfer: 0
                    })), kc = ua(x({}, Ol, {
                        relatedTarget: 0
                    })), Cm = ua(x({}, Jr, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })), Rm = ua(x({}, Jr, {
                        clipboardData: function(i) {
                            return "clipboardData"in i ? i.clipboardData : window.clipboardData
                        }
                    })), Dm = ua(x({}, Jr, {
                        data: 0
                    })), by = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    }, Nm = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    }, Hc = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };
                    function pd(i) {
                        var s = this.nativeEvent;
                        return s.getModifierState ? s.getModifierState(i) : (i = Hc[i]) ? !!s[i] : !1
                    }
                    function Pl() {
                        return pd
                    }
                    var Lm = ua(x({}, Ol, {
                        key: function(i) {
                            if (i.key) {
                                var s = by[i.key] || i.key;
                                if (s !== "Unidentified")
                                    return s
                            }
                            return i.type === "keypress" ? (i = Il(i),
                            i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? Nm[i.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: Pl,
                        charCode: function(i) {
                            return i.type === "keypress" ? Il(i) : 0
                        },
                        keyCode: function(i) {
                            return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0
                        },
                        which: function(i) {
                            return i.type === "keypress" ? Il(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0
                        }
                    }))
                      , md = ua(x({}, Vc, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    }))
                      , gd = ua(x({}, Ol, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: Pl
                    }))
                      , Um = ua(x({}, Jr, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    }))
                      , Im = ua(x({}, Vc, {
                        deltaX: function(i) {
                            return "deltaX"in i ? i.deltaX : "wheelDeltaX"in i ? -i.wheelDeltaX : 0
                        },
                        deltaY: function(i) {
                            return "deltaY"in i ? i.deltaY : "wheelDeltaY"in i ? -i.wheelDeltaY : "wheelDelta"in i ? -i.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    }))
                      , Ho = ua(x({}, Jr, {
                        newState: 0,
                        oldState: 0
                    }))
                      , yf = [9, 13, 27, 32]
                      , _f = yr && "CompositionEvent"in window
                      , Go = null;
                    yr && "documentMode"in document && (Go = document.documentMode);
                    var Om = yr && "TextEvent"in window && !Go
                      , vd = yr && (!_f || Go && 8 < Go && 11 >= Go)
                      , Pm = " "
                      , zi = !1;
                    function yd(i, s) {
                        switch (i) {
                        case "keyup":
                            return yf.indexOf(s.keyCode) !== -1;
                        case "keydown":
                            return s.keyCode !== 229;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    function _d(i) {
                        return i = i.detail,
                        typeof i == "object" && "data"in i ? i.data : null
                    }
                    var Wo = !1;
                    function zm(i, s) {
                        switch (i) {
                        case "compositionend":
                            return _d(s);
                        case "keypress":
                            return s.which !== 32 ? null : (zi = !0,
                            Pm);
                        case "textInput":
                            return i = s.data,
                            i === Pm && zi ? null : i;
                        default:
                            return null
                        }
                    }
                    function Gc(i, s) {
                        if (Wo)
                            return i === "compositionend" || !_f && yd(i, s) ? (i = ud(),
                            Vo = Ul = _r = null,
                            Wo = !1,
                            i) : null;
                        switch (i) {
                        case "paste":
                            return null;
                        case "keypress":
                            if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) {
                                if (s.char && 1 < s.char.length)
                                    return s.char;
                                if (s.which)
                                    return String.fromCharCode(s.which)
                            }
                            return null;
                        case "compositionend":
                            return vd && s.locale !== "ko" ? null : s.data;
                        default:
                            return null
                        }
                    }
                    var Bm = {
                        color: !0,
                        date: !0,
                        datetime: !0,
                        "datetime-local": !0,
                        email: !0,
                        month: !0,
                        number: !0,
                        password: !0,
                        range: !0,
                        search: !0,
                        tel: !0,
                        text: !0,
                        time: !0,
                        url: !0,
                        week: !0
                    };
                    function Wc(i) {
                        var s = i && i.nodeName && i.nodeName.toLowerCase();
                        return s === "input" ? !!Bm[i.type] : s === "textarea"
                    }
                    function Sd(i, s, u, h) {
                        Kr ? Fo ? Fo.push(h) : Fo = [h] : Kr = h,
                        s = yi(s, "onChange"),
                        0 < s.length && (u = new Fc("onChange","change",null,u,h),
                        i.push({
                            event: u,
                            listeners: s
                        }))
                    }
                    var Xc = null
                      , $r = null;
                    function xd(i) {
                        me(i, 0)
                    }
                    function qc(i) {
                        if (kt(V(i)))
                            return i
                    }
                    function bd(i, s) {
                        if (i === "change")
                            return s
                    }
                    var Md = !1;
                    if (yr) {
                        var Yc;
                        if (yr) {
                            var jc = "oninput"in document;
                            if (!jc) {
                                var Td = document.createElement("div");
                                Td.setAttribute("oninput", "return;"),
                                jc = typeof Td.oninput == "function"
                            }
                            Yc = jc
                        } else
                            Yc = !1;
                        Md = Yc && (!document.documentMode || 9 < document.documentMode)
                    }
                    function Sf() {
                        Xc && (Xc.detachEvent("onpropertychange", Zc),
                        $r = Xc = null)
                    }
                    function Zc(i) {
                        if (i.propertyName === "value" && qc($r)) {
                            var s = [];
                            Sd(s, $r, i, hf(i)),
                            cd(xd, s)
                        }
                    }
                    function Ed(i, s, u) {
                        i === "focusin" ? (Sf(),
                        Xc = s,
                        $r = u,
                        Xc.attachEvent("onpropertychange", Zc)) : i === "focusout" && Sf()
                    }
                    function Fm(i) {
                        if (i === "selectionchange" || i === "keyup" || i === "keydown")
                            return qc($r)
                    }
                    function Ad(i, s) {
                        if (i === "click")
                            return qc(s)
                    }
                    function Vm(i, s) {
                        if (i === "input" || i === "change")
                            return qc(s)
                    }
                    function Sr(i, s) {
                        return i === s && (i !== 0 || 1 / i === 1 / s) || i !== i && s !== s
                    }
                    var fa = typeof Object.is == "function" ? Object.is : Sr;
                    function Qc(i, s) {
                        if (fa(i, s))
                            return !0;
                        if (typeof i != "object" || i === null || typeof s != "object" || s === null)
                            return !1;
                        var u = Object.keys(i)
                          , h = Object.keys(s);
                        if (u.length !== h.length)
                            return !1;
                        for (h = 0; h < u.length; h++) {
                            var S = u[h];
                            if (!xt.call(s, S) || !fa(i[S], s[S]))
                                return !1
                        }
                        return !0
                    }
                    function wd(i) {
                        for (; i && i.firstChild; )
                            i = i.firstChild;
                        return i
                    }
                    function rs(i, s) {
                        var u = wd(i);
                        i = 0;
                        for (var h; u; ) {
                            if (u.nodeType === 3) {
                                if (h = i + u.textContent.length,
                                i <= s && h >= s)
                                    return {
                                        node: u,
                                        offset: s - i
                                    };
                                i = h
                            }
                            e: {
                                for (; u; ) {
                                    if (u.nextSibling) {
                                        u = u.nextSibling;
                                        break e
                                    }
                                    u = u.parentNode
                                }
                                u = void 0
                            }
                            u = wd(u)
                        }
                    }
                    function Kc(i, s) {
                        return i && s ? i === s ? !0 : i && i.nodeType === 3 ? !1 : s && s.nodeType === 3 ? Kc(i, s.parentNode) : "contains"in i ? i.contains(s) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(s) & 16) : !1 : !1
                    }
                    function Cd(i) {
                        i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
                        for (var s = an(i.document); s instanceof i.HTMLIFrameElement; ) {
                            try {
                                var u = typeof s.contentWindow.location.href == "string"
                            } catch {
                                u = !1
                            }
                            if (u)
                                i = s.contentWindow;
                            else
                                break;
                            s = an(i.document)
                        }
                        return s
                    }
                    function Jc(i) {
                        var s = i && i.nodeName && i.nodeName.toLowerCase();
                        return s && (s === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || s === "textarea" || i.contentEditable === "true")
                    }
                    var km = yr && "documentMode"in document && 11 >= document.documentMode
                      , Xo = null
                      , $c = null
                      , qo = null
                      , xf = !1;
                    function eu(i, s, u) {
                        var h = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
                        xf || Xo == null || Xo !== an(h) || (h = Xo,
                        "selectionStart"in h && Jc(h) ? h = {
                            start: h.selectionStart,
                            end: h.selectionEnd
                        } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(),
                        h = {
                            anchorNode: h.anchorNode,
                            anchorOffset: h.anchorOffset,
                            focusNode: h.focusNode,
                            focusOffset: h.focusOffset
                        }),
                        qo && Qc(qo, h) || (qo = h,
                        h = yi($c, "onSelect"),
                        0 < h.length && (s = new Fc("onSelect","select",null,s,u),
                        i.push({
                            event: s,
                            listeners: h
                        }),
                        s.target = Xo)))
                    }
                    function ws(i, s) {
                        var u = {};
                        return u[i.toLowerCase()] = s.toLowerCase(),
                        u["Webkit" + i] = "webkit" + s,
                        u["Moz" + i] = "moz" + s,
                        u
                    }
                    var Rn = {
                        animationend: ws("Animation", "AnimationEnd"),
                        animationiteration: ws("Animation", "AnimationIteration"),
                        animationstart: ws("Animation", "AnimationStart"),
                        transitionrun: ws("Transition", "TransitionRun"),
                        transitionstart: ws("Transition", "TransitionStart"),
                        transitioncancel: ws("Transition", "TransitionCancel"),
                        transitionend: ws("Transition", "TransitionEnd")
                    }
                      , Rd = {}
                      , Hm = {};
                    yr && (Hm = document.createElement("div").style,
                    "AnimationEvent"in window || (delete Rn.animationend.animation,
                    delete Rn.animationiteration.animation,
                    delete Rn.animationstart.animation),
                    "TransitionEvent"in window || delete Rn.transitionend.transition);
                    function eo(i) {
                        if (Rd[i])
                            return Rd[i];
                        if (!Rn[i])
                            return i;
                        var s = Rn[i], u;
                        for (u in s)
                            if (s.hasOwnProperty(u) && u in Hm)
                                return Rd[i] = s[u];
                        return i
                    }
                    var zl = eo("animationend")
                      , xr = eo("animationiteration")
                      , Dd = eo("animationstart")
                      , Gm = eo("transitionrun")
                      , tu = eo("transitionstart")
                      , Xs = eo("transitioncancel")
                      , Nd = eo("transitionend")
                      , bf = new Map
                      , Mf = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
                    Mf.push("scrollEnd");
                    function Oa(i, s) {
                        bf.set(i, s),
                        ze(s, [i])
                    }
                    var Bl = typeof reportError == "function" ? reportError : function(i) {
                        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                            var s = new window.ErrorEvent("error",{
                                bubbles: !0,
                                cancelable: !0,
                                message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
                                error: i
                            });
                            if (!window.dispatchEvent(s))
                                return
                        } else if (typeof process == "object" && typeof process.emit == "function") {
                            process.emit("uncaughtException", i);
                            return
                        }
                        console.error(i)
                    }
                      , ha = []
                      , Yo = 0
                      , Tf = 0;
                    function Ef() {
                        for (var i = Yo, s = Tf = Yo = 0; s < i; ) {
                            var u = ha[s];
                            ha[s++] = null;
                            var h = ha[s];
                            ha[s++] = null;
                            var S = ha[s];
                            ha[s++] = null;
                            var b = ha[s];
                            if (ha[s++] = null,
                            h !== null && S !== null) {
                                var D = h.pending;
                                D === null ? S.next = S : (S.next = D.next,
                                D.next = S),
                                h.pending = S
                            }
                            b !== 0 && wf(u, S, b)
                        }
                    }
                    function nu(i, s, u, h) {
                        ha[Yo++] = i,
                        ha[Yo++] = s,
                        ha[Yo++] = u,
                        ha[Yo++] = h,
                        Tf |= h,
                        i.lanes |= h,
                        i = i.alternate,
                        i !== null && (i.lanes |= h)
                    }
                    function Af(i, s, u, h) {
                        return nu(i, s, u, h),
                        iu(i)
                    }
                    function Yi(i, s) {
                        return nu(i, null, null, s),
                        iu(i)
                    }
                    function wf(i, s, u) {
                        i.lanes |= u;
                        var h = i.alternate;
                        h !== null && (h.lanes |= u);
                        for (var S = !1, b = i.return; b !== null; )
                            b.childLanes |= u,
                            h = b.alternate,
                            h !== null && (h.childLanes |= u),
                            b.tag === 22 && (i = b.stateNode,
                            i === null || i._visibility & 1 || (S = !0)),
                            i = b,
                            b = b.return;
                        return i.tag === 3 ? (b = i.stateNode,
                        S && s !== null && (S = 31 - et(u),
                        i = b.hiddenUpdates,
                        h = i[S],
                        h === null ? i[S] = [s] : h.push(s),
                        s.lane = u | 536870912),
                        b) : null
                    }
                    function iu(i) {
                        if (50 < li)
                            throw li = 0,
                            ci = null,
                            Error(r(185));
                        for (var s = i.return; s !== null; )
                            i = s,
                            s = i.return;
                        return i.tag === 3 ? i.stateNode : null
                    }
                    var jo = {};
                    function My(i, s, u, h) {
                        this.tag = i,
                        this.key = u,
                        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                        this.index = 0,
                        this.refCleanup = this.ref = null,
                        this.pendingProps = s,
                        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                        this.mode = h,
                        this.subtreeFlags = this.flags = 0,
                        this.deletions = null,
                        this.childLanes = this.lanes = 0,
                        this.alternate = null
                    }
                    function $i(i, s, u, h) {
                        return new My(i,s,u,h)
                    }
                    function Bi(i) {
                        return i = i.prototype,
                        !(!i || !i.isReactComponent)
                    }
                    function qs(i, s) {
                        var u = i.alternate;
                        return u === null ? (u = $i(i.tag, s, i.key, i.mode),
                        u.elementType = i.elementType,
                        u.type = i.type,
                        u.stateNode = i.stateNode,
                        u.alternate = i,
                        i.alternate = u) : (u.pendingProps = s,
                        u.type = i.type,
                        u.flags = 0,
                        u.subtreeFlags = 0,
                        u.deletions = null),
                        u.flags = i.flags & 65011712,
                        u.childLanes = i.childLanes,
                        u.lanes = i.lanes,
                        u.child = i.child,
                        u.memoizedProps = i.memoizedProps,
                        u.memoizedState = i.memoizedState,
                        u.updateQueue = i.updateQueue,
                        s = i.dependencies,
                        u.dependencies = s === null ? null : {
                            lanes: s.lanes,
                            firstContext: s.firstContext
                        },
                        u.sibling = i.sibling,
                        u.index = i.index,
                        u.ref = i.ref,
                        u.refCleanup = i.refCleanup,
                        u
                    }
                    function ea(i, s) {
                        i.flags &= 65011714;
                        var u = i.alternate;
                        return u === null ? (i.childLanes = 0,
                        i.lanes = s,
                        i.child = null,
                        i.subtreeFlags = 0,
                        i.memoizedProps = null,
                        i.memoizedState = null,
                        i.updateQueue = null,
                        i.dependencies = null,
                        i.stateNode = null) : (i.childLanes = u.childLanes,
                        i.lanes = u.lanes,
                        i.child = u.child,
                        i.subtreeFlags = 0,
                        i.deletions = null,
                        i.memoizedProps = u.memoizedProps,
                        i.memoizedState = u.memoizedState,
                        i.updateQueue = u.updateQueue,
                        i.type = u.type,
                        s = u.dependencies,
                        i.dependencies = s === null ? null : {
                            lanes: s.lanes,
                            firstContext: s.firstContext
                        }),
                        i
                    }
                    function au(i, s, u, h, S, b) {
                        var D = 0;
                        if (h = i,
                        typeof i == "function")
                            Bi(i) && (D = 1);
                        else if (typeof i == "string")
                            D = M2(i, u, le.current) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
                        else
                            e: switch (i) {
                            case U:
                                return i = $i(31, u, s, S),
                                i.elementType = U,
                                i.lanes = b,
                                i;
                            case A:
                                return da(u.children, S, b, s);
                            case E:
                                D = 8,
                                S |= 24;
                                break;
                            case N:
                                return i = $i(12, u, s, S | 2),
                                i.elementType = N,
                                i.lanes = b,
                                i;
                            case B:
                                return i = $i(13, u, s, S),
                                i.elementType = B,
                                i.lanes = b,
                                i;
                            case X:
                                return i = $i(19, u, s, S),
                                i.elementType = X,
                                i.lanes = b,
                                i;
                            default:
                                if (typeof i == "object" && i !== null)
                                    switch (i.$$typeof) {
                                    case L:
                                        D = 10;
                                        break e;
                                    case I:
                                        D = 9;
                                        break e;
                                    case k:
                                        D = 11;
                                        break e;
                                    case G:
                                        D = 14;
                                        break e;
                                    case P:
                                        D = 16,
                                        h = null;
                                        break e
                                    }
                                D = 29,
                                u = Error(r(130, i === null ? "null" : typeof i, "")),
                                h = null
                            }
                        return s = $i(D, u, s, S),
                        s.elementType = i,
                        s.type = h,
                        s.lanes = b,
                        s
                    }
                    function da(i, s, u, h) {
                        return i = $i(7, i, h, s),
                        i.lanes = u,
                        i
                    }
                    function br(i, s, u) {
                        return i = $i(6, i, null, s),
                        i.lanes = u,
                        i
                    }
                    function Ys(i) {
                        var s = $i(18, null, null, 0);
                        return s.stateNode = i,
                        s
                    }
                    function su(i, s, u) {
                        return s = $i(4, i.children !== null ? i.children : [], i.key, s),
                        s.lanes = u,
                        s.stateNode = {
                            containerInfo: i.containerInfo,
                            pendingChildren: null,
                            implementation: i.implementation
                        },
                        s
                    }
                    var Cf = new WeakMap;
                    function ii(i, s) {
                        if (typeof i == "object" && i !== null) {
                            var u = Cf.get(i);
                            return u !== void 0 ? u : (s = {
                                value: i,
                                source: s,
                                stack: $e(s)
                            },
                            Cf.set(i, s),
                            s)
                        }
                        return {
                            value: i,
                            source: s,
                            stack: $e(s)
                        }
                    }
                    var Zo = []
                      , Cs = 0
                      , to = null
                      , Rs = 0
                      , Pa = []
                      , za = 0
                      , os = null
                      , Ds = 1
                      , Ba = "";
                    function js(i, s) {
                        Zo[Cs++] = Rs,
                        Zo[Cs++] = to,
                        to = i,
                        Rs = s
                    }
                    function Rf(i, s, u) {
                        Pa[za++] = Ds,
                        Pa[za++] = Ba,
                        Pa[za++] = os,
                        os = i;
                        var h = Ds;
                        i = Ba;
                        var S = 32 - et(h) - 1;
                        h &= ~(1 << S),
                        u += 1;
                        var b = 32 - et(s) + S;
                        if (30 < b) {
                            var D = S - S % 5;
                            b = (h & (1 << D) - 1).toString(32),
                            h >>= D,
                            S -= D,
                            Ds = 1 << 32 - et(s) + S | u << S | h,
                            Ba = b + i
                        } else
                            Ds = 1 << b | u << S | h,
                            Ba = i
                    }
                    function ru(i) {
                        i.return !== null && (js(i, 1),
                        Rf(i, 1, 0))
                    }
                    function ou(i) {
                        for (; i === to; )
                            to = Zo[--Cs],
                            Zo[Cs] = null,
                            Rs = Zo[--Cs],
                            Zo[Cs] = null;
                        for (; i === os; )
                            os = Pa[--za],
                            Pa[za] = null,
                            Ba = Pa[--za],
                            Pa[za] = null,
                            Ds = Pa[--za],
                            Pa[za] = null
                    }
                    function Ld(i, s) {
                        Pa[za++] = Ds,
                        Pa[za++] = Ba,
                        Pa[za++] = os,
                        Ds = s.id,
                        Ba = s.overflow,
                        os = i
                    }
                    var Ni = null
                      , on = null
                      , fn = !1
                      , di = null
                      , Fa = !1
                      , Df = Error(r(519));
                    function no(i) {
                        throw Fl(ii(Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", "")), i)),
                        Df
                    }
                    function Mr(i) {
                        var s = i.stateNode
                          , u = i.type
                          , h = i.memoizedProps;
                        switch (s[Zn] = i,
                        s[Ci] = h,
                        u) {
                        case "dialog":
                            ne("cancel", s),
                            ne("close", s);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            ne("load", s);
                            break;
                        case "video":
                        case "audio":
                            for (u = 0; u < Br.length; u++)
                                ne(Br[u], s);
                            break;
                        case "source":
                            ne("error", s);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            ne("error", s),
                            ne("load", s);
                            break;
                        case "details":
                            ne("toggle", s);
                            break;
                        case "input":
                            ne("invalid", s),
                            Ji(s, h.value, h.defaultValue, h.checked, h.defaultChecked, h.type, h.name, !0);
                            break;
                        case "select":
                            ne("invalid", s);
                            break;
                        case "textarea":
                            ne("invalid", s),
                            hi(s, h.value, h.defaultValue, h.children)
                        }
                        u = h.children,
                        typeof u != "string" && typeof u != "number" && typeof u != "bigint" || s.textContent === "" + u || h.suppressHydrationWarning === !0 || Mx(s.textContent, u) ? (h.popover != null && (ne("beforetoggle", s),
                        ne("toggle", s)),
                        h.onScroll != null && ne("scroll", s),
                        h.onScrollEnd != null && ne("scrollend", s),
                        h.onClick != null && (s.onclick = Gs),
                        s = !0) : s = !1,
                        s || no(i, !0)
                    }
                    function Ud(i) {
                        for (Ni = i.return; Ni; )
                            switch (Ni.tag) {
                            case 5:
                            case 31:
                            case 13:
                                Fa = !1;
                                return;
                            case 27:
                            case 3:
                                Fa = !0;
                                return;
                            default:
                                Ni = Ni.return
                            }
                    }
                    function io(i) {
                        if (i !== Ni)
                            return !1;
                        if (!fn)
                            return Ud(i),
                            fn = !0,
                            !1;
                        var s = i.tag, u;
                        if ((u = s !== 3 && s !== 27) && ((u = s === 5) && (u = i.type,
                        u = !(u !== "form" && u !== "button") || Vy(i.type, i.memoizedProps)),
                        u = !u),
                        u && on && no(i),
                        Ud(i),
                        s === 13) {
                            if (i = i.memoizedState,
                            i = i !== null ? i.dehydrated : null,
                            !i)
                                throw Error(r(317));
                            on = Lx(i)
                        } else if (s === 31) {
                            if (i = i.memoizedState,
                            i = i !== null ? i.dehydrated : null,
                            !i)
                                throw Error(r(317));
                            on = Lx(i)
                        } else
                            s === 27 ? (s = on,
                            uc(i.type) ? (i = Xy,
                            Xy = null,
                            on = i) : on = s) : on = Ni ? lr(i.stateNode.nextSibling) : null;
                        return !0
                    }
                    function ls() {
                        on = Ni = null,
                        fn = !1
                    }
                    function Nf() {
                        var i = di;
                        return i !== null && (Ui === null ? Ui = i : Ui.push.apply(Ui, i),
                        di = null),
                        i
                    }
                    function Fl(i) {
                        di === null ? di = [i] : di.push(i)
                    }
                    var Lf = j(null)
                      , ao = null
                      , cs = null;
                    function Zs(i, s, u) {
                        Re(Lf, s._currentValue),
                        s._currentValue = u
                    }
                    function Tr(i) {
                        i._currentValue = Lf.current,
                        ve(Lf)
                    }
                    function Id(i, s, u) {
                        for (; i !== null; ) {
                            var h = i.alternate;
                            if ((i.childLanes & s) !== s ? (i.childLanes |= s,
                            h !== null && (h.childLanes |= s)) : h !== null && (h.childLanes & s) !== s && (h.childLanes |= s),
                            i === u)
                                break;
                            i = i.return
                        }
                    }
                    function Od(i, s, u, h) {
                        var S = i.child;
                        for (S !== null && (S.return = i); S !== null; ) {
                            var b = S.dependencies;
                            if (b !== null) {
                                var D = S.child;
                                b = b.firstContext;
                                e: for (; b !== null; ) {
                                    var F = b;
                                    b = S;
                                    for (var ee = 0; ee < s.length; ee++)
                                        if (F.context === s[ee]) {
                                            b.lanes |= u,
                                            F = b.alternate,
                                            F !== null && (F.lanes |= u),
                                            Id(b.return, u, i),
                                            h || (D = null);
                                            break e
                                        }
                                    b = F.next
                                }
                            } else if (S.tag === 18) {
                                if (D = S.return,
                                D === null)
                                    throw Error(r(341));
                                D.lanes |= u,
                                b = D.alternate,
                                b !== null && (b.lanes |= u),
                                Id(D, u, i),
                                D = null
                            } else
                                D = S.child;
                            if (D !== null)
                                D.return = S;
                            else
                                for (D = S; D !== null; ) {
                                    if (D === i) {
                                        D = null;
                                        break
                                    }
                                    if (S = D.sibling,
                                    S !== null) {
                                        S.return = D.return,
                                        D = S;
                                        break
                                    }
                                    D = D.return
                                }
                            S = D
                        }
                    }
                    function Qo(i, s, u, h) {
                        i = null;
                        for (var S = s, b = !1; S !== null; ) {
                            if (!b) {
                                if ((S.flags & 524288) !== 0)
                                    b = !0;
                                else if ((S.flags & 262144) !== 0)
                                    break
                            }
                            if (S.tag === 10) {
                                var D = S.alternate;
                                if (D === null)
                                    throw Error(r(387));
                                if (D = D.memoizedProps,
                                D !== null) {
                                    var F = S.type;
                                    fa(S.pendingProps.value, D.value) || (i !== null ? i.push(F) : i = [F])
                                }
                            } else if (S === ke.current) {
                                if (D = S.alternate,
                                D === null)
                                    throw Error(r(387));
                                D.memoizedState.memoizedState !== S.memoizedState.memoizedState && (i !== null ? i.push(Mp) : i = [Mp])
                            }
                            S = S.return
                        }
                        i !== null && Od(s, i, u, h),
                        s.flags |= 262144
                    }
                    function lu(i) {
                        for (i = i.firstContext; i !== null; ) {
                            if (!fa(i.context._currentValue, i.memoizedValue))
                                return !0;
                            i = i.next
                        }
                        return !1
                    }
                    function us(i) {
                        ao = i,
                        cs = null,
                        i = i.dependencies,
                        i !== null && (i.firstContext = null)
                    }
                    function xi(i) {
                        return Pd(ao, i)
                    }
                    function cu(i, s) {
                        return ao === null && us(i),
                        Pd(i, s)
                    }
                    function Pd(i, s) {
                        var u = s._currentValue;
                        if (s = {
                            context: s,
                            memoizedValue: u,
                            next: null
                        },
                        cs === null) {
                            if (i === null)
                                throw Error(r(308));
                            cs = s,
                            i.dependencies = {
                                lanes: 0,
                                firstContext: s
                            },
                            i.flags |= 524288
                        } else
                            cs = cs.next = s;
                        return u
                    }
                    var Wm = typeof AbortController < "u" ? AbortController : function() {
                        var i = []
                          , s = this.signal = {
                            aborted: !1,
                            addEventListener: function(u, h) {
                                i.push(h)
                            }
                        };
                        this.abort = function() {
                            s.aborted = !0,
                            i.forEach(function(u) {
                                return u()
                            })
                        }
                    }
                      , Xm = t.unstable_scheduleCallback
                      , qm = t.unstable_NormalPriority
                      , pi = {
                        $$typeof: L,
                        Consumer: null,
                        Provider: null,
                        _currentValue: null,
                        _currentValue2: null,
                        _threadCount: 0
                    };
                    function Ko() {
                        return {
                            controller: new Wm,
                            data: new Map,
                            refCount: 0
                        }
                    }
                    function Vl(i) {
                        i.refCount--,
                        i.refCount === 0 && Xm(qm, function() {
                            i.controller.abort()
                        })
                    }
                    var kl = null
                      , gn = 0
                      , so = 0
                      , Hl = null;
                    function Ym(i, s) {
                        if (kl === null) {
                            var u = kl = [];
                            gn = 0,
                            so = Oe(),
                            Hl = {
                                status: "pending",
                                value: void 0,
                                then: function(h) {
                                    u.push(h)
                                }
                            }
                        }
                        return gn++,
                        s.then(jm, jm),
                        s
                    }
                    function jm() {
                        if (--gn === 0 && kl !== null) {
                            Hl !== null && (Hl.status = "fulfilled");
                            var i = kl;
                            kl = null,
                            so = 0,
                            Hl = null;
                            for (var s = 0; s < i.length; s++)
                                (0,
                                i[s])()
                        }
                    }
                    function Ty(i, s) {
                        var u = []
                          , h = {
                            status: "pending",
                            value: null,
                            reason: null,
                            then: function(S) {
                                u.push(S)
                            }
                        };
                        return i.then(function() {
                            h.status = "fulfilled",
                            h.value = s;
                            for (var S = 0; S < u.length; S++)
                                (0,
                                u[S])(s)
                        }, function(S) {
                            for (h.status = "rejected",
                            h.reason = S,
                            S = 0; S < u.length; S++)
                                (0,
                                u[S])(void 0)
                        }),
                        h
                    }
                    var Zm = Q.S;
                    Q.S = function(i, s) {
                        vp = oe(),
                        typeof s == "object" && s !== null && typeof s.then == "function" && Ym(i, s),
                        Zm !== null && Zm(i, s)
                    }
                    ;
                    var Jo = j(null);
                    function uu() {
                        var i = Jo.current;
                        return i !== null ? i : yn.pooledCache
                    }
                    function fs(i, s) {
                        s === null ? Re(Jo, Jo.current) : Re(Jo, s.pool)
                    }
                    function zd() {
                        var i = uu();
                        return i === null ? null : {
                            parent: pi._currentValue,
                            pool: i
                        }
                    }
                    var Er = Error(r(460))
                      , Ar = Error(r(474))
                      , Gl = Error(r(542))
                      , fu = {
                        then: function() {}
                    };
                    function Uf(i) {
                        return i = i.status,
                        i === "fulfilled" || i === "rejected"
                    }
                    function Qm(i, s, u) {
                        switch (u = i[u],
                        u === void 0 ? i.push(s) : u !== s && (s.then(Gs, Gs),
                        s = u),
                        s.status) {
                        case "fulfilled":
                            return s.value;
                        case "rejected":
                            throw i = s.reason,
                            Fd(i),
                            i;
                        default:
                            if (typeof s.status == "string")
                                s.then(Gs, Gs);
                            else {
                                if (i = yn,
                                i !== null && 100 < i.shellSuspendCounter)
                                    throw Error(r(482));
                                i = s,
                                i.status = "pending",
                                i.then(function(h) {
                                    if (s.status === "pending") {
                                        var S = s;
                                        S.status = "fulfilled",
                                        S.value = h
                                    }
                                }, function(h) {
                                    if (s.status === "pending") {
                                        var S = s;
                                        S.status = "rejected",
                                        S.reason = h
                                    }
                                })
                            }
                            switch (s.status) {
                            case "fulfilled":
                                return s.value;
                            case "rejected":
                                throw i = s.reason,
                                Fd(i),
                                i
                            }
                            throw oo = s,
                            Er
                        }
                    }
                    function ro(i) {
                        try {
                            var s = i._init;
                            return s(i._payload)
                        } catch (u) {
                            throw u !== null && typeof u == "object" && typeof u.then == "function" ? (oo = u,
                            Er) : u
                        }
                    }
                    var oo = null;
                    function Bd() {
                        if (oo === null)
                            throw Error(r(459));
                        var i = oo;
                        return oo = null,
                        i
                    }
                    function Fd(i) {
                        if (i === Er || i === Gl)
                            throw Error(r(483))
                    }
                    var $o = null
                      , el = 0;
                    function jt(i) {
                        var s = el;
                        return el += 1,
                        $o === null && ($o = []),
                        Qm($o, i, s)
                    }
                    function hu(i, s) {
                        s = s.props.ref,
                        i.ref = s !== void 0 ? s : null
                    }
                    function ta(i, s) {
                        throw s.$$typeof === M ? Error(r(525)) : (i = Object.prototype.toString.call(s),
                        Error(r(31, i === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : i)))
                    }
                    function If(i) {
                        function s(ue, ie) {
                            if (i) {
                                var de = ue.deletions;
                                de === null ? (ue.deletions = [ie],
                                ue.flags |= 16) : de.push(ie)
                            }
                        }
                        function u(ue, ie) {
                            if (!i)
                                return null;
                            for (; ie !== null; )
                                s(ue, ie),
                                ie = ie.sibling;
                            return null
                        }
                        function h(ue) {
                            for (var ie = new Map; ue !== null; )
                                ue.key !== null ? ie.set(ue.key, ue) : ie.set(ue.index, ue),
                                ue = ue.sibling;
                            return ie
                        }
                        function S(ue, ie) {
                            return ue = qs(ue, ie),
                            ue.index = 0,
                            ue.sibling = null,
                            ue
                        }
                        function b(ue, ie, de) {
                            return ue.index = de,
                            i ? (de = ue.alternate,
                            de !== null ? (de = de.index,
                            de < ie ? (ue.flags |= 67108866,
                            ie) : de) : (ue.flags |= 67108866,
                            ie)) : (ue.flags |= 1048576,
                            ie)
                        }
                        function D(ue) {
                            return i && ue.alternate === null && (ue.flags |= 67108866),
                            ue
                        }
                        function F(ue, ie, de, Le) {
                            return ie === null || ie.tag !== 6 ? (ie = br(de, ue.mode, Le),
                            ie.return = ue,
                            ie) : (ie = S(ie, de),
                            ie.return = ue,
                            ie)
                        }
                        function ee(ue, ie, de, Le) {
                            var Nt = de.type;
                            return Nt === A ? De(ue, ie, de.props.children, Le, de.key) : ie !== null && (ie.elementType === Nt || typeof Nt == "object" && Nt !== null && Nt.$$typeof === P && ro(Nt) === ie.type) ? (ie = S(ie, de.props),
                            hu(ie, de),
                            ie.return = ue,
                            ie) : (ie = au(de.type, de.key, de.props, null, ue.mode, Le),
                            hu(ie, de),
                            ie.return = ue,
                            ie)
                        }
                        function pe(ue, ie, de, Le) {
                            return ie === null || ie.tag !== 4 || ie.stateNode.containerInfo !== de.containerInfo || ie.stateNode.implementation !== de.implementation ? (ie = su(de, ue.mode, Le),
                            ie.return = ue,
                            ie) : (ie = S(ie, de.children || []),
                            ie.return = ue,
                            ie)
                        }
                        function De(ue, ie, de, Le, Nt) {
                            return ie === null || ie.tag !== 7 ? (ie = da(de, ue.mode, Le, Nt),
                            ie.return = ue,
                            ie) : (ie = S(ie, de),
                            ie.return = ue,
                            ie)
                        }
                        function Ie(ue, ie, de) {
                            if (typeof ie == "string" && ie !== "" || typeof ie == "number" || typeof ie == "bigint")
                                return ie = br("" + ie, ue.mode, de),
                                ie.return = ue,
                                ie;
                            if (typeof ie == "object" && ie !== null) {
                                switch (ie.$$typeof) {
                                case C:
                                    return de = au(ie.type, ie.key, ie.props, null, ue.mode, de),
                                    hu(de, ie),
                                    de.return = ue,
                                    de;
                                case R:
                                    return ie = su(ie, ue.mode, de),
                                    ie.return = ue,
                                    ie;
                                case P:
                                    return ie = ro(ie),
                                    Ie(ue, ie, de)
                                }
                                if (J(ie) || q(ie))
                                    return ie = da(ie, ue.mode, de, null),
                                    ie.return = ue,
                                    ie;
                                if (typeof ie.then == "function")
                                    return Ie(ue, jt(ie), de);
                                if (ie.$$typeof === L)
                                    return Ie(ue, cu(ue, ie), de);
                                ta(ue, ie)
                            }
                            return null
                        }
                        function ge(ue, ie, de, Le) {
                            var Nt = ie !== null ? ie.key : null;
                            if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
                                return Nt !== null ? null : F(ue, ie, "" + de, Le);
                            if (typeof de == "object" && de !== null) {
                                switch (de.$$typeof) {
                                case C:
                                    return de.key === Nt ? ee(ue, ie, de, Le) : null;
                                case R:
                                    return de.key === Nt ? pe(ue, ie, de, Le) : null;
                                case P:
                                    return de = ro(de),
                                    ge(ue, ie, de, Le)
                                }
                                if (J(de) || q(de))
                                    return Nt !== null ? null : De(ue, ie, de, Le, null);
                                if (typeof de.then == "function")
                                    return ge(ue, ie, jt(de), Le);
                                if (de.$$typeof === L)
                                    return ge(ue, ie, cu(ue, de), Le);
                                ta(ue, de)
                            }
                            return null
                        }
                        function Se(ue, ie, de, Le, Nt) {
                            if (typeof Le == "string" && Le !== "" || typeof Le == "number" || typeof Le == "bigint")
                                return ue = ue.get(de) || null,
                                F(ie, ue, "" + Le, Nt);
                            if (typeof Le == "object" && Le !== null) {
                                switch (Le.$$typeof) {
                                case C:
                                    return ue = ue.get(Le.key === null ? de : Le.key) || null,
                                    ee(ie, ue, Le, Nt);
                                case R:
                                    return ue = ue.get(Le.key === null ? de : Le.key) || null,
                                    pe(ie, ue, Le, Nt);
                                case P:
                                    return Le = ro(Le),
                                    Se(ue, ie, de, Le, Nt)
                                }
                                if (J(Le) || q(Le))
                                    return ue = ue.get(de) || null,
                                    De(ie, ue, Le, Nt, null);
                                if (typeof Le.then == "function")
                                    return Se(ue, ie, de, jt(Le), Nt);
                                if (Le.$$typeof === L)
                                    return Se(ue, ie, de, cu(ie, Le), Nt);
                                ta(ie, Le)
                            }
                            return null
                        }
                        function yt(ue, ie, de, Le) {
                            for (var Nt = null, Dn = null, bt = ie, $t = ie = 0, _n = null; bt !== null && $t < de.length; $t++) {
                                bt.index > $t ? (_n = bt,
                                bt = null) : _n = bt.sibling;
                                var Nn = ge(ue, bt, de[$t], Le);
                                if (Nn === null) {
                                    bt === null && (bt = _n);
                                    break
                                }
                                i && bt && Nn.alternate === null && s(ue, bt),
                                ie = b(Nn, ie, $t),
                                Dn === null ? Nt = Nn : Dn.sibling = Nn,
                                Dn = Nn,
                                bt = _n
                            }
                            if ($t === de.length)
                                return u(ue, bt),
                                fn && js(ue, $t),
                                Nt;
                            if (bt === null) {
                                for (; $t < de.length; $t++)
                                    bt = Ie(ue, de[$t], Le),
                                    bt !== null && (ie = b(bt, ie, $t),
                                    Dn === null ? Nt = bt : Dn.sibling = bt,
                                    Dn = bt);
                                return fn && js(ue, $t),
                                Nt
                            }
                            for (bt = h(bt); $t < de.length; $t++)
                                _n = Se(bt, ue, $t, de[$t], Le),
                                _n !== null && (i && _n.alternate !== null && bt.delete(_n.key === null ? $t : _n.key),
                                ie = b(_n, ie, $t),
                                Dn === null ? Nt = _n : Dn.sibling = _n,
                                Dn = _n);
                            return i && bt.forEach(function(mc) {
                                return s(ue, mc)
                            }),
                            fn && js(ue, $t),
                            Nt
                        }
                        function zt(ue, ie, de, Le) {
                            if (de == null)
                                throw Error(r(151));
                            for (var Nt = null, Dn = null, bt = ie, $t = ie = 0, _n = null, Nn = de.next(); bt !== null && !Nn.done; $t++,
                            Nn = de.next()) {
                                bt.index > $t ? (_n = bt,
                                bt = null) : _n = bt.sibling;
                                var mc = ge(ue, bt, Nn.value, Le);
                                if (mc === null) {
                                    bt === null && (bt = _n);
                                    break
                                }
                                i && bt && mc.alternate === null && s(ue, bt),
                                ie = b(mc, ie, $t),
                                Dn === null ? Nt = mc : Dn.sibling = mc,
                                Dn = mc,
                                bt = _n
                            }
                            if (Nn.done)
                                return u(ue, bt),
                                fn && js(ue, $t),
                                Nt;
                            if (bt === null) {
                                for (; !Nn.done; $t++,
                                Nn = de.next())
                                    Nn = Ie(ue, Nn.value, Le),
                                    Nn !== null && (ie = b(Nn, ie, $t),
                                    Dn === null ? Nt = Nn : Dn.sibling = Nn,
                                    Dn = Nn);
                                return fn && js(ue, $t),
                                Nt
                            }
                            for (bt = h(bt); !Nn.done; $t++,
                            Nn = de.next())
                                Nn = Se(bt, ue, $t, Nn.value, Le),
                                Nn !== null && (i && Nn.alternate !== null && bt.delete(Nn.key === null ? $t : Nn.key),
                                ie = b(Nn, ie, $t),
                                Dn === null ? Nt = Nn : Dn.sibling = Nn,
                                Dn = Nn);
                            return i && bt.forEach(function(z2) {
                                return s(ue, z2)
                            }),
                            fn && js(ue, $t),
                            Nt
                        }
                        function Gn(ue, ie, de, Le) {
                            if (typeof de == "object" && de !== null && de.type === A && de.key === null && (de = de.props.children),
                            typeof de == "object" && de !== null) {
                                switch (de.$$typeof) {
                                case C:
                                    e: {
                                        for (var Nt = de.key; ie !== null; ) {
                                            if (ie.key === Nt) {
                                                if (Nt = de.type,
                                                Nt === A) {
                                                    if (ie.tag === 7) {
                                                        u(ue, ie.sibling),
                                                        Le = S(ie, de.props.children),
                                                        Le.return = ue,
                                                        ue = Le;
                                                        break e
                                                    }
                                                } else if (ie.elementType === Nt || typeof Nt == "object" && Nt !== null && Nt.$$typeof === P && ro(Nt) === ie.type) {
                                                    u(ue, ie.sibling),
                                                    Le = S(ie, de.props),
                                                    hu(Le, de),
                                                    Le.return = ue,
                                                    ue = Le;
                                                    break e
                                                }
                                                u(ue, ie);
                                                break
                                            } else
                                                s(ue, ie);
                                            ie = ie.sibling
                                        }
                                        de.type === A ? (Le = da(de.props.children, ue.mode, Le, de.key),
                                        Le.return = ue,
                                        ue = Le) : (Le = au(de.type, de.key, de.props, null, ue.mode, Le),
                                        hu(Le, de),
                                        Le.return = ue,
                                        ue = Le)
                                    }
                                    return D(ue);
                                case R:
                                    e: {
                                        for (Nt = de.key; ie !== null; ) {
                                            if (ie.key === Nt)
                                                if (ie.tag === 4 && ie.stateNode.containerInfo === de.containerInfo && ie.stateNode.implementation === de.implementation) {
                                                    u(ue, ie.sibling),
                                                    Le = S(ie, de.children || []),
                                                    Le.return = ue,
                                                    ue = Le;
                                                    break e
                                                } else {
                                                    u(ue, ie);
                                                    break
                                                }
                                            else
                                                s(ue, ie);
                                            ie = ie.sibling
                                        }
                                        Le = su(de, ue.mode, Le),
                                        Le.return = ue,
                                        ue = Le
                                    }
                                    return D(ue);
                                case P:
                                    return de = ro(de),
                                    Gn(ue, ie, de, Le)
                                }
                                if (J(de))
                                    return yt(ue, ie, de, Le);
                                if (q(de)) {
                                    if (Nt = q(de),
                                    typeof Nt != "function")
                                        throw Error(r(150));
                                    return de = Nt.call(de),
                                    zt(ue, ie, de, Le)
                                }
                                if (typeof de.then == "function")
                                    return Gn(ue, ie, jt(de), Le);
                                if (de.$$typeof === L)
                                    return Gn(ue, ie, cu(ue, de), Le);
                                ta(ue, de)
                            }
                            return typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint" ? (de = "" + de,
                            ie !== null && ie.tag === 6 ? (u(ue, ie.sibling),
                            Le = S(ie, de),
                            Le.return = ue,
                            ue = Le) : (u(ue, ie),
                            Le = br(de, ue.mode, Le),
                            Le.return = ue,
                            ue = Le),
                            D(ue)) : u(ue, ie)
                        }
                        return function(ue, ie, de, Le) {
                            try {
                                el = 0;
                                var Nt = Gn(ue, ie, de, Le);
                                return $o = null,
                                Nt
                            } catch (bt) {
                                if (bt === Er || bt === Gl)
                                    throw bt;
                                var Dn = $i(29, bt, null, ue.mode);
                                return Dn.lanes = Le,
                                Dn.return = ue,
                                Dn
                            }
                        }
                    }
                    var tl = If(!0)
                      , du = If(!1)
                      , Va = !1;
                    function lo(i) {
                        i.updateQueue = {
                            baseState: i.memoizedState,
                            firstBaseUpdate: null,
                            lastBaseUpdate: null,
                            shared: {
                                pending: null,
                                lanes: 0,
                                hiddenCallbacks: null
                            },
                            callbacks: null
                        }
                    }
                    function Of(i, s) {
                        i = i.updateQueue,
                        s.updateQueue === i && (s.updateQueue = {
                            baseState: i.baseState,
                            firstBaseUpdate: i.firstBaseUpdate,
                            lastBaseUpdate: i.lastBaseUpdate,
                            shared: i.shared,
                            callbacks: null
                        })
                    }
                    function wr(i) {
                        return {
                            lane: i,
                            tag: 0,
                            payload: null,
                            callback: null,
                            next: null
                        }
                    }
                    function co(i, s, u) {
                        var h = i.updateQueue;
                        if (h === null)
                            return null;
                        if (h = h.shared,
                        (Mn & 2) !== 0) {
                            var S = h.pending;
                            return S === null ? s.next = s : (s.next = S.next,
                            S.next = s),
                            h.pending = s,
                            s = iu(i),
                            wf(i, null, u),
                            s
                        }
                        return nu(i, h, s, u),
                        iu(i)
                    }
                    function hs(i, s, u) {
                        if (s = s.updateQueue,
                        s !== null && (s = s.shared,
                        (u & 4194048) !== 0)) {
                            var h = s.lanes;
                            h &= i.pendingLanes,
                            u |= h,
                            s.lanes = u,
                            zc(i, u)
                        }
                    }
                    function pu(i, s) {
                        var u = i.updateQueue
                          , h = i.alternate;
                        if (h !== null && (h = h.updateQueue,
                        u === h)) {
                            var S = null
                              , b = null;
                            if (u = u.firstBaseUpdate,
                            u !== null) {
                                do {
                                    var D = {
                                        lane: u.lane,
                                        tag: u.tag,
                                        payload: u.payload,
                                        callback: null,
                                        next: null
                                    };
                                    b === null ? S = b = D : b = b.next = D,
                                    u = u.next
                                } while (u !== null);
                                b === null ? S = b = s : b = b.next = s
                            } else
                                S = b = s;
                            u = {
                                baseState: h.baseState,
                                firstBaseUpdate: S,
                                lastBaseUpdate: b,
                                shared: h.shared,
                                callbacks: h.callbacks
                            },
                            i.updateQueue = u;
                            return
                        }
                        i = u.lastBaseUpdate,
                        i === null ? u.firstBaseUpdate = s : i.next = s,
                        u.lastBaseUpdate = s
                    }
                    var mu = !1;
                    function nl() {
                        if (mu) {
                            var i = Hl;
                            if (i !== null)
                                throw i
                        }
                    }
                    function il(i, s, u, h) {
                        mu = !1;
                        var S = i.updateQueue;
                        Va = !1;
                        var b = S.firstBaseUpdate
                          , D = S.lastBaseUpdate
                          , F = S.shared.pending;
                        if (F !== null) {
                            S.shared.pending = null;
                            var ee = F
                              , pe = ee.next;
                            ee.next = null,
                            D === null ? b = pe : D.next = pe,
                            D = ee;
                            var De = i.alternate;
                            De !== null && (De = De.updateQueue,
                            F = De.lastBaseUpdate,
                            F !== D && (F === null ? De.firstBaseUpdate = pe : F.next = pe,
                            De.lastBaseUpdate = ee))
                        }
                        if (b !== null) {
                            var Ie = S.baseState;
                            D = 0,
                            De = pe = ee = null,
                            F = b;
                            do {
                                var ge = F.lane & -536870913
                                  , Se = ge !== F.lane;
                                if (Se ? (Yt & ge) === ge : (h & ge) === ge) {
                                    ge !== 0 && ge === so && (mu = !0),
                                    De !== null && (De = De.next = {
                                        lane: 0,
                                        tag: F.tag,
                                        payload: F.payload,
                                        callback: null,
                                        next: null
                                    });
                                    e: {
                                        var yt = i
                                          , zt = F;
                                        ge = s;
                                        var Gn = u;
                                        switch (zt.tag) {
                                        case 1:
                                            if (yt = zt.payload,
                                            typeof yt == "function") {
                                                Ie = yt.call(Gn, Ie, ge);
                                                break e
                                            }
                                            Ie = yt;
                                            break e;
                                        case 3:
                                            yt.flags = yt.flags & -65537 | 128;
                                        case 0:
                                            if (yt = zt.payload,
                                            ge = typeof yt == "function" ? yt.call(Gn, Ie, ge) : yt,
                                            ge == null)
                                                break e;
                                            Ie = x({}, Ie, ge);
                                            break e;
                                        case 2:
                                            Va = !0
                                        }
                                    }
                                    ge = F.callback,
                                    ge !== null && (i.flags |= 64,
                                    Se && (i.flags |= 8192),
                                    Se = S.callbacks,
                                    Se === null ? S.callbacks = [ge] : Se.push(ge))
                                } else
                                    Se = {
                                        lane: ge,
                                        tag: F.tag,
                                        payload: F.payload,
                                        callback: F.callback,
                                        next: null
                                    },
                                    De === null ? (pe = De = Se,
                                    ee = Ie) : De = De.next = Se,
                                    D |= ge;
                                if (F = F.next,
                                F === null) {
                                    if (F = S.shared.pending,
                                    F === null)
                                        break;
                                    Se = F,
                                    F = Se.next,
                                    Se.next = null,
                                    S.lastBaseUpdate = Se,
                                    S.shared.pending = null
                                }
                            } while (!0);
                            De === null && (ee = Ie),
                            S.baseState = ee,
                            S.firstBaseUpdate = pe,
                            S.lastBaseUpdate = De,
                            b === null && (S.shared.lanes = 0),
                            Pn |= D,
                            i.lanes = D,
                            i.memoizedState = Ie
                        }
                    }
                    function Cr(i, s) {
                        if (typeof i != "function")
                            throw Error(r(191, i));
                        i.call(s)
                    }
                    function Pf(i, s) {
                        var u = i.callbacks;
                        if (u !== null)
                            for (i.callbacks = null,
                            i = 0; i < u.length; i++)
                                Cr(u[i], s)
                    }
                    var Wl = j(null)
                      , gu = j(0);
                    function Km(i, s) {
                        i = Ut,
                        Re(gu, i),
                        Re(Wl, s),
                        Ut = i | s.baseLanes
                    }
                    function Xl() {
                        Re(gu, Ut),
                        Re(Wl, Wl.current)
                    }
                    function Dt() {
                        Ut = gu.current,
                        ve(Wl),
                        ve(gu)
                    }
                    var ka = j(null)
                      , ds = null;
                    function Rr(i) {
                        var s = i.alternate;
                        Re(mi, mi.current & 1),
                        Re(ka, i),
                        ds === null && (s === null || Wl.current !== null || s.memoizedState !== null) && (ds = i)
                    }
                    function al(i) {
                        Re(mi, mi.current),
                        Re(ka, i),
                        ds === null && (ds = i)
                    }
                    function Jm(i) {
                        i.tag === 22 ? (Re(mi, mi.current),
                        Re(ka, i),
                        ds === null && (ds = i)) : uo(i)
                    }
                    function uo() {
                        Re(mi, mi.current),
                        Re(ka, ka.current)
                    }
                    function Ha(i) {
                        ve(ka),
                        ds === i && (ds = null),
                        ve(mi)
                    }
                    var mi = j(0);
                    function zf(i) {
                        for (var s = i; s !== null; ) {
                            if (s.tag === 13) {
                                var u = s.memoizedState;
                                if (u !== null && (u = u.dehydrated,
                                u === null || Gy(u) || Wy(u)))
                                    return s
                            } else if (s.tag === 19 && (s.memoizedProps.revealOrder === "forwards" || s.memoizedProps.revealOrder === "backwards" || s.memoizedProps.revealOrder === "unstable_legacy-backwards" || s.memoizedProps.revealOrder === "together")) {
                                if ((s.flags & 128) !== 0)
                                    return s
                            } else if (s.child !== null) {
                                s.child.return = s,
                                s = s.child;
                                continue
                            }
                            if (s === i)
                                break;
                            for (; s.sibling === null; ) {
                                if (s.return === null || s.return === i)
                                    return null;
                                s = s.return
                            }
                            s.sibling.return = s.return,
                            s = s.sibling
                        }
                        return null
                    }
                    var Ns = 0
                      , Gt = null
                      , wn = null
                      , gi = null
                      , Bf = !1
                      , ql = !1
                      , Ga = !1
                      , ps = 0
                      , bi = 0
                      , pa = null
                      , na = 0;
                    function ai() {
                        throw Error(r(321))
                    }
                    function Vd(i, s) {
                        if (s === null)
                            return !1;
                        for (var u = 0; u < s.length && u < i.length; u++)
                            if (!fa(i[u], s[u]))
                                return !1;
                        return !0
                    }
                    function Mi(i, s, u, h, S, b) {
                        return Ns = b,
                        Gt = s,
                        s.memoizedState = null,
                        s.updateQueue = null,
                        s.lanes = 0,
                        Q.H = i === null || i.memoizedState === null ? Tg : sp,
                        Ga = !1,
                        b = u(h, S),
                        Ga = !1,
                        ql && (b = $m(s, u, h, S)),
                        Qs(i),
                        b
                    }
                    function Qs(i) {
                        Q.H = yu;
                        var s = wn !== null && wn.next !== null;
                        if (Ns = 0,
                        gi = wn = Gt = null,
                        Bf = !1,
                        bi = 0,
                        pa = null,
                        s)
                            throw Error(r(300));
                        i === null || Ti || (i = i.dependencies,
                        i !== null && lu(i) && (Ti = !0))
                    }
                    function $m(i, s, u, h) {
                        Gt = i;
                        var S = 0;
                        do {
                            if (ql && (pa = null),
                            bi = 0,
                            ql = !1,
                            25 <= S)
                                throw Error(r(301));
                            if (S += 1,
                            gi = wn = null,
                            i.updateQueue != null) {
                                var b = i.updateQueue;
                                b.lastEffect = null,
                                b.events = null,
                                b.stores = null,
                                b.memoCache != null && (b.memoCache.index = 0)
                            }
                            Q.H = Eg,
                            b = s(u, h)
                        } while (ql);
                        return b
                    }
                    function Ey() {
                        var i = Q.H
                          , s = i.useState()[0];
                        return s = typeof s.then == "function" ? Yl(s) : s,
                        i = i.useState()[0],
                        (wn !== null ? wn.memoizedState : null) !== i && (Gt.flags |= 1024),
                        s
                    }
                    function kd() {
                        var i = ps !== 0;
                        return ps = 0,
                        i
                    }
                    function Hd(i, s, u) {
                        s.updateQueue = i.updateQueue,
                        s.flags &= -2053,
                        i.lanes &= ~u
                    }
                    function Gd(i) {
                        if (Bf) {
                            for (i = i.memoizedState; i !== null; ) {
                                var s = i.queue;
                                s !== null && (s.pending = null),
                                i = i.next
                            }
                            Bf = !1
                        }
                        Ns = 0,
                        gi = wn = Gt = null,
                        ql = !1,
                        bi = ps = 0,
                        pa = null
                    }
                    function ji() {
                        var i = {
                            memoizedState: null,
                            baseState: null,
                            baseQueue: null,
                            queue: null,
                            next: null
                        };
                        return gi === null ? Gt.memoizedState = gi = i : gi = gi.next = i,
                        gi
                    }
                    function si() {
                        if (wn === null) {
                            var i = Gt.alternate;
                            i = i !== null ? i.memoizedState : null
                        } else
                            i = wn.next;
                        var s = gi === null ? Gt.memoizedState : gi.next;
                        if (s !== null)
                            gi = s,
                            wn = i;
                        else {
                            if (i === null)
                                throw Gt.alternate === null ? Error(r(467)) : Error(r(310));
                            wn = i,
                            i = {
                                memoizedState: wn.memoizedState,
                                baseState: wn.baseState,
                                baseQueue: wn.baseQueue,
                                queue: wn.queue,
                                next: null
                            },
                            gi === null ? Gt.memoizedState = gi = i : gi = gi.next = i
                        }
                        return gi
                    }
                    function Ff() {
                        return {
                            lastEffect: null,
                            events: null,
                            stores: null,
                            memoCache: null
                        }
                    }
                    function Yl(i) {
                        var s = bi;
                        return bi += 1,
                        pa === null && (pa = []),
                        i = Qm(pa, i, s),
                        s = Gt,
                        (gi === null ? s.memoizedState : gi.next) === null && (s = s.alternate,
                        Q.H = s === null || s.memoizedState === null ? Tg : sp),
                        i
                    }
                    function Vf(i) {
                        if (i !== null && typeof i == "object") {
                            if (typeof i.then == "function")
                                return Yl(i);
                            if (i.$$typeof === L)
                                return xi(i)
                        }
                        throw Error(r(438, String(i)))
                    }
                    function fo(i) {
                        var s = null
                          , u = Gt.updateQueue;
                        if (u !== null && (s = u.memoCache),
                        s == null) {
                            var h = Gt.alternate;
                            h !== null && (h = h.updateQueue,
                            h !== null && (h = h.memoCache,
                            h != null && (s = {
                                data: h.data.map(function(S) {
                                    return S.slice()
                                }),
                                index: 0
                            })))
                        }
                        if (s ??= {
                            data: [],
                            index: 0
                        },
                        u === null && (u = Ff(),
                        Gt.updateQueue = u),
                        u.memoCache = s,
                        u = s.data[s.index],
                        u === void 0)
                            for (u = s.data[s.index] = Array(i),
                            h = 0; h < i; h++)
                                u[h] = W;
                        return s.index++,
                        u
                    }
                    function ma(i, s) {
                        return typeof s == "function" ? s(i) : s
                    }
                    function kf(i) {
                        return Wd(si(), wn, i)
                    }
                    function Wd(i, s, u) {
                        var h = i.queue;
                        if (h === null)
                            throw Error(r(311));
                        h.lastRenderedReducer = u;
                        var S = i.baseQueue
                          , b = h.pending;
                        if (b !== null) {
                            if (S !== null) {
                                var D = S.next;
                                S.next = b.next,
                                b.next = D
                            }
                            s.baseQueue = S = b,
                            h.pending = null
                        }
                        if (b = i.baseState,
                        S === null)
                            i.memoizedState = b;
                        else {
                            s = S.next;
                            var F = D = null
                              , ee = null
                              , pe = s
                              , De = !1;
                            do {
                                var Ie = pe.lane & -536870913;
                                if (Ie !== pe.lane ? (Yt & Ie) === Ie : (Ns & Ie) === Ie) {
                                    var ge = pe.revertLane;
                                    if (ge === 0)
                                        ee !== null && (ee = ee.next = {
                                            lane: 0,
                                            revertLane: 0,
                                            gesture: null,
                                            action: pe.action,
                                            hasEagerState: pe.hasEagerState,
                                            eagerState: pe.eagerState,
                                            next: null
                                        }),
                                        Ie === so && (De = !0);
                                    else if ((Ns & ge) === ge) {
                                        pe = pe.next,
                                        ge === so && (De = !0);
                                        continue
                                    } else
                                        Ie = {
                                            lane: 0,
                                            revertLane: pe.revertLane,
                                            gesture: null,
                                            action: pe.action,
                                            hasEagerState: pe.hasEagerState,
                                            eagerState: pe.eagerState,
                                            next: null
                                        },
                                        ee === null ? (F = ee = Ie,
                                        D = b) : ee = ee.next = Ie,
                                        Gt.lanes |= ge,
                                        Pn |= ge;
                                    Ie = pe.action,
                                    Ga && u(b, Ie),
                                    b = pe.hasEagerState ? pe.eagerState : u(b, Ie)
                                } else
                                    ge = {
                                        lane: Ie,
                                        revertLane: pe.revertLane,
                                        gesture: pe.gesture,
                                        action: pe.action,
                                        hasEagerState: pe.hasEagerState,
                                        eagerState: pe.eagerState,
                                        next: null
                                    },
                                    ee === null ? (F = ee = ge,
                                    D = b) : ee = ee.next = ge,
                                    Gt.lanes |= Ie,
                                    Pn |= Ie;
                                pe = pe.next
                            } while (pe !== null && pe !== s);
                            if (ee === null ? D = b : ee.next = F,
                            !fa(b, i.memoizedState) && (Ti = !0,
                            De && (u = Hl,
                            u !== null)))
                                throw u;
                            i.memoizedState = b,
                            i.baseState = D,
                            i.baseQueue = ee,
                            h.lastRenderedState = b
                        }
                        return S === null && (h.lanes = 0),
                        [i.memoizedState, h.dispatch]
                    }
                    function Xd(i) {
                        var s = si()
                          , u = s.queue;
                        if (u === null)
                            throw Error(r(311));
                        u.lastRenderedReducer = i;
                        var h = u.dispatch
                          , S = u.pending
                          , b = s.memoizedState;
                        if (S !== null) {
                            u.pending = null;
                            var D = S = S.next;
                            do
                                b = i(b, D.action),
                                D = D.next;
                            while (D !== S);
                            fa(b, s.memoizedState) || (Ti = !0),
                            s.memoizedState = b,
                            s.baseQueue === null && (s.baseState = b),
                            u.lastRenderedState = b
                        }
                        return [b, h]
                    }
                    function jl(i, s, u) {
                        var h = Gt
                          , S = si()
                          , b = fn;
                        if (b) {
                            if (u === void 0)
                                throw Error(r(407));
                            u = u()
                        } else
                            u = s();
                        var D = !fa((wn || S).memoizedState, u);
                        if (D && (S.memoizedState = u,
                        Ti = !0),
                        S = S.queue,
                        Wf(ng.bind(null, h, S, i), [i]),
                        S.getSnapshot !== s || D || gi !== null && gi.memoizedState.tag & 1) {
                            if (h.flags |= 2048,
                            Ql(9, {
                                destroy: void 0
                            }, tg.bind(null, h, S, u, s), null),
                            yn === null)
                                throw Error(r(349));
                            b || (Ns & 127) !== 0 || eg(h, s, u)
                        }
                        return u
                    }
                    function eg(i, s, u) {
                        i.flags |= 16384,
                        i = {
                            getSnapshot: s,
                            value: u
                        },
                        s = Gt.updateQueue,
                        s === null ? (s = Ff(),
                        Gt.updateQueue = s,
                        s.stores = [i]) : (u = s.stores,
                        u === null ? s.stores = [i] : u.push(i))
                    }
                    function tg(i, s, u, h) {
                        s.value = u,
                        s.getSnapshot = h,
                        Zl(s) && ig(i)
                    }
                    function ng(i, s, u) {
                        return u(function() {
                            Zl(s) && ig(i)
                        })
                    }
                    function Zl(i) {
                        var s = i.getSnapshot;
                        i = i.value;
                        try {
                            var u = s();
                            return !fa(i, u)
                        } catch {
                            return !0
                        }
                    }
                    function ig(i) {
                        var s = Yi(i, 2);
                        s !== null && Ii(s, i, 2)
                    }
                    function qd(i) {
                        var s = ji();
                        if (typeof i == "function") {
                            var u = i;
                            if (i = u(),
                            Ga) {
                                ft(!0);
                                try {
                                    u()
                                } finally {
                                    ft(!1)
                                }
                            }
                        }
                        return s.memoizedState = s.baseState = i,
                        s.queue = {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: ma,
                            lastRenderedState: i
                        },
                        s
                    }
                    function ag(i, s, u, h) {
                        return i.baseState = u,
                        Wd(i, wn, typeof h == "function" ? h : ma)
                    }
                    function Ay(i, s, u, h, S) {
                        if (Yf(i))
                            throw Error(r(485));
                        if (i = s.action,
                        i !== null) {
                            var b = {
                                payload: S,
                                action: i,
                                next: null,
                                isTransition: !0,
                                status: "pending",
                                value: null,
                                reason: null,
                                listeners: [],
                                then: function(D) {
                                    b.listeners.push(D)
                                }
                            };
                            Q.T !== null ? u(!0) : b.isTransition = !1,
                            h(b),
                            u = s.pending,
                            u === null ? (b.next = s.pending = b,
                            sg(s, b)) : (b.next = u.next,
                            s.pending = u.next = b)
                        }
                    }
                    function sg(i, s) {
                        var u = s.action
                          , h = s.payload
                          , S = i.state;
                        if (s.isTransition) {
                            var b = Q.T
                              , D = {};
                            Q.T = D;
                            try {
                                var F = u(S, h)
                                  , ee = Q.S;
                                ee !== null && ee(D, F),
                                rg(i, s, F)
                            } catch (pe) {
                                Yd(i, s, pe)
                            } finally {
                                b !== null && D.types !== null && (b.types = D.types),
                                Q.T = b
                            }
                        } else
                            try {
                                b = u(S, h),
                                rg(i, s, b)
                            } catch (pe) {
                                Yd(i, s, pe)
                            }
                    }
                    function rg(i, s, u) {
                        u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(function(h) {
                            og(i, s, h)
                        }, function(h) {
                            return Yd(i, s, h)
                        }) : og(i, s, u)
                    }
                    function og(i, s, u) {
                        s.status = "fulfilled",
                        s.value = u,
                        lg(s),
                        i.state = u,
                        s = i.pending,
                        s !== null && (u = s.next,
                        u === s ? i.pending = null : (u = u.next,
                        s.next = u,
                        sg(i, u)))
                    }
                    function Yd(i, s, u) {
                        var h = i.pending;
                        if (i.pending = null,
                        h !== null) {
                            h = h.next;
                            do
                                s.status = "rejected",
                                s.reason = u,
                                lg(s),
                                s = s.next;
                            while (s !== h)
                        }
                        i.action = null
                    }
                    function lg(i) {
                        i = i.listeners;
                        for (var s = 0; s < i.length; s++)
                            (0,
                            i[s])()
                    }
                    function cg(i, s) {
                        return s
                    }
                    function ug(i, s) {
                        if (fn) {
                            var u = yn.formState;
                            if (u !== null) {
                                e: {
                                    var h = Gt;
                                    if (fn) {
                                        if (on) {
                                            t: {
                                                for (var S = on, b = Fa; S.nodeType !== 8; ) {
                                                    if (!b) {
                                                        S = null;
                                                        break t
                                                    }
                                                    if (S = lr(S.nextSibling),
                                                    S === null) {
                                                        S = null;
                                                        break t
                                                    }
                                                }
                                                b = S.data,
                                                S = b === "F!" || b === "F" ? S : null
                                            }
                                            if (S) {
                                                on = lr(S.nextSibling),
                                                h = S.data === "F!";
                                                break e
                                            }
                                        }
                                        no(h)
                                    }
                                    h = !1
                                }
                                h && (s = u[0])
                            }
                        }
                        return u = ji(),
                        u.memoizedState = u.baseState = s,
                        h = {
                            pending: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: cg,
                            lastRenderedState: s
                        },
                        u.queue = h,
                        u = xg.bind(null, Gt, h),
                        h.dispatch = u,
                        h = qd(!1),
                        b = ap.bind(null, Gt, !1, h.queue),
                        h = ji(),
                        S = {
                            state: s,
                            dispatch: null,
                            action: i,
                            pending: null
                        },
                        h.queue = S,
                        u = Ay.bind(null, Gt, S, b, u),
                        S.dispatch = u,
                        h.memoizedState = i,
                        [s, u, !1]
                    }
                    function fg(i) {
                        return jd(si(), wn, i)
                    }
                    function jd(i, s, u) {
                        if (s = Wd(i, s, cg)[0],
                        i = kf(ma)[0],
                        typeof s == "object" && s !== null && typeof s.then == "function")
                            try {
                                var h = Yl(s)
                            } catch (D) {
                                throw D === Er ? Gl : D
                            }
                        else
                            h = s;
                        s = si();
                        var S = s.queue
                          , b = S.dispatch;
                        return u !== s.memoizedState && (Gt.flags |= 2048,
                        Ql(9, {
                            destroy: void 0
                        }, wy.bind(null, S, u), null)),
                        [h, b, i]
                    }
                    function wy(i, s) {
                        i.action = s
                    }
                    function hg(i) {
                        var s = si()
                          , u = wn;
                        if (u !== null)
                            return jd(s, u, i);
                        si(),
                        s = s.memoizedState,
                        u = si();
                        var h = u.queue.dispatch;
                        return u.memoizedState = i,
                        [s, h, !1]
                    }
                    function Ql(i, s, u, h) {
                        return i = {
                            tag: i,
                            create: u,
                            deps: h,
                            inst: s,
                            next: null
                        },
                        s = Gt.updateQueue,
                        s === null && (s = Ff(),
                        Gt.updateQueue = s),
                        u = s.lastEffect,
                        u === null ? s.lastEffect = i.next = i : (h = u.next,
                        u.next = i,
                        i.next = h,
                        s.lastEffect = i),
                        i
                    }
                    function dg() {
                        return si().memoizedState
                    }
                    function Hf(i, s, u, h) {
                        var S = ji();
                        Gt.flags |= i,
                        S.memoizedState = Ql(1 | s, {
                            destroy: void 0
                        }, u, h === void 0 ? null : h)
                    }
                    function Gf(i, s, u, h) {
                        var S = si();
                        h = h === void 0 ? null : h;
                        var b = S.memoizedState.inst;
                        wn !== null && h !== null && Vd(h, wn.memoizedState.deps) ? S.memoizedState = Ql(s, b, u, h) : (Gt.flags |= i,
                        S.memoizedState = Ql(1 | s, b, u, h))
                    }
                    function Zd(i, s) {
                        Hf(8390656, 8, i, s)
                    }
                    function Wf(i, s) {
                        Gf(2048, 8, i, s)
                    }
                    function Cy(i) {
                        Gt.flags |= 4;
                        var s = Gt.updateQueue;
                        if (s === null)
                            s = Ff(),
                            Gt.updateQueue = s,
                            s.events = [i];
                        else {
                            var u = s.events;
                            u === null ? s.events = [i] : u.push(i)
                        }
                    }
                    function Qd(i) {
                        var s = si().memoizedState;
                        return Cy({
                            ref: s,
                            nextImpl: i
                        }),
                        function() {
                            if ((Mn & 2) !== 0)
                                throw Error(r(440));
                            return s.impl.apply(void 0, arguments)
                        }
                    }
                    function Kd(i, s) {
                        return Gf(4, 2, i, s)
                    }
                    function Jd(i, s) {
                        return Gf(4, 4, i, s)
                    }
                    function Xf(i, s) {
                        if (typeof s == "function") {
                            i = i();
                            var u = s(i);
                            return function() {
                                typeof u == "function" ? u() : s(null)
                            }
                        }
                        if (s != null)
                            return i = i(),
                            s.current = i,
                            function() {
                                s.current = null
                            }
                    }
                    function qf(i, s, u) {
                        u = u != null ? u.concat([i]) : null,
                        Gf(4, 4, Xf.bind(null, s, i), u)
                    }
                    function $d() {}
                    function pg(i, s) {
                        var u = si();
                        s = s === void 0 ? null : s;
                        var h = u.memoizedState;
                        return s !== null && Vd(s, h[1]) ? h[0] : (u.memoizedState = [i, s],
                        i)
                    }
                    function mg(i, s) {
                        var u = si();
                        s = s === void 0 ? null : s;
                        var h = u.memoizedState;
                        if (s !== null && Vd(s, h[1]))
                            return h[0];
                        if (h = i(),
                        Ga) {
                            ft(!0);
                            try {
                                i()
                            } finally {
                                ft(!1)
                            }
                        }
                        return u.memoizedState = [h, s],
                        h
                    }
                    function ep(i, s, u) {
                        return u === void 0 || (Ns & 1073741824) !== 0 && (Yt & 261930) === 0 ? i.memoizedState = s : (i.memoizedState = u,
                        i = _s(),
                        Gt.lanes |= i,
                        Pn |= i,
                        u)
                    }
                    function tp(i, s, u, h) {
                        return fa(u, s) ? u : Wl.current !== null ? (i = ep(i, u, h),
                        fa(i, s) || (Ti = !0),
                        i) : (Ns & 42) === 0 || (Ns & 1073741824) !== 0 && (Yt & 261930) === 0 ? (Ti = !0,
                        i.memoizedState = u) : (i = _s(),
                        Gt.lanes |= i,
                        Pn |= i,
                        s)
                    }
                    function gg(i, s, u, h, S) {
                        var b = se.p;
                        se.p = b !== 0 && 8 > b ? b : 8;
                        var D = Q.T
                          , F = {};
                        Q.T = F,
                        ap(i, !1, s, u);
                        try {
                            var ee = S()
                              , pe = Q.S;
                            pe !== null && pe(F, ee),
                            ee !== null && typeof ee == "object" && typeof ee.then == "function" ? vu(i, s, Ty(ee, h), qn(i)) : vu(i, s, h, qn(i))
                        } catch (De) {
                            vu(i, s, {
                                then: function() {},
                                status: "rejected",
                                reason: De
                            }, qn())
                        } finally {
                            se.p = b,
                            D !== null && F.types !== null && (D.types = F.types),
                            Q.T = D
                        }
                    }
                    function Ry() {}
                    function np(i, s, u, h) {
                        if (i.tag !== 5)
                            throw Error(r(476));
                        var S = vg(i).queue;
                        gg(i, S, s, Te, u === null ? Ry : function() {
                            return yg(i),
                            u(h)
                        }
                        )
                    }
                    function vg(i) {
                        var s = i.memoizedState;
                        if (s !== null)
                            return s;
                        s = {
                            memoizedState: Te,
                            baseState: Te,
                            baseQueue: null,
                            queue: {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: ma,
                                lastRenderedState: Te
                            },
                            next: null
                        };
                        var u = {};
                        return s.next = {
                            memoizedState: u,
                            baseState: u,
                            baseQueue: null,
                            queue: {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: ma,
                                lastRenderedState: u
                            },
                            next: null
                        },
                        i.memoizedState = s,
                        i = i.alternate,
                        i !== null && (i.memoizedState = s),
                        s
                    }
                    function yg(i) {
                        var s = vg(i);
                        s.next === null && (s = i.alternate.memoizedState),
                        vu(i, s.next.queue, {}, qn())
                    }
                    function ip() {
                        return xi(Mp)
                    }
                    function _g() {
                        return si().memoizedState
                    }
                    function Sg() {
                        return si().memoizedState
                    }
                    function Dy(i) {
                        for (var s = i.return; s !== null; ) {
                            switch (s.tag) {
                            case 24:
                            case 3:
                                var u = qn();
                                i = wr(u);
                                var h = co(s, i, u);
                                h !== null && (Ii(h, s, u),
                                hs(h, s, u)),
                                s = {
                                    cache: Ko()
                                },
                                i.payload = s;
                                return
                            }
                            s = s.return
                        }
                    }
                    function Ny(i, s, u) {
                        var h = qn();
                        u = {
                            lane: h,
                            revertLane: 0,
                            gesture: null,
                            action: u,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        },
                        Yf(i) ? bg(s, u) : (u = Af(i, s, u, h),
                        u !== null && (Ii(u, i, h),
                        Mg(u, s, h)))
                    }
                    function xg(i, s, u) {
                        vu(i, s, u, qn())
                    }
                    function vu(i, s, u, h) {
                        var S = {
                            lane: h,
                            revertLane: 0,
                            gesture: null,
                            action: u,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        };
                        if (Yf(i))
                            bg(s, S);
                        else {
                            var b = i.alternate;
                            if (i.lanes === 0 && (b === null || b.lanes === 0) && (b = s.lastRenderedReducer,
                            b !== null))
                                try {
                                    var D = s.lastRenderedState
                                      , F = b(D, u);
                                    if (S.hasEagerState = !0,
                                    S.eagerState = F,
                                    fa(F, D))
                                        return nu(i, s, S, 0),
                                        yn === null && Ef(),
                                        !1
                                } catch {}
                            if (u = Af(i, s, S, h),
                            u !== null)
                                return Ii(u, i, h),
                                Mg(u, s, h),
                                !0
                        }
                        return !1
                    }
                    function ap(i, s, u, h) {
                        if (h = {
                            lane: 2,
                            revertLane: Oe(),
                            gesture: null,
                            action: h,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        },
                        Yf(i)) {
                            if (s)
                                throw Error(r(479))
                        } else
                            s = Af(i, u, h, 2),
                            s !== null && Ii(s, i, 2)
                    }
                    function Yf(i) {
                        var s = i.alternate;
                        return i === Gt || s !== null && s === Gt
                    }
                    function bg(i, s) {
                        ql = Bf = !0;
                        var u = i.pending;
                        u === null ? s.next = s : (s.next = u.next,
                        u.next = s),
                        i.pending = s
                    }
                    function Mg(i, s, u) {
                        if ((u & 4194048) !== 0) {
                            var h = s.lanes;
                            h &= i.pendingLanes,
                            u |= h,
                            s.lanes = u,
                            zc(i, u)
                        }
                    }
                    var yu = {
                        readContext: xi,
                        use: Vf,
                        useCallback: ai,
                        useContext: ai,
                        useEffect: ai,
                        useImperativeHandle: ai,
                        useLayoutEffect: ai,
                        useInsertionEffect: ai,
                        useMemo: ai,
                        useReducer: ai,
                        useRef: ai,
                        useState: ai,
                        useDebugValue: ai,
                        useDeferredValue: ai,
                        useTransition: ai,
                        useSyncExternalStore: ai,
                        useId: ai,
                        useHostTransitionStatus: ai,
                        useFormState: ai,
                        useActionState: ai,
                        useOptimistic: ai,
                        useMemoCache: ai,
                        useCacheRefresh: ai
                    };
                    yu.useEffectEvent = ai;
                    var Tg = {
                        readContext: xi,
                        use: Vf,
                        useCallback: function(i, s) {
                            return ji().memoizedState = [i, s === void 0 ? null : s],
                            i
                        },
                        useContext: xi,
                        useEffect: Zd,
                        useImperativeHandle: function(i, s, u) {
                            u = u != null ? u.concat([i]) : null,
                            Hf(4194308, 4, Xf.bind(null, s, i), u)
                        },
                        useLayoutEffect: function(i, s) {
                            return Hf(4194308, 4, i, s)
                        },
                        useInsertionEffect: function(i, s) {
                            Hf(4, 2, i, s)
                        },
                        useMemo: function(i, s) {
                            var u = ji();
                            s = s === void 0 ? null : s;
                            var h = i();
                            if (Ga) {
                                ft(!0);
                                try {
                                    i()
                                } finally {
                                    ft(!1)
                                }
                            }
                            return u.memoizedState = [h, s],
                            h
                        },
                        useReducer: function(i, s, u) {
                            var h = ji();
                            if (u !== void 0) {
                                var S = u(s);
                                if (Ga) {
                                    ft(!0);
                                    try {
                                        u(s)
                                    } finally {
                                        ft(!1)
                                    }
                                }
                            } else
                                S = s;
                            return h.memoizedState = h.baseState = S,
                            i = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: i,
                                lastRenderedState: S
                            },
                            h.queue = i,
                            i = i.dispatch = Ny.bind(null, Gt, i),
                            [h.memoizedState, i]
                        },
                        useRef: function(i) {
                            var s = ji();
                            return i = {
                                current: i
                            },
                            s.memoizedState = i
                        },
                        useState: function(i) {
                            i = qd(i);
                            var s = i.queue
                              , u = xg.bind(null, Gt, s);
                            return s.dispatch = u,
                            [i.memoizedState, u]
                        },
                        useDebugValue: $d,
                        useDeferredValue: function(i, s) {
                            return ep(ji(), i, s)
                        },
                        useTransition: function() {
                            var i = qd(!1);
                            return i = gg.bind(null, Gt, i.queue, !0, !1),
                            ji().memoizedState = i,
                            [!1, i]
                        },
                        useSyncExternalStore: function(i, s, u) {
                            var h = Gt
                              , S = ji();
                            if (fn) {
                                if (u === void 0)
                                    throw Error(r(407));
                                u = u()
                            } else {
                                if (u = s(),
                                yn === null)
                                    throw Error(r(349));
                                (Yt & 127) !== 0 || eg(h, s, u)
                            }
                            S.memoizedState = u;
                            var b = {
                                value: u,
                                getSnapshot: s
                            };
                            return S.queue = b,
                            Zd(ng.bind(null, h, b, i), [i]),
                            h.flags |= 2048,
                            Ql(9, {
                                destroy: void 0
                            }, tg.bind(null, h, b, u, s), null),
                            u
                        },
                        useId: function() {
                            var i = ji()
                              , s = yn.identifierPrefix;
                            if (fn) {
                                var u = Ba
                                  , h = Ds;
                                u = (h & ~(1 << 32 - et(h) - 1)).toString(32) + u,
                                s = "_" + s + "R_" + u,
                                u = ps++,
                                0 < u && (s += "H" + u.toString(32)),
                                s += "_"
                            } else
                                u = na++,
                                s = "_" + s + "r_" + u.toString(32) + "_";
                            return i.memoizedState = s
                        },
                        useHostTransitionStatus: ip,
                        useFormState: ug,
                        useActionState: ug,
                        useOptimistic: function(i) {
                            var s = ji();
                            s.memoizedState = s.baseState = i;
                            var u = {
                                pending: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: null,
                                lastRenderedState: null
                            };
                            return s.queue = u,
                            s = ap.bind(null, Gt, !0, u),
                            u.dispatch = s,
                            [i, s]
                        },
                        useMemoCache: fo,
                        useCacheRefresh: function() {
                            return ji().memoizedState = Dy.bind(null, Gt)
                        },
                        useEffectEvent: function(i) {
                            var s = ji()
                              , u = {
                                impl: i
                            };
                            return s.memoizedState = u,
                            function() {
                                if ((Mn & 2) !== 0)
                                    throw Error(r(440));
                                return u.impl.apply(void 0, arguments)
                            }
                        }
                    }
                      , sp = {
                        readContext: xi,
                        use: Vf,
                        useCallback: pg,
                        useContext: xi,
                        useEffect: Wf,
                        useImperativeHandle: qf,
                        useInsertionEffect: Kd,
                        useLayoutEffect: Jd,
                        useMemo: mg,
                        useReducer: kf,
                        useRef: dg,
                        useState: function() {
                            return kf(ma)
                        },
                        useDebugValue: $d,
                        useDeferredValue: function(i, s) {
                            return tp(si(), wn.memoizedState, i, s)
                        },
                        useTransition: function() {
                            var i = kf(ma)[0]
                              , s = si().memoizedState;
                            return [typeof i == "boolean" ? i : Yl(i), s]
                        },
                        useSyncExternalStore: jl,
                        useId: _g,
                        useHostTransitionStatus: ip,
                        useFormState: fg,
                        useActionState: fg,
                        useOptimistic: function(i, s) {
                            return ag(si(), wn, i, s)
                        },
                        useMemoCache: fo,
                        useCacheRefresh: Sg
                    };
                    sp.useEffectEvent = Qd;
                    var Eg = {
                        readContext: xi,
                        use: Vf,
                        useCallback: pg,
                        useContext: xi,
                        useEffect: Wf,
                        useImperativeHandle: qf,
                        useInsertionEffect: Kd,
                        useLayoutEffect: Jd,
                        useMemo: mg,
                        useReducer: Xd,
                        useRef: dg,
                        useState: function() {
                            return Xd(ma)
                        },
                        useDebugValue: $d,
                        useDeferredValue: function(i, s) {
                            var u = si();
                            return wn === null ? ep(u, i, s) : tp(u, wn.memoizedState, i, s)
                        },
                        useTransition: function() {
                            var i = Xd(ma)[0]
                              , s = si().memoizedState;
                            return [typeof i == "boolean" ? i : Yl(i), s]
                        },
                        useSyncExternalStore: jl,
                        useId: _g,
                        useHostTransitionStatus: ip,
                        useFormState: hg,
                        useActionState: hg,
                        useOptimistic: function(i, s) {
                            var u = si();
                            return wn !== null ? ag(u, wn, i, s) : (u.baseState = i,
                            [i, u.queue.dispatch])
                        },
                        useMemoCache: fo,
                        useCacheRefresh: Sg
                    };
                    Eg.useEffectEvent = Qd;
                    function rp(i, s, u, h) {
                        s = i.memoizedState,
                        u = u(h, s),
                        u = u == null ? s : x({}, s, u),
                        i.memoizedState = u,
                        i.lanes === 0 && (i.updateQueue.baseState = u)
                    }
                    var op = {
                        enqueueSetState: function(i, s, u) {
                            i = i._reactInternals;
                            var h = qn()
                              , S = wr(h);
                            S.payload = s,
                            u != null && (S.callback = u),
                            s = co(i, S, h),
                            s !== null && (Ii(s, i, h),
                            hs(s, i, h))
                        },
                        enqueueReplaceState: function(i, s, u) {
                            i = i._reactInternals;
                            var h = qn()
                              , S = wr(h);
                            S.tag = 1,
                            S.payload = s,
                            u != null && (S.callback = u),
                            s = co(i, S, h),
                            s !== null && (Ii(s, i, h),
                            hs(s, i, h))
                        },
                        enqueueForceUpdate: function(i, s) {
                            i = i._reactInternals;
                            var u = qn()
                              , h = wr(u);
                            h.tag = 2,
                            s != null && (h.callback = s),
                            s = co(i, h, u),
                            s !== null && (Ii(s, i, u),
                            hs(s, i, u))
                        }
                    };
                    function Ag(i, s, u, h, S, b, D) {
                        return i = i.stateNode,
                        typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(h, b, D) : s.prototype && s.prototype.isPureReactComponent ? !Qc(u, h) || !Qc(S, b) : !0
                    }
                    function wg(i, s, u, h) {
                        i = s.state,
                        typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(u, h),
                        typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(u, h),
                        s.state !== i && op.enqueueReplaceState(s, s.state, null)
                    }
                    function sl(i, s) {
                        var u = s;
                        if ("ref"in s) {
                            u = {};
                            for (var h in s)
                                h !== "ref" && (u[h] = s[h])
                        }
                        if (i = i.defaultProps) {
                            u === s && (u = x({}, u));
                            for (var S in i)
                                u[S] === void 0 && (u[S] = i[S])
                        }
                        return u
                    }
                    function Ly(i) {
                        Bl(i)
                    }
                    function Cg(i) {
                        console.error(i)
                    }
                    function Uy(i) {
                        Bl(i)
                    }
                    function jf(i, s) {
                        try {
                            var u = i.onUncaughtError;
                            u(s.value, {
                                componentStack: s.stack
                            })
                        } catch (h) {
                            setTimeout(function() {
                                throw h
                            })
                        }
                    }
                    function ms(i, s, u) {
                        try {
                            var h = i.onCaughtError;
                            h(u.value, {
                                componentStack: u.stack,
                                errorBoundary: s.tag === 1 ? s.stateNode : null
                            })
                        } catch (S) {
                            setTimeout(function() {
                                throw S
                            })
                        }
                    }
                    function Zf(i, s, u) {
                        return u = wr(u),
                        u.tag = 3,
                        u.payload = {
                            element: null
                        },
                        u.callback = function() {
                            jf(i, s)
                        }
                        ,
                        u
                    }
                    function Qf(i) {
                        return i = wr(i),
                        i.tag = 3,
                        i
                    }
                    function lp(i, s, u, h) {
                        var S = u.type.getDerivedStateFromError;
                        if (typeof S == "function") {
                            var b = h.value;
                            i.payload = function() {
                                return S(b)
                            }
                            ,
                            i.callback = function() {
                                ms(s, u, h)
                            }
                        }
                        var D = u.stateNode;
                        D !== null && typeof D.componentDidCatch == "function" && (i.callback = function() {
                            ms(s, u, h),
                            typeof S != "function" && (sr === null ? sr = new Set([this]) : sr.add(this));
                            var F = h.stack;
                            this.componentDidCatch(h.value, {
                                componentStack: F !== null ? F : ""
                            })
                        }
                        )
                    }
                    function Rg(i, s, u, h, S) {
                        if (u.flags |= 32768,
                        h !== null && typeof h == "object" && typeof h.then == "function") {
                            if (s = u.alternate,
                            s !== null && Qo(s, u, S, !0),
                            u = ka.current,
                            u !== null) {
                                switch (u.tag) {
                                case 31:
                                case 13:
                                    return ds === null ? Jt() : u.alternate === null && Pt === 0 && (Pt = 3),
                                    u.flags &= -257,
                                    u.flags |= 65536,
                                    u.lanes = S,
                                    h === fu ? u.flags |= 16384 : (s = u.updateQueue,
                                    s === null ? u.updateQueue = new Set([h]) : s.add(h),
                                    oc(i, h, S)),
                                    !1;
                                case 22:
                                    return u.flags |= 65536,
                                    h === fu ? u.flags |= 16384 : (s = u.updateQueue,
                                    s === null ? (s = {
                                        transitions: null,
                                        markerInstances: null,
                                        retryQueue: new Set([h])
                                    },
                                    u.updateQueue = s) : (u = s.retryQueue,
                                    u === null ? s.retryQueue = new Set([h]) : u.add(h)),
                                    oc(i, h, S)),
                                    !1
                                }
                                throw Error(r(435, u.tag))
                            }
                            return oc(i, h, S),
                            Jt(),
                            !1
                        }
                        if (fn)
                            return s = ka.current,
                            s !== null ? ((s.flags & 65536) === 0 && (s.flags |= 256),
                            s.flags |= 65536,
                            s.lanes = S,
                            h !== Df && (i = Error(r(422), {
                                cause: h
                            }),
                            Fl(ii(i, u)))) : (h !== Df && (s = Error(r(423), {
                                cause: h
                            }),
                            Fl(ii(s, u))),
                            i = i.current.alternate,
                            i.flags |= 65536,
                            S &= -S,
                            i.lanes |= S,
                            h = ii(h, u),
                            S = Zf(i.stateNode, h, S),
                            pu(i, S),
                            Pt !== 4 && (Pt = 2)),
                            !1;
                        var b = Error(r(520), {
                            cause: h
                        });
                        if (b = ii(b, u),
                        Pr === null ? Pr = [b] : Pr.push(b),
                        Pt !== 4 && (Pt = 2),
                        s === null)
                            return !0;
                        h = ii(h, u),
                        u = s;
                        do {
                            switch (u.tag) {
                            case 3:
                                return u.flags |= 65536,
                                i = S & -S,
                                u.lanes |= i,
                                i = Zf(u.stateNode, h, i),
                                pu(u, i),
                                !1;
                            case 1:
                                if (s = u.type,
                                b = u.stateNode,
                                (u.flags & 128) === 0 && (typeof s.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (sr === null || !sr.has(b))))
                                    return u.flags |= 65536,
                                    S &= -S,
                                    u.lanes |= S,
                                    S = Qf(S),
                                    lp(S, i, u, h),
                                    pu(u, S),
                                    !1
                            }
                            u = u.return
                        } while (u !== null);
                        return !1
                    }
                    var Kf = Error(r(461))
                      , Ti = !1;
                    function Fi(i, s, u, h) {
                        s.child = i === null ? du(s, null, u, h) : tl(s, i.child, u, h)
                    }
                    function cp(i, s, u, h, S) {
                        u = u.render;
                        var b = s.ref;
                        if ("ref"in h) {
                            var D = {};
                            for (var F in h)
                                F !== "ref" && (D[F] = h[F])
                        } else
                            D = h;
                        return us(s),
                        h = Mi(i, s, u, D, b, S),
                        F = kd(),
                        i !== null && !Ti ? (Hd(i, s, S),
                        Dr(i, s, S)) : (fn && F && ru(s),
                        s.flags |= 1,
                        Fi(i, s, h, S),
                        s.child)
                    }
                    function Dg(i, s, u, h, S) {
                        if (i === null) {
                            var b = u.type;
                            return typeof b == "function" && !Bi(b) && b.defaultProps === void 0 && u.compare === null ? (s.tag = 15,
                            s.type = b,
                            Ng(i, s, b, h, S)) : (i = au(u.type, null, h, s, s.mode, S),
                            i.ref = s.ref,
                            i.return = s,
                            s.child = i)
                        }
                        if (b = i.child,
                        !ia(i, S)) {
                            var D = b.memoizedProps;
                            if (u = u.compare,
                            u = u !== null ? u : Qc,
                            u(D, h) && i.ref === s.ref)
                                return Dr(i, s, S)
                        }
                        return s.flags |= 1,
                        i = qs(b, h),
                        i.ref = s.ref,
                        i.return = s,
                        s.child = i
                    }
                    function Ng(i, s, u, h, S) {
                        if (i !== null) {
                            var b = i.memoizedProps;
                            if (Qc(b, h) && i.ref === s.ref)
                                if (Ti = !1,
                                s.pendingProps = h = b,
                                ia(i, S))
                                    (i.flags & 131072) !== 0 && (Ti = !0);
                                else
                                    return s.lanes = i.lanes,
                                    Dr(i, s, S)
                        }
                        return Jf(i, s, u, h, S)
                    }
                    function Lg(i, s, u, h) {
                        var S = h.children
                          , b = i !== null ? i.memoizedState : null;
                        if (i === null && s.stateNode === null && (s.stateNode = {
                            _visibility: 1,
                            _pendingMarkers: null,
                            _retryCache: null,
                            _transitions: null
                        }),
                        h.mode === "hidden") {
                            if ((s.flags & 128) !== 0) {
                                if (b = b !== null ? b.baseLanes | u : u,
                                i !== null) {
                                    for (h = s.child = i.child,
                                    S = 0; h !== null; )
                                        S = S | h.lanes | h.childLanes,
                                        h = h.sibling;
                                    h = S & ~b
                                } else
                                    h = 0,
                                    s.child = null;
                                return Ug(i, s, b, u, h)
                            }
                            if ((u & 536870912) !== 0)
                                s.memoizedState = {
                                    baseLanes: 0,
                                    cachePool: null
                                },
                                i !== null && fs(s, b !== null ? b.cachePool : null),
                                b !== null ? Km(s, b) : Xl(),
                                Jm(s);
                            else
                                return h = s.lanes = 536870912,
                                Ug(i, s, b !== null ? b.baseLanes | u : u, u, h)
                        } else
                            b !== null ? (fs(s, b.cachePool),
                            Km(s, b),
                            uo(s),
                            s.memoizedState = null) : (i !== null && fs(s, null),
                            Xl(),
                            uo(s));
                        return Fi(i, s, S, u),
                        s.child
                    }
                    function Kl(i, s) {
                        return i !== null && i.tag === 22 || s.stateNode !== null || (s.stateNode = {
                            _visibility: 1,
                            _pendingMarkers: null,
                            _retryCache: null,
                            _transitions: null
                        }),
                        s.sibling
                    }
                    function Ug(i, s, u, h, S) {
                        var b = uu();
                        return b = b === null ? null : {
                            parent: pi._currentValue,
                            pool: b
                        },
                        s.memoizedState = {
                            baseLanes: u,
                            cachePool: b
                        },
                        i !== null && fs(s, null),
                        Xl(),
                        Jm(s),
                        i !== null && Qo(i, s, h, !0),
                        s.childLanes = S,
                        null
                    }
                    function ri(i, s) {
                        return s = ll({
                            mode: s.mode,
                            children: s.children
                        }, i.mode),
                        s.ref = i.ref,
                        i.child = s,
                        s.return = i,
                        s
                    }
                    function up(i, s, u) {
                        return tl(s, i.child, null, u),
                        i = ri(s, s.pendingProps),
                        i.flags |= 2,
                        Ha(s),
                        s.memoizedState = null,
                        i
                    }
                    function Iy(i, s, u) {
                        var h = s.pendingProps
                          , S = (s.flags & 128) !== 0;
                        if (s.flags &= -129,
                        i === null) {
                            if (fn) {
                                if (h.mode === "hidden")
                                    return i = ri(s, h),
                                    s.lanes = 536870912,
                                    Kl(null, i);
                                if (al(s),
                                (i = on) ? (i = Nx(i, Fa),
                                i = i !== null && i.data === "&" ? i : null,
                                i !== null && (s.memoizedState = {
                                    dehydrated: i,
                                    treeContext: os !== null ? {
                                        id: Ds,
                                        overflow: Ba
                                    } : null,
                                    retryLane: 536870912,
                                    hydrationErrors: null
                                },
                                u = Ys(i),
                                u.return = s,
                                s.child = u,
                                Ni = s,
                                on = null)) : i = null,
                                i === null)
                                    throw no(s);
                                return s.lanes = 536870912,
                                null
                            }
                            return ri(s, h)
                        }
                        var b = i.memoizedState;
                        if (b !== null) {
                            var D = b.dehydrated;
                            if (al(s),
                            S)
                                if (s.flags & 256)
                                    s.flags &= -257,
                                    s = up(i, s, u);
                                else if (s.memoizedState !== null)
                                    s.child = i.child,
                                    s.flags |= 128,
                                    s = null;
                                else
                                    throw Error(r(558));
                            else if (Ti || Qo(i, s, u, !1),
                            S = (u & i.childLanes) !== 0,
                            Ti || S) {
                                if (h = yn,
                                h !== null && (D = Yr(h, u),
                                D !== 0 && D !== b.retryLane))
                                    throw b.retryLane = D,
                                    Yi(i, D),
                                    Ii(h, i, D),
                                    Kf;
                                Jt(),
                                s = up(i, s, u)
                            } else
                                i = b.treeContext,
                                on = lr(D.nextSibling),
                                Ni = s,
                                fn = !0,
                                di = null,
                                Fa = !1,
                                i !== null && Ld(s, i),
                                s = ri(s, h),
                                s.flags |= 4096;
                            return s
                        }
                        return i = qs(i.child, {
                            mode: h.mode,
                            children: h.children
                        }),
                        i.ref = s.ref,
                        s.child = i,
                        i.return = s,
                        i
                    }
                    function _u(i, s) {
                        var u = s.ref;
                        if (u === null)
                            i !== null && i.ref !== null && (s.flags |= 4194816);
                        else {
                            if (typeof u != "function" && typeof u != "object")
                                throw Error(r(284));
                            (i === null || i.ref !== u) && (s.flags |= 4194816)
                        }
                    }
                    function Jf(i, s, u, h, S) {
                        return us(s),
                        u = Mi(i, s, u, h, void 0, S),
                        h = kd(),
                        i !== null && !Ti ? (Hd(i, s, S),
                        Dr(i, s, S)) : (fn && h && ru(s),
                        s.flags |= 1,
                        Fi(i, s, u, S),
                        s.child)
                    }
                    function rl(i, s, u, h, S, b) {
                        return us(s),
                        s.updateQueue = null,
                        u = $m(s, h, u, S),
                        Qs(i),
                        h = kd(),
                        i !== null && !Ti ? (Hd(i, s, b),
                        Dr(i, s, b)) : (fn && h && ru(s),
                        s.flags |= 1,
                        Fi(i, s, u, b),
                        s.child)
                    }
                    function $f(i, s, u, h, S) {
                        if (us(s),
                        s.stateNode === null) {
                            var b = jo
                              , D = u.contextType;
                            typeof D == "object" && D !== null && (b = xi(D)),
                            b = new u(h,b),
                            s.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null,
                            b.updater = op,
                            s.stateNode = b,
                            b._reactInternals = s,
                            b = s.stateNode,
                            b.props = h,
                            b.state = s.memoizedState,
                            b.refs = {},
                            lo(s),
                            D = u.contextType,
                            b.context = typeof D == "object" && D !== null ? xi(D) : jo,
                            b.state = s.memoizedState,
                            D = u.getDerivedStateFromProps,
                            typeof D == "function" && (rp(s, u, D, h),
                            b.state = s.memoizedState),
                            typeof u.getDerivedStateFromProps == "function" || typeof b.getSnapshotBeforeUpdate == "function" || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (D = b.state,
                            typeof b.componentWillMount == "function" && b.componentWillMount(),
                            typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(),
                            D !== b.state && op.enqueueReplaceState(b, b.state, null),
                            il(s, h, b, S),
                            nl(),
                            b.state = s.memoizedState),
                            typeof b.componentDidMount == "function" && (s.flags |= 4194308),
                            h = !0
                        } else if (i === null) {
                            b = s.stateNode;
                            var F = s.memoizedProps
                              , ee = sl(u, F);
                            b.props = ee;
                            var pe = b.context
                              , De = u.contextType;
                            D = jo,
                            typeof De == "object" && De !== null && (D = xi(De));
                            var Ie = u.getDerivedStateFromProps;
                            De = typeof Ie == "function" || typeof b.getSnapshotBeforeUpdate == "function",
                            F = s.pendingProps !== F,
                            De || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (F || pe !== D) && wg(s, b, h, D),
                            Va = !1;
                            var ge = s.memoizedState;
                            b.state = ge,
                            il(s, h, b, S),
                            nl(),
                            pe = s.memoizedState,
                            F || ge !== pe || Va ? (typeof Ie == "function" && (rp(s, u, Ie, h),
                            pe = s.memoizedState),
                            (ee = Va || Ag(s, u, ee, h, ge, pe, D)) ? (De || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (typeof b.componentWillMount == "function" && b.componentWillMount(),
                            typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()),
                            typeof b.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof b.componentDidMount == "function" && (s.flags |= 4194308),
                            s.memoizedProps = h,
                            s.memoizedState = pe),
                            b.props = h,
                            b.state = pe,
                            b.context = D,
                            h = ee) : (typeof b.componentDidMount == "function" && (s.flags |= 4194308),
                            h = !1)
                        } else {
                            b = s.stateNode,
                            Of(i, s),
                            D = s.memoizedProps,
                            De = sl(u, D),
                            b.props = De,
                            Ie = s.pendingProps,
                            ge = b.context,
                            pe = u.contextType,
                            ee = jo,
                            typeof pe == "object" && pe !== null && (ee = xi(pe)),
                            F = u.getDerivedStateFromProps,
                            (pe = typeof F == "function" || typeof b.getSnapshotBeforeUpdate == "function") || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (D !== Ie || ge !== ee) && wg(s, b, h, ee),
                            Va = !1,
                            ge = s.memoizedState,
                            b.state = ge,
                            il(s, h, b, S),
                            nl();
                            var Se = s.memoizedState;
                            D !== Ie || ge !== Se || Va || i !== null && i.dependencies !== null && lu(i.dependencies) ? (typeof F == "function" && (rp(s, u, F, h),
                            Se = s.memoizedState),
                            (De = Va || Ag(s, u, De, h, ge, Se, ee) || i !== null && i.dependencies !== null && lu(i.dependencies)) ? (pe || typeof b.UNSAFE_componentWillUpdate != "function" && typeof b.componentWillUpdate != "function" || (typeof b.componentWillUpdate == "function" && b.componentWillUpdate(h, Se, ee),
                            typeof b.UNSAFE_componentWillUpdate == "function" && b.UNSAFE_componentWillUpdate(h, Se, ee)),
                            typeof b.componentDidUpdate == "function" && (s.flags |= 4),
                            typeof b.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof b.componentDidUpdate != "function" || D === i.memoizedProps && ge === i.memoizedState || (s.flags |= 4),
                            typeof b.getSnapshotBeforeUpdate != "function" || D === i.memoizedProps && ge === i.memoizedState || (s.flags |= 1024),
                            s.memoizedProps = h,
                            s.memoizedState = Se),
                            b.props = h,
                            b.state = Se,
                            b.context = ee,
                            h = De) : (typeof b.componentDidUpdate != "function" || D === i.memoizedProps && ge === i.memoizedState || (s.flags |= 4),
                            typeof b.getSnapshotBeforeUpdate != "function" || D === i.memoizedProps && ge === i.memoizedState || (s.flags |= 1024),
                            h = !1)
                        }
                        return b = h,
                        _u(i, s),
                        h = (s.flags & 128) !== 0,
                        b || h ? (b = s.stateNode,
                        u = h && typeof u.getDerivedStateFromError != "function" ? null : b.render(),
                        s.flags |= 1,
                        i !== null && h ? (s.child = tl(s, i.child, null, S),
                        s.child = tl(s, null, u, S)) : Fi(i, s, u, S),
                        s.memoizedState = b.state,
                        i = s.child) : i = Dr(i, s, S),
                        i
                    }
                    function ol(i, s, u, h) {
                        return ls(),
                        s.flags |= 256,
                        Fi(i, s, u, h),
                        s.child
                    }
                    var ho = {
                        dehydrated: null,
                        treeContext: null,
                        retryLane: 0,
                        hydrationErrors: null
                    };
                    function ga(i) {
                        return {
                            baseLanes: i,
                            cachePool: zd()
                        }
                    }
                    function fp(i, s, u) {
                        return i = i !== null ? i.childLanes & ~u : 0,
                        s && (i |= Li),
                        i
                    }
                    function Ig(i, s, u) {
                        var h = s.pendingProps, S = !1, b = (s.flags & 128) !== 0, D;
                        if ((D = b) || (D = i !== null && i.memoizedState === null ? !1 : (mi.current & 2) !== 0),
                        D && (S = !0,
                        s.flags &= -129),
                        D = (s.flags & 32) !== 0,
                        s.flags &= -33,
                        i === null) {
                            if (fn) {
                                if (S ? Rr(s) : uo(s),
                                (i = on) ? (i = Nx(i, Fa),
                                i = i !== null && i.data !== "&" ? i : null,
                                i !== null && (s.memoizedState = {
                                    dehydrated: i,
                                    treeContext: os !== null ? {
                                        id: Ds,
                                        overflow: Ba
                                    } : null,
                                    retryLane: 536870912,
                                    hydrationErrors: null
                                },
                                u = Ys(i),
                                u.return = s,
                                s.child = u,
                                Ni = s,
                                on = null)) : i = null,
                                i === null)
                                    throw no(s);
                                return Wy(i) ? s.lanes = 32 : s.lanes = 536870912,
                                null
                            }
                            var F = h.children;
                            return h = h.fallback,
                            S ? (uo(s),
                            S = s.mode,
                            F = ll({
                                mode: "hidden",
                                children: F
                            }, S),
                            h = da(h, S, u, null),
                            F.return = s,
                            h.return = s,
                            F.sibling = h,
                            s.child = F,
                            h = s.child,
                            h.memoizedState = ga(u),
                            h.childLanes = fp(i, D, u),
                            s.memoizedState = ho,
                            Kl(null, h)) : (Rr(s),
                            Jl(s, F))
                        }
                        var ee = i.memoizedState;
                        if (ee !== null && (F = ee.dehydrated,
                        F !== null)) {
                            if (b)
                                s.flags & 256 ? (Rr(s),
                                s.flags &= -257,
                                s = $l(i, s, u)) : s.memoizedState !== null ? (uo(s),
                                s.child = i.child,
                                s.flags |= 128,
                                s = null) : (uo(s),
                                F = h.fallback,
                                S = s.mode,
                                h = ll({
                                    mode: "visible",
                                    children: h.children
                                }, S),
                                F = da(F, S, u, null),
                                F.flags |= 2,
                                h.return = s,
                                F.return = s,
                                h.sibling = F,
                                s.child = h,
                                tl(s, i.child, null, u),
                                h = s.child,
                                h.memoizedState = ga(u),
                                h.childLanes = fp(i, D, u),
                                s.memoizedState = ho,
                                s = Kl(null, h));
                            else if (Rr(s),
                            Wy(F)) {
                                if (D = F.nextSibling && F.nextSibling.dataset,
                                D)
                                    var pe = D.dgst;
                                D = pe,
                                h = Error(r(419)),
                                h.stack = "",
                                h.digest = D,
                                Fl({
                                    value: h,
                                    source: null,
                                    stack: null
                                }),
                                s = $l(i, s, u)
                            } else if (Ti || Qo(i, s, u, !1),
                            D = (u & i.childLanes) !== 0,
                            Ti || D) {
                                if (D = yn,
                                D !== null && (h = Yr(D, u),
                                h !== 0 && h !== ee.retryLane))
                                    throw ee.retryLane = h,
                                    Yi(i, h),
                                    Ii(D, i, h),
                                    Kf;
                                Gy(F) || Jt(),
                                s = $l(i, s, u)
                            } else
                                Gy(F) ? (s.flags |= 192,
                                s.child = i.child,
                                s = null) : (i = ee.treeContext,
                                on = lr(F.nextSibling),
                                Ni = s,
                                fn = !0,
                                di = null,
                                Fa = !1,
                                i !== null && Ld(s, i),
                                s = Jl(s, h.children),
                                s.flags |= 4096);
                            return s
                        }
                        return S ? (uo(s),
                        F = h.fallback,
                        S = s.mode,
                        ee = i.child,
                        pe = ee.sibling,
                        h = qs(ee, {
                            mode: "hidden",
                            children: h.children
                        }),
                        h.subtreeFlags = ee.subtreeFlags & 65011712,
                        pe !== null ? F = qs(pe, F) : (F = da(F, S, u, null),
                        F.flags |= 2),
                        F.return = s,
                        h.return = s,
                        h.sibling = F,
                        s.child = h,
                        Kl(null, h),
                        h = s.child,
                        F = i.child.memoizedState,
                        F === null ? F = ga(u) : (S = F.cachePool,
                        S !== null ? (ee = pi._currentValue,
                        S = S.parent !== ee ? {
                            parent: ee,
                            pool: ee
                        } : S) : S = zd(),
                        F = {
                            baseLanes: F.baseLanes | u,
                            cachePool: S
                        }),
                        h.memoizedState = F,
                        h.childLanes = fp(i, D, u),
                        s.memoizedState = ho,
                        Kl(i.child, h)) : (Rr(s),
                        u = i.child,
                        i = u.sibling,
                        u = qs(u, {
                            mode: "visible",
                            children: h.children
                        }),
                        u.return = s,
                        u.sibling = null,
                        i !== null && (D = s.deletions,
                        D === null ? (s.deletions = [i],
                        s.flags |= 16) : D.push(i)),
                        s.child = u,
                        s.memoizedState = null,
                        u)
                    }
                    function Jl(i, s) {
                        return s = ll({
                            mode: "visible",
                            children: s
                        }, i.mode),
                        s.return = i,
                        i.child = s
                    }
                    function ll(i, s) {
                        return i = $i(22, i, null, s),
                        i.lanes = 0,
                        i
                    }
                    function $l(i, s, u) {
                        return tl(s, i.child, null, u),
                        i = Jl(s, s.pendingProps.children),
                        i.flags |= 2,
                        s.memoizedState = null,
                        i
                    }
                    function Su(i, s, u) {
                        i.lanes |= s;
                        var h = i.alternate;
                        h !== null && (h.lanes |= s),
                        Id(i.return, s, u)
                    }
                    function xu(i, s, u, h, S, b) {
                        var D = i.memoizedState;
                        D === null ? i.memoizedState = {
                            isBackwards: s,
                            rendering: null,
                            renderingStartTime: 0,
                            last: h,
                            tail: u,
                            tailMode: S,
                            treeForkCount: b
                        } : (D.isBackwards = s,
                        D.rendering = null,
                        D.renderingStartTime = 0,
                        D.last = h,
                        D.tail = u,
                        D.tailMode = S,
                        D.treeForkCount = b)
                    }
                    function Og(i, s, u) {
                        var h = s.pendingProps
                          , S = h.revealOrder
                          , b = h.tail;
                        h = h.children;
                        var D = mi.current
                          , F = (D & 2) !== 0;
                        if (F ? (D = D & 1 | 2,
                        s.flags |= 128) : D &= 1,
                        Re(mi, D),
                        Fi(i, s, h, u),
                        h = fn ? Rs : 0,
                        !F && i !== null && (i.flags & 128) !== 0)
                            e: for (i = s.child; i !== null; ) {
                                if (i.tag === 13)
                                    i.memoizedState !== null && Su(i, u, s);
                                else if (i.tag === 19)
                                    Su(i, u, s);
                                else if (i.child !== null) {
                                    i.child.return = i,
                                    i = i.child;
                                    continue
                                }
                                if (i === s)
                                    break e;
                                for (; i.sibling === null; ) {
                                    if (i.return === null || i.return === s)
                                        break e;
                                    i = i.return
                                }
                                i.sibling.return = i.return,
                                i = i.sibling
                            }
                        switch (S) {
                        case "forwards":
                            for (u = s.child,
                            S = null; u !== null; )
                                i = u.alternate,
                                i !== null && zf(i) === null && (S = u),
                                u = u.sibling;
                            u = S,
                            u === null ? (S = s.child,
                            s.child = null) : (S = u.sibling,
                            u.sibling = null),
                            xu(s, !1, S, u, b, h);
                            break;
                        case "backwards":
                        case "unstable_legacy-backwards":
                            for (u = null,
                            S = s.child,
                            s.child = null; S !== null; ) {
                                if (i = S.alternate,
                                i !== null && zf(i) === null) {
                                    s.child = S;
                                    break
                                }
                                i = S.sibling,
                                S.sibling = u,
                                u = S,
                                S = i
                            }
                            xu(s, !0, u, null, b, h);
                            break;
                        case "together":
                            xu(s, !1, null, null, void 0, h);
                            break;
                        default:
                            s.memoizedState = null
                        }
                        return s.child
                    }
                    function Dr(i, s, u) {
                        if (i !== null && (s.dependencies = i.dependencies),
                        Pn |= s.lanes,
                        (u & s.childLanes) === 0)
                            if (i !== null) {
                                if (Qo(i, s, u, !1),
                                (u & s.childLanes) === 0)
                                    return null
                            } else
                                return null;
                        if (i !== null && s.child !== i.child)
                            throw Error(r(153));
                        if (s.child !== null) {
                            for (i = s.child,
                            u = qs(i, i.pendingProps),
                            s.child = u,
                            u.return = s; i.sibling !== null; )
                                i = i.sibling,
                                u = u.sibling = qs(i, i.pendingProps),
                                u.return = s;
                            u.sibling = null
                        }
                        return s.child
                    }
                    function ia(i, s) {
                        return (i.lanes & s) !== 0 ? !0 : (i = i.dependencies,
                        !!(i !== null && lu(i)))
                    }
                    function Pg(i, s, u) {
                        switch (s.tag) {
                        case 3:
                            at(s, s.stateNode.containerInfo),
                            Zs(s, pi, i.memoizedState.cache),
                            ls();
                            break;
                        case 27:
                        case 5:
                            Ft(s);
                            break;
                        case 4:
                            at(s, s.stateNode.containerInfo);
                            break;
                        case 10:
                            Zs(s, s.type, s.memoizedProps.value);
                            break;
                        case 31:
                            if (s.memoizedState !== null)
                                return s.flags |= 128,
                                al(s),
                                null;
                            break;
                        case 13:
                            var h = s.memoizedState;
                            if (h !== null)
                                return h.dehydrated !== null ? (Rr(s),
                                s.flags |= 128,
                                null) : (u & s.child.childLanes) !== 0 ? Ig(i, s, u) : (Rr(s),
                                i = Dr(i, s, u),
                                i !== null ? i.sibling : null);
                            Rr(s);
                            break;
                        case 19:
                            var S = (i.flags & 128) !== 0;
                            if (h = (u & s.childLanes) !== 0,
                            h || (Qo(i, s, u, !1),
                            h = (u & s.childLanes) !== 0),
                            S) {
                                if (h)
                                    return Og(i, s, u);
                                s.flags |= 128
                            }
                            if (S = s.memoizedState,
                            S !== null && (S.rendering = null,
                            S.tail = null,
                            S.lastEffect = null),
                            Re(mi, mi.current),
                            h)
                                break;
                            return null;
                        case 22:
                            return s.lanes = 0,
                            Lg(i, s, u, s.pendingProps);
                        case 24:
                            Zs(s, pi, i.memoizedState.cache)
                        }
                        return Dr(i, s, u)
                    }
                    function zg(i, s, u) {
                        if (i !== null)
                            if (i.memoizedProps !== s.pendingProps)
                                Ti = !0;
                            else {
                                if (!ia(i, u) && (s.flags & 128) === 0)
                                    return Ti = !1,
                                    Pg(i, s, u);
                                Ti = (i.flags & 131072) !== 0
                            }
                        else
                            Ti = !1,
                            fn && (s.flags & 1048576) !== 0 && Rf(s, Rs, s.index);
                        switch (s.lanes = 0,
                        s.tag) {
                        case 16:
                            e: {
                                var h = s.pendingProps;
                                if (i = ro(s.elementType),
                                s.type = i,
                                typeof i == "function")
                                    Bi(i) ? (h = sl(i, h),
                                    s.tag = 1,
                                    s = $f(null, s, i, h, u)) : (s.tag = 0,
                                    s = Jf(null, s, i, h, u));
                                else {
                                    if (i != null) {
                                        var S = i.$$typeof;
                                        if (S === k) {
                                            s.tag = 11,
                                            s = cp(null, s, i, h, u);
                                            break e
                                        } else if (S === G) {
                                            s.tag = 14,
                                            s = Dg(null, s, i, h, u);
                                            break e
                                        }
                                    }
                                    throw s = ce(i) || i,
                                    Error(r(306, s, ""))
                                }
                            }
                            return s;
                        case 0:
                            return Jf(i, s, s.type, s.pendingProps, u);
                        case 1:
                            return h = s.type,
                            S = sl(h, s.pendingProps),
                            $f(i, s, h, S, u);
                        case 3:
                            e: {
                                if (at(s, s.stateNode.containerInfo),
                                i === null)
                                    throw Error(r(387));
                                h = s.pendingProps;
                                var b = s.memoizedState;
                                S = b.element,
                                Of(i, s),
                                il(s, h, null, u);
                                var D = s.memoizedState;
                                if (h = D.cache,
                                Zs(s, pi, h),
                                h !== b.cache && Od(s, [pi], u, !0),
                                nl(),
                                h = D.element,
                                b.isDehydrated)
                                    if (b = {
                                        element: h,
                                        isDehydrated: !1,
                                        cache: D.cache
                                    },
                                    s.updateQueue.baseState = b,
                                    s.memoizedState = b,
                                    s.flags & 256) {
                                        s = ol(i, s, h, u);
                                        break e
                                    } else if (h !== S) {
                                        S = ii(Error(r(424)), s),
                                        Fl(S),
                                        s = ol(i, s, h, u);
                                        break e
                                    } else
                                        for (i = s.stateNode.containerInfo,
                                        i.nodeType === 9 ? i = i.body : i = i.nodeName === "HTML" ? i.ownerDocument.body : i,
                                        on = lr(i.firstChild),
                                        Ni = s,
                                        fn = !0,
                                        di = null,
                                        Fa = !0,
                                        u = du(s, null, h, u),
                                        s.child = u; u; )
                                            u.flags = u.flags & -3 | 4096,
                                            u = u.sibling;
                                else {
                                    if (ls(),
                                    h === S) {
                                        s = Dr(i, s, u);
                                        break e
                                    }
                                    Fi(i, s, h, u)
                                }
                                s = s.child
                            }
                            return s;
                        case 26:
                            return _u(i, s),
                            i === null ? (u = zx(s.type, null, s.pendingProps, null)) ? s.memoizedState = u : fn || (u = s.type,
                            i = s.pendingProps,
                            h = Wg(Ne.current).createElement(u),
                            h[Zn] = s,
                            h[Ci] = i,
                            _a(h, u, i),
                            he(h),
                            s.stateNode = h) : s.memoizedState = zx(s.type, i.memoizedProps, s.pendingProps, i.memoizedState),
                            null;
                        case 27:
                            return Ft(s),
                            i === null && fn && (h = s.stateNode = Ix(s.type, s.pendingProps, Ne.current),
                            Ni = s,
                            Fa = !0,
                            S = on,
                            uc(s.type) ? (Xy = S,
                            on = lr(h.firstChild)) : on = S),
                            Fi(i, s, s.pendingProps.children, u),
                            _u(i, s),
                            i === null && (s.flags |= 4194304),
                            s.child;
                        case 5:
                            return i === null && fn && ((S = h = on) && (h = u2(h, s.type, s.pendingProps, Fa),
                            h !== null ? (s.stateNode = h,
                            Ni = s,
                            on = lr(h.firstChild),
                            Fa = !1,
                            S = !0) : S = !1),
                            S || no(s)),
                            Ft(s),
                            S = s.type,
                            b = s.pendingProps,
                            D = i !== null ? i.memoizedProps : null,
                            h = b.children,
                            Vy(S, b) ? h = null : D !== null && Vy(S, D) && (s.flags |= 32),
                            s.memoizedState !== null && (S = Mi(i, s, Ey, null, null, u),
                            Mp._currentValue = S),
                            _u(i, s),
                            Fi(i, s, h, u),
                            s.child;
                        case 6:
                            return i === null && fn && ((i = u = on) && (u = f2(u, s.pendingProps, Fa),
                            u !== null ? (s.stateNode = u,
                            Ni = s,
                            on = null,
                            i = !0) : i = !1),
                            i || no(s)),
                            null;
                        case 13:
                            return Ig(i, s, u);
                        case 4:
                            return at(s, s.stateNode.containerInfo),
                            h = s.pendingProps,
                            i === null ? s.child = tl(s, null, h, u) : Fi(i, s, h, u),
                            s.child;
                        case 11:
                            return cp(i, s, s.type, s.pendingProps, u);
                        case 7:
                            return Fi(i, s, s.pendingProps, u),
                            s.child;
                        case 8:
                            return Fi(i, s, s.pendingProps.children, u),
                            s.child;
                        case 12:
                            return Fi(i, s, s.pendingProps.children, u),
                            s.child;
                        case 10:
                            return h = s.pendingProps,
                            Zs(s, s.type, h.value),
                            Fi(i, s, h.children, u),
                            s.child;
                        case 9:
                            return S = s.type._context,
                            h = s.pendingProps.children,
                            us(s),
                            S = xi(S),
                            h = h(S),
                            s.flags |= 1,
                            Fi(i, s, h, u),
                            s.child;
                        case 14:
                            return Dg(i, s, s.type, s.pendingProps, u);
                        case 15:
                            return Ng(i, s, s.type, s.pendingProps, u);
                        case 19:
                            return Og(i, s, u);
                        case 31:
                            return Iy(i, s, u);
                        case 22:
                            return Lg(i, s, u, s.pendingProps);
                        case 24:
                            return us(s),
                            h = xi(pi),
                            i === null ? (S = uu(),
                            S === null && (S = yn,
                            b = Ko(),
                            S.pooledCache = b,
                            b.refCount++,
                            b !== null && (S.pooledCacheLanes |= u),
                            S = b),
                            s.memoizedState = {
                                parent: h,
                                cache: S
                            },
                            lo(s),
                            Zs(s, pi, S)) : ((i.lanes & u) !== 0 && (Of(i, s),
                            il(s, null, null, u),
                            nl()),
                            S = i.memoizedState,
                            b = s.memoizedState,
                            S.parent !== h ? (S = {
                                parent: h,
                                cache: h
                            },
                            s.memoizedState = S,
                            s.lanes === 0 && (s.memoizedState = s.updateQueue.baseState = S),
                            Zs(s, pi, h)) : (h = b.cache,
                            Zs(s, pi, h),
                            h !== S.cache && Od(s, [pi], u, !0))),
                            Fi(i, s, s.pendingProps.children, u),
                            s.child;
                        case 29:
                            throw s.pendingProps
                        }
                        throw Error(r(156, s.tag))
                    }
                    function Ls(i) {
                        i.flags |= 4
                    }
                    function hp(i, s, u, h, S) {
                        if ((s = (i.mode & 32) !== 0) && (s = !1),
                        s) {
                            if (i.flags |= 16777216,
                            (S & 335544128) === S)
                                if (i.stateNode.complete)
                                    i.flags |= 8192;
                                else if (sn())
                                    i.flags |= 8192;
                                else
                                    throw oo = fu,
                                    Ar
                        } else
                            i.flags &= -16777217
                    }
                    function Bg(i, s) {
                        if (s.type !== "stylesheet" || (s.state.loading & 4) !== 0)
                            i.flags &= -16777217;
                        else if (i.flags |= 16777216,
                        !Hx(s))
                            if (sn())
                                i.flags |= 8192;
                            else
                                throw oo = fu,
                                Ar
                    }
                    function eh(i, s) {
                        s !== null && (i.flags |= 4),
                        i.flags & 16384 && (s = i.tag !== 22 ? xn() : 536870912,
                        i.lanes |= s,
                        Or |= s)
                    }
                    function Nr(i, s) {
                        if (!fn)
                            switch (i.tailMode) {
                            case "hidden":
                                s = i.tail;
                                for (var u = null; s !== null; )
                                    s.alternate !== null && (u = s),
                                    s = s.sibling;
                                u === null ? i.tail = null : u.sibling = null;
                                break;
                            case "collapsed":
                                u = i.tail;
                                for (var h = null; u !== null; )
                                    u.alternate !== null && (h = u),
                                    u = u.sibling;
                                h === null ? s || i.tail === null ? i.tail = null : i.tail.sibling = null : h.sibling = null
                            }
                    }
                    function ln(i) {
                        var s = i.alternate !== null && i.alternate.child === i.child
                          , u = 0
                          , h = 0;
                        if (s)
                            for (var S = i.child; S !== null; )
                                u |= S.lanes | S.childLanes,
                                h |= S.subtreeFlags & 65011712,
                                h |= S.flags & 65011712,
                                S.return = i,
                                S = S.sibling;
                        else
                            for (S = i.child; S !== null; )
                                u |= S.lanes | S.childLanes,
                                h |= S.subtreeFlags,
                                h |= S.flags,
                                S.return = i,
                                S = S.sibling;
                        return i.subtreeFlags |= h,
                        i.childLanes = u,
                        s
                    }
                    function Wa(i, s, u) {
                        var h = s.pendingProps;
                        switch (ou(s),
                        s.tag) {
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return ln(s),
                            null;
                        case 1:
                            return ln(s),
                            null;
                        case 3:
                            return u = s.stateNode,
                            h = null,
                            i !== null && (h = i.memoizedState.cache),
                            s.memoizedState.cache !== h && (s.flags |= 2048),
                            Tr(pi),
                            Je(),
                            u.pendingContext && (u.context = u.pendingContext,
                            u.pendingContext = null),
                            (i === null || i.child === null) && (io(s) ? Ls(s) : i === null || i.memoizedState.isDehydrated && (s.flags & 256) === 0 || (s.flags |= 1024,
                            Nf())),
                            ln(s),
                            null;
                        case 26:
                            var S = s.type
                              , b = s.memoizedState;
                            return i === null ? (Ls(s),
                            b !== null ? (ln(s),
                            Bg(s, b)) : (ln(s),
                            hp(s, S, null, h, u))) : b ? b !== i.memoizedState ? (Ls(s),
                            ln(s),
                            Bg(s, b)) : (ln(s),
                            s.flags &= -16777217) : (i = i.memoizedProps,
                            i !== h && Ls(s),
                            ln(s),
                            hp(s, S, i, h, u)),
                            null;
                        case 27:
                            if (Vt(s),
                            u = Ne.current,
                            S = s.type,
                            i !== null && s.stateNode != null)
                                i.memoizedProps !== h && Ls(s);
                            else {
                                if (!h) {
                                    if (s.stateNode === null)
                                        throw Error(r(166));
                                    return ln(s),
                                    null
                                }
                                i = le.current,
                                io(s) ? Mr(s, i) : (i = Ix(S, h, u),
                                s.stateNode = i,
                                Ls(s))
                            }
                            return ln(s),
                            null;
                        case 5:
                            if (Vt(s),
                            S = s.type,
                            i !== null && s.stateNode != null)
                                i.memoizedProps !== h && Ls(s);
                            else {
                                if (!h) {
                                    if (s.stateNode === null)
                                        throw Error(r(166));
                                    return ln(s),
                                    null
                                }
                                if (b = le.current,
                                io(s))
                                    Mr(s, b);
                                else {
                                    var D = Wg(Ne.current);
                                    switch (b) {
                                    case 1:
                                        b = D.createElementNS("http://www.w3.org/2000/svg", S);
                                        break;
                                    case 2:
                                        b = D.createElementNS("http://www.w3.org/1998/Math/MathML", S);
                                        break;
                                    default:
                                        switch (S) {
                                        case "svg":
                                            b = D.createElementNS("http://www.w3.org/2000/svg", S);
                                            break;
                                        case "math":
                                            b = D.createElementNS("http://www.w3.org/1998/Math/MathML", S);
                                            break;
                                        case "script":
                                            b = D.createElement("div"),
                                            b.innerHTML = "<script><\/script>",
                                            b = b.removeChild(b.firstChild);
                                            break;
                                        case "select":
                                            b = typeof h.is == "string" ? D.createElement("select", {
                                                is: h.is
                                            }) : D.createElement("select"),
                                            h.multiple ? b.multiple = !0 : h.size && (b.size = h.size);
                                            break;
                                        default:
                                            b = typeof h.is == "string" ? D.createElement(S, {
                                                is: h.is
                                            }) : D.createElement(S)
                                        }
                                    }
                                    b[Zn] = s,
                                    b[Ci] = h;
                                    e: for (D = s.child; D !== null; ) {
                                        if (D.tag === 5 || D.tag === 6)
                                            b.appendChild(D.stateNode);
                                        else if (D.tag !== 4 && D.tag !== 27 && D.child !== null) {
                                            D.child.return = D,
                                            D = D.child;
                                            continue
                                        }
                                        if (D === s)
                                            break e;
                                        for (; D.sibling === null; ) {
                                            if (D.return === null || D.return === s)
                                                break e;
                                            D = D.return
                                        }
                                        D.sibling.return = D.return,
                                        D = D.sibling
                                    }
                                    s.stateNode = b;
                                    e: switch (_a(b, S, h),
                                    S) {
                                    case "button":
                                    case "input":
                                    case "select":
                                    case "textarea":
                                        h = !!h.autoFocus;
                                        break e;
                                    case "img":
                                        h = !0;
                                        break e;
                                    default:
                                        h = !1
                                    }
                                    h && Ls(s)
                                }
                            }
                            return ln(s),
                            hp(s, s.type, i === null ? null : i.memoizedProps, s.pendingProps, u),
                            null;
                        case 6:
                            if (i && s.stateNode != null)
                                i.memoizedProps !== h && Ls(s);
                            else {
                                if (typeof h != "string" && s.stateNode === null)
                                    throw Error(r(166));
                                if (i = Ne.current,
                                io(s)) {
                                    if (i = s.stateNode,
                                    u = s.memoizedProps,
                                    h = null,
                                    S = Ni,
                                    S !== null)
                                        switch (S.tag) {
                                        case 27:
                                        case 5:
                                            h = S.memoizedProps
                                        }
                                    i[Zn] = s,
                                    i = !!(i.nodeValue === u || h !== null && h.suppressHydrationWarning === !0 || Mx(i.nodeValue, u)),
                                    i || no(s, !0)
                                } else
                                    i = Wg(i).createTextNode(h),
                                    i[Zn] = s,
                                    s.stateNode = i
                            }
                            return ln(s),
                            null;
                        case 31:
                            if (u = s.memoizedState,
                            i === null || i.memoizedState !== null) {
                                if (h = io(s),
                                u !== null) {
                                    if (i === null) {
                                        if (!h)
                                            throw Error(r(318));
                                        if (i = s.memoizedState,
                                        i = i !== null ? i.dehydrated : null,
                                        !i)
                                            throw Error(r(557));
                                        i[Zn] = s
                                    } else
                                        ls(),
                                        (s.flags & 128) === 0 && (s.memoizedState = null),
                                        s.flags |= 4;
                                    ln(s),
                                    i = !1
                                } else
                                    u = Nf(),
                                    i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = u),
                                    i = !0;
                                if (!i)
                                    return s.flags & 256 ? (Ha(s),
                                    s) : (Ha(s),
                                    null);
                                if ((s.flags & 128) !== 0)
                                    throw Error(r(558))
                            }
                            return ln(s),
                            null;
                        case 13:
                            if (h = s.memoizedState,
                            i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
                                if (S = io(s),
                                h !== null && h.dehydrated !== null) {
                                    if (i === null) {
                                        if (!S)
                                            throw Error(r(318));
                                        if (S = s.memoizedState,
                                        S = S !== null ? S.dehydrated : null,
                                        !S)
                                            throw Error(r(317));
                                        S[Zn] = s
                                    } else
                                        ls(),
                                        (s.flags & 128) === 0 && (s.memoizedState = null),
                                        s.flags |= 4;
                                    ln(s),
                                    S = !1
                                } else
                                    S = Nf(),
                                    i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = S),
                                    S = !0;
                                if (!S)
                                    return s.flags & 256 ? (Ha(s),
                                    s) : (Ha(s),
                                    null)
                            }
                            return Ha(s),
                            (s.flags & 128) !== 0 ? (s.lanes = u,
                            s) : (u = h !== null,
                            i = i !== null && i.memoizedState !== null,
                            u && (h = s.child,
                            S = null,
                            h.alternate !== null && h.alternate.memoizedState !== null && h.alternate.memoizedState.cachePool !== null && (S = h.alternate.memoizedState.cachePool.pool),
                            b = null,
                            h.memoizedState !== null && h.memoizedState.cachePool !== null && (b = h.memoizedState.cachePool.pool),
                            b !== S && (h.flags |= 2048)),
                            u !== i && u && (s.child.flags |= 8192),
                            eh(s, s.updateQueue),
                            ln(s),
                            null);
                        case 4:
                            return Je(),
                            i === null && Lt(s.stateNode.containerInfo),
                            ln(s),
                            null;
                        case 10:
                            return Tr(s.type),
                            ln(s),
                            null;
                        case 19:
                            if (ve(mi),
                            h = s.memoizedState,
                            h === null)
                                return ln(s),
                                null;
                            if (S = (s.flags & 128) !== 0,
                            b = h.rendering,
                            b === null)
                                if (S)
                                    Nr(h, !1);
                                else {
                                    if (Pt !== 0 || i !== null && (i.flags & 128) !== 0)
                                        for (i = s.child; i !== null; ) {
                                            if (b = zf(i),
                                            b !== null) {
                                                for (s.flags |= 128,
                                                Nr(h, !1),
                                                i = b.updateQueue,
                                                s.updateQueue = i,
                                                eh(s, i),
                                                s.subtreeFlags = 0,
                                                i = u,
                                                u = s.child; u !== null; )
                                                    ea(u, i),
                                                    u = u.sibling;
                                                return Re(mi, mi.current & 1 | 2),
                                                fn && js(s, h.treeForkCount),
                                                s.child
                                            }
                                            i = i.sibling
                                        }
                                    h.tail !== null && oe() > nc && (s.flags |= 128,
                                    S = !0,
                                    Nr(h, !1),
                                    s.lanes = 4194304)
                                }
                            else {
                                if (!S)
                                    if (i = zf(b),
                                    i !== null) {
                                        if (s.flags |= 128,
                                        S = !0,
                                        i = i.updateQueue,
                                        s.updateQueue = i,
                                        eh(s, i),
                                        Nr(h, !0),
                                        h.tail === null && h.tailMode === "hidden" && !b.alternate && !fn)
                                            return ln(s),
                                            null
                                    } else
                                        2 * oe() - h.renderingStartTime > nc && u !== 536870912 && (s.flags |= 128,
                                        S = !0,
                                        Nr(h, !1),
                                        s.lanes = 4194304);
                                h.isBackwards ? (b.sibling = s.child,
                                s.child = b) : (i = h.last,
                                i !== null ? i.sibling = b : s.child = b,
                                h.last = b)
                            }
                            return h.tail !== null ? (i = h.tail,
                            h.rendering = i,
                            h.tail = i.sibling,
                            h.renderingStartTime = oe(),
                            i.sibling = null,
                            u = mi.current,
                            Re(mi, S ? u & 1 | 2 : u & 1),
                            fn && js(s, h.treeForkCount),
                            i) : (ln(s),
                            null);
                        case 22:
                        case 23:
                            return Ha(s),
                            Dt(),
                            h = s.memoizedState !== null,
                            i !== null ? i.memoizedState !== null !== h && (s.flags |= 8192) : h && (s.flags |= 8192),
                            h ? (u & 536870912) !== 0 && (s.flags & 128) === 0 && (ln(s),
                            s.subtreeFlags & 6 && (s.flags |= 8192)) : ln(s),
                            u = s.updateQueue,
                            u !== null && eh(s, u.retryQueue),
                            u = null,
                            i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (u = i.memoizedState.cachePool.pool),
                            h = null,
                            s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool),
                            h !== u && (s.flags |= 2048),
                            i !== null && ve(Jo),
                            null;
                        case 24:
                            return u = null,
                            i !== null && (u = i.memoizedState.cache),
                            s.memoizedState.cache !== u && (s.flags |= 2048),
                            Tr(pi),
                            ln(s),
                            null;
                        case 25:
                            return null;
                        case 30:
                            return null
                        }
                        throw Error(r(156, s.tag))
                    }
                    function Fg(i, s) {
                        switch (ou(s),
                        s.tag) {
                        case 1:
                            return i = s.flags,
                            i & 65536 ? (s.flags = i & -65537 | 128,
                            s) : null;
                        case 3:
                            return Tr(pi),
                            Je(),
                            i = s.flags,
                            (i & 65536) !== 0 && (i & 128) === 0 ? (s.flags = i & -65537 | 128,
                            s) : null;
                        case 26:
                        case 27:
                        case 5:
                            return Vt(s),
                            null;
                        case 31:
                            if (s.memoizedState !== null) {
                                if (Ha(s),
                                s.alternate === null)
                                    throw Error(r(340));
                                ls()
                            }
                            return i = s.flags,
                            i & 65536 ? (s.flags = i & -65537 | 128,
                            s) : null;
                        case 13:
                            if (Ha(s),
                            i = s.memoizedState,
                            i !== null && i.dehydrated !== null) {
                                if (s.alternate === null)
                                    throw Error(r(340));
                                ls()
                            }
                            return i = s.flags,
                            i & 65536 ? (s.flags = i & -65537 | 128,
                            s) : null;
                        case 19:
                            return ve(mi),
                            null;
                        case 4:
                            return Je(),
                            null;
                        case 10:
                            return Tr(s.type),
                            null;
                        case 22:
                        case 23:
                            return Ha(s),
                            Dt(),
                            i !== null && ve(Jo),
                            i = s.flags,
                            i & 65536 ? (s.flags = i & -65537 | 128,
                            s) : null;
                        case 24:
                            return Tr(pi),
                            null;
                        case 25:
                            return null;
                        default:
                            return null
                        }
                    }
                    function Vg(i, s) {
                        switch (ou(s),
                        s.tag) {
                        case 3:
                            Tr(pi),
                            Je();
                            break;
                        case 26:
                        case 27:
                        case 5:
                            Vt(s);
                            break;
                        case 4:
                            Je();
                            break;
                        case 31:
                            s.memoizedState !== null && Ha(s);
                            break;
                        case 13:
                            Ha(s);
                            break;
                        case 19:
                            ve(mi);
                            break;
                        case 10:
                            Tr(s.type);
                            break;
                        case 22:
                        case 23:
                            Ha(s),
                            Dt(),
                            i !== null && ve(Jo);
                            break;
                        case 24:
                            Tr(pi)
                        }
                    }
                    function cl(i, s) {
                        try {
                            var u = s.updateQueue
                              , h = u !== null ? u.lastEffect : null;
                            if (h !== null) {
                                var S = h.next;
                                u = S;
                                do {
                                    if ((u.tag & i) === i) {
                                        h = void 0;
                                        var b = u.create
                                          , D = u.inst;
                                        h = b(),
                                        D.destroy = h
                                    }
                                    u = u.next
                                } while (u !== S)
                            }
                        } catch (F) {
                            Tn(s, s.return, F)
                        }
                    }
                    function Lr(i, s, u) {
                        try {
                            var h = s.updateQueue
                              , S = h !== null ? h.lastEffect : null;
                            if (S !== null) {
                                var b = S.next;
                                h = b;
                                do {
                                    if ((h.tag & i) === i) {
                                        var D = h.inst
                                          , F = D.destroy;
                                        if (F !== void 0) {
                                            D.destroy = void 0,
                                            S = s;
                                            var ee = u
                                              , pe = F;
                                            try {
                                                pe()
                                            } catch (De) {
                                                Tn(S, ee, De)
                                            }
                                        }
                                    }
                                    h = h.next
                                } while (h !== b)
                            }
                        } catch (De) {
                            Tn(s, s.return, De)
                        }
                    }
                    function th(i) {
                        var s = i.updateQueue;
                        if (s !== null) {
                            var u = i.stateNode;
                            try {
                                Pf(s, u)
                            } catch (h) {
                                Tn(i, i.return, h)
                            }
                        }
                    }
                    function dp(i, s, u) {
                        u.props = sl(i.type, i.memoizedProps),
                        u.state = i.memoizedState;
                        try {
                            u.componentWillUnmount()
                        } catch (h) {
                            Tn(i, s, h)
                        }
                    }
                    function Ks(i, s) {
                        try {
                            var u = i.ref;
                            if (u !== null) {
                                switch (i.tag) {
                                case 26:
                                case 27:
                                case 5:
                                    var h = i.stateNode;
                                    break;
                                case 30:
                                    h = i.stateNode;
                                    break;
                                default:
                                    h = i.stateNode
                                }
                                typeof u == "function" ? i.refCleanup = u(h) : u.current = h
                            }
                        } catch (S) {
                            Tn(i, s, S)
                        }
                    }
                    function va(i, s) {
                        var u = i.ref
                          , h = i.refCleanup;
                        if (u !== null)
                            if (typeof h == "function")
                                try {
                                    h()
                                } catch (S) {
                                    Tn(i, s, S)
                                } finally {
                                    i.refCleanup = null,
                                    i = i.alternate,
                                    i != null && (i.refCleanup = null)
                                }
                            else if (typeof u == "function")
                                try {
                                    u(null)
                                } catch (S) {
                                    Tn(i, s, S)
                                }
                            else
                                u.current = null
                    }
                    function bu(i) {
                        var s = i.type
                          , u = i.memoizedProps
                          , h = i.stateNode;
                        try {
                            e: switch (s) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                u.autoFocus && h.focus();
                                break e;
                            case "img":
                                u.src ? h.src = u.src : u.srcSet && (h.srcset = u.srcSet)
                            }
                        } catch (S) {
                            Tn(i, i.return, S)
                        }
                    }
                    function ul(i, s, u) {
                        try {
                            var h = i.stateNode;
                            a2(h, i.type, u, s),
                            h[Ci] = s
                        } catch (S) {
                            Tn(i, i.return, S)
                        }
                    }
                    function Xa(i) {
                        return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && uc(i.type) || i.tag === 4
                    }
                    function Ma(i) {
                        e: for (; ; ) {
                            for (; i.sibling === null; ) {
                                if (i.return === null || Xa(i.return))
                                    return null;
                                i = i.return
                            }
                            for (i.sibling.return = i.return,
                            i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
                                if (i.tag === 27 && uc(i.type) || i.flags & 2 || i.child === null || i.tag === 4)
                                    continue e;
                                i.child.return = i,
                                i = i.child
                            }
                            if (!(i.flags & 2))
                                return i.stateNode
                        }
                    }
                    function Js(i, s, u) {
                        var h = i.tag;
                        if (h === 5 || h === 6)
                            i = i.stateNode,
                            s ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(i, s) : (s = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u,
                            s.appendChild(i),
                            u = u._reactRootContainer,
                            u != null || s.onclick !== null || (s.onclick = Gs));
                        else if (h !== 4 && (h === 27 && uc(i.type) && (u = i.stateNode,
                        s = null),
                        i = i.child,
                        i !== null))
                            for (Js(i, s, u),
                            i = i.sibling; i !== null; )
                                Js(i, s, u),
                                i = i.sibling
                    }
                    function qa(i, s, u) {
                        var h = i.tag;
                        if (h === 5 || h === 6)
                            i = i.stateNode,
                            s ? u.insertBefore(i, s) : u.appendChild(i);
                        else if (h !== 4 && (h === 27 && uc(i.type) && (u = i.stateNode),
                        i = i.child,
                        i !== null))
                            for (qa(i, s, u),
                            i = i.sibling; i !== null; )
                                qa(i, s, u),
                                i = i.sibling
                    }
                    function Us(i) {
                        var s = i.stateNode
                          , u = i.memoizedProps;
                        try {
                            for (var h = i.type, S = s.attributes; S.length; )
                                s.removeAttributeNode(S[0]);
                            _a(s, h, u),
                            s[Zn] = i,
                            s[Ci] = u
                        } catch (b) {
                            Tn(i, i.return, b)
                        }
                    }
                    var Wn = !1
                      , Qn = !1
                      , $s = !1
                      , Mu = typeof WeakSet == "function" ? WeakSet : Set
                      , vn = null;
                    function $n(i, s) {
                        if (i = i.containerInfo,
                        By = Kg,
                        i = Cd(i),
                        Jc(i)) {
                            if ("selectionStart"in i)
                                var u = {
                                    start: i.selectionStart,
                                    end: i.selectionEnd
                                };
                            else
                                e: {
                                    u = (u = i.ownerDocument) && u.defaultView || window;
                                    var h = u.getSelection && u.getSelection();
                                    if (h && h.rangeCount !== 0) {
                                        u = h.anchorNode;
                                        var S = h.anchorOffset
                                          , b = h.focusNode;
                                        h = h.focusOffset;
                                        try {
                                            u.nodeType,
                                            b.nodeType
                                        } catch {
                                            u = null;
                                            break e
                                        }
                                        var D = 0
                                          , F = -1
                                          , ee = -1
                                          , pe = 0
                                          , De = 0
                                          , Ie = i
                                          , ge = null;
                                        t: for (; ; ) {
                                            for (var Se; Ie !== u || S !== 0 && Ie.nodeType !== 3 || (F = D + S),
                                            Ie !== b || h !== 0 && Ie.nodeType !== 3 || (ee = D + h),
                                            Ie.nodeType === 3 && (D += Ie.nodeValue.length),
                                            (Se = Ie.firstChild) !== null; )
                                                ge = Ie,
                                                Ie = Se;
                                            for (; ; ) {
                                                if (Ie === i)
                                                    break t;
                                                if (ge === u && ++pe === S && (F = D),
                                                ge === b && ++De === h && (ee = D),
                                                (Se = Ie.nextSibling) !== null)
                                                    break;
                                                Ie = ge,
                                                ge = Ie.parentNode
                                            }
                                            Ie = Se
                                        }
                                        u = F === -1 || ee === -1 ? null : {
                                            start: F,
                                            end: ee
                                        }
                                    } else
                                        u = null
                                }
                            u = u || {
                                start: 0,
                                end: 0
                            }
                        } else
                            u = null;
                        for (Fy = {
                            focusedElem: i,
                            selectionRange: u
                        },
                        Kg = !1,
                        vn = s; vn !== null; )
                            if (s = vn,
                            i = s.child,
                            (s.subtreeFlags & 1028) !== 0 && i !== null)
                                i.return = s,
                                vn = i;
                            else
                                for (; vn !== null; ) {
                                    switch (s = vn,
                                    b = s.alternate,
                                    i = s.flags,
                                    s.tag) {
                                    case 0:
                                        if ((i & 4) !== 0 && (i = s.updateQueue,
                                        i = i !== null ? i.events : null,
                                        i !== null))
                                            for (u = 0; u < i.length; u++)
                                                S = i[u],
                                                S.ref.impl = S.nextImpl;
                                        break;
                                    case 11:
                                    case 15:
                                        break;
                                    case 1:
                                        if ((i & 1024) !== 0 && b !== null) {
                                            i = void 0,
                                            u = s,
                                            S = b.memoizedProps,
                                            b = b.memoizedState,
                                            h = u.stateNode;
                                            try {
                                                var yt = sl(u.type, S);
                                                i = h.getSnapshotBeforeUpdate(yt, b),
                                                h.__reactInternalSnapshotBeforeUpdate = i
                                            } catch (zt) {
                                                Tn(u, u.return, zt)
                                            }
                                        }
                                        break;
                                    case 3:
                                        if ((i & 1024) !== 0) {
                                            if (i = s.stateNode.containerInfo,
                                            u = i.nodeType,
                                            u === 9)
                                                Hy(i);
                                            else if (u === 1)
                                                switch (i.nodeName) {
                                                case "HEAD":
                                                case "HTML":
                                                case "BODY":
                                                    Hy(i);
                                                    break;
                                                default:
                                                    i.textContent = ""
                                                }
                                        }
                                        break;
                                    case 5:
                                    case 26:
                                    case 27:
                                    case 6:
                                    case 4:
                                    case 17:
                                        break;
                                    default:
                                        if ((i & 1024) !== 0)
                                            throw Error(r(163))
                                    }
                                    if (i = s.sibling,
                                    i !== null) {
                                        i.return = s.return,
                                        vn = i;
                                        break
                                    }
                                    vn = s.return
                                }
                    }
                    function hn(i, s, u) {
                        var h = u.flags;
                        switch (u.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Is(i, u),
                            h & 4 && cl(5, u);
                            break;
                        case 1:
                            if (Is(i, u),
                            h & 4)
                                if (i = u.stateNode,
                                s === null)
                                    try {
                                        i.componentDidMount()
                                    } catch (D) {
                                        Tn(u, u.return, D)
                                    }
                                else {
                                    var S = sl(u.type, s.memoizedProps);
                                    s = s.memoizedState;
                                    try {
                                        i.componentDidUpdate(S, s, i.__reactInternalSnapshotBeforeUpdate)
                                    } catch (D) {
                                        Tn(u, u.return, D)
                                    }
                                }
                            h & 64 && th(u),
                            h & 512 && Ks(u, u.return);
                            break;
                        case 3:
                            if (Is(i, u),
                            h & 64 && (i = u.updateQueue,
                            i !== null)) {
                                if (s = null,
                                u.child !== null)
                                    switch (u.child.tag) {
                                    case 27:
                                    case 5:
                                        s = u.child.stateNode;
                                        break;
                                    case 1:
                                        s = u.child.stateNode
                                    }
                                try {
                                    Pf(i, s)
                                } catch (D) {
                                    Tn(u, u.return, D)
                                }
                            }
                            break;
                        case 27:
                            s === null && h & 4 && Us(u);
                        case 26:
                        case 5:
                            Is(i, u),
                            s === null && h & 4 && bu(u),
                            h & 512 && Ks(u, u.return);
                            break;
                        case 12:
                            Is(i, u);
                            break;
                        case 31:
                            Is(i, u),
                            h & 4 && er(i, u);
                            break;
                        case 13:
                            Is(i, u),
                            h & 4 && kg(i, u),
                            h & 64 && (i = u.memoizedState,
                            i !== null && (i = i.dehydrated,
                            i !== null && (u = Mo.bind(null, u),
                            h2(i, u))));
                            break;
                        case 22:
                            if (h = u.memoizedState !== null || Wn,
                            !h) {
                                s = s !== null && s.memoizedState !== null || Qn,
                                S = Wn;
                                var b = Qn;
                                Wn = h,
                                (Qn = s) && !b ? ja(i, u, (u.subtreeFlags & 8772) !== 0) : Is(i, u),
                                Wn = S,
                                Qn = b
                            }
                            break;
                        case 30:
                            break;
                        default:
                            Is(i, u)
                        }
                    }
                    function Ur(i) {
                        var s = i.alternate;
                        s !== null && (i.alternate = null,
                        Ur(s)),
                        i.child = null,
                        i.deletions = null,
                        i.sibling = null,
                        i.tag === 5 && (s = i.stateNode,
                        s !== null && Dl(s)),
                        i.stateNode = null,
                        i.return = null,
                        i.dependencies = null,
                        i.memoizedProps = null,
                        i.memoizedState = null,
                        i.pendingProps = null,
                        i.stateNode = null,
                        i.updateQueue = null
                    }
                    var mn = null
                      , aa = !1;
                    function gs(i, s, u) {
                        for (u = u.child; u !== null; )
                            po(i, s, u),
                            u = u.sibling
                    }
                    function po(i, s, u) {
                        if (rt && typeof rt.onCommitFiberUnmount == "function")
                            try {
                                rt.onCommitFiberUnmount(We, u)
                            } catch {}
                        switch (u.tag) {
                        case 26:
                            Qn || va(u, s),
                            gs(i, s, u),
                            u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode,
                            u.parentNode.removeChild(u));
                            break;
                        case 27:
                            Qn || va(u, s);
                            var h = mn
                              , S = aa;
                            uc(u.type) && (mn = u.stateNode,
                            aa = !1),
                            gs(i, s, u),
                            Sp(u.stateNode),
                            mn = h,
                            aa = S;
                            break;
                        case 5:
                            Qn || va(u, s);
                        case 6:
                            if (h = mn,
                            S = aa,
                            mn = null,
                            gs(i, s, u),
                            mn = h,
                            aa = S,
                            mn !== null)
                                if (aa)
                                    try {
                                        (mn.nodeType === 9 ? mn.body : mn.nodeName === "HTML" ? mn.ownerDocument.body : mn).removeChild(u.stateNode)
                                    } catch (b) {
                                        Tn(u, s, b)
                                    }
                                else
                                    try {
                                        mn.removeChild(u.stateNode)
                                    } catch (b) {
                                        Tn(u, s, b)
                                    }
                            break;
                        case 18:
                            mn !== null && (aa ? (i = mn,
                            Rx(i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i, u.stateNode),
                            uh(i)) : Rx(mn, u.stateNode));
                            break;
                        case 4:
                            h = mn,
                            S = aa,
                            mn = u.stateNode.containerInfo,
                            aa = !0,
                            gs(i, s, u),
                            mn = h,
                            aa = S;
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Lr(2, u, s),
                            Qn || Lr(4, u, s),
                            gs(i, s, u);
                            break;
                        case 1:
                            Qn || (va(u, s),
                            h = u.stateNode,
                            typeof h.componentWillUnmount == "function" && dp(u, s, h)),
                            gs(i, s, u);
                            break;
                        case 21:
                            gs(i, s, u);
                            break;
                        case 22:
                            Qn = (h = Qn) || u.memoizedState !== null,
                            gs(i, s, u),
                            Qn = h;
                            break;
                        default:
                            gs(i, s, u)
                        }
                    }
                    function er(i, s) {
                        if (s.memoizedState === null && (i = s.alternate,
                        i !== null && (i = i.memoizedState,
                        i !== null))) {
                            i = i.dehydrated;
                            try {
                                uh(i)
                            } catch (u) {
                                Tn(s, s.return, u)
                            }
                        }
                    }
                    function kg(i, s) {
                        if (s.memoizedState === null && (i = s.alternate,
                        i !== null && (i = i.memoizedState,
                        i !== null && (i = i.dehydrated,
                        i !== null))))
                            try {
                                uh(i)
                            } catch (u) {
                                Tn(s, s.return, u)
                            }
                    }
                    function Oy(i) {
                        switch (i.tag) {
                        case 31:
                        case 13:
                        case 19:
                            var s = i.stateNode;
                            return s === null && (s = i.stateNode = new Mu),
                            s;
                        case 22:
                            return i = i.stateNode,
                            s = i._retryCache,
                            s === null && (s = i._retryCache = new Mu),
                            s;
                        default:
                            throw Error(r(435, i.tag))
                        }
                    }
                    function nh(i, s) {
                        var u = Oy(i);
                        s.forEach(function(h) {
                            if (!u.has(h)) {
                                u.add(h);
                                var S = lc.bind(null, i, h);
                                h.then(S, S)
                            }
                        })
                    }
                    function dn(i, s) {
                        var u = s.deletions;
                        if (u !== null)
                            for (var h = 0; h < u.length; h++) {
                                var S = u[h]
                                  , b = i
                                  , D = s
                                  , F = D;
                                e: for (; F !== null; ) {
                                    switch (F.tag) {
                                    case 27:
                                        if (uc(F.type)) {
                                            mn = F.stateNode,
                                            aa = !1;
                                            break e
                                        }
                                        break;
                                    case 5:
                                        mn = F.stateNode,
                                        aa = !1;
                                        break e;
                                    case 3:
                                    case 4:
                                        mn = F.stateNode.containerInfo,
                                        aa = !0;
                                        break e
                                    }
                                    F = F.return
                                }
                                if (mn === null)
                                    throw Error(r(160));
                                po(b, D, S),
                                mn = null,
                                aa = !1,
                                b = S.alternate,
                                b !== null && (b.return = null),
                                S.return = null
                            }
                        if (s.subtreeFlags & 13886)
                            for (s = s.child; s !== null; )
                                fl(s, i),
                                s = s.sibling
                    }
                    var Ta = null;
                    function fl(i, s) {
                        var u = i.alternate
                          , h = i.flags;
                        switch (i.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            dn(s, i),
                            sa(i),
                            h & 4 && (Lr(3, i, i.return),
                            cl(3, i),
                            Lr(5, i, i.return));
                            break;
                        case 1:
                            dn(s, i),
                            sa(i),
                            h & 512 && (Qn || u === null || va(u, u.return)),
                            h & 64 && Wn && (i = i.updateQueue,
                            i !== null && (h = i.callbacks,
                            h !== null && (u = i.shared.hiddenCallbacks,
                            i.shared.hiddenCallbacks = u === null ? h : u.concat(h))));
                            break;
                        case 26:
                            var S = Ta;
                            if (dn(s, i),
                            sa(i),
                            h & 512 && (Qn || u === null || va(u, u.return)),
                            h & 4) {
                                var b = u !== null ? u.memoizedState : null;
                                if (h = i.memoizedState,
                                u === null)
                                    if (h === null)
                                        if (i.stateNode === null) {
                                            e: {
                                                h = i.type,
                                                u = i.memoizedProps,
                                                S = S.ownerDocument || S;
                                                t: switch (h) {
                                                case "title":
                                                    b = S.getElementsByTagName("title")[0],
                                                    (!b || b[Es] || b[Zn] || b.namespaceURI === "http://www.w3.org/2000/svg" || b.hasAttribute("itemprop")) && (b = S.createElement(h),
                                                    S.head.insertBefore(b, S.querySelector("head > title"))),
                                                    _a(b, h, u),
                                                    b[Zn] = i,
                                                    he(b),
                                                    h = b;
                                                    break e;
                                                case "link":
                                                    var D = Vx("link", "href", S).get(h + (u.href || ""));
                                                    if (D) {
                                                        for (var F = 0; F < D.length; F++)
                                                            if (b = D[F],
                                                            b.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && b.getAttribute("rel") === (u.rel == null ? null : u.rel) && b.getAttribute("title") === (u.title == null ? null : u.title) && b.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                                                                D.splice(F, 1);
                                                                break t
                                                            }
                                                    }
                                                    b = S.createElement(h),
                                                    _a(b, h, u),
                                                    S.head.appendChild(b);
                                                    break;
                                                case "meta":
                                                    if (D = Vx("meta", "content", S).get(h + (u.content || ""))) {
                                                        for (F = 0; F < D.length; F++)
                                                            if (b = D[F],
                                                            b.getAttribute("content") === (u.content == null ? null : "" + u.content) && b.getAttribute("name") === (u.name == null ? null : u.name) && b.getAttribute("property") === (u.property == null ? null : u.property) && b.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && b.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                                                                D.splice(F, 1);
                                                                break t
                                                            }
                                                    }
                                                    b = S.createElement(h),
                                                    _a(b, h, u),
                                                    S.head.appendChild(b);
                                                    break;
                                                default:
                                                    throw Error(r(468, h))
                                                }
                                                b[Zn] = i,
                                                he(b),
                                                h = b
                                            }
                                            i.stateNode = h
                                        } else
                                            kx(S, i.type, i.stateNode);
                                    else
                                        i.stateNode = Fx(S, h, i.memoizedProps);
                                else
                                    b !== h ? (b === null ? u.stateNode !== null && (u = u.stateNode,
                                    u.parentNode.removeChild(u)) : b.count--,
                                    h === null ? kx(S, i.type, i.stateNode) : Fx(S, h, i.memoizedProps)) : h === null && i.stateNode !== null && ul(i, i.memoizedProps, u.memoizedProps)
                            }
                            break;
                        case 27:
                            dn(s, i),
                            sa(i),
                            h & 512 && (Qn || u === null || va(u, u.return)),
                            u !== null && h & 4 && ul(i, i.memoizedProps, u.memoizedProps);
                            break;
                        case 5:
                            if (dn(s, i),
                            sa(i),
                            h & 512 && (Qn || u === null || va(u, u.return)),
                            i.flags & 32) {
                                S = i.stateNode;
                                try {
                                    Di(S, "")
                                } catch (yt) {
                                    Tn(i, i.return, yt)
                                }
                            }
                            h & 4 && i.stateNode != null && (S = i.memoizedProps,
                            ul(i, S, u !== null ? u.memoizedProps : S)),
                            h & 1024 && ($s = !0);
                            break;
                        case 6:
                            if (dn(s, i),
                            sa(i),
                            h & 4) {
                                if (i.stateNode === null)
                                    throw Error(r(162));
                                h = i.memoizedProps,
                                u = i.stateNode;
                                try {
                                    u.nodeValue = h
                                } catch (yt) {
                                    Tn(i, i.return, yt)
                                }
                            }
                            break;
                        case 3:
                            if (Yg = null,
                            S = Ta,
                            Ta = Xg(s.containerInfo),
                            dn(s, i),
                            Ta = S,
                            sa(i),
                            h & 4 && u !== null && u.memoizedState.isDehydrated)
                                try {
                                    uh(s.containerInfo)
                                } catch (yt) {
                                    Tn(i, i.return, yt)
                                }
                            $s && ($s = !1,
                            Tu(i));
                            break;
                        case 4:
                            h = Ta,
                            Ta = Xg(i.stateNode.containerInfo),
                            dn(s, i),
                            sa(i),
                            Ta = h;
                            break;
                        case 12:
                            dn(s, i),
                            sa(i);
                            break;
                        case 31:
                            dn(s, i),
                            sa(i),
                            h & 4 && (h = i.updateQueue,
                            h !== null && (i.updateQueue = null,
                            nh(i, h)));
                            break;
                        case 13:
                            dn(s, i),
                            sa(i),
                            i.child.flags & 8192 && i.memoizedState !== null != (u !== null && u.memoizedState !== null) && (yo = oe()),
                            h & 4 && (h = i.updateQueue,
                            h !== null && (i.updateQueue = null,
                            nh(i, h)));
                            break;
                        case 22:
                            S = i.memoizedState !== null;
                            var ee = u !== null && u.memoizedState !== null
                              , pe = Wn
                              , De = Qn;
                            if (Wn = pe || S,
                            Qn = De || ee,
                            dn(s, i),
                            Qn = De,
                            Wn = pe,
                            sa(i),
                            h & 8192)
                                e: for (s = i.stateNode,
                                s._visibility = S ? s._visibility & -2 : s._visibility | 1,
                                S && (u === null || ee || Wn || Qn || Ya(i)),
                                u = null,
                                s = i; ; ) {
                                    if (s.tag === 5 || s.tag === 26) {
                                        if (u === null) {
                                            ee = u = s;
                                            try {
                                                if (b = ee.stateNode,
                                                S)
                                                    D = b.style,
                                                    typeof D.setProperty == "function" ? D.setProperty("display", "none", "important") : D.display = "none";
                                                else {
                                                    F = ee.stateNode;
                                                    var Ie = ee.memoizedProps.style
                                                      , ge = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null;
                                                    F.style.display = ge == null || typeof ge == "boolean" ? "" : ("" + ge).trim()
                                                }
                                            } catch (yt) {
                                                Tn(ee, ee.return, yt)
                                            }
                                        }
                                    } else if (s.tag === 6) {
                                        if (u === null) {
                                            ee = s;
                                            try {
                                                ee.stateNode.nodeValue = S ? "" : ee.memoizedProps
                                            } catch (yt) {
                                                Tn(ee, ee.return, yt)
                                            }
                                        }
                                    } else if (s.tag === 18) {
                                        if (u === null) {
                                            ee = s;
                                            try {
                                                var Se = ee.stateNode;
                                                S ? Dx(Se, !0) : Dx(ee.stateNode, !1)
                                            } catch (yt) {
                                                Tn(ee, ee.return, yt)
                                            }
                                        }
                                    } else if ((s.tag !== 22 && s.tag !== 23 || s.memoizedState === null || s === i) && s.child !== null) {
                                        s.child.return = s,
                                        s = s.child;
                                        continue
                                    }
                                    if (s === i)
                                        break e;
                                    for (; s.sibling === null; ) {
                                        if (s.return === null || s.return === i)
                                            break e;
                                        u === s && (u = null),
                                        s = s.return
                                    }
                                    u === s && (u = null),
                                    s.sibling.return = s.return,
                                    s = s.sibling
                                }
                            h & 4 && (h = i.updateQueue,
                            h !== null && (u = h.retryQueue,
                            u !== null && (h.retryQueue = null,
                            nh(i, u))));
                            break;
                        case 19:
                            dn(s, i),
                            sa(i),
                            h & 4 && (h = i.updateQueue,
                            h !== null && (i.updateQueue = null,
                            nh(i, h)));
                            break;
                        case 30:
                            break;
                        case 21:
                            break;
                        default:
                            dn(s, i),
                            sa(i)
                        }
                    }
                    function sa(i) {
                        var s = i.flags;
                        if (s & 2) {
                            try {
                                for (var u, h = i.return; h !== null; ) {
                                    if (Xa(h)) {
                                        u = h;
                                        break
                                    }
                                    h = h.return
                                }
                                if (u == null)
                                    throw Error(r(160));
                                switch (u.tag) {
                                case 27:
                                    var S = u.stateNode;
                                    qa(i, Ma(i), S);
                                    break;
                                case 5:
                                    var b = u.stateNode;
                                    u.flags & 32 && (Di(b, ""),
                                    u.flags &= -33),
                                    qa(i, Ma(i), b);
                                    break;
                                case 3:
                                case 4:
                                    var D = u.stateNode.containerInfo;
                                    Js(i, Ma(i), D);
                                    break;
                                default:
                                    throw Error(r(161))
                                }
                            } catch (F) {
                                Tn(i, i.return, F)
                            }
                            i.flags &= -3
                        }
                        s & 4096 && (i.flags &= -4097)
                    }
                    function Tu(i) {
                        if (i.subtreeFlags & 1024)
                            for (i = i.child; i !== null; ) {
                                var s = i;
                                Tu(s),
                                s.tag === 5 && s.flags & 1024 && s.stateNode.reset(),
                                i = i.sibling
                            }
                    }
                    function Is(i, s) {
                        if (s.subtreeFlags & 8772)
                            for (s = s.child; s !== null; )
                                hn(i, s.alternate, s),
                                s = s.sibling
                    }
                    function Ya(i) {
                        for (i = i.child; i !== null; ) {
                            var s = i;
                            switch (s.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Lr(4, s, s.return),
                                Ya(s);
                                break;
                            case 1:
                                va(s, s.return);
                                var u = s.stateNode;
                                typeof u.componentWillUnmount == "function" && dp(s, s.return, u),
                                Ya(s);
                                break;
                            case 27:
                                Sp(s.stateNode);
                            case 26:
                            case 5:
                                va(s, s.return),
                                Ya(s);
                                break;
                            case 22:
                                s.memoizedState === null && Ya(s);
                                break;
                            case 30:
                                Ya(s);
                                break;
                            default:
                                Ya(s)
                            }
                            i = i.sibling
                        }
                    }
                    function ja(i, s, u) {
                        for (u = u && (s.subtreeFlags & 8772) !== 0,
                        s = s.child; s !== null; ) {
                            var h = s.alternate
                              , S = i
                              , b = s
                              , D = b.flags;
                            switch (b.tag) {
                            case 0:
                            case 11:
                            case 15:
                                ja(S, b, u),
                                cl(4, b);
                                break;
                            case 1:
                                if (ja(S, b, u),
                                h = b,
                                S = h.stateNode,
                                typeof S.componentDidMount == "function")
                                    try {
                                        S.componentDidMount()
                                    } catch (pe) {
                                        Tn(h, h.return, pe)
                                    }
                                if (h = b,
                                S = h.updateQueue,
                                S !== null) {
                                    var F = h.stateNode;
                                    try {
                                        var ee = S.shared.hiddenCallbacks;
                                        if (ee !== null)
                                            for (S.shared.hiddenCallbacks = null,
                                            S = 0; S < ee.length; S++)
                                                Cr(ee[S], F)
                                    } catch (pe) {
                                        Tn(h, h.return, pe)
                                    }
                                }
                                u && D & 64 && th(b),
                                Ks(b, b.return);
                                break;
                            case 27:
                                Us(b);
                            case 26:
                            case 5:
                                ja(S, b, u),
                                u && h === null && D & 4 && bu(b),
                                Ks(b, b.return);
                                break;
                            case 12:
                                ja(S, b, u);
                                break;
                            case 31:
                                ja(S, b, u),
                                u && D & 4 && er(S, b);
                                break;
                            case 13:
                                ja(S, b, u),
                                u && D & 4 && kg(S, b);
                                break;
                            case 22:
                                b.memoizedState === null && ja(S, b, u),
                                Ks(b, b.return);
                                break;
                            case 30:
                                break;
                            default:
                                ja(S, b, u)
                            }
                            s = s.sibling
                        }
                    }
                    function Eu(i, s) {
                        var u = null;
                        i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (u = i.memoizedState.cachePool.pool),
                        i = null,
                        s.memoizedState !== null && s.memoizedState.cachePool !== null && (i = s.memoizedState.cachePool.pool),
                        i !== u && (i != null && i.refCount++,
                        u != null && Vl(u))
                    }
                    function mo(i, s) {
                        i = null,
                        s.alternate !== null && (i = s.alternate.memoizedState.cache),
                        s = s.memoizedState.cache,
                        s !== i && (s.refCount++,
                        i != null && Vl(i))
                    }
                    function ra(i, s, u, h) {
                        if (s.subtreeFlags & 10256)
                            for (s = s.child; s !== null; )
                                pp(i, s, u, h),
                                s = s.sibling
                    }
                    function pp(i, s, u, h) {
                        var S = s.flags;
                        switch (s.tag) {
                        case 0:
                        case 11:
                        case 15:
                            ra(i, s, u, h),
                            S & 2048 && cl(9, s);
                            break;
                        case 1:
                            ra(i, s, u, h);
                            break;
                        case 3:
                            ra(i, s, u, h),
                            S & 2048 && (i = null,
                            s.alternate !== null && (i = s.alternate.memoizedState.cache),
                            s = s.memoizedState.cache,
                            s !== i && (s.refCount++,
                            i != null && Vl(i)));
                            break;
                        case 12:
                            if (S & 2048) {
                                ra(i, s, u, h),
                                i = s.stateNode;
                                try {
                                    var b = s.memoizedProps
                                      , D = b.id
                                      , F = b.onPostCommit;
                                    typeof F == "function" && F(D, s.alternate === null ? "mount" : "update", i.passiveEffectDuration, -0)
                                } catch (ee) {
                                    Tn(s, s.return, ee)
                                }
                            } else
                                ra(i, s, u, h);
                            break;
                        case 31:
                            ra(i, s, u, h);
                            break;
                        case 13:
                            ra(i, s, u, h);
                            break;
                        case 23:
                            break;
                        case 22:
                            b = s.stateNode,
                            D = s.alternate,
                            s.memoizedState !== null ? b._visibility & 2 ? ra(i, s, u, h) : tr(i, s) : b._visibility & 2 ? ra(i, s, u, h) : (b._visibility |= 2,
                            vs(i, s, u, h, (s.subtreeFlags & 10256) !== 0 || !1)),
                            S & 2048 && Eu(D, s);
                            break;
                        case 24:
                            ra(i, s, u, h),
                            S & 2048 && mo(s.alternate, s);
                            break;
                        default:
                            ra(i, s, u, h)
                        }
                    }
                    function vs(i, s, u, h, S) {
                        for (S = S && ((s.subtreeFlags & 10256) !== 0 || !1),
                        s = s.child; s !== null; ) {
                            var b = i
                              , D = s
                              , F = u
                              , ee = h
                              , pe = D.flags;
                            switch (D.tag) {
                            case 0:
                            case 11:
                            case 15:
                                vs(b, D, F, ee, S),
                                cl(8, D);
                                break;
                            case 23:
                                break;
                            case 22:
                                var De = D.stateNode;
                                D.memoizedState !== null ? De._visibility & 2 ? vs(b, D, F, ee, S) : tr(b, D) : (De._visibility |= 2,
                                vs(b, D, F, ee, S)),
                                S && pe & 2048 && Eu(D.alternate, D);
                                break;
                            case 24:
                                vs(b, D, F, ee, S),
                                S && pe & 2048 && mo(D.alternate, D);
                                break;
                            default:
                                vs(b, D, F, ee, S)
                            }
                            s = s.sibling
                        }
                    }
                    function tr(i, s) {
                        if (s.subtreeFlags & 10256)
                            for (s = s.child; s !== null; ) {
                                var u = i
                                  , h = s
                                  , S = h.flags;
                                switch (h.tag) {
                                case 22:
                                    tr(u, h),
                                    S & 2048 && Eu(h.alternate, h);
                                    break;
                                case 24:
                                    tr(u, h),
                                    S & 2048 && mo(h.alternate, h);
                                    break;
                                default:
                                    tr(u, h)
                                }
                                s = s.sibling
                            }
                    }
                    var hl = 8192;
                    function Ir(i, s, u) {
                        if (i.subtreeFlags & hl)
                            for (i = i.child; i !== null; )
                                Au(i, s, u),
                                i = i.sibling
                    }
                    function Au(i, s, u) {
                        switch (i.tag) {
                        case 26:
                            Ir(i, s, u),
                            i.flags & hl && i.memoizedState !== null && T2(u, Ta, i.memoizedState, i.memoizedProps);
                            break;
                        case 5:
                            Ir(i, s, u);
                            break;
                        case 3:
                        case 4:
                            var h = Ta;
                            Ta = Xg(i.stateNode.containerInfo),
                            Ir(i, s, u),
                            Ta = h;
                            break;
                        case 22:
                            i.memoizedState === null && (h = i.alternate,
                            h !== null && h.memoizedState !== null ? (h = hl,
                            hl = 16777216,
                            Ir(i, s, u),
                            hl = h) : Ir(i, s, u));
                            break;
                        default:
                            Ir(i, s, u)
                        }
                    }
                    function go(i) {
                        var s = i.alternate;
                        if (s !== null && (i = s.child,
                        i !== null)) {
                            s.child = null;
                            do
                                s = i.sibling,
                                i.sibling = null,
                                i = s;
                            while (i !== null)
                        }
                    }
                    function nr(i) {
                        var s = i.deletions;
                        if ((i.flags & 16) !== 0) {
                            if (s !== null)
                                for (var u = 0; u < s.length; u++) {
                                    var h = s[u];
                                    vn = h,
                                    mp(h, i)
                                }
                            go(i)
                        }
                        if (i.subtreeFlags & 10256)
                            for (i = i.child; i !== null; )
                                ec(i),
                                i = i.sibling
                    }
                    function ec(i) {
                        switch (i.tag) {
                        case 0:
                        case 11:
                        case 15:
                            nr(i),
                            i.flags & 2048 && Lr(9, i, i.return);
                            break;
                        case 3:
                            nr(i);
                            break;
                        case 12:
                            nr(i);
                            break;
                        case 22:
                            var s = i.stateNode;
                            i.memoizedState !== null && s._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (s._visibility &= -3,
                            ir(i)) : nr(i);
                            break;
                        default:
                            nr(i)
                        }
                    }
                    function ir(i) {
                        var s = i.deletions;
                        if ((i.flags & 16) !== 0) {
                            if (s !== null)
                                for (var u = 0; u < s.length; u++) {
                                    var h = s[u];
                                    vn = h,
                                    mp(h, i)
                                }
                            go(i)
                        }
                        for (i = i.child; i !== null; ) {
                            switch (s = i,
                            s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Lr(8, s, s.return),
                                ir(s);
                                break;
                            case 22:
                                u = s.stateNode,
                                u._visibility & 2 && (u._visibility &= -3,
                                ir(s));
                                break;
                            default:
                                ir(s)
                            }
                            i = i.sibling
                        }
                    }
                    function mp(i, s) {
                        for (; vn !== null; ) {
                            var u = vn;
                            switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Lr(8, u, s);
                                break;
                            case 23:
                            case 22:
                                if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
                                    var h = u.memoizedState.cachePool.pool;
                                    h != null && h.refCount++
                                }
                                break;
                            case 24:
                                Vl(u.memoizedState.cache)
                            }
                            if (h = u.child,
                            h !== null)
                                h.return = u,
                                vn = h;
                            else
                                e: for (u = i; vn !== null; ) {
                                    h = vn;
                                    var S = h.sibling
                                      , b = h.return;
                                    if (Ur(h),
                                    h === u) {
                                        vn = null;
                                        break e
                                    }
                                    if (S !== null) {
                                        S.return = b,
                                        vn = S;
                                        break e
                                    }
                                    vn = b
                                }
                        }
                    }
                    var ys = {
                        getCacheForType: function(i) {
                            var s = xi(pi)
                              , u = s.data.get(i);
                            return u === void 0 && (u = i(),
                            s.data.set(i, u)),
                            u
                        },
                        cacheSignal: function() {
                            return xi(pi).controller.signal
                        }
                    }
                      , tc = typeof WeakMap == "function" ? WeakMap : Map
                      , Mn = 0
                      , yn = null
                      , Kt = null
                      , Yt = 0
                      , En = 0
                      , Xn = null
                      , Vi = !1
                      , kn = !1
                      , Os = !1
                      , Ut = 0
                      , Pt = 0
                      , Pn = 0
                      , ar = 0
                      , vo = 0
                      , Li = 0
                      , Or = 0
                      , Pr = null
                      , Ui = null
                      , gp = !1
                      , yo = 0
                      , vp = 0
                      , nc = 1 / 0
                      , wu = null
                      , sr = null
                      , vi = 0
                      , zn = null
                      , _o = null
                      , Zi = 0
                      , oi = 0
                      , Cu = null
                      , yp = null
                      , li = 0
                      , ci = null;
                    function qn() {
                        return (Mn & 2) !== 0 && Yt !== 0 ? Yt & -Yt : Q.T !== null ? Oe() : ss()
                    }
                    function _s() {
                        if (Li === 0)
                            if ((Yt & 536870912) === 0 || fn) {
                                var i = ht;
                                ht <<= 1,
                                (ht & 3932160) === 0 && (ht = 262144),
                                Li = i
                            } else
                                Li = 536870912;
                        return i = ka.current,
                        i !== null && (i.flags |= 32),
                        Li
                    }
                    function Ii(i, s, u) {
                        (i === yn && (En === 2 || En === 9) || i.cancelPendingCommit !== null) && (rr(i, 0),
                        Ps(i, Yt, Li, !1)),
                        Gi(i, u),
                        ((Mn & 2) === 0 || i !== yn) && (i === yn && ((Mn & 2) === 0 && (ar |= u),
                        Pt === 4 && Ps(i, Yt, Li, !1)),
                        l(i))
                    }
                    function Hg(i, s, u) {
                        if ((Mn & 6) !== 0)
                            throw Error(r(327));
                        var h = !u && (s & 127) === 0 && (s & i.expiredLanes) === 0 || Mt(i, s)
                          , S = h ? So(i, s) : Cn(i, s, !0)
                          , b = h;
                        do {
                            if (S === 0) {
                                kn && !h && Ps(i, s, 0, !1);
                                break
                            } else {
                                if (u = i.current.alternate,
                                b && !ih(u)) {
                                    S = Cn(i, s, !1),
                                    b = !1;
                                    continue
                                }
                                if (S === 2) {
                                    if (b = s,
                                    i.errorRecoveryDisabledLanes & b)
                                        var D = 0;
                                    else
                                        D = i.pendingLanes & -536870913,
                                        D = D !== 0 ? D : D & 536870912 ? 536870912 : 0;
                                    if (D !== 0) {
                                        s = D;
                                        e: {
                                            var F = i;
                                            S = Pr;
                                            var ee = F.current.memoizedState.isDehydrated;
                                            if (ee && (rr(F, D).flags |= 256),
                                            D = Cn(F, D, !1),
                                            D !== 2) {
                                                if (Os && !ee) {
                                                    F.errorRecoveryDisabledLanes |= b,
                                                    ar |= b,
                                                    S = 4;
                                                    break e
                                                }
                                                b = Ui,
                                                Ui = S,
                                                b !== null && (Ui === null ? Ui = b : Ui.push.apply(Ui, b))
                                            }
                                            S = D
                                        }
                                        if (b = !1,
                                        S !== 2)
                                            continue
                                    }
                                }
                                if (S === 1) {
                                    rr(i, 0),
                                    Ps(i, s, 0, !0);
                                    break
                                }
                                e: {
                                    switch (h = i,
                                    b = S,
                                    b) {
                                    case 0:
                                    case 1:
                                        throw Error(r(345));
                                    case 4:
                                        if ((s & 4194048) !== s)
                                            break;
                                    case 6:
                                        Ps(h, s, Li, !Vi);
                                        break e;
                                    case 2:
                                        Ui = null;
                                        break;
                                    case 3:
                                    case 5:
                                        break;
                                    default:
                                        throw Error(r(329))
                                    }
                                    if ((s & 62914560) === s && (S = yo + 300 - oe(),
                                    10 < S)) {
                                        if (Ps(h, s, Li, !Vi),
                                        pt(h, 0, !0) !== 0)
                                            break e;
                                        Zi = s,
                                        h.timeoutHandle = wx(Ru.bind(null, h, u, Ui, wu, gp, s, Li, ar, Or, Vi, b, "Throttled", -0, 0), S);
                                        break e
                                    }
                                    Ru(h, u, Ui, wu, gp, s, Li, ar, Or, Vi, b, null, -0, 0)
                                }
                            }
                            break
                        } while (!0);
                        l(i)
                    }
                    function Ru(i, s, u, h, S, b, D, F, ee, pe, De, Ie, ge, Se) {
                        if (i.timeoutHandle = -1,
                        Ie = s.subtreeFlags,
                        Ie & 8192 || (Ie & 16785408) === 16785408) {
                            Ie = {
                                stylesheets: null,
                                count: 0,
                                imgCount: 0,
                                imgBytes: 0,
                                suspenseyImages: [],
                                waitingForImages: !0,
                                waitingForViewTransition: !1,
                                unsuspend: Gs
                            },
                            Au(s, b, Ie);
                            var yt = (b & 62914560) === b ? yo - oe() : (b & 4194048) === b ? vp - oe() : 0;
                            if (yt = E2(Ie, yt),
                            yt !== null) {
                                Zi = b,
                                i.cancelPendingCommit = yt(sh.bind(null, i, s, b, u, h, S, D, F, ee, De, Ie, null, ge, Se)),
                                Ps(i, b, D, !pe);
                                return
                            }
                        }
                        sh(i, s, b, u, h, S, D, F, ee)
                    }
                    function ih(i) {
                        for (var s = i; ; ) {
                            var u = s.tag;
                            if ((u === 0 || u === 11 || u === 15) && s.flags & 16384 && (u = s.updateQueue,
                            u !== null && (u = u.stores,
                            u !== null)))
                                for (var h = 0; h < u.length; h++) {
                                    var S = u[h]
                                      , b = S.getSnapshot;
                                    S = S.value;
                                    try {
                                        if (!fa(b(), S))
                                            return !1
                                    } catch {
                                        return !1
                                    }
                                }
                            if (u = s.child,
                            s.subtreeFlags & 16384 && u !== null)
                                u.return = s,
                                s = u;
                            else {
                                if (s === i)
                                    break;
                                for (; s.sibling === null; ) {
                                    if (s.return === null || s.return === i)
                                        return !0;
                                    s = s.return
                                }
                                s.sibling.return = s.return,
                                s = s.sibling
                            }
                        }
                        return !0
                    }
                    function Ps(i, s, u, h) {
                        s &= ~vo,
                        s &= ~ar,
                        i.suspendedLanes |= s,
                        i.pingedLanes &= ~s,
                        h && (i.warmLanes |= s),
                        h = i.expirationTimes;
                        for (var S = s; 0 < S; ) {
                            var b = 31 - et(S)
                              , D = 1 << b;
                            h[b] = -1,
                            S &= ~D
                        }
                        u !== 0 && mr(i, u, s)
                    }
                    function dl() {
                        return (Mn & 6) === 0 ? (d(0, !1),
                        !1) : !0
                    }
                    function ic() {
                        if (Kt !== null) {
                            if (En === 0)
                                var i = Kt.return;
                            else
                                i = Kt,
                                cs = ao = null,
                                Gd(i),
                                $o = null,
                                el = 0,
                                i = Kt;
                            for (; i !== null; )
                                Vg(i.alternate, i),
                                i = i.return;
                            Kt = null
                        }
                    }
                    function rr(i, s) {
                        var u = i.timeoutHandle;
                        u !== -1 && (i.timeoutHandle = -1,
                        o2(u)),
                        u = i.cancelPendingCommit,
                        u !== null && (i.cancelPendingCommit = null,
                        u()),
                        Zi = 0,
                        ic(),
                        yn = i,
                        Kt = u = qs(i.current, null),
                        Yt = s,
                        En = 0,
                        Xn = null,
                        Vi = !1,
                        kn = Mt(i, s),
                        Os = !1,
                        Or = Li = vo = ar = Pn = Pt = 0,
                        Ui = Pr = null,
                        gp = !1,
                        (s & 8) !== 0 && (s |= s & 32);
                        var h = i.entangledLanes;
                        if (h !== 0)
                            for (i = i.entanglements,
                            h &= s; 0 < h; ) {
                                var S = 31 - et(h)
                                  , b = 1 << S;
                                s |= i[S],
                                h &= ~b
                            }
                        return Ut = s,
                        Ef(),
                        u
                    }
                    function Gg(i, s) {
                        Gt = null,
                        Q.H = yu,
                        s === Er || s === Gl ? (s = Bd(),
                        En = 3) : s === Ar ? (s = Bd(),
                        En = 4) : En = s === Kf ? 8 : s !== null && typeof s == "object" && typeof s.then == "function" ? 6 : 1,
                        Xn = s,
                        Kt === null && (Pt = 1,
                        jf(i, ii(s, i.current)))
                    }
                    function sn() {
                        var i = ka.current;
                        return i === null ? !0 : (Yt & 4194048) === Yt ? ds === null : (Yt & 62914560) === Yt || (Yt & 536870912) !== 0 ? i === ds : !1
                    }
                    function Ln() {
                        var i = Q.H;
                        return Q.H = yu,
                        i === null ? yu : i
                    }
                    function rn() {
                        var i = Q.A;
                        return Q.A = ys,
                        i
                    }
                    function Jt() {
                        Pt = 4,
                        Vi || (Yt & 4194048) !== Yt && ka.current !== null || (kn = !0),
                        (Pn & 134217727) === 0 && (ar & 134217727) === 0 || yn === null || Ps(yn, Yt, Li, !1)
                    }
                    function Cn(i, s, u) {
                        var h = Mn;
                        Mn |= 2;
                        var S = Ln()
                          , b = rn();
                        (yn !== i || Yt !== s) && (wu = null,
                        rr(i, s)),
                        s = !1;
                        var D = Pt;
                        e: do
                            try {
                                if (En !== 0 && Kt !== null) {
                                    var F = Kt
                                      , ee = Xn;
                                    switch (En) {
                                    case 8:
                                        ic(),
                                        D = 6;
                                        break e;
                                    case 3:
                                    case 2:
                                    case 9:
                                    case 6:
                                        ka.current === null && (s = !0);
                                        var pe = En;
                                        if (En = 0,
                                        Xn = null,
                                        Bn(i, F, ee, pe),
                                        u && kn) {
                                            D = 0;
                                            break e
                                        }
                                        break;
                                    default:
                                        pe = En,
                                        En = 0,
                                        Xn = null,
                                        Bn(i, F, ee, pe)
                                    }
                                }
                                Za(),
                                D = Pt;
                                break
                            } catch (De) {
                                Gg(i, De)
                            }
                        while (!0);
                        return s && i.shellSuspendCounter++,
                        cs = ao = null,
                        Mn = h,
                        Q.H = S,
                        Q.A = b,
                        Kt === null && (yn = null,
                        Yt = 0,
                        Ef()),
                        D
                    }
                    function Za() {
                        for (; Kt !== null; )
                            ah(Kt)
                    }
                    function So(i, s) {
                        var u = Mn;
                        Mn |= 2;
                        var h = Ln()
                          , S = rn();
                        yn !== i || Yt !== s ? (wu = null,
                        nc = oe() + 500,
                        rr(i, s)) : kn = Mt(i, s);
                        e: do
                            try {
                                if (En !== 0 && Kt !== null) {
                                    s = Kt;
                                    var b = Xn;
                                    t: switch (En) {
                                    case 1:
                                        En = 0,
                                        Xn = null,
                                        Bn(i, s, b, 1);
                                        break;
                                    case 2:
                                    case 9:
                                        if (Uf(b)) {
                                            En = 0,
                                            Xn = null,
                                            or(s);
                                            break
                                        }
                                        s = function() {
                                            En !== 2 && En !== 9 || yn !== i || (En = 7),
                                            l(i)
                                        }
                                        ,
                                        b.then(s, s);
                                        break e;
                                    case 3:
                                        En = 7;
                                        break e;
                                    case 4:
                                        En = 5;
                                        break e;
                                    case 7:
                                        Uf(b) ? (En = 0,
                                        Xn = null,
                                        or(s)) : (En = 0,
                                        Xn = null,
                                        Bn(i, s, b, 7));
                                        break;
                                    case 5:
                                        var D = null;
                                        switch (Kt.tag) {
                                        case 26:
                                            D = Kt.memoizedState;
                                        case 5:
                                        case 27:
                                            var F = Kt;
                                            if (D ? Hx(D) : F.stateNode.complete) {
                                                En = 0,
                                                Xn = null;
                                                var ee = F.sibling;
                                                if (ee !== null)
                                                    Kt = ee;
                                                else {
                                                    var pe = F.return;
                                                    pe !== null ? (Kt = pe,
                                                    zs(pe)) : Kt = null
                                                }
                                                break t
                                            }
                                        }
                                        En = 0,
                                        Xn = null,
                                        Bn(i, s, b, 5);
                                        break;
                                    case 6:
                                        En = 0,
                                        Xn = null,
                                        Bn(i, s, b, 6);
                                        break;
                                    case 8:
                                        ic(),
                                        Pt = 6;
                                        break e;
                                    default:
                                        throw Error(r(462))
                                    }
                                }
                                ac();
                                break
                            } catch (De) {
                                Gg(i, De)
                            }
                        while (!0);
                        return cs = ao = null,
                        Q.H = h,
                        Q.A = S,
                        Mn = u,
                        Kt !== null ? 0 : (yn = null,
                        Yt = 0,
                        Ef(),
                        Pt)
                    }
                    function ac() {
                        for (; Kt !== null && !H(); )
                            ah(Kt)
                    }
                    function ah(i) {
                        var s = zg(i.alternate, i, Ut);
                        i.memoizedProps = i.pendingProps,
                        s === null ? zs(i) : Kt = s
                    }
                    function or(i) {
                        var s = i
                          , u = s.alternate;
                        switch (s.tag) {
                        case 15:
                        case 0:
                            s = rl(u, s, s.pendingProps, s.type, void 0, Yt);
                            break;
                        case 11:
                            s = rl(u, s, s.pendingProps, s.type.render, s.ref, Yt);
                            break;
                        case 5:
                            Gd(s);
                        default:
                            Vg(u, s),
                            s = Kt = ea(s, Ut),
                            s = zg(u, s, Ut)
                        }
                        i.memoizedProps = i.pendingProps,
                        s === null ? zs(i) : Kt = s
                    }
                    function Bn(i, s, u, h) {
                        cs = ao = null,
                        Gd(s),
                        $o = null,
                        el = 0;
                        var S = s.return;
                        try {
                            if (Rg(i, S, s, u, Yt)) {
                                Pt = 1,
                                jf(i, ii(u, i.current)),
                                Kt = null;
                                return
                            }
                        } catch (b) {
                            if (S !== null)
                                throw Kt = S,
                                b;
                            Pt = 1,
                            jf(i, ii(u, i.current)),
                            Kt = null;
                            return
                        }
                        s.flags & 32768 ? (fn || h === 1 ? i = !0 : kn || (Yt & 536870912) !== 0 ? i = !1 : (Vi = i = !0,
                        (h === 2 || h === 9 || h === 3 || h === 6) && (h = ka.current,
                        h !== null && h.tag === 13 && (h.flags |= 16384))),
                        xo(s, i)) : zs(s)
                    }
                    function zs(i) {
                        var s = i;
                        do {
                            if ((s.flags & 32768) !== 0) {
                                xo(s, Vi);
                                return
                            }
                            i = s.return;
                            var u = Wa(s.alternate, s, Ut);
                            if (u !== null) {
                                Kt = u;
                                return
                            }
                            if (s = s.sibling,
                            s !== null) {
                                Kt = s;
                                return
                            }
                            Kt = s = i
                        } while (s !== null);
                        Pt === 0 && (Pt = 5)
                    }
                    function xo(i, s) {
                        do {
                            var u = Fg(i.alternate, i);
                            if (u !== null) {
                                u.flags &= 32767,
                                Kt = u;
                                return
                            }
                            if (u = i.return,
                            u !== null && (u.flags |= 32768,
                            u.subtreeFlags = 0,
                            u.deletions = null),
                            !s && (i = i.sibling,
                            i !== null)) {
                                Kt = i;
                                return
                            }
                            Kt = i = u
                        } while (i !== null);
                        Pt = 6,
                        Kt = null
                    }
                    function sh(i, s, u, h, S, b, D, F, ee) {
                        i.cancelPendingCommit = null;
                        do
                            rc();
                        while (vi !== 0);
                        if ((Mn & 6) !== 0)
                            throw Error(r(327));
                        if (s !== null) {
                            if (s === i.current)
                                throw Error(r(177));
                            if (b = s.lanes | s.childLanes,
                            b |= Tf,
                            qr(i, u, b, D, F, ee),
                            i === yn && (Kt = yn = null,
                            Yt = 0),
                            _o = s,
                            zn = i,
                            Zi = u,
                            oi = b,
                            Cu = S,
                            yp = h,
                            (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? (i.callbackNode = null,
                            i.callbackPriority = 0,
                            zr(st, function() {
                                return Du(),
                                null
                            })) : (i.callbackNode = null,
                            i.callbackPriority = 0),
                            h = (s.flags & 13878) !== 0,
                            (s.subtreeFlags & 13878) !== 0 || h) {
                                h = Q.T,
                                Q.T = null,
                                S = se.p,
                                se.p = 2,
                                D = Mn,
                                Mn |= 4;
                                try {
                                    $n(i, s, u)
                                } finally {
                                    Mn = D,
                                    se.p = S,
                                    Q.T = h
                                }
                            }
                            vi = 1,
                            Ea(),
                            pl(),
                            sc()
                        }
                    }
                    function Ea() {
                        if (vi === 1) {
                            vi = 0;
                            var i = zn
                              , s = _o
                              , u = (s.flags & 13878) !== 0;
                            if ((s.subtreeFlags & 13878) !== 0 || u) {
                                u = Q.T,
                                Q.T = null;
                                var h = se.p;
                                se.p = 2;
                                var S = Mn;
                                Mn |= 4;
                                try {
                                    fl(s, i);
                                    var b = Fy
                                      , D = Cd(i.containerInfo)
                                      , F = b.focusedElem
                                      , ee = b.selectionRange;
                                    if (D !== F && F && F.ownerDocument && Kc(F.ownerDocument.documentElement, F)) {
                                        if (ee !== null && Jc(F)) {
                                            var pe = ee.start
                                              , De = ee.end;
                                            if (De === void 0 && (De = pe),
                                            "selectionStart"in F)
                                                F.selectionStart = pe,
                                                F.selectionEnd = Math.min(De, F.value.length);
                                            else {
                                                var Ie = F.ownerDocument || document
                                                  , ge = Ie && Ie.defaultView || window;
                                                if (ge.getSelection) {
                                                    var Se = ge.getSelection()
                                                      , yt = F.textContent.length
                                                      , zt = Math.min(ee.start, yt)
                                                      , Gn = ee.end === void 0 ? zt : Math.min(ee.end, yt);
                                                    !Se.extend && zt > Gn && (D = Gn,
                                                    Gn = zt,
                                                    zt = D);
                                                    var ue = rs(F, zt)
                                                      , ie = rs(F, Gn);
                                                    if (ue && ie && (Se.rangeCount !== 1 || Se.anchorNode !== ue.node || Se.anchorOffset !== ue.offset || Se.focusNode !== ie.node || Se.focusOffset !== ie.offset)) {
                                                        var de = Ie.createRange();
                                                        de.setStart(ue.node, ue.offset),
                                                        Se.removeAllRanges(),
                                                        zt > Gn ? (Se.addRange(de),
                                                        Se.extend(ie.node, ie.offset)) : (de.setEnd(ie.node, ie.offset),
                                                        Se.addRange(de))
                                                    }
                                                }
                                            }
                                        }
                                        for (Ie = [],
                                        Se = F; Se = Se.parentNode; )
                                            Se.nodeType === 1 && Ie.push({
                                                element: Se,
                                                left: Se.scrollLeft,
                                                top: Se.scrollTop
                                            });
                                        for (typeof F.focus == "function" && F.focus(),
                                        F = 0; F < Ie.length; F++) {
                                            var Le = Ie[F];
                                            Le.element.scrollLeft = Le.left,
                                            Le.element.scrollTop = Le.top
                                        }
                                    }
                                    Kg = !!By,
                                    Fy = By = null
                                } finally {
                                    Mn = S,
                                    se.p = h,
                                    Q.T = u
                                }
                            }
                            i.current = s,
                            vi = 2
                        }
                    }
                    function pl() {
                        if (vi === 2) {
                            vi = 0;
                            var i = zn
                              , s = _o
                              , u = (s.flags & 8772) !== 0;
                            if ((s.subtreeFlags & 8772) !== 0 || u) {
                                u = Q.T,
                                Q.T = null;
                                var h = se.p;
                                se.p = 2;
                                var S = Mn;
                                Mn |= 4;
                                try {
                                    hn(i, s.alternate, s)
                                } finally {
                                    Mn = S,
                                    se.p = h,
                                    Q.T = u
                                }
                            }
                            vi = 3
                        }
                    }
                    function sc() {
                        if (vi === 4 || vi === 3) {
                            vi = 0,
                            O();
                            var i = zn
                              , s = _o
                              , u = Zi
                              , h = yp;
                            (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? vi = 5 : (vi = 0,
                            _o = zn = null,
                            ya(i, i.pendingLanes));
                            var S = i.pendingLanes;
                            if (S === 0 && (sr = null),
                            Ua(u),
                            s = s.stateNode,
                            rt && typeof rt.onCommitFiberRoot == "function")
                                try {
                                    rt.onCommitFiberRoot(We, s, void 0, (s.current.flags & 128) === 128)
                                } catch {}
                            if (h !== null) {
                                s = Q.T,
                                S = se.p,
                                se.p = 2,
                                Q.T = null;
                                try {
                                    for (var b = i.onRecoverableError, D = 0; D < h.length; D++) {
                                        var F = h[D];
                                        b(F.value, {
                                            componentStack: F.stack
                                        })
                                    }
                                } finally {
                                    Q.T = s,
                                    se.p = S
                                }
                            }
                            (Zi & 3) !== 0 && rc(),
                            l(i),
                            S = i.pendingLanes,
                            (u & 261930) !== 0 && (S & 42) !== 0 ? i === ci ? li++ : (li = 0,
                            ci = i) : li = 0,
                            d(0, !1)
                        }
                    }
                    function ya(i, s) {
                        (i.pooledCacheLanes &= s) === 0 && (s = i.pooledCache,
                        s != null && (i.pooledCache = null,
                        Vl(s)))
                    }
                    function rc() {
                        return Ea(),
                        pl(),
                        sc(),
                        Du()
                    }
                    function Du() {
                        if (vi !== 5)
                            return !1;
                        var i = zn
                          , s = oi;
                        oi = 0;
                        var u = Ua(Zi)
                          , h = Q.T
                          , S = se.p;
                        try {
                            se.p = 32 > u ? 32 : u,
                            Q.T = null,
                            u = Cu,
                            Cu = null;
                            var b = zn
                              , D = Zi;
                            if (vi = 0,
                            _o = zn = null,
                            Zi = 0,
                            (Mn & 6) !== 0)
                                throw Error(r(331));
                            var F = Mn;
                            if (Mn |= 4,
                            ec(b.current),
                            pp(b, b.current, D, u),
                            Mn = F,
                            d(0, !1),
                            rt && typeof rt.onPostCommitFiberRoot == "function")
                                try {
                                    rt.onPostCommitFiberRoot(We, b)
                                } catch {}
                            return !0
                        } finally {
                            se.p = S,
                            Q.T = h,
                            ya(i, s)
                        }
                    }
                    function _p(i, s, u) {
                        s = ii(u, s),
                        s = Zf(i.stateNode, s, 2),
                        i = co(i, s, 2),
                        i !== null && (Gi(i, 2),
                        l(i))
                    }
                    function Tn(i, s, u) {
                        if (i.tag === 3)
                            _p(i, i, u);
                        else
                            for (; s !== null; ) {
                                if (s.tag === 3) {
                                    _p(s, i, u);
                                    break
                                } else if (s.tag === 1) {
                                    var h = s.stateNode;
                                    if (typeof s.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (sr === null || !sr.has(h))) {
                                        i = ii(u, i),
                                        u = Qf(2),
                                        h = co(s, u, 2),
                                        h !== null && (lp(u, h, s, i),
                                        Gi(h, 2),
                                        l(h));
                                        break
                                    }
                                }
                                s = s.return
                            }
                    }
                    function oc(i, s, u) {
                        var h = i.pingCache;
                        if (h === null) {
                            h = i.pingCache = new tc;
                            var S = new Set;
                            h.set(s, S)
                        } else
                            S = h.get(s),
                            S === void 0 && (S = new Set,
                            h.set(s, S));
                        S.has(u) || (Os = !0,
                        S.add(u),
                        i = bo.bind(null, i, s, u),
                        s.then(i, i))
                    }
                    function bo(i, s, u) {
                        var h = i.pingCache;
                        h !== null && h.delete(s),
                        i.pingedLanes |= i.suspendedLanes & u,
                        i.warmLanes &= ~u,
                        yn === i && (Yt & u) === u && (Pt === 4 || Pt === 3 && (Yt & 62914560) === Yt && 300 > oe() - yo ? (Mn & 2) === 0 && rr(i, 0) : vo |= u,
                        Or === Yt && (Or = 0)),
                        l(i)
                    }
                    function Ei(i, s) {
                        s === 0 && (s = xn()),
                        i = Yi(i, s),
                        i !== null && (Gi(i, s),
                        l(i))
                    }
                    function Mo(i) {
                        var s = i.memoizedState
                          , u = 0;
                        s !== null && (u = s.retryLane),
                        Ei(i, u)
                    }
                    function lc(i, s) {
                        var u = 0;
                        switch (i.tag) {
                        case 31:
                        case 13:
                            var h = i.stateNode
                              , S = i.memoizedState;
                            S !== null && (u = S.retryLane);
                            break;
                        case 19:
                            h = i.stateNode;
                            break;
                        case 22:
                            h = i.stateNode._retryCache;
                            break;
                        default:
                            throw Error(r(314))
                        }
                        h !== null && h.delete(s),
                        Ei(i, u)
                    }
                    function zr(i, s) {
                        return Ke(i, s)
                    }
                    var cc = null
                      , To = null
                      , rh = !1
                      , Eo = !1
                      , Nu = !1
                      , o = 0;
                    function l(i) {
                        i !== To && i.next === null && (To === null ? cc = To = i : To = To.next = i),
                        Eo = !0,
                        rh || (rh = !0,
                        be())
                    }
                    function d(i, s) {
                        if (!Nu && Eo) {
                            Nu = !0;
                            do
                                for (var u = !1, h = cc; h !== null; ) {
                                    if (!s)
                                        if (i !== 0) {
                                            var S = h.pendingLanes;
                                            if (S === 0)
                                                var b = 0;
                                            else {
                                                var D = h.suspendedLanes
                                                  , F = h.pingedLanes;
                                                b = (1 << 31 - et(42 | i) + 1) - 1,
                                                b &= S & ~(D & ~F),
                                                b = b & 201326741 ? b & 201326741 | 1 : b ? b | 2 : 0
                                            }
                                            b !== 0 && (u = !0,
                                            $(h, b))
                                        } else
                                            b = Yt,
                                            b = pt(h, h === yn ? b : 0, h.cancelPendingCommit !== null || h.timeoutHandle !== -1),
                                            (b & 3) === 0 || Mt(h, b) || (u = !0,
                                            $(h, b));
                                    h = h.next
                                }
                            while (u);
                            Nu = !1
                        }
                    }
                    function y() {
                        T()
                    }
                    function T() {
                        Eo = rh = !1;
                        var i = 0;
                        o !== 0 && r2() && (i = o);
                        for (var s = oe(), u = null, h = cc; h !== null; ) {
                            var S = h.next
                              , b = w(h, s);
                            b === 0 ? (h.next = null,
                            u === null ? cc = S : u.next = S,
                            S === null && (To = u)) : (u = h,
                            (i !== 0 || (b & 3) !== 0) && (Eo = !0)),
                            h = S
                        }
                        vi !== 0 && vi !== 5 || d(i, !1),
                        o !== 0 && (o = 0)
                    }
                    function w(i, s) {
                        for (var u = i.suspendedLanes, h = i.pingedLanes, S = i.expirationTimes, b = i.pendingLanes & -62914561; 0 < b; ) {
                            var D = 31 - et(b)
                              , F = 1 << D
                              , ee = S[D];
                            ee === -1 ? ((F & u) === 0 || (F & h) !== 0) && (S[D] = In(F, s)) : ee <= s && (i.expiredLanes |= F),
                            b &= ~F
                        }
                        if (s = yn,
                        u = Yt,
                        u = pt(i, i === s ? u : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1),
                        h = i.callbackNode,
                        u === 0 || i === s && (En === 2 || En === 9) || i.cancelPendingCommit !== null)
                            return h !== null && h !== null && wt(h),
                            i.callbackNode = null,
                            i.callbackPriority = 0;
                        if ((u & 3) === 0 || Mt(i, u)) {
                            if (s = u & -u,
                            s === i.callbackPriority)
                                return s;
                            switch (h !== null && wt(h),
                            Ua(u)) {
                            case 2:
                            case 8:
                                u = Me;
                                break;
                            case 32:
                                u = st;
                                break;
                            case 268435456:
                                u = St;
                                break;
                            default:
                                u = st
                            }
                            return h = z.bind(null, i),
                            u = Ke(u, h),
                            i.callbackPriority = s,
                            i.callbackNode = u,
                            s
                        }
                        return h !== null && h !== null && wt(h),
                        i.callbackPriority = 2,
                        i.callbackNode = null,
                        2
                    }
                    function z(i, s) {
                        if (vi !== 0 && vi !== 5)
                            return i.callbackNode = null,
                            i.callbackPriority = 0,
                            null;
                        var u = i.callbackNode;
                        if (rc() && i.callbackNode !== u)
                            return null;
                        var h = Yt;
                        return h = pt(i, i === yn ? h : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1),
                        h === 0 ? null : (Hg(i, h, s),
                        w(i, oe()),
                        i.callbackNode != null && i.callbackNode === u ? z.bind(null, i) : null)
                    }
                    function $(i, s) {
                        if (rc())
                            return null;
                        Hg(i, s, !0)
                    }
                    function be() {
                        l2(function() {
                            (Mn & 6) !== 0 ? Ke(Ue, y) : T()
                        })
                    }
                    function Oe() {
                        if (o === 0) {
                            var i = so;
                            i === 0 && (i = Ge,
                            Ge <<= 1,
                            (Ge & 261888) === 0 && (Ge = 256)),
                            o = i
                        }
                        return o
                    }
                    function it(i) {
                        return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : uf("" + i)
                    }
                    function Qe(i, s) {
                        var u = s.ownerDocument.createElement("input");
                        return u.name = s.name,
                        u.value = s.value,
                        i.id && u.setAttribute("form", i.id),
                        s.parentNode.insertBefore(u, s),
                        i = new FormData(i),
                        u.parentNode.removeChild(u),
                        i
                    }
                    function gt(i, s, u, h, S) {
                        if (s === "submit" && u && u.stateNode === S) {
                            var b = it((S[Ci] || null).action)
                              , D = h.submitter;
                            D && (s = (s = D[Ci] || null) ? it(s.formAction) : D.getAttribute("formAction"),
                            s !== null && (b = s,
                            D = null));
                            var F = new Fc("action","action",null,h,S);
                            i.push({
                                event: F,
                                listeners: [{
                                    instance: null,
                                    listener: function() {
                                        if (h.defaultPrevented) {
                                            if (o !== 0) {
                                                var ee = D ? Qe(S, D) : new FormData(S);
                                                np(u, {
                                                    pending: !0,
                                                    data: ee,
                                                    method: S.method,
                                                    action: b
                                                }, null, ee)
                                            }
                                        } else
                                            typeof b == "function" && (F.preventDefault(),
                                            ee = D ? Qe(S, D) : new FormData(S),
                                            np(u, {
                                                pending: !0,
                                                data: ee,
                                                method: S.method,
                                                action: b
                                            }, b, ee))
                                    },
                                    currentTarget: S
                                }]
                            })
                        }
                    }
                    for (var Ht = 0; Ht < Mf.length; Ht++) {
                        var ui = Mf[Ht];
                        Oa(ui.toLowerCase(), "on" + (ui[0].toUpperCase() + ui.slice(1)))
                    }
                    Oa(zl, "onAnimationEnd"),
                    Oa(xr, "onAnimationIteration"),
                    Oa(Dd, "onAnimationStart"),
                    Oa("dblclick", "onDoubleClick"),
                    Oa("focusin", "onFocus"),
                    Oa("focusout", "onBlur"),
                    Oa(Gm, "onTransitionRun"),
                    Oa(tu, "onTransitionStart"),
                    Oa(Xs, "onTransitionCancel"),
                    Oa(Nd, "onTransitionEnd"),
                    qe("onMouseEnter", ["mouseout", "mouseover"]),
                    qe("onMouseLeave", ["mouseout", "mouseover"]),
                    qe("onPointerEnter", ["pointerout", "pointerover"]),
                    qe("onPointerLeave", ["pointerout", "pointerover"]),
                    ze("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
                    ze("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
                    ze("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
                    ze("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
                    ze("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
                    ze("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                    var Br = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
                      , ml = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Br));
                    function me(i, s) {
                        s = (s & 4) !== 0;
                        for (var u = 0; u < i.length; u++) {
                            var h = i[u]
                              , S = h.event;
                            h = h.listeners;
                            e: {
                                var b = void 0;
                                if (s)
                                    for (var D = h.length - 1; 0 <= D; D--) {
                                        var F = h[D]
                                          , ee = F.instance
                                          , pe = F.currentTarget;
                                        if (F = F.listener,
                                        ee !== b && S.isPropagationStopped())
                                            break e;
                                        b = F,
                                        S.currentTarget = pe;
                                        try {
                                            b(S)
                                        } catch (De) {
                                            Bl(De)
                                        }
                                        S.currentTarget = null,
                                        b = ee
                                    }
                                else
                                    for (D = 0; D < h.length; D++) {
                                        if (F = h[D],
                                        ee = F.instance,
                                        pe = F.currentTarget,
                                        F = F.listener,
                                        ee !== b && S.isPropagationStopped())
                                            break e;
                                        b = F,
                                        S.currentTarget = pe;
                                        try {
                                            b(S)
                                        } catch (De) {
                                            Bl(De)
                                        }
                                        S.currentTarget = null,
                                        b = ee
                                    }
                            }
                        }
                    }
                    function ne(i, s) {
                        var u = s[Ia];
                        u === void 0 && (u = s[Ia] = new Set);
                        var h = i + "__bubble";
                        u.has(h) || (Kn(s, i, 2, !1),
                        u.add(h))
                    }
                    function _e(i, s, u) {
                        var h = 0;
                        s && (h |= 4),
                        Kn(u, i, h, s)
                    }
                    var Xe = "_reactListening" + Math.random().toString(36).slice(2);
                    function Lt(i) {
                        if (!i[Xe]) {
                            i[Xe] = !0,
                            ye.forEach(function(u) {
                                u !== "selectionchange" && (ml.has(u) || _e(u, !1, i),
                                _e(u, !0, i))
                            });
                            var s = i.nodeType === 9 ? i : i.ownerDocument;
                            s === null || s[Xe] || (s[Xe] = !0,
                            _e("selectionchange", !1, s))
                        }
                    }
                    function Kn(i, s, u, h) {
                        switch (Yx(s)) {
                        case 2:
                            var S = D2;
                            break;
                        case 8:
                            S = N2;
                            break;
                        default:
                            S = Qy
                        }
                        u = S.bind(null, s, u, i),
                        S = void 0,
                        !pf || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (S = !0),
                        h ? S !== void 0 ? i.addEventListener(s, u, {
                            capture: !0,
                            passive: S
                        }) : i.addEventListener(s, u, !0) : S !== void 0 ? i.addEventListener(s, u, {
                            passive: S
                        }) : i.addEventListener(s, u, !1)
                    }
                    function It(i, s, u, h, S) {
                        var b = h;
                        if ((s & 1) === 0 && (s & 2) === 0 && h !== null)
                            e: for (; ; ) {
                                if (h === null)
                                    return;
                                var D = h.tag;
                                if (D === 3 || D === 4) {
                                    var F = h.stateNode.containerInfo;
                                    if (F === S)
                                        break;
                                    if (D === 4)
                                        for (D = h.return; D !== null; ) {
                                            var ee = D.tag;
                                            if ((ee === 3 || ee === 4) && D.stateNode.containerInfo === S)
                                                return;
                                            D = D.return
                                        }
                                    for (; F !== null; ) {
                                        if (D = gr(F),
                                        D === null)
                                            return;
                                        if (ee = D.tag,
                                        ee === 5 || ee === 6 || ee === 26 || ee === 27) {
                                            h = b = D;
                                            continue e
                                        }
                                        F = F.parentNode
                                    }
                                }
                                h = h.return
                            }
                        cd(function() {
                            var pe = b
                              , De = hf(u)
                              , Ie = [];
                            e: {
                                var ge = bf.get(i);
                                if (ge !== void 0) {
                                    var Se = Fc
                                      , yt = i;
                                    switch (i) {
                                    case "keypress":
                                        if (Il(u) === 0)
                                            break e;
                                    case "keydown":
                                    case "keyup":
                                        Se = Lm;
                                        break;
                                    case "focusin":
                                        yt = "focus",
                                        Se = kc;
                                        break;
                                    case "focusout":
                                        yt = "blur",
                                        Se = kc;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        Se = kc;
                                        break;
                                    case "click":
                                        if (u.button === 2)
                                            break e;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        Se = dd;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        Se = wm;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        Se = gd;
                                        break;
                                    case zl:
                                    case xr:
                                    case Dd:
                                        Se = Cm;
                                        break;
                                    case Nd:
                                        Se = Um;
                                        break;
                                    case "scroll":
                                    case "scrollend":
                                        Se = hd;
                                        break;
                                    case "wheel":
                                        Se = Im;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        Se = Rm;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        Se = md;
                                        break;
                                    case "toggle":
                                    case "beforetoggle":
                                        Se = Ho
                                    }
                                    var zt = (s & 4) !== 0
                                      , Gn = !zt && (i === "scroll" || i === "scrollend")
                                      , ue = zt ? ge !== null ? ge + "Capture" : null : ge;
                                    zt = [];
                                    for (var ie = pe, de; ie !== null; ) {
                                        var Le = ie;
                                        if (de = Le.stateNode,
                                        Le = Le.tag,
                                        Le !== 5 && Le !== 26 && Le !== 27 || de === null || ue === null || (Le = Ll(ie, ue),
                                        Le != null && zt.push(pn(ie, Le, de))),
                                        Gn)
                                            break;
                                        ie = ie.return
                                    }
                                    0 < zt.length && (ge = new Se(ge,yt,null,u,De),
                                    Ie.push({
                                        event: ge,
                                        listeners: zt
                                    }))
                                }
                            }
                            if ((s & 7) === 0) {
                                e: {
                                    if (ge = i === "mouseover" || i === "pointerover",
                                    Se = i === "mouseout" || i === "pointerout",
                                    ge && u !== ff && (yt = u.relatedTarget || u.fromElement) && (gr(yt) || yt[Wi]))
                                        break e;
                                    if ((Se || ge) && (ge = De.window === De ? De : (ge = De.ownerDocument) ? ge.defaultView || ge.parentWindow : window,
                                    Se ? (yt = u.relatedTarget || u.toElement,
                                    Se = pe,
                                    yt = yt ? gr(yt) : null,
                                    yt !== null && (Gn = f(yt),
                                    zt = yt.tag,
                                    yt !== Gn || zt !== 5 && zt !== 27 && zt !== 6) && (yt = null)) : (Se = null,
                                    yt = pe),
                                    Se !== yt)) {
                                        if (zt = dd,
                                        Le = "onMouseLeave",
                                        ue = "onMouseEnter",
                                        ie = "mouse",
                                        (i === "pointerout" || i === "pointerover") && (zt = md,
                                        Le = "onPointerLeave",
                                        ue = "onPointerEnter",
                                        ie = "pointer"),
                                        Gn = Se == null ? ge : V(Se),
                                        de = yt == null ? ge : V(yt),
                                        ge = new zt(Le,ie + "leave",Se,u,De),
                                        ge.target = Gn,
                                        ge.relatedTarget = de,
                                        Le = null,
                                        gr(De) === pe && (zt = new zt(ue,ie + "enter",yt,u,De),
                                        zt.target = de,
                                        zt.relatedTarget = Gn,
                                        Le = zt),
                                        Gn = Le,
                                        Se && yt)
                                            t: {
                                                for (zt = An,
                                                ue = Se,
                                                ie = yt,
                                                de = 0,
                                                Le = ue; Le; Le = zt(Le))
                                                    de++;
                                                Le = 0;
                                                for (var Nt = ie; Nt; Nt = zt(Nt))
                                                    Le++;
                                                for (; 0 < de - Le; )
                                                    ue = zt(ue),
                                                    de--;
                                                for (; 0 < Le - de; )
                                                    ie = zt(ie),
                                                    Le--;
                                                for (; de--; ) {
                                                    if (ue === ie || ie !== null && ue === ie.alternate) {
                                                        zt = ue;
                                                        break t
                                                    }
                                                    ue = zt(ue),
                                                    ie = zt(ie)
                                                }
                                                zt = null
                                            }
                                        else
                                            zt = null;
                                        Se !== null && Fr(Ie, ge, Se, zt, !1),
                                        yt !== null && Gn !== null && Fr(Ie, Gn, yt, zt, !0)
                                    }
                                }
                                e: {
                                    if (ge = pe ? V(pe) : window,
                                    Se = ge.nodeName && ge.nodeName.toLowerCase(),
                                    Se === "select" || Se === "input" && ge.type === "file")
                                        var Dn = bd;
                                    else if (Wc(ge))
                                        if (Md)
                                            Dn = Vm;
                                        else {
                                            Dn = Fm;
                                            var bt = Ed
                                        }
                                    else
                                        Se = ge.nodeName,
                                        !Se || Se.toLowerCase() !== "input" || ge.type !== "checkbox" && ge.type !== "radio" ? pe && cf(pe.elementType) && (Dn = bd) : Dn = Ad;
                                    if (Dn && (Dn = Dn(i, pe))) {
                                        Sd(Ie, Dn, u, De);
                                        break e
                                    }
                                    bt && bt(i, ge, pe),
                                    i === "focusout" && pe && ge.type === "number" && pe.memoizedProps.value != null && bn(ge, "number", ge.value)
                                }
                                switch (bt = pe ? V(pe) : window,
                                i) {
                                case "focusin":
                                    (Wc(bt) || bt.contentEditable === "true") && (Xo = bt,
                                    $c = pe,
                                    qo = null);
                                    break;
                                case "focusout":
                                    qo = $c = Xo = null;
                                    break;
                                case "mousedown":
                                    xf = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    xf = !1,
                                    eu(Ie, u, De);
                                    break;
                                case "selectionchange":
                                    if (km)
                                        break;
                                case "keydown":
                                case "keyup":
                                    eu(Ie, u, De)
                                }
                                var $t;
                                if (_f)
                                    e: {
                                        switch (i) {
                                        case "compositionstart":
                                            var _n = "onCompositionStart";
                                            break e;
                                        case "compositionend":
                                            _n = "onCompositionEnd";
                                            break e;
                                        case "compositionupdate":
                                            _n = "onCompositionUpdate";
                                            break e
                                        }
                                        _n = void 0
                                    }
                                else
                                    Wo ? yd(i, u) && (_n = "onCompositionEnd") : i === "keydown" && u.keyCode === 229 && (_n = "onCompositionStart");
                                _n && (vd && u.locale !== "ko" && (Wo || _n !== "onCompositionStart" ? _n === "onCompositionEnd" && Wo && ($t = ud()) : (_r = De,
                                Ul = "value"in _r ? _r.value : _r.textContent,
                                Wo = !0)),
                                bt = yi(pe, _n),
                                0 < bt.length && (_n = new Dm(_n,i,null,u,De),
                                Ie.push({
                                    event: _n,
                                    listeners: bt
                                }),
                                $t ? _n.data = $t : ($t = _d(u),
                                $t !== null && (_n.data = $t)))),
                                ($t = Om ? zm(i, u) : Gc(i, u)) && (_n = yi(pe, "onBeforeInput"),
                                0 < _n.length && (bt = new Dm("onBeforeInput","beforeinput",null,u,De),
                                Ie.push({
                                    event: bt,
                                    listeners: _n
                                }),
                                bt.data = $t)),
                                gt(Ie, i, pe, u, De)
                            }
                            me(Ie, s)
                        })
                    }
                    function pn(i, s, u) {
                        return {
                            instance: i,
                            listener: s,
                            currentTarget: u
                        }
                    }
                    function yi(i, s) {
                        for (var u = s + "Capture", h = []; i !== null; ) {
                            var S = i
                              , b = S.stateNode;
                            if (S = S.tag,
                            S !== 5 && S !== 26 && S !== 27 || b === null || (S = Ll(i, u),
                            S != null && h.unshift(pn(i, S, b)),
                            S = Ll(i, s),
                            S != null && h.push(pn(i, S, b))),
                            i.tag === 3)
                                return h;
                            i = i.return
                        }
                        return []
                    }
                    function An(i) {
                        if (i === null)
                            return null;
                        do
                            i = i.return;
                        while (i && i.tag !== 5 && i.tag !== 27);
                        return i || null
                    }
                    function Fr(i, s, u, h, S) {
                        for (var b = s._reactName, D = []; u !== null && u !== h; ) {
                            var F = u
                              , ee = F.alternate
                              , pe = F.stateNode;
                            if (F = F.tag,
                            ee !== null && ee === h)
                                break;
                            F !== 5 && F !== 26 && F !== 27 || pe === null || (ee = pe,
                            S ? (pe = Ll(u, b),
                            pe != null && D.unshift(pn(u, pe, ee))) : S || (pe = Ll(u, b),
                            pe != null && D.push(pn(u, pe, ee)))),
                            u = u.return
                        }
                        D.length !== 0 && i.push({
                            event: s,
                            listeners: D
                        })
                    }
                    var Py = /\r\n?/g
                      , i2 = /\u0000|\uFFFD/g;
                    function bx(i) {
                        return (typeof i == "string" ? i : "" + i).replace(Py, `
`).replace(i2, "")
                    }
                    function Mx(i, s) {
                        return s = bx(s),
                        bx(i) === s
                    }
                    function Hn(i, s, u, h, S, b) {
                        switch (u) {
                        case "children":
                            typeof h == "string" ? s === "body" || s === "textarea" && h === "" || Di(i, h) : (typeof h == "number" || typeof h == "bigint") && s !== "body" && Di(i, "" + h);
                            break;
                        case "className":
                            Qt(i, "class", h);
                            break;
                        case "tabIndex":
                            Qt(i, "tabindex", h);
                            break;
                        case "dir":
                        case "role":
                        case "viewBox":
                        case "width":
                        case "height":
                            Qt(i, u, h);
                            break;
                        case "style":
                            rd(i, h, b);
                            break;
                        case "data":
                            if (s !== "object") {
                                Qt(i, "data", h);
                                break
                            }
                        case "src":
                        case "href":
                            if (h === "" && (s !== "a" || u !== "href")) {
                                i.removeAttribute(u);
                                break
                            }
                            if (h == null || typeof h == "function" || typeof h == "symbol" || typeof h == "boolean") {
                                i.removeAttribute(u);
                                break
                            }
                            h = uf("" + h),
                            i.setAttribute(u, h);
                            break;
                        case "action":
                        case "formAction":
                            if (typeof h == "function") {
                                i.setAttribute(u, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                                break
                            } else
                                typeof b == "function" && (u === "formAction" ? (s !== "input" && Hn(i, s, "name", S.name, S, null),
                                Hn(i, s, "formEncType", S.formEncType, S, null),
                                Hn(i, s, "formMethod", S.formMethod, S, null),
                                Hn(i, s, "formTarget", S.formTarget, S, null)) : (Hn(i, s, "encType", S.encType, S, null),
                                Hn(i, s, "method", S.method, S, null),
                                Hn(i, s, "target", S.target, S, null)));
                            if (h == null || typeof h == "symbol" || typeof h == "boolean") {
                                i.removeAttribute(u);
                                break
                            }
                            h = uf("" + h),
                            i.setAttribute(u, h);
                            break;
                        case "onClick":
                            h != null && (i.onclick = Gs);
                            break;
                        case "onScroll":
                            h != null && ne("scroll", i);
                            break;
                        case "onScrollEnd":
                            h != null && ne("scrollend", i);
                            break;
                        case "dangerouslySetInnerHTML":
                            if (h != null) {
                                if (typeof h != "object" || !("__html"in h))
                                    throw Error(r(61));
                                if (u = h.__html,
                                u != null) {
                                    if (S.children != null)
                                        throw Error(r(60));
                                    i.innerHTML = u
                                }
                            }
                            break;
                        case "multiple":
                            i.multiple = h && typeof h != "function" && typeof h != "symbol";
                            break;
                        case "muted":
                            i.muted = h && typeof h != "function" && typeof h != "symbol";
                            break;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "defaultValue":
                        case "defaultChecked":
                        case "innerHTML":
                        case "ref":
                            break;
                        case "autoFocus":
                            break;
                        case "xlinkHref":
                            if (h == null || typeof h == "function" || typeof h == "boolean" || typeof h == "symbol") {
                                i.removeAttribute("xlink:href");
                                break
                            }
                            u = uf("" + h),
                            i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", u);
                            break;
                        case "contentEditable":
                        case "spellCheck":
                        case "draggable":
                        case "value":
                        case "autoReverse":
                        case "externalResourcesRequired":
                        case "focusable":
                        case "preserveAlpha":
                            h != null && typeof h != "function" && typeof h != "symbol" ? i.setAttribute(u, "" + h) : i.removeAttribute(u);
                            break;
                        case "inert":
                        case "allowFullScreen":
                        case "async":
                        case "autoPlay":
                        case "controls":
                        case "default":
                        case "defer":
                        case "disabled":
                        case "disablePictureInPicture":
                        case "disableRemotePlayback":
                        case "formNoValidate":
                        case "hidden":
                        case "loop":
                        case "noModule":
                        case "noValidate":
                        case "open":
                        case "playsInline":
                        case "readOnly":
                        case "required":
                        case "reversed":
                        case "scoped":
                        case "seamless":
                        case "itemScope":
                            h && typeof h != "function" && typeof h != "symbol" ? i.setAttribute(u, "") : i.removeAttribute(u);
                            break;
                        case "capture":
                        case "download":
                            h === !0 ? i.setAttribute(u, "") : h !== !1 && h != null && typeof h != "function" && typeof h != "symbol" ? i.setAttribute(u, h) : i.removeAttribute(u);
                            break;
                        case "cols":
                        case "rows":
                        case "size":
                        case "span":
                            h != null && typeof h != "function" && typeof h != "symbol" && !isNaN(h) && 1 <= h ? i.setAttribute(u, h) : i.removeAttribute(u);
                            break;
                        case "rowSpan":
                        case "start":
                            h == null || typeof h == "function" || typeof h == "symbol" || isNaN(h) ? i.removeAttribute(u) : i.setAttribute(u, h);
                            break;
                        case "popover":
                            ne("beforetoggle", i),
                            ne("toggle", i),
                            Tt(i, "popover", h);
                            break;
                        case "xlinkActuate":
                            cn(i, "http://www.w3.org/1999/xlink", "xlink:actuate", h);
                            break;
                        case "xlinkArcrole":
                            cn(i, "http://www.w3.org/1999/xlink", "xlink:arcrole", h);
                            break;
                        case "xlinkRole":
                            cn(i, "http://www.w3.org/1999/xlink", "xlink:role", h);
                            break;
                        case "xlinkShow":
                            cn(i, "http://www.w3.org/1999/xlink", "xlink:show", h);
                            break;
                        case "xlinkTitle":
                            cn(i, "http://www.w3.org/1999/xlink", "xlink:title", h);
                            break;
                        case "xlinkType":
                            cn(i, "http://www.w3.org/1999/xlink", "xlink:type", h);
                            break;
                        case "xmlBase":
                            cn(i, "http://www.w3.org/XML/1998/namespace", "xml:base", h);
                            break;
                        case "xmlLang":
                            cn(i, "http://www.w3.org/XML/1998/namespace", "xml:lang", h);
                            break;
                        case "xmlSpace":
                            cn(i, "http://www.w3.org/XML/1998/namespace", "xml:space", h);
                            break;
                        case "is":
                            Tt(i, "is", h);
                            break;
                        case "innerText":
                        case "textContent":
                            break;
                        default:
                            (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = od.get(u) || u,
                            Tt(i, u, h))
                        }
                    }
                    function zy(i, s, u, h, S, b) {
                        switch (u) {
                        case "style":
                            rd(i, h, b);
                            break;
                        case "dangerouslySetInnerHTML":
                            if (h != null) {
                                if (typeof h != "object" || !("__html"in h))
                                    throw Error(r(61));
                                if (u = h.__html,
                                u != null) {
                                    if (S.children != null)
                                        throw Error(r(60));
                                    i.innerHTML = u
                                }
                            }
                            break;
                        case "children":
                            typeof h == "string" ? Di(i, h) : (typeof h == "number" || typeof h == "bigint") && Di(i, "" + h);
                            break;
                        case "onScroll":
                            h != null && ne("scroll", i);
                            break;
                        case "onScrollEnd":
                            h != null && ne("scrollend", i);
                            break;
                        case "onClick":
                            h != null && (i.onclick = Gs);
                            break;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "innerHTML":
                        case "ref":
                            break;
                        case "innerText":
                        case "textContent":
                            break;
                        default:
                            if (!fe.hasOwnProperty(u))
                                e: {
                                    if (u[0] === "o" && u[1] === "n" && (S = u.endsWith("Capture"),
                                    s = u.slice(2, S ? u.length - 7 : void 0),
                                    b = i[Ci] || null,
                                    b = b != null ? b[u] : null,
                                    typeof b == "function" && i.removeEventListener(s, b, S),
                                    typeof h == "function")) {
                                        typeof b != "function" && b !== null && (u in i ? i[u] = null : i.hasAttribute(u) && i.removeAttribute(u)),
                                        i.addEventListener(s, h, S);
                                        break e
                                    }
                                    u in i ? i[u] = h : h === !0 ? i.setAttribute(u, "") : Tt(i, u, h)
                                }
                        }
                    }
                    function _a(i, s, u) {
                        switch (s) {
                        case "div":
                        case "span":
                        case "svg":
                        case "path":
                        case "a":
                        case "g":
                        case "p":
                        case "li":
                            break;
                        case "img":
                            ne("error", i),
                            ne("load", i);
                            var h = !1, S = !1, b;
                            for (b in u)
                                if (u.hasOwnProperty(b)) {
                                    var D = u[b];
                                    if (D != null)
                                        switch (b) {
                                        case "src":
                                            h = !0;
                                            break;
                                        case "srcSet":
                                            S = !0;
                                            break;
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            throw Error(r(137, s));
                                        default:
                                            Hn(i, s, b, D, u, null)
                                        }
                                }
                            S && Hn(i, s, "srcSet", u.srcSet, u, null),
                            h && Hn(i, s, "src", u.src, u, null);
                            return;
                        case "input":
                            ne("invalid", i);
                            var F = b = D = S = null
                              , ee = null
                              , pe = null;
                            for (h in u)
                                if (u.hasOwnProperty(h)) {
                                    var De = u[h];
                                    if (De != null)
                                        switch (h) {
                                        case "name":
                                            S = De;
                                            break;
                                        case "type":
                                            D = De;
                                            break;
                                        case "checked":
                                            ee = De;
                                            break;
                                        case "defaultChecked":
                                            pe = De;
                                            break;
                                        case "value":
                                            b = De;
                                            break;
                                        case "defaultValue":
                                            F = De;
                                            break;
                                        case "children":
                                        case "dangerouslySetInnerHTML":
                                            if (De != null)
                                                throw Error(r(137, s));
                                            break;
                                        default:
                                            Hn(i, s, h, De, u, null)
                                        }
                                }
                            Ji(i, b, F, ee, pe, D, S, !1);
                            return;
                        case "select":
                            ne("invalid", i),
                            h = D = b = null;
                            for (S in u)
                                if (u.hasOwnProperty(S) && (F = u[S],
                                F != null))
                                    switch (S) {
                                    case "value":
                                        b = F;
                                        break;
                                    case "defaultValue":
                                        D = F;
                                        break;
                                    case "multiple":
                                        h = F;
                                    default:
                                        Hn(i, s, S, F, u, null)
                                    }
                            s = b,
                            u = D,
                            i.multiple = !!h,
                            s != null ? Jn(i, !!h, s, !1) : u != null && Jn(i, !!h, u, !0);
                            return;
                        case "textarea":
                            ne("invalid", i),
                            b = S = h = null;
                            for (D in u)
                                if (u.hasOwnProperty(D) && (F = u[D],
                                F != null))
                                    switch (D) {
                                    case "value":
                                        h = F;
                                        break;
                                    case "defaultValue":
                                        S = F;
                                        break;
                                    case "children":
                                        b = F;
                                        break;
                                    case "dangerouslySetInnerHTML":
                                        if (F != null)
                                            throw Error(r(91));
                                        break;
                                    default:
                                        Hn(i, s, D, F, u, null)
                                    }
                            hi(i, h, S, b);
                            return;
                        case "option":
                            for (ee in u)
                                u.hasOwnProperty(ee) && (h = u[ee],
                                h != null) && (ee === "selected" ? i.selected = h && typeof h != "function" && typeof h != "symbol" : Hn(i, s, ee, h, u, null));
                            return;
                        case "dialog":
                            ne("beforetoggle", i),
                            ne("toggle", i),
                            ne("cancel", i),
                            ne("close", i);
                            break;
                        case "iframe":
                        case "object":
                            ne("load", i);
                            break;
                        case "video":
                        case "audio":
                            for (h = 0; h < Br.length; h++)
                                ne(Br[h], i);
                            break;
                        case "image":
                            ne("error", i),
                            ne("load", i);
                            break;
                        case "details":
                            ne("toggle", i);
                            break;
                        case "embed":
                        case "source":
                        case "link":
                            ne("error", i),
                            ne("load", i);
                        case "area":
                        case "base":
                        case "br":
                        case "col":
                        case "hr":
                        case "keygen":
                        case "meta":
                        case "param":
                        case "track":
                        case "wbr":
                        case "menuitem":
                            for (pe in u)
                                if (u.hasOwnProperty(pe) && (h = u[pe],
                                h != null))
                                    switch (pe) {
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        throw Error(r(137, s));
                                    default:
                                        Hn(i, s, pe, h, u, null)
                                    }
                            return;
                        default:
                            if (cf(s)) {
                                for (De in u)
                                    u.hasOwnProperty(De) && (h = u[De],
                                    h !== void 0 && zy(i, s, De, h, u, void 0));
                                return
                            }
                        }
                        for (F in u)
                            u.hasOwnProperty(F) && (h = u[F],
                            h != null && Hn(i, s, F, h, u, null))
                    }
                    function a2(i, s, u, h) {
                        switch (s) {
                        case "div":
                        case "span":
                        case "svg":
                        case "path":
                        case "a":
                        case "g":
                        case "p":
                        case "li":
                            break;
                        case "input":
                            var S = null
                              , b = null
                              , D = null
                              , F = null
                              , ee = null
                              , pe = null
                              , De = null;
                            for (Se in u) {
                                var Ie = u[Se];
                                if (u.hasOwnProperty(Se) && Ie != null)
                                    switch (Se) {
                                    case "checked":
                                        break;
                                    case "value":
                                        break;
                                    case "defaultValue":
                                        ee = Ie;
                                    default:
                                        h.hasOwnProperty(Se) || Hn(i, s, Se, null, h, Ie)
                                    }
                            }
                            for (var ge in h) {
                                var Se = h[ge];
                                if (Ie = u[ge],
                                h.hasOwnProperty(ge) && (Se != null || Ie != null))
                                    switch (ge) {
                                    case "type":
                                        b = Se;
                                        break;
                                    case "name":
                                        S = Se;
                                        break;
                                    case "checked":
                                        pe = Se;
                                        break;
                                    case "defaultChecked":
                                        De = Se;
                                        break;
                                    case "value":
                                        D = Se;
                                        break;
                                    case "defaultValue":
                                        F = Se;
                                        break;
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        if (Se != null)
                                            throw Error(r(137, s));
                                        break;
                                    default:
                                        Se !== Ie && Hn(i, s, ge, Se, h, Ie)
                                    }
                            }
                            Ri(i, D, F, ee, pe, De, b, S);
                            return;
                        case "select":
                            Se = D = F = ge = null;
                            for (b in u)
                                if (ee = u[b],
                                u.hasOwnProperty(b) && ee != null)
                                    switch (b) {
                                    case "value":
                                        break;
                                    case "multiple":
                                        Se = ee;
                                    default:
                                        h.hasOwnProperty(b) || Hn(i, s, b, null, h, ee)
                                    }
                            for (S in h)
                                if (b = h[S],
                                ee = u[S],
                                h.hasOwnProperty(S) && (b != null || ee != null))
                                    switch (S) {
                                    case "value":
                                        ge = b;
                                        break;
                                    case "defaultValue":
                                        F = b;
                                        break;
                                    case "multiple":
                                        D = b;
                                    default:
                                        b !== ee && Hn(i, s, S, b, h, ee)
                                    }
                            s = F,
                            u = D,
                            h = Se,
                            ge != null ? Jn(i, !!u, ge, !1) : !!h != !!u && (s != null ? Jn(i, !!u, s, !0) : Jn(i, !!u, u ? [] : "", !1));
                            return;
                        case "textarea":
                            Se = ge = null;
                            for (F in u)
                                if (S = u[F],
                                u.hasOwnProperty(F) && S != null && !h.hasOwnProperty(F))
                                    switch (F) {
                                    case "value":
                                        break;
                                    case "children":
                                        break;
                                    default:
                                        Hn(i, s, F, null, h, S)
                                    }
                            for (D in h)
                                if (S = h[D],
                                b = u[D],
                                h.hasOwnProperty(D) && (S != null || b != null))
                                    switch (D) {
                                    case "value":
                                        ge = S;
                                        break;
                                    case "defaultValue":
                                        Se = S;
                                        break;
                                    case "children":
                                        break;
                                    case "dangerouslySetInnerHTML":
                                        if (S != null)
                                            throw Error(r(91));
                                        break;
                                    default:
                                        S !== b && Hn(i, s, D, S, h, b)
                                    }
                            qi(i, ge, Se);
                            return;
                        case "option":
                            for (var yt in u)
                                ge = u[yt],
                                u.hasOwnProperty(yt) && ge != null && !h.hasOwnProperty(yt) && (yt === "selected" ? i.selected = !1 : Hn(i, s, yt, null, h, ge));
                            for (ee in h)
                                ge = h[ee],
                                Se = u[ee],
                                h.hasOwnProperty(ee) && ge !== Se && (ge != null || Se != null) && (ee === "selected" ? i.selected = ge && typeof ge != "function" && typeof ge != "symbol" : Hn(i, s, ee, ge, h, Se));
                            return;
                        case "img":
                        case "link":
                        case "area":
                        case "base":
                        case "br":
                        case "col":
                        case "embed":
                        case "hr":
                        case "keygen":
                        case "meta":
                        case "param":
                        case "source":
                        case "track":
                        case "wbr":
                        case "menuitem":
                            for (var zt in u)
                                ge = u[zt],
                                u.hasOwnProperty(zt) && ge != null && !h.hasOwnProperty(zt) && Hn(i, s, zt, null, h, ge);
                            for (pe in h)
                                if (ge = h[pe],
                                Se = u[pe],
                                h.hasOwnProperty(pe) && ge !== Se && (ge != null || Se != null))
                                    switch (pe) {
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        if (ge != null)
                                            throw Error(r(137, s));
                                        break;
                                    default:
                                        Hn(i, s, pe, ge, h, Se)
                                    }
                            return;
                        default:
                            if (cf(s)) {
                                for (var Gn in u)
                                    ge = u[Gn],
                                    u.hasOwnProperty(Gn) && ge !== void 0 && !h.hasOwnProperty(Gn) && zy(i, s, Gn, void 0, h, ge);
                                for (De in h)
                                    ge = h[De],
                                    Se = u[De],
                                    !h.hasOwnProperty(De) || ge === Se || ge === void 0 && Se === void 0 || zy(i, s, De, ge, h, Se);
                                return
                            }
                        }
                        for (var ue in u)
                            ge = u[ue],
                            u.hasOwnProperty(ue) && ge != null && !h.hasOwnProperty(ue) && Hn(i, s, ue, null, h, ge);
                        for (Ie in h)
                            ge = h[Ie],
                            Se = u[Ie],
                            !h.hasOwnProperty(Ie) || ge === Se || ge == null && Se == null || Hn(i, s, Ie, ge, h, Se)
                    }
                    function Tx(i) {
                        switch (i) {
                        case "css":
                        case "script":
                        case "font":
                        case "img":
                        case "image":
                        case "input":
                        case "link":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    function s2() {
                        if (typeof performance.getEntriesByType == "function") {
                            for (var i = 0, s = 0, u = performance.getEntriesByType("resource"), h = 0; h < u.length; h++) {
                                var S = u[h]
                                  , b = S.transferSize
                                  , D = S.initiatorType
                                  , F = S.duration;
                                if (b && F && Tx(D)) {
                                    for (D = 0,
                                    F = S.responseEnd,
                                    h += 1; h < u.length; h++) {
                                        var ee = u[h]
                                          , pe = ee.startTime;
                                        if (pe > F)
                                            break;
                                        var De = ee.transferSize
                                          , Ie = ee.initiatorType;
                                        De && Tx(Ie) && (ee = ee.responseEnd,
                                        D += De * (ee < F ? 1 : (F - pe) / (ee - pe)))
                                    }
                                    if (--h,
                                    s += 8 * (b + D) / (S.duration / 1e3),
                                    i++,
                                    10 < i)
                                        break
                                }
                            }
                            if (0 < i)
                                return s / i / 1e6
                        }
                        return navigator.connection && (i = navigator.connection.downlink,
                        typeof i == "number") ? i : 5
                    }
                    var By = null
                      , Fy = null;
                    function Wg(i) {
                        return i.nodeType === 9 ? i : i.ownerDocument
                    }
                    function Ex(i) {
                        switch (i) {
                        case "http://www.w3.org/2000/svg":
                            return 1;
                        case "http://www.w3.org/1998/Math/MathML":
                            return 2;
                        default:
                            return 0
                        }
                    }
                    function Ax(i, s) {
                        if (i === 0)
                            switch (s) {
                            case "svg":
                                return 1;
                            case "math":
                                return 2;
                            default:
                                return 0
                            }
                        return i === 1 && s === "foreignObject" ? 0 : i
                    }
                    function Vy(i, s) {
                        return i === "textarea" || i === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.children == "bigint" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null
                    }
                    var ky = null;
                    function r2() {
                        var i = window.event;
                        return i && i.type === "popstate" ? i === ky ? !1 : (ky = i,
                        !0) : (ky = null,
                        !1)
                    }
                    var wx = typeof setTimeout == "function" ? setTimeout : void 0
                      , o2 = typeof clearTimeout == "function" ? clearTimeout : void 0
                      , Cx = typeof Promise == "function" ? Promise : void 0
                      , l2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Cx < "u" ? function(i) {
                        return Cx.resolve(null).then(i).catch(c2)
                    }
                    : wx;
                    function c2(i) {
                        setTimeout(function() {
                            throw i
                        })
                    }
                    function uc(i) {
                        return i === "head"
                    }
                    function Rx(i, s) {
                        var u = s
                          , h = 0;
                        do {
                            var S = u.nextSibling;
                            if (i.removeChild(u),
                            S && S.nodeType === 8)
                                if (u = S.data,
                                u === "/$" || u === "/&") {
                                    if (h === 0) {
                                        i.removeChild(S),
                                        uh(s);
                                        return
                                    }
                                    h--
                                } else if (u === "$" || u === "$?" || u === "$~" || u === "$!" || u === "&")
                                    h++;
                                else if (u === "html")
                                    Sp(i.ownerDocument.documentElement);
                                else if (u === "head") {
                                    u = i.ownerDocument.head,
                                    Sp(u);
                                    for (var b = u.firstChild; b; ) {
                                        var D = b.nextSibling
                                          , F = b.nodeName;
                                        b[Es] || F === "SCRIPT" || F === "STYLE" || F === "LINK" && b.rel.toLowerCase() === "stylesheet" || u.removeChild(b),
                                        b = D
                                    }
                                } else
                                    u === "body" && Sp(i.ownerDocument.body);
                            u = S
                        } while (u);
                        uh(s)
                    }
                    function Dx(i, s) {
                        var u = i;
                        i = 0;
                        do {
                            var h = u.nextSibling;
                            if (u.nodeType === 1 ? s ? (u._stashedDisplay = u.style.display,
                            u.style.display = "none") : (u.style.display = u._stashedDisplay || "",
                            u.getAttribute("style") === "" && u.removeAttribute("style")) : u.nodeType === 3 && (s ? (u._stashedText = u.nodeValue,
                            u.nodeValue = "") : u.nodeValue = u._stashedText || ""),
                            h && h.nodeType === 8)
                                if (u = h.data,
                                u === "/$") {
                                    if (i === 0)
                                        break;
                                    i--
                                } else
                                    u !== "$" && u !== "$?" && u !== "$~" && u !== "$!" || i++;
                            u = h
                        } while (u)
                    }
                    function Hy(i) {
                        var s = i.firstChild;
                        for (s && s.nodeType === 10 && (s = s.nextSibling); s; ) {
                            var u = s;
                            switch (s = s.nextSibling,
                            u.nodeName) {
                            case "HTML":
                            case "HEAD":
                            case "BODY":
                                Hy(u),
                                Dl(u);
                                continue;
                            case "SCRIPT":
                            case "STYLE":
                                continue;
                            case "LINK":
                                if (u.rel.toLowerCase() === "stylesheet")
                                    continue
                            }
                            i.removeChild(u)
                        }
                    }
                    function u2(i, s, u, h) {
                        for (; i.nodeType === 1; ) {
                            var S = u;
                            if (i.nodeName.toLowerCase() !== s.toLowerCase()) {
                                if (!h && (i.nodeName !== "INPUT" || i.type !== "hidden"))
                                    break
                            } else if (h) {
                                if (!i[Es])
                                    switch (s) {
                                    case "meta":
                                        if (!i.hasAttribute("itemprop"))
                                            break;
                                        return i;
                                    case "link":
                                        if (b = i.getAttribute("rel"),
                                        b === "stylesheet" && i.hasAttribute("data-precedence"))
                                            break;
                                        if (b !== S.rel || i.getAttribute("href") !== (S.href == null || S.href === "" ? null : S.href) || i.getAttribute("crossorigin") !== (S.crossOrigin == null ? null : S.crossOrigin) || i.getAttribute("title") !== (S.title == null ? null : S.title))
                                            break;
                                        return i;
                                    case "style":
                                        if (i.hasAttribute("data-precedence"))
                                            break;
                                        return i;
                                    case "script":
                                        if (b = i.getAttribute("src"),
                                        (b !== (S.src == null ? null : S.src) || i.getAttribute("type") !== (S.type == null ? null : S.type) || i.getAttribute("crossorigin") !== (S.crossOrigin == null ? null : S.crossOrigin)) && b && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                                            break;
                                        return i;
                                    default:
                                        return i
                                    }
                            } else if (s === "input" && i.type === "hidden") {
                                var b = S.name == null ? null : "" + S.name;
                                if (S.type === "hidden" && i.getAttribute("name") === b)
                                    return i
                            } else
                                return i;
                            if (i = lr(i.nextSibling),
                            i === null)
                                break
                        }
                        return null
                    }
                    function f2(i, s, u) {
                        if (s === "")
                            return null;
                        for (; i.nodeType !== 3; )
                            if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !u || (i = lr(i.nextSibling),
                            i === null))
                                return null;
                        return i
                    }
                    function Nx(i, s) {
                        for (; i.nodeType !== 8; )
                            if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !s || (i = lr(i.nextSibling),
                            i === null))
                                return null;
                        return i
                    }
                    function Gy(i) {
                        return i.data === "$?" || i.data === "$~"
                    }
                    function Wy(i) {
                        return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState !== "loading"
                    }
                    function h2(i, s) {
                        var u = i.ownerDocument;
                        if (i.data === "$~")
                            i._reactRetry = s;
                        else if (i.data !== "$?" || u.readyState !== "loading")
                            s();
                        else {
                            var h = function() {
                                s(),
                                u.removeEventListener("DOMContentLoaded", h)
                            };
                            u.addEventListener("DOMContentLoaded", h),
                            i._reactRetry = h
                        }
                    }
                    function lr(i) {
                        for (; i != null; i = i.nextSibling) {
                            var s = i.nodeType;
                            if (s === 1 || s === 3)
                                break;
                            if (s === 8) {
                                if (s = i.data,
                                s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&" || s === "F!" || s === "F")
                                    break;
                                if (s === "/$" || s === "/&")
                                    return null
                            }
                        }
                        return i
                    }
                    var Xy = null;
                    function Lx(i) {
                        i = i.nextSibling;
                        for (var s = 0; i; ) {
                            if (i.nodeType === 8) {
                                var u = i.data;
                                if (u === "/$" || u === "/&") {
                                    if (s === 0)
                                        return lr(i.nextSibling);
                                    s--
                                } else
                                    u !== "$" && u !== "$!" && u !== "$?" && u !== "$~" && u !== "&" || s++
                            }
                            i = i.nextSibling
                        }
                        return null
                    }
                    function Ux(i) {
                        i = i.previousSibling;
                        for (var s = 0; i; ) {
                            if (i.nodeType === 8) {
                                var u = i.data;
                                if (u === "$" || u === "$!" || u === "$?" || u === "$~" || u === "&") {
                                    if (s === 0)
                                        return i;
                                    s--
                                } else
                                    u !== "/$" && u !== "/&" || s++
                            }
                            i = i.previousSibling
                        }
                        return null
                    }
                    function Ix(i, s, u) {
                        switch (s = Wg(u),
                        i) {
                        case "html":
                            if (i = s.documentElement,
                            !i)
                                throw Error(r(452));
                            return i;
                        case "head":
                            if (i = s.head,
                            !i)
                                throw Error(r(453));
                            return i;
                        case "body":
                            if (i = s.body,
                            !i)
                                throw Error(r(454));
                            return i;
                        default:
                            throw Error(r(451))
                        }
                    }
                    function Sp(i) {
                        for (var s = i.attributes; s.length; )
                            i.removeAttributeNode(s[0]);
                        Dl(i)
                    }
                    var cr = new Map
                      , Ox = new Set;
                    function Xg(i) {
                        return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument
                    }
                    var gl = se.d;
                    se.d = {
                        f: d2,
                        r: p2,
                        D: m2,
                        C: g2,
                        L: v2,
                        m: y2,
                        X: S2,
                        S: _2,
                        M: x2
                    };
                    function d2() {
                        var i = gl.f()
                          , s = dl();
                        return i || s
                    }
                    function p2(i) {
                        var s = vr(i);
                        s !== null && s.tag === 5 && s.type === "form" ? yg(s) : gl.r(i)
                    }
                    var oh = typeof document > "u" ? null : document;
                    function Px(i, s, u) {
                        var h = oh;
                        if (h && typeof s == "string" && s) {
                            var S = ni(s);
                            S = 'link[rel="' + i + '"][href="' + S + '"]',
                            typeof u == "string" && (S += '[crossorigin="' + u + '"]'),
                            Ox.has(S) || (Ox.add(S),
                            i = {
                                rel: i,
                                crossOrigin: u,
                                href: s
                            },
                            h.querySelector(S) === null && (s = h.createElement("link"),
                            _a(s, "link", i),
                            he(s),
                            h.head.appendChild(s)))
                        }
                    }
                    function m2(i) {
                        gl.D(i),
                        Px("dns-prefetch", i, null)
                    }
                    function g2(i, s) {
                        gl.C(i, s),
                        Px("preconnect", i, s)
                    }
                    function v2(i, s, u) {
                        gl.L(i, s, u);
                        var h = oh;
                        if (h && i && s) {
                            var S = 'link[rel="preload"][as="' + ni(s) + '"]';
                            s === "image" && u && u.imageSrcSet ? (S += '[imagesrcset="' + ni(u.imageSrcSet) + '"]',
                            typeof u.imageSizes == "string" && (S += '[imagesizes="' + ni(u.imageSizes) + '"]')) : S += '[href="' + ni(i) + '"]';
                            var b = S;
                            switch (s) {
                            case "style":
                                b = lh(i);
                                break;
                            case "script":
                                b = ch(i)
                            }
                            cr.has(b) || (i = x({
                                rel: "preload",
                                href: s === "image" && u && u.imageSrcSet ? void 0 : i,
                                as: s
                            }, u),
                            cr.set(b, i),
                            h.querySelector(S) !== null || s === "style" && h.querySelector(xp(b)) || s === "script" && h.querySelector(bp(b)) || (s = h.createElement("link"),
                            _a(s, "link", i),
                            he(s),
                            h.head.appendChild(s)))
                        }
                    }
                    function y2(i, s) {
                        gl.m(i, s);
                        var u = oh;
                        if (u && i) {
                            var h = s && typeof s.as == "string" ? s.as : "script"
                              , S = 'link[rel="modulepreload"][as="' + ni(h) + '"][href="' + ni(i) + '"]'
                              , b = S;
                            switch (h) {
                            case "audioworklet":
                            case "paintworklet":
                            case "serviceworker":
                            case "sharedworker":
                            case "worker":
                            case "script":
                                b = ch(i)
                            }
                            if (!cr.has(b) && (i = x({
                                rel: "modulepreload",
                                href: i
                            }, s),
                            cr.set(b, i),
                            u.querySelector(S) === null)) {
                                switch (h) {
                                case "audioworklet":
                                case "paintworklet":
                                case "serviceworker":
                                case "sharedworker":
                                case "worker":
                                case "script":
                                    if (u.querySelector(bp(b)))
                                        return
                                }
                                h = u.createElement("link"),
                                _a(h, "link", i),
                                he(h),
                                u.head.appendChild(h)
                            }
                        }
                    }
                    function _2(i, s, u) {
                        gl.S(i, s, u);
                        var h = oh;
                        if (h && i) {
                            var S = re(h).hoistableStyles
                              , b = lh(i);
                            s = s || "default";
                            var D = S.get(b);
                            if (!D) {
                                var F = {
                                    loading: 0,
                                    preload: null
                                };
                                if (D = h.querySelector(xp(b)))
                                    F.loading = 5;
                                else {
                                    i = x({
                                        rel: "stylesheet",
                                        href: i,
                                        "data-precedence": s
                                    }, u),
                                    (u = cr.get(b)) && qy(i, u);
                                    var ee = D = h.createElement("link");
                                    he(ee),
                                    _a(ee, "link", i),
                                    ee._p = new Promise(function(pe, De) {
                                        ee.onload = pe,
                                        ee.onerror = De
                                    }
                                    ),
                                    ee.addEventListener("load", function() {
                                        F.loading |= 1
                                    }),
                                    ee.addEventListener("error", function() {
                                        F.loading |= 2
                                    }),
                                    F.loading |= 4,
                                    qg(D, s, h)
                                }
                                D = {
                                    type: "stylesheet",
                                    instance: D,
                                    count: 1,
                                    state: F
                                },
                                S.set(b, D)
                            }
                        }
                    }
                    function S2(i, s) {
                        gl.X(i, s);
                        var u = oh;
                        if (u && i) {
                            var h = re(u).hoistableScripts
                              , S = ch(i)
                              , b = h.get(S);
                            b || (b = u.querySelector(bp(S)),
                            b || (i = x({
                                src: i,
                                async: !0
                            }, s),
                            (s = cr.get(S)) && Yy(i, s),
                            b = u.createElement("script"),
                            he(b),
                            _a(b, "link", i),
                            u.head.appendChild(b)),
                            b = {
                                type: "script",
                                instance: b,
                                count: 1,
                                state: null
                            },
                            h.set(S, b))
                        }
                    }
                    function x2(i, s) {
                        gl.M(i, s);
                        var u = oh;
                        if (u && i) {
                            var h = re(u).hoistableScripts
                              , S = ch(i)
                              , b = h.get(S);
                            b || (b = u.querySelector(bp(S)),
                            b || (i = x({
                                src: i,
                                async: !0,
                                type: "module"
                            }, s),
                            (s = cr.get(S)) && Yy(i, s),
                            b = u.createElement("script"),
                            he(b),
                            _a(b, "link", i),
                            u.head.appendChild(b)),
                            b = {
                                type: "script",
                                instance: b,
                                count: 1,
                                state: null
                            },
                            h.set(S, b))
                        }
                    }
                    function zx(i, s, u, h) {
                        var S = (S = Ne.current) ? Xg(S) : null;
                        if (!S)
                            throw Error(r(446));
                        switch (i) {
                        case "meta":
                        case "title":
                            return null;
                        case "style":
                            return typeof u.precedence == "string" && typeof u.href == "string" ? (s = lh(u.href),
                            u = re(S).hoistableStyles,
                            h = u.get(s),
                            h || (h = {
                                type: "style",
                                instance: null,
                                count: 0,
                                state: null
                            },
                            u.set(s, h)),
                            h) : {
                                type: "void",
                                instance: null,
                                count: 0,
                                state: null
                            };
                        case "link":
                            if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
                                i = lh(u.href);
                                var b = re(S).hoistableStyles
                                  , D = b.get(i);
                                if (D || (S = S.ownerDocument || S,
                                D = {
                                    type: "stylesheet",
                                    instance: null,
                                    count: 0,
                                    state: {
                                        loading: 0,
                                        preload: null
                                    }
                                },
                                b.set(i, D),
                                (b = S.querySelector(xp(i))) && !b._p && (D.instance = b,
                                D.state.loading = 5),
                                cr.has(i) || (u = {
                                    rel: "preload",
                                    as: "style",
                                    href: u.href,
                                    crossOrigin: u.crossOrigin,
                                    integrity: u.integrity,
                                    media: u.media,
                                    hrefLang: u.hrefLang,
                                    referrerPolicy: u.referrerPolicy
                                },
                                cr.set(i, u),
                                b || b2(S, i, u, D.state))),
                                s && h === null)
                                    throw Error(r(528, ""));
                                return D
                            }
                            if (s && h !== null)
                                throw Error(r(529, ""));
                            return null;
                        case "script":
                            return s = u.async,
                            u = u.src,
                            typeof u == "string" && s && typeof s != "function" && typeof s != "symbol" ? (s = ch(u),
                            u = re(S).hoistableScripts,
                            h = u.get(s),
                            h || (h = {
                                type: "script",
                                instance: null,
                                count: 0,
                                state: null
                            },
                            u.set(s, h)),
                            h) : {
                                type: "void",
                                instance: null,
                                count: 0,
                                state: null
                            };
                        default:
                            throw Error(r(444, i))
                        }
                    }
                    function lh(i) {
                        return 'href="' + ni(i) + '"'
                    }
                    function xp(i) {
                        return 'link[rel="stylesheet"][' + i + "]"
                    }
                    function Bx(i) {
                        return x({}, i, {
                            "data-precedence": i.precedence,
                            precedence: null
                        })
                    }
                    function b2(i, s, u, h) {
                        i.querySelector('link[rel="preload"][as="style"][' + s + "]") ? h.loading = 1 : (s = i.createElement("link"),
                        h.preload = s,
                        s.addEventListener("load", function() {
                            return h.loading |= 1
                        }),
                        s.addEventListener("error", function() {
                            return h.loading |= 2
                        }),
                        _a(s, "link", u),
                        he(s),
                        i.head.appendChild(s))
                    }
                    function ch(i) {
                        return '[src="' + ni(i) + '"]'
                    }
                    function bp(i) {
                        return "script[async]" + i
                    }
                    function Fx(i, s, u) {
                        if (s.count++,
                        s.instance === null)
                            switch (s.type) {
                            case "style":
                                var h = i.querySelector('style[data-href~="' + ni(u.href) + '"]');
                                if (h)
                                    return s.instance = h,
                                    he(h),
                                    h;
                                var S = x({}, u, {
                                    "data-href": u.href,
                                    "data-precedence": u.precedence,
                                    href: null,
                                    precedence: null
                                });
                                return h = (i.ownerDocument || i).createElement("style"),
                                he(h),
                                _a(h, "style", S),
                                qg(h, u.precedence, i),
                                s.instance = h;
                            case "stylesheet":
                                S = lh(u.href);
                                var b = i.querySelector(xp(S));
                                if (b)
                                    return s.state.loading |= 4,
                                    s.instance = b,
                                    he(b),
                                    b;
                                h = Bx(u),
                                (S = cr.get(S)) && qy(h, S),
                                b = (i.ownerDocument || i).createElement("link"),
                                he(b);
                                var D = b;
                                return D._p = new Promise(function(F, ee) {
                                    D.onload = F,
                                    D.onerror = ee
                                }
                                ),
                                _a(b, "link", h),
                                s.state.loading |= 4,
                                qg(b, u.precedence, i),
                                s.instance = b;
                            case "script":
                                return b = ch(u.src),
                                (S = i.querySelector(bp(b))) ? (s.instance = S,
                                he(S),
                                S) : (h = u,
                                (S = cr.get(b)) && (h = x({}, u),
                                Yy(h, S)),
                                i = i.ownerDocument || i,
                                S = i.createElement("script"),
                                he(S),
                                _a(S, "link", h),
                                i.head.appendChild(S),
                                s.instance = S);
                            case "void":
                                return null;
                            default:
                                throw Error(r(443, s.type))
                            }
                        else
                            s.type === "stylesheet" && (s.state.loading & 4) === 0 && (h = s.instance,
                            s.state.loading |= 4,
                            qg(h, u.precedence, i));
                        return s.instance
                    }
                    function qg(i, s, u) {
                        for (var h = u.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), S = h.length ? h[h.length - 1] : null, b = S, D = 0; D < h.length; D++) {
                            var F = h[D];
                            if (F.dataset.precedence === s)
                                b = F;
                            else if (b !== S)
                                break
                        }
                        b ? b.parentNode.insertBefore(i, b.nextSibling) : (s = u.nodeType === 9 ? u.head : u,
                        s.insertBefore(i, s.firstChild))
                    }
                    function qy(i, s) {
                        i.crossOrigin ??= s.crossOrigin,
                        i.referrerPolicy ??= s.referrerPolicy,
                        i.title ??= s.title
                    }
                    function Yy(i, s) {
                        i.crossOrigin ??= s.crossOrigin,
                        i.referrerPolicy ??= s.referrerPolicy,
                        i.integrity ??= s.integrity
                    }
                    var Yg = null;
                    function Vx(i, s, u) {
                        if (Yg === null) {
                            var h = new Map
                              , S = Yg = new Map;
                            S.set(u, h)
                        } else
                            S = Yg,
                            h = S.get(u),
                            h || (h = new Map,
                            S.set(u, h));
                        if (h.has(i))
                            return h;
                        for (h.set(i, null),
                        u = u.getElementsByTagName(i),
                        S = 0; S < u.length; S++) {
                            var b = u[S];
                            if (!(b[Es] || b[Zn] || i === "link" && b.getAttribute("rel") === "stylesheet") && b.namespaceURI !== "http://www.w3.org/2000/svg") {
                                var D = b.getAttribute(s) || "";
                                D = i + D;
                                var F = h.get(D);
                                F ? F.push(b) : h.set(D, [b])
                            }
                        }
                        return h
                    }
                    function kx(i, s, u) {
                        i = i.ownerDocument || i,
                        i.head.insertBefore(u, s === "title" ? i.querySelector("head > title") : null)
                    }
                    function M2(i, s, u) {
                        if (u === 1 || s.itemProp != null)
                            return !1;
                        switch (i) {
                        case "meta":
                        case "title":
                            return !0;
                        case "style":
                            if (typeof s.precedence != "string" || typeof s.href != "string" || s.href === "")
                                break;
                            return !0;
                        case "link":
                            if (typeof s.rel != "string" || typeof s.href != "string" || s.href === "" || s.onLoad || s.onError)
                                break;
                            return s.rel === "stylesheet" ? (i = s.disabled,
                            typeof s.precedence == "string" && i == null) : !0;
                        case "script":
                            if (s.async && typeof s.async != "function" && typeof s.async != "symbol" && !s.onLoad && !s.onError && s.src && typeof s.src == "string")
                                return !0
                        }
                        return !1
                    }
                    function Hx(i) {
                        return !(i.type === "stylesheet" && (i.state.loading & 3) === 0)
                    }
                    function T2(i, s, u, h) {
                        if (u.type === "stylesheet" && (typeof h.media != "string" || matchMedia(h.media).matches !== !1) && (u.state.loading & 4) === 0) {
                            if (u.instance === null) {
                                var S = lh(h.href)
                                  , b = s.querySelector(xp(S));
                                if (b) {
                                    s = b._p,
                                    s !== null && typeof s == "object" && typeof s.then == "function" && (i.count++,
                                    i = jg.bind(i),
                                    s.then(i, i)),
                                    u.state.loading |= 4,
                                    u.instance = b,
                                    he(b);
                                    return
                                }
                                b = s.ownerDocument || s,
                                h = Bx(h),
                                (S = cr.get(S)) && qy(h, S),
                                b = b.createElement("link"),
                                he(b);
                                var D = b;
                                D._p = new Promise(function(F, ee) {
                                    D.onload = F,
                                    D.onerror = ee
                                }
                                ),
                                _a(b, "link", h),
                                u.instance = b
                            }
                            i.stylesheets === null && (i.stylesheets = new Map),
                            i.stylesheets.set(u, s),
                            (s = u.state.preload) && (u.state.loading & 3) === 0 && (i.count++,
                            u = jg.bind(i),
                            s.addEventListener("load", u),
                            s.addEventListener("error", u))
                        }
                    }
                    var jy = 0;
                    function E2(i, s) {
                        return i.stylesheets && i.count === 0 && Qg(i, i.stylesheets),
                        0 < i.count || 0 < i.imgCount ? function(u) {
                            var h = setTimeout(function() {
                                if (i.stylesheets && Qg(i, i.stylesheets),
                                i.unsuspend) {
                                    var b = i.unsuspend;
                                    i.unsuspend = null,
                                    b()
                                }
                            }, 6e4 + s);
                            0 < i.imgBytes && jy === 0 && (jy = 62500 * s2());
                            var S = setTimeout(function() {
                                if (i.waitingForImages = !1,
                                i.count === 0 && (i.stylesheets && Qg(i, i.stylesheets),
                                i.unsuspend)) {
                                    var b = i.unsuspend;
                                    i.unsuspend = null,
                                    b()
                                }
                            }, (i.imgBytes > jy ? 50 : 800) + s);
                            return i.unsuspend = u,
                            function() {
                                i.unsuspend = null,
                                clearTimeout(h),
                                clearTimeout(S)
                            }
                        }
                        : null
                    }
                    function jg() {
                        if (this.count--,
                        this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
                            if (this.stylesheets)
                                Qg(this, this.stylesheets);
                            else if (this.unsuspend) {
                                var i = this.unsuspend;
                                this.unsuspend = null,
                                i()
                            }
                        }
                    }
                    var Zg = null;
                    function Qg(i, s) {
                        i.stylesheets = null,
                        i.unsuspend !== null && (i.count++,
                        Zg = new Map,
                        s.forEach(A2, i),
                        Zg = null,
                        jg.call(i))
                    }
                    function A2(i, s) {
                        if (!(s.state.loading & 4)) {
                            var u = Zg.get(i);
                            if (u)
                                var h = u.get(null);
                            else {
                                u = new Map,
                                Zg.set(i, u);
                                for (var S = i.querySelectorAll("link[data-precedence],style[data-precedence]"), b = 0; b < S.length; b++) {
                                    var D = S[b];
                                    (D.nodeName === "LINK" || D.getAttribute("media") !== "not all") && (u.set(D.dataset.precedence, D),
                                    h = D)
                                }
                                h && u.set(null, h)
                            }
                            S = s.instance,
                            D = S.getAttribute("data-precedence"),
                            b = u.get(D) || h,
                            b === h && u.set(null, S),
                            u.set(D, S),
                            this.count++,
                            h = jg.bind(this),
                            S.addEventListener("load", h),
                            S.addEventListener("error", h),
                            b ? b.parentNode.insertBefore(S, b.nextSibling) : (i = i.nodeType === 9 ? i.head : i,
                            i.insertBefore(S, i.firstChild)),
                            s.state.loading |= 4
                        }
                    }
                    var Mp = {
                        $$typeof: L,
                        Provider: null,
                        Consumer: null,
                        _currentValue: Te,
                        _currentValue2: Te,
                        _threadCount: 0
                    };
                    function w2(i, s, u, h, S, b, D, F, ee) {
                        this.tag = 1,
                        this.containerInfo = i,
                        this.pingCache = this.current = this.pendingChildren = null,
                        this.timeoutHandle = -1,
                        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                        this.callbackPriority = 0,
                        this.expirationTimes = xa(-1),
                        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                        this.entanglements = xa(0),
                        this.hiddenUpdates = xa(null),
                        this.identifierPrefix = h,
                        this.onUncaughtError = S,
                        this.onCaughtError = b,
                        this.onRecoverableError = D,
                        this.pooledCache = null,
                        this.pooledCacheLanes = 0,
                        this.formState = ee,
                        this.incompleteTransitions = new Map
                    }
                    function C2(i, s, u, h, S, b, D, F, ee, pe, De, Ie) {
                        return i = new w2(i,s,u,D,ee,pe,De,Ie,F),
                        s = 1,
                        b === !0 && (s |= 24),
                        b = $i(3, null, null, s),
                        i.current = b,
                        b.stateNode = i,
                        s = Ko(),
                        s.refCount++,
                        i.pooledCache = s,
                        s.refCount++,
                        b.memoizedState = {
                            element: h,
                            isDehydrated: u,
                            cache: s
                        },
                        lo(b),
                        i
                    }
                    function R2(i) {
                        return i ? (i = jo,
                        i) : jo
                    }
                    function Gx(i, s, u, h, S, b) {
                        S = R2(S),
                        h.context === null ? h.context = S : h.pendingContext = S,
                        h = wr(s),
                        h.payload = {
                            element: u
                        },
                        b = b === void 0 ? null : b,
                        b !== null && (h.callback = b),
                        u = co(i, h, s),
                        u !== null && (Ii(u, i, s),
                        hs(u, i, s))
                    }
                    function Wx(i, s) {
                        if (i = i.memoizedState,
                        i !== null && i.dehydrated !== null) {
                            var u = i.retryLane;
                            i.retryLane = u !== 0 && u < s ? u : s
                        }
                    }
                    function Zy(i, s) {
                        Wx(i, s),
                        (i = i.alternate) && Wx(i, s)
                    }
                    function Xx(i) {
                        if (i.tag === 13 || i.tag === 31) {
                            var s = Yi(i, 67108864);
                            s !== null && Ii(s, i, 67108864),
                            Zy(i, 67108864)
                        }
                    }
                    function qx(i) {
                        if (i.tag === 13 || i.tag === 31) {
                            var s = qn();
                            s = jr(s);
                            var u = Yi(i, s);
                            u !== null && Ii(u, i, s),
                            Zy(i, s)
                        }
                    }
                    var Kg = !0;
                    function D2(i, s, u, h) {
                        var S = Q.T;
                        Q.T = null;
                        var b = se.p;
                        try {
                            se.p = 2,
                            Qy(i, s, u, h)
                        } finally {
                            se.p = b,
                            Q.T = S
                        }
                    }
                    function N2(i, s, u, h) {
                        var S = Q.T;
                        Q.T = null;
                        var b = se.p;
                        try {
                            se.p = 8,
                            Qy(i, s, u, h)
                        } finally {
                            se.p = b,
                            Q.T = S
                        }
                    }
                    function Qy(i, s, u, h) {
                        if (Kg) {
                            var S = Ky(h);
                            if (S === null)
                                It(i, s, h, Jg, u),
                                jx(i, h);
                            else if (U2(S, i, s, u, h))
                                h.stopPropagation();
                            else if (jx(i, h),
                            s & 4 && -1 < L2.indexOf(i)) {
                                for (; S !== null; ) {
                                    var b = vr(S);
                                    if (b !== null)
                                        switch (b.tag) {
                                        case 3:
                                            if (b = b.stateNode,
                                            b.current.memoizedState.isDehydrated) {
                                                var D = xe(b.pendingLanes);
                                                if (D !== 0) {
                                                    var F = b;
                                                    for (F.pendingLanes |= 2,
                                                    F.entangledLanes |= 2; D; ) {
                                                        var ee = 1 << 31 - et(D);
                                                        F.entanglements[1] |= ee,
                                                        D &= ~ee
                                                    }
                                                    l(b),
                                                    (Mn & 6) === 0 && (nc = oe() + 500,
                                                    d(0, !1))
                                                }
                                            }
                                            break;
                                        case 31:
                                        case 13:
                                            F = Yi(b, 2),
                                            F !== null && Ii(F, b, 2),
                                            dl(),
                                            Zy(b, 2)
                                        }
                                    if (b = Ky(h),
                                    b === null && It(i, s, h, Jg, u),
                                    b === S)
                                        break;
                                    S = b
                                }
                                S !== null && h.stopPropagation()
                            } else
                                It(i, s, h, null, u)
                        }
                    }
                    function Ky(i) {
                        return i = hf(i),
                        Jy(i)
                    }
                    var Jg = null;
                    function Jy(i) {
                        if (Jg = null,
                        i = gr(i),
                        i !== null) {
                            var s = f(i);
                            if (s === null)
                                i = null;
                            else {
                                var u = s.tag;
                                if (u === 13) {
                                    if (i = p(s),
                                    i !== null)
                                        return i;
                                    i = null
                                } else if (u === 31) {
                                    if (i = m(s),
                                    i !== null)
                                        return i;
                                    i = null
                                } else if (u === 3) {
                                    if (s.stateNode.current.memoizedState.isDehydrated)
                                        return s.tag === 3 ? s.stateNode.containerInfo : null;
                                    i = null
                                } else
                                    s !== i && (i = null)
                            }
                        }
                        return Jg = i,
                        null
                    }
                    function Yx(i) {
                        switch (i) {
                        case "beforetoggle":
                        case "cancel":
                        case "click":
                        case "close":
                        case "contextmenu":
                        case "copy":
                        case "cut":
                        case "auxclick":
                        case "dblclick":
                        case "dragend":
                        case "dragstart":
                        case "drop":
                        case "focusin":
                        case "focusout":
                        case "input":
                        case "invalid":
                        case "keydown":
                        case "keypress":
                        case "keyup":
                        case "mousedown":
                        case "mouseup":
                        case "paste":
                        case "pause":
                        case "play":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                        case "ratechange":
                        case "reset":
                        case "resize":
                        case "seeked":
                        case "submit":
                        case "toggle":
                        case "touchcancel":
                        case "touchend":
                        case "touchstart":
                        case "volumechange":
                        case "change":
                        case "selectionchange":
                        case "textInput":
                        case "compositionstart":
                        case "compositionend":
                        case "compositionupdate":
                        case "beforeblur":
                        case "afterblur":
                        case "beforeinput":
                        case "blur":
                        case "fullscreenchange":
                        case "focus":
                        case "hashchange":
                        case "popstate":
                        case "select":
                        case "selectstart":
                            return 2;
                        case "drag":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "mousemove":
                        case "mouseout":
                        case "mouseover":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "scroll":
                        case "touchmove":
                        case "wheel":
                        case "mouseenter":
                        case "mouseleave":
                        case "pointerenter":
                        case "pointerleave":
                            return 8;
                        case "message":
                            switch (Ce()) {
                            case Ue:
                                return 2;
                            case Me:
                                return 8;
                            case st:
                            case je:
                                return 32;
                            case St:
                                return 268435456;
                            default:
                                return 32
                            }
                        default:
                            return 32
                        }
                    }
                    var $y = !1
                      , fc = null
                      , hc = null
                      , dc = null
                      , Tp = new Map
                      , Ep = new Map
                      , pc = []
                      , L2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
                    function jx(i, s) {
                        switch (i) {
                        case "focusin":
                        case "focusout":
                            fc = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            hc = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            dc = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            Tp.delete(s.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            Ep.delete(s.pointerId)
                        }
                    }
                    function Ap(i, s, u, h, S, b) {
                        return i === null || i.nativeEvent !== b ? (i = {
                            blockedOn: s,
                            domEventName: u,
                            eventSystemFlags: h,
                            nativeEvent: b,
                            targetContainers: [S]
                        },
                        s !== null && (s = vr(s),
                        s !== null && Xx(s)),
                        i) : (i.eventSystemFlags |= h,
                        s = i.targetContainers,
                        S !== null && s.indexOf(S) === -1 && s.push(S),
                        i)
                    }
                    function U2(i, s, u, h, S) {
                        switch (s) {
                        case "focusin":
                            return fc = Ap(fc, i, s, u, h, S),
                            !0;
                        case "dragenter":
                            return hc = Ap(hc, i, s, u, h, S),
                            !0;
                        case "mouseover":
                            return dc = Ap(dc, i, s, u, h, S),
                            !0;
                        case "pointerover":
                            var b = S.pointerId;
                            return Tp.set(b, Ap(Tp.get(b) || null, i, s, u, h, S)),
                            !0;
                        case "gotpointercapture":
                            return b = S.pointerId,
                            Ep.set(b, Ap(Ep.get(b) || null, i, s, u, h, S)),
                            !0
                        }
                        return !1
                    }
                    function Zx(i) {
                        var s = gr(i.target);
                        if (s !== null) {
                            var u = f(s);
                            if (u !== null) {
                                if (s = u.tag,
                                s === 13) {
                                    if (s = p(u),
                                    s !== null) {
                                        i.blockedOn = s,
                                        Rl(i.priority, function() {
                                            qx(u)
                                        });
                                        return
                                    }
                                } else if (s === 31) {
                                    if (s = m(u),
                                    s !== null) {
                                        i.blockedOn = s,
                                        Rl(i.priority, function() {
                                            qx(u)
                                        });
                                        return
                                    }
                                } else if (s === 3 && u.stateNode.current.memoizedState.isDehydrated) {
                                    i.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
                                    return
                                }
                            }
                        }
                        i.blockedOn = null
                    }
                    function $g(i) {
                        if (i.blockedOn !== null)
                            return !1;
                        for (var s = i.targetContainers; 0 < s.length; ) {
                            var u = Ky(i.nativeEvent);
                            if (u === null) {
                                u = i.nativeEvent;
                                var h = new u.constructor(u.type,u);
                                ff = h,
                                u.target.dispatchEvent(h),
                                ff = null
                            } else
                                return s = vr(u),
                                s !== null && Xx(s),
                                i.blockedOn = u,
                                !1;
                            s.shift()
                        }
                        return !0
                    }
                    function Qx(i, s, u) {
                        $g(i) && u.delete(s)
                    }
                    function I2() {
                        $y = !1,
                        fc !== null && $g(fc) && (fc = null),
                        hc !== null && $g(hc) && (hc = null),
                        dc !== null && $g(dc) && (dc = null),
                        Tp.forEach(Qx),
                        Ep.forEach(Qx)
                    }
                    function ev(i, s) {
                        i.blockedOn === s && (i.blockedOn = null,
                        $y || ($y = !0,
                        t.unstable_scheduleCallback(t.unstable_NormalPriority, I2)))
                    }
                    var tv = null;
                    function Kx(i) {
                        tv !== i && (tv = i,
                        t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
                            tv === i && (tv = null);
                            for (var s = 0; s < i.length; s += 3) {
                                var u = i[s]
                                  , h = i[s + 1]
                                  , S = i[s + 2];
                                if (typeof h != "function") {
                                    if (Jy(h || u) === null)
                                        continue;
                                    break
                                }
                                var b = vr(u);
                                b !== null && (i.splice(s, 3),
                                s -= 3,
                                np(b, {
                                    pending: !0,
                                    data: S,
                                    method: u.method,
                                    action: h
                                }, h, S))
                            }
                        }))
                    }
                    function uh(i) {
                        function s(ee) {
                            return ev(ee, i)
                        }
                        fc !== null && ev(fc, i),
                        hc !== null && ev(hc, i),
                        dc !== null && ev(dc, i),
                        Tp.forEach(s),
                        Ep.forEach(s);
                        for (var u = 0; u < pc.length; u++) {
                            var h = pc[u];
                            h.blockedOn === i && (h.blockedOn = null)
                        }
                        for (; 0 < pc.length && (u = pc[0],
                        u.blockedOn === null); )
                            Zx(u),
                            u.blockedOn === null && pc.shift();
                        if (u = (i.ownerDocument || i).$$reactFormReplay,
                        u != null)
                            for (h = 0; h < u.length; h += 3) {
                                var S = u[h]
                                  , b = u[h + 1]
                                  , D = S[Ci] || null;
                                if (typeof b == "function")
                                    D || Kx(u);
                                else if (D) {
                                    var F = null;
                                    if (b && b.hasAttribute("formAction")) {
                                        if (S = b,
                                        D = b[Ci] || null)
                                            F = D.formAction;
                                        else if (Jy(S) !== null)
                                            continue
                                    } else
                                        F = D.action;
                                    typeof F == "function" ? u[h + 1] = F : (u.splice(h, 3),
                                    h -= 3),
                                    Kx(u)
                                }
                            }
                    }
                    function O2() {
                        function i(b) {
                            b.canIntercept && b.info === "react-transition" && b.intercept({
                                handler: function() {
                                    return new Promise(function(D) {
                                        return S = D
                                    }
                                    )
                                },
                                focusReset: "manual",
                                scroll: "manual"
                            })
                        }
                        function s() {
                            S !== null && (S(),
                            S = null),
                            h || setTimeout(u, 20)
                        }
                        function u() {
                            if (!h && !navigation.transition) {
                                var b = navigation.currentEntry;
                                b && b.url != null && navigation.navigate(b.url, {
                                    state: b.getState(),
                                    info: "react-transition",
                                    history: "replace"
                                })
                            }
                        }
                        if (typeof navigation == "object") {
                            var h = !1
                              , S = null;
                            return navigation.addEventListener("navigate", i),
                            navigation.addEventListener("navigatesuccess", s),
                            navigation.addEventListener("navigateerror", s),
                            setTimeout(u, 100),
                            function() {
                                h = !0,
                                navigation.removeEventListener("navigate", i),
                                navigation.removeEventListener("navigatesuccess", s),
                                navigation.removeEventListener("navigateerror", s),
                                S !== null && (S(),
                                S = null)
                            }
                        }
                    }
                    function e_(i) {
                        this._internalRoot = i
                    }
                    t_.prototype.render = e_.prototype.render = function(i) {
                        var s = this._internalRoot;
                        if (s === null)
                            throw Error(r(409));
                        var u = s.current;
                        Gx(u, qn(), i, s, null, null)
                    }
                    ,
                    t_.prototype.unmount = e_.prototype.unmount = function() {
                        var i = this._internalRoot;
                        if (i !== null) {
                            this._internalRoot = null;
                            var s = i.containerInfo;
                            Gx(i.current, 2, null, i, null, null),
                            dl(),
                            s[Wi] = null
                        }
                    }
                    ;
                    function t_(i) {
                        this._internalRoot = i
                    }
                    t_.prototype.unstable_scheduleHydration = function(i) {
                        if (i) {
                            var s = ss();
                            i = {
                                blockedOn: null,
                                target: i,
                                priority: s
                            };
                            for (var u = 0; u < pc.length && s !== 0 && s < pc[u].priority; u++)
                                ;
                            pc.splice(u, 0, i),
                            u === 0 && Zx(i)
                        }
                    }
                    ;
                    var Jx = n.version;
                    if (Jx !== "19.2.3")
                        throw Error(r(527, Jx, "19.2.3"));
                    se.findDOMNode = function(i) {
                        var s = i._reactInternals;
                        if (s === void 0)
                            throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","),
                            Error(r(268, i)));
                        return i = v(s),
                        i = i !== null ? _(i) : null,
                        i = i === null ? null : i.stateNode,
                        i
                    }
                    ;
                    var P2 = {
                        bundleType: 0,
                        version: "19.2.3",
                        rendererPackageName: "react-dom",
                        currentDispatcherRef: Q,
                        reconcilerVersion: "19.2.3"
                    };
                    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
                        var nv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                        if (!nv.isDisabled && nv.supportsFiber)
                            try {
                                We = nv.inject(P2),
                                rt = nv
                            } catch {}
                    }
                    e.createRoot = function(i, s) {
                        if (!c(i))
                            throw Error(r(299));
                        var u = !1
                          , h = ""
                          , S = Ly
                          , b = Cg
                          , D = Uy;
                        return s != null && (s.unstable_strictMode === !0 && (u = !0),
                        s.identifierPrefix !== void 0 && (h = s.identifierPrefix),
                        s.onUncaughtError !== void 0 && (S = s.onUncaughtError),
                        s.onCaughtError !== void 0 && (b = s.onCaughtError),
                        s.onRecoverableError !== void 0 && (D = s.onRecoverableError)),
                        s = C2(i, 1, !1, null, null, u, h, null, S, b, D, O2),
                        i[Wi] = s.current,
                        Lt(i),
                        new e_(s)
                    }
                }
                ))
                  , ew = Ai(( (e, t) => {
                    function n() {
                        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
                            try {
                                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
                            } catch (a) {
                                console.error(a)
                            }
                    }
                    n(),
                    t.exports = $2()
                }
                ))
                  , tw = av(ew())
                  , lt = av(wp(), 1)
                  , Ao = j2();
                const sv = "182"
                  , nw = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                }
                  , iw = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                }
                  , ib = 0
                  , i_ = 1
                  , ab = 2
                  , aw = 3
                  , sb = 0
                  , fh = 1
                  , Cp = 2
                  , Lu = 3
                  , vl = 0
                  , Qa = 1
                  , wo = 2
                  , Co = 0
                  , Uu = 1
                  , a_ = 2
                  , s_ = 3
                  , r_ = 4
                  , rb = 5
                  , gc = 100
                  , ob = 101
                  , lb = 102
                  , cb = 103
                  , ub = 104
                  , fb = 200
                  , hb = 201
                  , db = 202
                  , pb = 203
                  , rv = 204
                  , ov = 205
                  , mb = 206
                  , gb = 207
                  , vb = 208
                  , yb = 209
                  , _b = 210
                  , Sb = 211
                  , xb = 212
                  , bb = 213
                  , Mb = 214
                  , lv = 0
                  , cv = 1
                  , uv = 2
                  , Iu = 3
                  , fv = 4
                  , hv = 5
                  , dv = 6
                  , pv = 7
                  , Rp = 0
                  , Tb = 1
                  , Eb = 2
                  , ur = 0
                  , o_ = 1
                  , l_ = 2
                  , c_ = 3
                  , mv = 4
                  , u_ = 5
                  , f_ = 6
                  , h_ = 7
                  , d_ = "attached"
                  , Ab = "detached"
                  , gv = 300
                  , Ro = 301
                  , vc = 302
                  , Dp = 303
                  , Np = 304
                  , hh = 306
                  , Lp = 1e3
                  , Ss = 1001
                  , Up = 1002
                  , Oi = 1003
                  , p_ = 1004
                  , sw = 1004
                  , dh = 1005
                  , rw = 1005
                  , ei = 1006
                  , Ip = 1007
                  , ow = 1007
                  , Do = 1008
                  , lw = 1008
                  , Ka = 1009
                  , m_ = 1010
                  , g_ = 1011
                  , ph = 1012
                  , vv = 1013
                  , fr = 1014
                  , Ja = 1015
                  , No = 1016
                  , yv = 1017
                  , _v = 1018
                  , mh = 1020
                  , v_ = 35902
                  , y_ = 35899
                  , __ = 1021
                  , S_ = 1022
                  , Aa = 1023
                  , Lo = 1026
                  , yc = 1027
                  , Sv = 1028
                  , Op = 1029
                  , Ou = 1030
                  , xv = 1031
                  , cw = 1032
                  , bv = 1033
                  , Pp = 33776
                  , zp = 33777
                  , Bp = 33778
                  , Fp = 33779
                  , Mv = 35840
                  , Tv = 35841
                  , Ev = 35842
                  , Av = 35843
                  , wv = 36196
                  , Cv = 37492
                  , Rv = 37496
                  , Dv = 37488
                  , Nv = 37489
                  , Lv = 37490
                  , Uv = 37491
                  , Iv = 37808
                  , Ov = 37809
                  , Pv = 37810
                  , zv = 37811
                  , Bv = 37812
                  , Fv = 37813
                  , Vv = 37814
                  , kv = 37815
                  , Hv = 37816
                  , Gv = 37817
                  , Wv = 37818
                  , Xv = 37819
                  , qv = 37820
                  , Yv = 37821
                  , jv = 36492
                  , Zv = 36494
                  , Qv = 36495
                  , Kv = 36283
                  , Jv = 36284
                  , $v = 36285
                  , e0 = 36286
                  , wb = 2200
                  , Cb = 2201
                  , Rb = 2202
                  , Vp = 2300
                  , t0 = 2301
                  , n0 = 2302
                  , Pu = 2400
                  , zu = 2401
                  , kp = 2402
                  , i0 = 2500
                  , x_ = 2501
                  , uw = 0
                  , fw = 1
                  , hw = 2
                  , Db = 3200
                  , dw = 3201
                  , pw = 3202
                  , mw = 3203
                  , _c = 0
                  , Nb = 1
                  , yl = ""
                  , wa = "srgb"
                  , Sc = "srgb-linear"
                  , Hp = "linear"
                  , Un = "srgb"
                  , gw = ""
                  , vw = "rg"
                  , yw = "ga"
                  , _w = 0
                  , Bu = 7680
                  , Sw = 7681
                  , xw = 7682
                  , bw = 7683
                  , Mw = 34055
                  , Tw = 34056
                  , Ew = 5386
                  , Aw = 512
                  , ww = 513
                  , Cw = 514
                  , Rw = 515
                  , Dw = 516
                  , Nw = 517
                  , Lw = 518
                  , b_ = 519
                  , Lb = 512
                  , Ub = 513
                  , Ib = 514
                  , a0 = 515
                  , Ob = 516
                  , Pb = 517
                  , s0 = 518
                  , zb = 519
                  , Gp = 35044
                  , Uw = 35048
                  , Iw = 35040
                  , Ow = 35045
                  , Pw = 35049
                  , zw = 35041
                  , Bw = 35046
                  , Fw = 35050
                  , Vw = 35042
                  , kw = "100"
                  , M_ = "300 es"
                  , Bs = 2e3
                  , gh = 2001
                  , Hw = {
                    COMPUTE: "compute",
                    RENDER: "render"
                }
                  , Gw = {
                    PERSPECTIVE: "perspective",
                    LINEAR: "linear",
                    FLAT: "flat"
                }
                  , Ww = {
                    NORMAL: "normal",
                    CENTROID: "centroid",
                    SAMPLE: "sample",
                    FIRST: "first",
                    EITHER: "either"
                };
                function Bb(e) {
                    for (let t = e.length - 1; t >= 0; --t)
                        if (e[t] >= 65535)
                            return !0;
                    return !1
                }
                const Xw = {
                    Int8Array,
                    Uint8Array,
                    Uint8ClampedArray,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                };
                function vh(e, t) {
                    return new Xw[e](t)
                }
                function Fb(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                }
                function Wp(e) {
                    return document.createElementNS("http://www.w3.org/1999/xhtml", e)
                }
                function Vb() {
                    const e = Wp("canvas");
                    return e.style.display = "block",
                    e
                }
                const kb = {};
                let xc = null;
                function qw(e) {
                    xc = e
                }
                function Yw() {
                    return xc
                }
                function Xp(...e) {
                    const t = "THREE." + e.shift();
                    xc ? xc("log", t, ...e) : console.log(t, ...e)
                }
                function ot(...e) {
                    const t = "THREE." + e.shift();
                    xc ? xc("warn", t, ...e) : console.warn(t, ...e)
                }
                function Et(...e) {
                    const t = "THREE." + e.shift();
                    xc ? xc("error", t, ...e) : console.error(t, ...e)
                }
                function yh(...e) {
                    const t = e.join(" ");
                    t in kb || (kb[t] = !0,
                    ot(...e))
                }
                function jw(e, t, n) {
                    return new Promise(function(a, r) {
                        function c() {
                            switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                            case e.WAIT_FAILED:
                                r();
                                break;
                            case e.TIMEOUT_EXPIRED:
                                setTimeout(c, n);
                                break;
                            default:
                                a()
                            }
                        }
                        setTimeout(c, n)
                    }
                    )
                }
                var Uo = class {
                    addEventListener(e, t) {
                        this._listeners === void 0 && (this._listeners = {});
                        const n = this._listeners;
                        n[e] === void 0 && (n[e] = []),
                        n[e].indexOf(t) === -1 && n[e].push(t)
                    }
                    hasEventListener(e, t) {
                        const n = this._listeners;
                        return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1
                    }
                    removeEventListener(e, t) {
                        const n = this._listeners;
                        if (n === void 0)
                            return;
                        const a = n[e];
                        if (a !== void 0) {
                            const r = a.indexOf(t);
                            r !== -1 && a.splice(r, 1)
                        }
                    }
                    dispatchEvent(e) {
                        const t = this._listeners;
                        if (t === void 0)
                            return;
                        const n = t[e.type];
                        if (n !== void 0) {
                            e.target = this;
                            const a = n.slice(0);
                            for (let r = 0, c = a.length; r < c; r++)
                                a[r].call(this, e);
                            e.target = null
                        }
                    }
                }
                ;
                const Ca = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                let Hb = 1234567;
                const Fu = Math.PI / 180
                  , _h = 180 / Math.PI;
                function Fs() {
                    const e = Math.random() * 4294967295 | 0
                      , t = Math.random() * 4294967295 | 0
                      , n = Math.random() * 4294967295 | 0
                      , a = Math.random() * 4294967295 | 0;
                    return (Ca[e & 255] + Ca[e >> 8 & 255] + Ca[e >> 16 & 255] + Ca[e >> 24 & 255] + "-" + Ca[t & 255] + Ca[t >> 8 & 255] + "-" + Ca[t >> 16 & 15 | 64] + Ca[t >> 24 & 255] + "-" + Ca[n & 63 | 128] + Ca[n >> 8 & 255] + "-" + Ca[n >> 16 & 255] + Ca[n >> 24 & 255] + Ca[a & 255] + Ca[a >> 8 & 255] + Ca[a >> 16 & 255] + Ca[a >> 24 & 255]).toLowerCase()
                }
                function Bt(e, t, n) {
                    return Math.max(t, Math.min(n, e))
                }
                function T_(e, t) {
                    return (e % t + t) % t
                }
                function Zw(e, t, n, a, r) {
                    return a + (e - t) * (r - a) / (n - t)
                }
                function Qw(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                }
                function qp(e, t, n) {
                    return (1 - n) * e + n * t
                }
                function Kw(e, t, n, a) {
                    return qp(e, t, 1 - Math.exp(-n * a))
                }
                function Jw(e, t=1) {
                    return t - Math.abs(T_(e, t * 2) - t)
                }
                function $w(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t),
                    e * e * (3 - 2 * e))
                }
                function eC(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t),
                    e * e * e * (e * (e * 6 - 15) + 10))
                }
                function tC(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                }
                function nC(e, t) {
                    return e + Math.random() * (t - e)
                }
                function iC(e) {
                    return e * (.5 - Math.random())
                }
                function aC(e) {
                    e !== void 0 && (Hb = e);
                    let t = Hb += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, t | 1),
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61),
                    ((t ^ t >>> 14) >>> 0) / 4294967296
                }
                function sC(e) {
                    return e * Fu
                }
                function rC(e) {
                    return e * _h
                }
                function oC(e) {
                    return (e & e - 1) === 0 && e !== 0
                }
                function lC(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                }
                function cC(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                }
                function uC(e, t, n, a, r) {
                    const c = Math.cos
                      , f = Math.sin
                      , p = c(n / 2)
                      , m = f(n / 2)
                      , g = c((t + a) / 2)
                      , v = f((t + a) / 2)
                      , _ = c((t - a) / 2)
                      , x = f((t - a) / 2)
                      , M = c((a - t) / 2)
                      , C = f((a - t) / 2);
                    switch (r) {
                    case "XYX":
                        e.set(p * v, m * _, m * x, p * g);
                        break;
                    case "YZY":
                        e.set(m * x, p * v, m * _, p * g);
                        break;
                    case "ZXZ":
                        e.set(m * _, m * x, p * v, p * g);
                        break;
                    case "XZX":
                        e.set(p * v, m * C, m * M, p * g);
                        break;
                    case "YXY":
                        e.set(m * M, p * v, m * C, p * g);
                        break;
                    case "ZYZ":
                        e.set(m * C, m * M, p * v, p * g);
                        break;
                    default:
                        ot("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                }
                function $a(e, t) {
                    switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return e / 4294967295;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int32Array:
                        return Math.max(e / 2147483647, -1);
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                function Zt(e, t) {
                    switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return Math.round(e * 4294967295);
                    case Uint16Array:
                        return Math.round(e * 65535);
                    case Uint8Array:
                        return Math.round(e * 255);
                    case Int32Array:
                        return Math.round(e * 2147483647);
                    case Int16Array:
                        return Math.round(e * 32767);
                    case Int8Array:
                        return Math.round(e * 127);
                    default:
                        throw new Error("Invalid component type.")
                    }
                }
                const fC = {
                    DEG2RAD: Fu,
                    RAD2DEG: _h,
                    generateUUID: Fs,
                    clamp: Bt,
                    euclideanModulo: T_,
                    mapLinear: Zw,
                    inverseLerp: Qw,
                    lerp: qp,
                    damp: Kw,
                    pingpong: Jw,
                    smoothstep: $w,
                    smootherstep: eC,
                    randInt: tC,
                    randFloat: nC,
                    randFloatSpread: iC,
                    seededRandom: aC,
                    degToRad: sC,
                    radToDeg: rC,
                    isPowerOfTwo: oC,
                    ceilPowerOfTwo: lC,
                    floorPowerOfTwo: cC,
                    setQuaternionFromProperEuler: uC,
                    normalize: Zt,
                    denormalize: $a
                };
                var Pe = class MA {
                    constructor(t=0, n=0) {
                        MA.prototype.isVector2 = !0,
                        this.x = t,
                        this.y = n
                    }
                    get width() {
                        return this.x
                    }
                    set width(t) {
                        this.x = t
                    }
                    get height() {
                        return this.y
                    }
                    set height(t) {
                        this.y = t
                    }
                    set(t, n) {
                        return this.x = t,
                        this.y = n,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    applyMatrix3(t) {
                        const n = this.x
                          , a = this.y
                          , r = t.elements;
                        return this.x = r[0] * n + r[3] * a + r[6],
                        this.y = r[1] * n + r[4] * a + r[7],
                        this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this
                    }
                    clamp(t, n) {
                        return this.x = Bt(this.x, t.x, n.x),
                        this.y = Bt(this.y, t.y, n.y),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = Bt(this.x, t, n),
                        this.y = Bt(this.y, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const a = this.length();
                        return this.divideScalar(a || 1).multiplyScalar(Bt(a, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    angleTo(t) {
                        const n = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const a = this.dot(t) / n;
                        return Math.acos(Bt(a, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const n = this.x - t.x
                          , a = this.y - t.y;
                        return n * n + a * a
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this
                    }
                    lerpVectors(t, n, a) {
                        return this.x = t.x + (n.x - t.x) * a,
                        this.y = t.y + (n.y - t.y) * a,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this
                    }
                    rotateAround(t, n) {
                        const a = Math.cos(n)
                          , r = Math.sin(n)
                          , c = this.x - t.x
                          , f = this.y - t.y;
                        return this.x = c * a - f * r + t.x,
                        this.y = c * r + f * a + t.y,
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y
                    }
                }
                  , xs = class {
                    constructor(e=0, t=0, n=0, a=1) {
                        this.isQuaternion = !0,
                        this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = a
                    }
                    static slerpFlat(e, t, n, a, r, c, f) {
                        let p = n[a + 0]
                          , m = n[a + 1]
                          , g = n[a + 2]
                          , v = n[a + 3]
                          , _ = r[c + 0]
                          , x = r[c + 1]
                          , M = r[c + 2]
                          , C = r[c + 3];
                        if (f <= 0) {
                            e[t + 0] = p,
                            e[t + 1] = m,
                            e[t + 2] = g,
                            e[t + 3] = v;
                            return
                        }
                        if (f >= 1) {
                            e[t + 0] = _,
                            e[t + 1] = x,
                            e[t + 2] = M,
                            e[t + 3] = C;
                            return
                        }
                        if (v !== C || p !== _ || m !== x || g !== M) {
                            let R = p * _ + m * x + g * M + v * C;
                            R < 0 && (_ = -_,
                            x = -x,
                            M = -M,
                            C = -C,
                            R = -R);
                            let A = 1 - f;
                            if (R < .9995) {
                                const E = Math.acos(R)
                                  , N = Math.sin(E);
                                A = Math.sin(A * E) / N,
                                f = Math.sin(f * E) / N,
                                p = p * A + _ * f,
                                m = m * A + x * f,
                                g = g * A + M * f,
                                v = v * A + C * f
                            } else {
                                p = p * A + _ * f,
                                m = m * A + x * f,
                                g = g * A + M * f,
                                v = v * A + C * f;
                                const E = 1 / Math.sqrt(p * p + m * m + g * g + v * v);
                                p *= E,
                                m *= E,
                                g *= E,
                                v *= E
                            }
                        }
                        e[t] = p,
                        e[t + 1] = m,
                        e[t + 2] = g,
                        e[t + 3] = v
                    }
                    static multiplyQuaternionsFlat(e, t, n, a, r, c) {
                        const f = n[a]
                          , p = n[a + 1]
                          , m = n[a + 2]
                          , g = n[a + 3]
                          , v = r[c]
                          , _ = r[c + 1]
                          , x = r[c + 2]
                          , M = r[c + 3];
                        return e[t] = f * M + g * v + p * x - m * _,
                        e[t + 1] = p * M + g * _ + m * v - f * x,
                        e[t + 2] = m * M + g * x + f * _ - p * v,
                        e[t + 3] = g * M - f * v - p * _ - m * x,
                        e
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x = e,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y = e,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(e) {
                        this._z = e,
                        this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(e) {
                        this._w = e,
                        this._onChangeCallback()
                    }
                    set(e, t, n, a) {
                        return this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = a,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._w)
                    }
                    copy(e) {
                        return this._x = e.x,
                        this._y = e.y,
                        this._z = e.z,
                        this._w = e.w,
                        this._onChangeCallback(),
                        this
                    }
                    setFromEuler(e, t=!0) {
                        const n = e._x
                          , a = e._y
                          , r = e._z
                          , c = e._order
                          , f = Math.cos
                          , p = Math.sin
                          , m = f(n / 2)
                          , g = f(a / 2)
                          , v = f(r / 2)
                          , _ = p(n / 2)
                          , x = p(a / 2)
                          , M = p(r / 2);
                        switch (c) {
                        case "XYZ":
                            this._x = _ * g * v + m * x * M,
                            this._y = m * x * v - _ * g * M,
                            this._z = m * g * M + _ * x * v,
                            this._w = m * g * v - _ * x * M;
                            break;
                        case "YXZ":
                            this._x = _ * g * v + m * x * M,
                            this._y = m * x * v - _ * g * M,
                            this._z = m * g * M - _ * x * v,
                            this._w = m * g * v + _ * x * M;
                            break;
                        case "ZXY":
                            this._x = _ * g * v - m * x * M,
                            this._y = m * x * v + _ * g * M,
                            this._z = m * g * M + _ * x * v,
                            this._w = m * g * v - _ * x * M;
                            break;
                        case "ZYX":
                            this._x = _ * g * v - m * x * M,
                            this._y = m * x * v + _ * g * M,
                            this._z = m * g * M - _ * x * v,
                            this._w = m * g * v + _ * x * M;
                            break;
                        case "YZX":
                            this._x = _ * g * v + m * x * M,
                            this._y = m * x * v + _ * g * M,
                            this._z = m * g * M - _ * x * v,
                            this._w = m * g * v - _ * x * M;
                            break;
                        case "XZY":
                            this._x = _ * g * v - m * x * M,
                            this._y = m * x * v - _ * g * M,
                            this._z = m * g * M + _ * x * v,
                            this._w = m * g * v + _ * x * M;
                            break;
                        default:
                            ot("Quaternion: .setFromEuler() encountered an unknown order: " + c)
                        }
                        return t === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromAxisAngle(e, t) {
                        const n = t / 2
                          , a = Math.sin(n);
                        return this._x = e.x * a,
                        this._y = e.y * a,
                        this._z = e.z * a,
                        this._w = Math.cos(n),
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(e) {
                        const t = e.elements
                          , n = t[0]
                          , a = t[4]
                          , r = t[8]
                          , c = t[1]
                          , f = t[5]
                          , p = t[9]
                          , m = t[2]
                          , g = t[6]
                          , v = t[10]
                          , _ = n + f + v;
                        if (_ > 0) {
                            const x = .5 / Math.sqrt(_ + 1);
                            this._w = .25 / x,
                            this._x = (g - p) * x,
                            this._y = (r - m) * x,
                            this._z = (c - a) * x
                        } else if (n > f && n > v) {
                            const x = 2 * Math.sqrt(1 + n - f - v);
                            this._w = (g - p) / x,
                            this._x = .25 * x,
                            this._y = (a + c) / x,
                            this._z = (r + m) / x
                        } else if (f > v) {
                            const x = 2 * Math.sqrt(1 + f - n - v);
                            this._w = (r - m) / x,
                            this._x = (a + c) / x,
                            this._y = .25 * x,
                            this._z = (p + g) / x
                        } else {
                            const x = 2 * Math.sqrt(1 + v - n - f);
                            this._w = (c - a) / x,
                            this._x = (r + m) / x,
                            this._y = (p + g) / x,
                            this._z = .25 * x
                        }
                        return this._onChangeCallback(),
                        this
                    }
                    setFromUnitVectors(e, t) {
                        let n = e.dot(t) + 1;
                        return n < 1e-8 ? (n = 0,
                        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                        this._y = e.x,
                        this._z = 0,
                        this._w = n) : (this._x = 0,
                        this._y = -e.z,
                        this._z = e.y,
                        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                        this._y = e.z * t.x - e.x * t.z,
                        this._z = e.x * t.y - e.y * t.x,
                        this._w = n),
                        this.normalize()
                    }
                    angleTo(e) {
                        return 2 * Math.acos(Math.abs(Bt(this.dot(e), -1, 1)))
                    }
                    rotateTowards(e, t) {
                        const n = this.angleTo(e);
                        if (n === 0)
                            return this;
                        const a = Math.min(1, t / n);
                        return this.slerp(e, a),
                        this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this._onChangeCallback(),
                        this
                    }
                    dot(e) {
                        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let e = this.length();
                        return e === 0 ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (e = 1 / e,
                        this._x = this._x * e,
                        this._y = this._y * e,
                        this._z = this._z * e,
                        this._w = this._w * e),
                        this._onChangeCallback(),
                        this
                    }
                    multiply(e) {
                        return this.multiplyQuaternions(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyQuaternions(e, this)
                    }
                    multiplyQuaternions(e, t) {
                        const n = e._x
                          , a = e._y
                          , r = e._z
                          , c = e._w
                          , f = t._x
                          , p = t._y
                          , m = t._z
                          , g = t._w;
                        return this._x = n * g + c * f + a * m - r * p,
                        this._y = a * g + c * p + r * f - n * m,
                        this._z = r * g + c * m + n * p - a * f,
                        this._w = c * g - n * f - a * p - r * m,
                        this._onChangeCallback(),
                        this
                    }
                    slerp(e, t) {
                        if (t <= 0)
                            return this;
                        if (t >= 1)
                            return this.copy(e);
                        let n = e._x
                          , a = e._y
                          , r = e._z
                          , c = e._w
                          , f = this.dot(e);
                        f < 0 && (n = -n,
                        a = -a,
                        r = -r,
                        c = -c,
                        f = -f);
                        let p = 1 - t;
                        if (f < .9995) {
                            const m = Math.acos(f)
                              , g = Math.sin(m);
                            p = Math.sin(p * m) / g,
                            t = Math.sin(t * m) / g,
                            this._x = this._x * p + n * t,
                            this._y = this._y * p + a * t,
                            this._z = this._z * p + r * t,
                            this._w = this._w * p + c * t,
                            this._onChangeCallback()
                        } else
                            this._x = this._x * p + n * t,
                            this._y = this._y * p + a * t,
                            this._z = this._z * p + r * t,
                            this._w = this._w * p + c * t,
                            this.normalize();
                        return this
                    }
                    slerpQuaternions(e, t, n) {
                        return this.copy(e).slerp(t, n)
                    }
                    random() {
                        const e = 2 * Math.PI * Math.random()
                          , t = 2 * Math.PI * Math.random()
                          , n = Math.random()
                          , a = Math.sqrt(1 - n)
                          , r = Math.sqrt(n);
                        return this.set(a * Math.sin(e), a * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
                    }
                    equals(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                    }
                    fromArray(e, t=0) {
                        return this._x = e[t],
                        this._y = e[t + 1],
                        this._z = e[t + 2],
                        this._w = e[t + 3],
                        this._onChangeCallback(),
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this._x,
                        e[t + 1] = this._y,
                        e[t + 2] = this._z,
                        e[t + 3] = this._w,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this._x = e.getX(t),
                        this._y = e.getY(t),
                        this._z = e.getZ(t),
                        this._w = e.getW(t),
                        this._onChangeCallback(),
                        this
                    }
                    toJSON() {
                        return this.toArray()
                    }
                    _onChange(e) {
                        return this._onChangeCallback = e,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._w
                    }
                }
                  , Y = class TA {
                    constructor(t=0, n=0, a=0) {
                        TA.prototype.isVector3 = !0,
                        this.x = t,
                        this.y = n,
                        this.z = a
                    }
                    set(t, n, a) {
                        return a === void 0 && (a = this.z),
                        this.x = t,
                        this.y = n,
                        this.z = a,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setZ(t) {
                        return this.z = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this.z = t.z + n.z,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this.z += t.z * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this.z = t.z - n.z,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this
                    }
                    multiplyVectors(t, n) {
                        return this.x = t.x * n.x,
                        this.y = t.y * n.y,
                        this.z = t.z * n.z,
                        this
                    }
                    applyEuler(t) {
                        return this.applyQuaternion(Gb.setFromEuler(t))
                    }
                    applyAxisAngle(t, n) {
                        return this.applyQuaternion(Gb.setFromAxisAngle(t, n))
                    }
                    applyMatrix3(t) {
                        const n = this.x
                          , a = this.y
                          , r = this.z
                          , c = t.elements;
                        return this.x = c[0] * n + c[3] * a + c[6] * r,
                        this.y = c[1] * n + c[4] * a + c[7] * r,
                        this.z = c[2] * n + c[5] * a + c[8] * r,
                        this
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                    applyMatrix4(t) {
                        const n = this.x
                          , a = this.y
                          , r = this.z
                          , c = t.elements
                          , f = 1 / (c[3] * n + c[7] * a + c[11] * r + c[15]);
                        return this.x = (c[0] * n + c[4] * a + c[8] * r + c[12]) * f,
                        this.y = (c[1] * n + c[5] * a + c[9] * r + c[13]) * f,
                        this.z = (c[2] * n + c[6] * a + c[10] * r + c[14]) * f,
                        this
                    }
                    applyQuaternion(t) {
                        const n = this.x
                          , a = this.y
                          , r = this.z
                          , c = t.x
                          , f = t.y
                          , p = t.z
                          , m = t.w
                          , g = 2 * (f * r - p * a)
                          , v = 2 * (p * n - c * r)
                          , _ = 2 * (c * a - f * n);
                        return this.x = n + m * g + f * _ - p * v,
                        this.y = a + m * v + p * g - c * _,
                        this.z = r + m * _ + c * v - f * g,
                        this
                    }
                    project(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                    unproject(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                    transformDirection(t) {
                        const n = this.x
                          , a = this.y
                          , r = this.z
                          , c = t.elements;
                        return this.x = c[0] * n + c[4] * a + c[8] * r,
                        this.y = c[1] * n + c[5] * a + c[9] * r,
                        this.z = c[2] * n + c[6] * a + c[10] * r,
                        this.normalize()
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this
                    }
                    clamp(t, n) {
                        return this.x = Bt(this.x, t.x, n.x),
                        this.y = Bt(this.y, t.y, n.y),
                        this.z = Bt(this.z, t.z, n.z),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = Bt(this.x, t, n),
                        this.y = Bt(this.y, t, n),
                        this.z = Bt(this.z, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const a = this.length();
                        return this.divideScalar(a || 1).multiplyScalar(Bt(a, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this.z += (t.z - this.z) * n,
                        this
                    }
                    lerpVectors(t, n, a) {
                        return this.x = t.x + (n.x - t.x) * a,
                        this.y = t.y + (n.y - t.y) * a,
                        this.z = t.z + (n.z - t.z) * a,
                        this
                    }
                    cross(t) {
                        return this.crossVectors(this, t)
                    }
                    crossVectors(t, n) {
                        const a = t.x
                          , r = t.y
                          , c = t.z
                          , f = n.x
                          , p = n.y
                          , m = n.z;
                        return this.x = r * m - c * p,
                        this.y = c * f - a * m,
                        this.z = a * p - r * f,
                        this
                    }
                    projectOnVector(t) {
                        const n = t.lengthSq();
                        if (n === 0)
                            return this.set(0, 0, 0);
                        const a = t.dot(this) / n;
                        return this.copy(t).multiplyScalar(a)
                    }
                    projectOnPlane(t) {
                        return E_.copy(this).projectOnVector(t),
                        this.sub(E_)
                    }
                    reflect(t) {
                        return this.sub(E_.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                    angleTo(t) {
                        const n = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (n === 0)
                            return Math.PI / 2;
                        const a = this.dot(t) / n;
                        return Math.acos(Bt(a, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const n = this.x - t.x
                          , a = this.y - t.y
                          , r = this.z - t.z;
                        return n * n + a * a + r * r
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                    setFromSphericalCoords(t, n, a) {
                        const r = Math.sin(n) * t;
                        return this.x = r * Math.sin(a),
                        this.y = Math.cos(n) * t,
                        this.z = r * Math.cos(a),
                        this
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                    setFromCylindricalCoords(t, n, a) {
                        return this.x = t * Math.sin(n),
                        this.y = a,
                        this.z = t * Math.cos(n),
                        this
                    }
                    setFromMatrixPosition(t) {
                        const n = t.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this
                    }
                    setFromMatrixScale(t) {
                        const n = this.setFromMatrixColumn(t, 0).length()
                          , a = this.setFromMatrixColumn(t, 1).length()
                          , r = this.setFromMatrixColumn(t, 2).length();
                        return this.x = n,
                        this.y = a,
                        this.z = r,
                        this
                    }
                    setFromMatrixColumn(t, n) {
                        return this.fromArray(t.elements, n * 4)
                    }
                    setFromMatrix3Column(t, n) {
                        return this.fromArray(t.elements, n * 3)
                    }
                    setFromEuler(t) {
                        return this.x = t._x,
                        this.y = t._y,
                        this.z = t._z,
                        this
                    }
                    setFromColor(t) {
                        return this.x = t.r,
                        this.y = t.g,
                        this.z = t.b,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this.z = t[n + 2],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t[n + 2] = this.z,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this.z = t.getZ(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this
                    }
                    randomDirection() {
                        const t = Math.random() * Math.PI * 2
                          , n = Math.random() * 2 - 1
                          , a = Math.sqrt(1 - n * n);
                        return this.x = a * Math.cos(t),
                        this.y = n,
                        this.z = a * Math.sin(t),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z
                    }
                }
                ;
                const E_ = new Y
                  , Gb = new xs;
                var en = class EA {
                    constructor(t, n, a, r, c, f, p, m, g) {
                        EA.prototype.isMatrix3 = !0,
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        t !== void 0 && this.set(t, n, a, r, c, f, p, m, g)
                    }
                    set(t, n, a, r, c, f, p, m, g) {
                        const v = this.elements;
                        return v[0] = t,
                        v[1] = r,
                        v[2] = p,
                        v[3] = n,
                        v[4] = c,
                        v[5] = m,
                        v[6] = a,
                        v[7] = f,
                        v[8] = g,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                    }
                    copy(t) {
                        const n = this.elements
                          , a = t.elements;
                        return n[0] = a[0],
                        n[1] = a[1],
                        n[2] = a[2],
                        n[3] = a[3],
                        n[4] = a[4],
                        n[5] = a[5],
                        n[6] = a[6],
                        n[7] = a[7],
                        n[8] = a[8],
                        this
                    }
                    extractBasis(t, n, a) {
                        return t.setFromMatrix3Column(this, 0),
                        n.setFromMatrix3Column(this, 1),
                        a.setFromMatrix3Column(this, 2),
                        this
                    }
                    setFromMatrix4(t) {
                        const n = t.elements;
                        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]),
                        this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, n) {
                        const a = t.elements
                          , r = n.elements
                          , c = this.elements
                          , f = a[0]
                          , p = a[3]
                          , m = a[6]
                          , g = a[1]
                          , v = a[4]
                          , _ = a[7]
                          , x = a[2]
                          , M = a[5]
                          , C = a[8]
                          , R = r[0]
                          , A = r[3]
                          , E = r[6]
                          , N = r[1]
                          , I = r[4]
                          , L = r[7]
                          , k = r[2]
                          , B = r[5]
                          , X = r[8];
                        return c[0] = f * R + p * N + m * k,
                        c[3] = f * A + p * I + m * B,
                        c[6] = f * E + p * L + m * X,
                        c[1] = g * R + v * N + _ * k,
                        c[4] = g * A + v * I + _ * B,
                        c[7] = g * E + v * L + _ * X,
                        c[2] = x * R + M * N + C * k,
                        c[5] = x * A + M * I + C * B,
                        c[8] = x * E + M * L + C * X,
                        this
                    }
                    multiplyScalar(t) {
                        const n = this.elements;
                        return n[0] *= t,
                        n[3] *= t,
                        n[6] *= t,
                        n[1] *= t,
                        n[4] *= t,
                        n[7] *= t,
                        n[2] *= t,
                        n[5] *= t,
                        n[8] *= t,
                        this
                    }
                    determinant() {
                        const t = this.elements
                          , n = t[0]
                          , a = t[1]
                          , r = t[2]
                          , c = t[3]
                          , f = t[4]
                          , p = t[5]
                          , m = t[6]
                          , g = t[7]
                          , v = t[8];
                        return n * f * v - n * p * g - a * c * v + a * p * m + r * c * g - r * f * m
                    }
                    invert() {
                        const t = this.elements
                          , n = t[0]
                          , a = t[1]
                          , r = t[2]
                          , c = t[3]
                          , f = t[4]
                          , p = t[5]
                          , m = t[6]
                          , g = t[7]
                          , v = t[8]
                          , _ = v * f - p * g
                          , x = p * m - v * c
                          , M = g * c - f * m
                          , C = n * _ + a * x + r * M;
                        if (C === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const R = 1 / C;
                        return t[0] = _ * R,
                        t[1] = (r * g - v * a) * R,
                        t[2] = (p * a - r * f) * R,
                        t[3] = x * R,
                        t[4] = (v * n - r * m) * R,
                        t[5] = (r * c - p * n) * R,
                        t[6] = M * R,
                        t[7] = (a * m - g * n) * R,
                        t[8] = (f * n - a * c) * R,
                        this
                    }
                    transpose() {
                        let t;
                        const n = this.elements;
                        return t = n[1],
                        n[1] = n[3],
                        n[3] = t,
                        t = n[2],
                        n[2] = n[6],
                        n[6] = t,
                        t = n[5],
                        n[5] = n[7],
                        n[7] = t,
                        this
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose()
                    }
                    transposeIntoArray(t) {
                        const n = this.elements;
                        return t[0] = n[0],
                        t[1] = n[3],
                        t[2] = n[6],
                        t[3] = n[1],
                        t[4] = n[4],
                        t[5] = n[7],
                        t[6] = n[2],
                        t[7] = n[5],
                        t[8] = n[8],
                        this
                    }
                    setUvTransform(t, n, a, r, c, f, p) {
                        const m = Math.cos(c)
                          , g = Math.sin(c);
                        return this.set(a * m, a * g, -a * (m * f + g * p) + f + t, -r * g, r * m, -r * (-g * f + m * p) + p + n, 0, 0, 1),
                        this
                    }
                    scale(t, n) {
                        return this.premultiply(A_.makeScale(t, n)),
                        this
                    }
                    rotate(t) {
                        return this.premultiply(A_.makeRotation(-t)),
                        this
                    }
                    translate(t, n) {
                        return this.premultiply(A_.makeTranslation(t, n)),
                        this
                    }
                    makeTranslation(t, n) {
                        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, n, 0, 0, 1),
                        this
                    }
                    makeRotation(t) {
                        const n = Math.cos(t)
                          , a = Math.sin(t);
                        return this.set(n, -a, 0, a, n, 0, 0, 0, 1),
                        this
                    }
                    makeScale(t, n) {
                        return this.set(t, 0, 0, 0, n, 0, 0, 0, 1),
                        this
                    }
                    equals(t) {
                        const n = this.elements
                          , a = t.elements;
                        for (let r = 0; r < 9; r++)
                            if (n[r] !== a[r])
                                return !1;
                        return !0
                    }
                    fromArray(t, n=0) {
                        for (let a = 0; a < 9; a++)
                            this.elements[a] = t[a + n];
                        return this
                    }
                    toArray(t=[], n=0) {
                        const a = this.elements;
                        return t[n] = a[0],
                        t[n + 1] = a[1],
                        t[n + 2] = a[2],
                        t[n + 3] = a[3],
                        t[n + 4] = a[4],
                        t[n + 5] = a[5],
                        t[n + 6] = a[6],
                        t[n + 7] = a[7],
                        t[n + 8] = a[8],
                        t
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements)
                    }
                }
                ;
                const A_ = new en
                  , Wb = new en().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
                  , Xb = new en().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
                function hC() {
                    const e = {
                        enabled: !0,
                        workingColorSpace: Sc,
                        spaces: {},
                        convert: function(r, c, f) {
                            return this.enabled === !1 || c === f || !c || !f || (this.spaces[c].transfer === Un && (r.r = _l(r.r),
                            r.g = _l(r.g),
                            r.b = _l(r.b)),
                            this.spaces[c].primaries !== this.spaces[f].primaries && (r.applyMatrix3(this.spaces[c].toXYZ),
                            r.applyMatrix3(this.spaces[f].fromXYZ)),
                            this.spaces[f].transfer === Un && (r.r = Sh(r.r),
                            r.g = Sh(r.g),
                            r.b = Sh(r.b))),
                            r
                        },
                        workingToColorSpace: function(r, c) {
                            return this.convert(r, this.workingColorSpace, c)
                        },
                        colorSpaceToWorking: function(r, c) {
                            return this.convert(r, c, this.workingColorSpace)
                        },
                        getPrimaries: function(r) {
                            return this.spaces[r].primaries
                        },
                        getTransfer: function(r) {
                            return r === yl ? Hp : this.spaces[r].transfer
                        },
                        getToneMappingMode: function(r) {
                            return this.spaces[r].outputColorSpaceConfig.toneMappingMode || "standard"
                        },
                        getLuminanceCoefficients: function(r, c=this.workingColorSpace) {
                            return r.fromArray(this.spaces[c].luminanceCoefficients)
                        },
                        define: function(r) {
                            Object.assign(this.spaces, r)
                        },
                        _getMatrix: function(r, c, f) {
                            return r.copy(this.spaces[c].toXYZ).multiply(this.spaces[f].fromXYZ)
                        },
                        _getDrawingBufferColorSpace: function(r) {
                            return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace
                        },
                        _getUnpackColorSpace: function(r=this.workingColorSpace) {
                            return this.spaces[r].workingColorSpaceConfig.unpackColorSpace
                        },
                        fromWorkingColorSpace: function(r, c) {
                            return yh("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
                            e.workingToColorSpace(r, c)
                        },
                        toWorkingColorSpace: function(r, c) {
                            return yh("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
                            e.colorSpaceToWorking(r, c)
                        }
                    }
                      , t = [.64, .33, .3, .6, .15, .06]
                      , n = [.2126, .7152, .0722]
                      , a = [.3127, .329];
                    return e.define({
                        [Sc]: {
                            primaries: t,
                            whitePoint: a,
                            transfer: Hp,
                            toXYZ: Wb,
                            fromXYZ: Xb,
                            luminanceCoefficients: n,
                            workingColorSpaceConfig: {
                                unpackColorSpace: wa
                            },
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: wa
                            }
                        },
                        [wa]: {
                            primaries: t,
                            whitePoint: a,
                            transfer: Un,
                            toXYZ: Wb,
                            fromXYZ: Xb,
                            luminanceCoefficients: n,
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: wa
                            }
                        }
                    }),
                    e
                }
                const Sn = hC();
                function _l(e) {
                    return e < .04045 ? e * .0773993808 : Math.pow(e * .9478672986 + .0521327014, 2.4)
                }
                function Sh(e) {
                    return e < .0031308 ? e * 12.92 : 1.055 * Math.pow(e, .41666) - .055
                }
                let xh;
                var qb = class {
                    static getDataURL(e, t="image/png") {
                        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                            return e.src;
                        let n;
                        if (e instanceof HTMLCanvasElement)
                            n = e;
                        else {
                            xh === void 0 && (xh = Wp("canvas")),
                            xh.width = e.width,
                            xh.height = e.height;
                            const a = xh.getContext("2d");
                            e instanceof ImageData ? a.putImageData(e, 0, 0) : a.drawImage(e, 0, 0, e.width, e.height),
                            n = xh
                        }
                        return n.toDataURL(t)
                    }
                    static sRGBToLinear(e) {
                        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                            const t = Wp("canvas");
                            t.width = e.width,
                            t.height = e.height;
                            const n = t.getContext("2d");
                            n.drawImage(e, 0, 0, e.width, e.height);
                            const a = n.getImageData(0, 0, e.width, e.height)
                              , r = a.data;
                            for (let c = 0; c < r.length; c++)
                                r[c] = _l(r[c] / 255) * 255;
                            return n.putImageData(a, 0, 0),
                            t
                        } else if (e.data) {
                            const t = e.data.slice(0);
                            for (let n = 0; n < t.length; n++)
                                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(_l(t[n] / 255) * 255) : t[n] = _l(t[n]);
                            return {
                                data: t,
                                width: e.width,
                                height: e.height
                            }
                        } else
                            return ot("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                            e
                    }
                }
                ;
                let dC = 0;
                var bc = class {
                    constructor(e=null) {
                        this.isSource = !0,
                        Object.defineProperty(this, "id", {
                            value: dC++
                        }),
                        this.uuid = Fs(),
                        this.data = e,
                        this.dataReady = !0,
                        this.version = 0
                    }
                    getSize(e) {
                        const t = this.data;
                        return typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : typeof VideoFrame < "u" && t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
                        e
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    toJSON(e) {
                        const t = e === void 0 || typeof e == "string";
                        if (!t && e.images[this.uuid] !== void 0)
                            return e.images[this.uuid];
                        const n = {
                            uuid: this.uuid,
                            url: ""
                        }
                          , a = this.data;
                        if (a !== null) {
                            let r;
                            if (Array.isArray(a)) {
                                r = [];
                                for (let c = 0, f = a.length; c < f; c++)
                                    a[c].isDataTexture ? r.push(w_(a[c].image)) : r.push(w_(a[c]))
                            } else
                                r = w_(a);
                            n.url = r
                        }
                        return t || (e.images[this.uuid] = n),
                        n
                    }
                }
                ;
                function w_(e) {
                    return typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap ? qb.getDataURL(e) : e.data ? {
                        data: Array.from(e.data),
                        width: e.width,
                        height: e.height,
                        type: e.data.constructor.name
                    } : (ot("Texture: Unable to serialize Texture."),
                    {})
                }
                let pC = 0;
                const C_ = new Y;
                var oa = class Sy extends Uo {
                    constructor(t=Sy.DEFAULT_IMAGE, n=Sy.DEFAULT_MAPPING, a=Ss, r=Ss, c=ei, f=Do, p=Aa, m=Ka, g=Sy.DEFAULT_ANISOTROPY, v=yl) {
                        super(),
                        this.isTexture = !0,
                        Object.defineProperty(this, "id", {
                            value: pC++
                        }),
                        this.uuid = Fs(),
                        this.name = "",
                        this.source = new bc(t),
                        this.mipmaps = [],
                        this.mapping = n,
                        this.channel = 0,
                        this.wrapS = a,
                        this.wrapT = r,
                        this.magFilter = c,
                        this.minFilter = f,
                        this.anisotropy = g,
                        this.format = p,
                        this.internalFormat = null,
                        this.type = m,
                        this.offset = new Pe(0,0),
                        this.repeat = new Pe(1,1),
                        this.center = new Pe(0,0),
                        this.rotation = 0,
                        this.matrixAutoUpdate = !0,
                        this.matrix = new en,
                        this.generateMipmaps = !0,
                        this.premultiplyAlpha = !1,
                        this.flipY = !0,
                        this.unpackAlignment = 4,
                        this.colorSpace = v,
                        this.userData = {},
                        this.updateRanges = [],
                        this.version = 0,
                        this.onUpdate = null,
                        this.renderTarget = null,
                        this.isRenderTargetTexture = !1,
                        this.isArrayTexture = !!(t && t.depth && t.depth > 1),
                        this.pmremVersion = 0
                    }
                    get width() {
                        return this.source.getSize(C_).x
                    }
                    get height() {
                        return this.source.getSize(C_).y
                    }
                    get depth() {
                        return this.source.getSize(C_).z
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(t=null) {
                        this.source.data = t
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    addUpdateRange(t, n) {
                        this.updateRanges.push({
                            start: t,
                            count: n
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.name = t.name,
                        this.source = t.source,
                        this.mipmaps = t.mipmaps.slice(0),
                        this.mapping = t.mapping,
                        this.channel = t.channel,
                        this.wrapS = t.wrapS,
                        this.wrapT = t.wrapT,
                        this.magFilter = t.magFilter,
                        this.minFilter = t.minFilter,
                        this.anisotropy = t.anisotropy,
                        this.format = t.format,
                        this.internalFormat = t.internalFormat,
                        this.type = t.type,
                        this.offset.copy(t.offset),
                        this.repeat.copy(t.repeat),
                        this.center.copy(t.center),
                        this.rotation = t.rotation,
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrix.copy(t.matrix),
                        this.generateMipmaps = t.generateMipmaps,
                        this.premultiplyAlpha = t.premultiplyAlpha,
                        this.flipY = t.flipY,
                        this.unpackAlignment = t.unpackAlignment,
                        this.colorSpace = t.colorSpace,
                        this.renderTarget = t.renderTarget,
                        this.isRenderTargetTexture = t.isRenderTargetTexture,
                        this.isArrayTexture = t.isArrayTexture,
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        this.needsUpdate = !0,
                        this
                    }
                    setValues(t) {
                        for (const n in t) {
                            const a = t[n];
                            if (a === void 0) {
                                ot(`Texture.setValues(): parameter '${n}' has value of undefined.`);
                                continue
                            }
                            const r = this[n];
                            if (r === void 0) {
                                ot(`Texture.setValues(): property '${n}' does not exist.`);
                                continue
                            }
                            r && a && r.isVector2 && a.isVector2 || r && a && r.isVector3 && a.isVector3 || r && a && r.isMatrix3 && a.isMatrix3 ? r.copy(a) : this[n] = a
                        }
                    }
                    toJSON(t) {
                        const n = t === void 0 || typeof t == "string";
                        if (!n && t.textures[this.uuid] !== void 0)
                            return t.textures[this.uuid];
                        const a = {
                            metadata: {
                                version: 4.7,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(t).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        return Object.keys(this.userData).length > 0 && (a.userData = this.userData),
                        n || (t.textures[this.uuid] = a),
                        a
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(t) {
                        if (this.mapping !== gv)
                            return t;
                        if (t.applyMatrix3(this.matrix),
                        t.x < 0 || t.x > 1)
                            switch (this.wrapS) {
                            case Lp:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case Ss:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case Up:
                                Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                                break
                            }
                        if (t.y < 0 || t.y > 1)
                            switch (this.wrapT) {
                            case Lp:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case Ss:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case Up:
                                Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                                break
                            }
                        return this.flipY && (t.y = 1 - t.y),
                        t
                    }
                    set needsUpdate(t) {
                        t === !0 && (this.version++,
                        this.source.needsUpdate = !0)
                    }
                    set needsPMREMUpdate(t) {
                        t === !0 && this.pmremVersion++
                    }
                }
                ;
                oa.DEFAULT_IMAGE = null,
                oa.DEFAULT_MAPPING = gv,
                oa.DEFAULT_ANISOTROPY = 1;
                var ti = class AA {
                    constructor(t=0, n=0, a=0, r=1) {
                        AA.prototype.isVector4 = !0,
                        this.x = t,
                        this.y = n,
                        this.z = a,
                        this.w = r
                    }
                    get width() {
                        return this.z
                    }
                    set width(t) {
                        this.z = t
                    }
                    get height() {
                        return this.w
                    }
                    set height(t) {
                        this.w = t
                    }
                    set(t, n, a, r) {
                        return this.x = t,
                        this.y = n,
                        this.z = a,
                        this.w = r,
                        this
                    }
                    setScalar(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this.w = t,
                        this
                    }
                    setX(t) {
                        return this.x = t,
                        this
                    }
                    setY(t) {
                        return this.y = t,
                        this
                    }
                    setZ(t) {
                        return this.z = t,
                        this
                    }
                    setW(t) {
                        return this.w = t,
                        this
                    }
                    setComponent(t, n) {
                        switch (t) {
                        case 0:
                            this.x = n;
                            break;
                        case 1:
                            this.y = n;
                            break;
                        case 2:
                            this.z = n;
                            break;
                        case 3:
                            this.w = n;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z,this.w)
                    }
                    copy(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this.w = t.w !== void 0 ? t.w : 1,
                        this
                    }
                    add(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this.w += t.w,
                        this
                    }
                    addScalar(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this.w += t,
                        this
                    }
                    addVectors(t, n) {
                        return this.x = t.x + n.x,
                        this.y = t.y + n.y,
                        this.z = t.z + n.z,
                        this.w = t.w + n.w,
                        this
                    }
                    addScaledVector(t, n) {
                        return this.x += t.x * n,
                        this.y += t.y * n,
                        this.z += t.z * n,
                        this.w += t.w * n,
                        this
                    }
                    sub(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this.w -= t.w,
                        this
                    }
                    subScalar(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this.w -= t,
                        this
                    }
                    subVectors(t, n) {
                        return this.x = t.x - n.x,
                        this.y = t.y - n.y,
                        this.z = t.z - n.z,
                        this.w = t.w - n.w,
                        this
                    }
                    multiply(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this.w *= t.w,
                        this
                    }
                    multiplyScalar(t) {
                        return this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this.w *= t,
                        this
                    }
                    applyMatrix4(t) {
                        const n = this.x
                          , a = this.y
                          , r = this.z
                          , c = this.w
                          , f = t.elements;
                        return this.x = f[0] * n + f[4] * a + f[8] * r + f[12] * c,
                        this.y = f[1] * n + f[5] * a + f[9] * r + f[13] * c,
                        this.z = f[2] * n + f[6] * a + f[10] * r + f[14] * c,
                        this.w = f[3] * n + f[7] * a + f[11] * r + f[15] * c,
                        this
                    }
                    divide(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this.w /= t.w,
                        this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const n = Math.sqrt(1 - t.w * t.w);
                        return n < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = t.x / n,
                        this.y = t.y / n,
                        this.z = t.z / n),
                        this
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let n, a, r, c;
                        const m = t.elements
                          , g = m[0]
                          , v = m[4]
                          , _ = m[8]
                          , x = m[1]
                          , M = m[5]
                          , C = m[9]
                          , R = m[2]
                          , A = m[6]
                          , E = m[10];
                        if (Math.abs(v - x) < .01 && Math.abs(_ - R) < .01 && Math.abs(C - A) < .01) {
                            if (Math.abs(v + x) < .1 && Math.abs(_ + R) < .1 && Math.abs(C + A) < .1 && Math.abs(g + M + E - 3) < .1)
                                return this.set(1, 0, 0, 0),
                                this;
                            n = Math.PI;
                            const I = (g + 1) / 2
                              , L = (M + 1) / 2
                              , k = (E + 1) / 2
                              , B = (v + x) / 4
                              , X = (_ + R) / 4
                              , G = (C + A) / 4;
                            return I > L && I > k ? I < .01 ? (a = 0,
                            r = .707106781,
                            c = .707106781) : (a = Math.sqrt(I),
                            r = B / a,
                            c = X / a) : L > k ? L < .01 ? (a = .707106781,
                            r = 0,
                            c = .707106781) : (r = Math.sqrt(L),
                            a = B / r,
                            c = G / r) : k < .01 ? (a = .707106781,
                            r = .707106781,
                            c = 0) : (c = Math.sqrt(k),
                            a = X / c,
                            r = G / c),
                            this.set(a, r, c, n),
                            this
                        }
                        let N = Math.sqrt((A - C) * (A - C) + (_ - R) * (_ - R) + (x - v) * (x - v));
                        return Math.abs(N) < .001 && (N = 1),
                        this.x = (A - C) / N,
                        this.y = (_ - R) / N,
                        this.z = (x - v) / N,
                        this.w = Math.acos((g + M + E - 1) / 2),
                        this
                    }
                    setFromMatrixPosition(t) {
                        const n = t.elements;
                        return this.x = n[12],
                        this.y = n[13],
                        this.z = n[14],
                        this.w = n[15],
                        this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this.w = Math.min(this.w, t.w),
                        this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this.w = Math.max(this.w, t.w),
                        this
                    }
                    clamp(t, n) {
                        return this.x = Bt(this.x, t.x, n.x),
                        this.y = Bt(this.y, t.y, n.y),
                        this.z = Bt(this.z, t.z, n.z),
                        this.w = Bt(this.w, t.w, n.w),
                        this
                    }
                    clampScalar(t, n) {
                        return this.x = Bt(this.x, t, n),
                        this.y = Bt(this.y, t, n),
                        this.z = Bt(this.z, t, n),
                        this.w = Bt(this.w, t, n),
                        this
                    }
                    clampLength(t, n) {
                        const a = this.length();
                        return this.divideScalar(a || 1).multiplyScalar(Bt(a, t, n))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                    }
                    roundToZero() {
                        return this.x = Math.trunc(this.x),
                        this.y = Math.trunc(this.y),
                        this.z = Math.trunc(this.z),
                        this.w = Math.trunc(this.w),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, n) {
                        return this.x += (t.x - this.x) * n,
                        this.y += (t.y - this.y) * n,
                        this.z += (t.z - this.z) * n,
                        this.w += (t.w - this.w) * n,
                        this
                    }
                    lerpVectors(t, n, a) {
                        return this.x = t.x + (n.x - t.x) * a,
                        this.y = t.y + (n.y - t.y) * a,
                        this.z = t.z + (n.z - t.z) * a,
                        this.w = t.w + (n.w - t.w) * a,
                        this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    }
                    fromArray(t, n=0) {
                        return this.x = t[n],
                        this.y = t[n + 1],
                        this.z = t[n + 2],
                        this.w = t[n + 3],
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this.x,
                        t[n + 1] = this.y,
                        t[n + 2] = this.z,
                        t[n + 3] = this.w,
                        t
                    }
                    fromBufferAttribute(t, n) {
                        return this.x = t.getX(n),
                        this.y = t.getY(n),
                        this.z = t.getZ(n),
                        this.w = t.getW(n),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this.w = Math.random(),
                        this
                    }
                    *[Symbol.iterator]() {
                        yield this.x,
                        yield this.y,
                        yield this.z,
                        yield this.w
                    }
                }
                  , R_ = class extends Uo {
                    constructor(e=1, t=1, n={}) {
                        super(),
                        n = Object.assign({
                            generateMipmaps: !1,
                            internalFormat: null,
                            minFilter: ei,
                            depthBuffer: !0,
                            stencilBuffer: !1,
                            resolveDepthBuffer: !0,
                            resolveStencilBuffer: !0,
                            depthTexture: null,
                            samples: 0,
                            count: 1,
                            depth: 1,
                            multiview: !1
                        }, n),
                        this.isRenderTarget = !0,
                        this.width = e,
                        this.height = t,
                        this.depth = n.depth,
                        this.scissor = new ti(0,0,e,t),
                        this.scissorTest = !1,
                        this.viewport = new ti(0,0,e,t);
                        const a = new oa({
                            width: e,
                            height: t,
                            depth: n.depth
                        });
                        this.textures = [];
                        const r = n.count;
                        for (let c = 0; c < r; c++)
                            this.textures[c] = a.clone(),
                            this.textures[c].isRenderTargetTexture = !0,
                            this.textures[c].renderTarget = this;
                        this._setTextureOptions(n),
                        this.depthBuffer = n.depthBuffer,
                        this.stencilBuffer = n.stencilBuffer,
                        this.resolveDepthBuffer = n.resolveDepthBuffer,
                        this.resolveStencilBuffer = n.resolveStencilBuffer,
                        this._depthTexture = null,
                        this.depthTexture = n.depthTexture,
                        this.samples = n.samples,
                        this.multiview = n.multiview
                    }
                    _setTextureOptions(e={}) {
                        const t = {
                            minFilter: ei,
                            generateMipmaps: !1,
                            flipY: !1,
                            internalFormat: null
                        };
                        e.mapping !== void 0 && (t.mapping = e.mapping),
                        e.wrapS !== void 0 && (t.wrapS = e.wrapS),
                        e.wrapT !== void 0 && (t.wrapT = e.wrapT),
                        e.wrapR !== void 0 && (t.wrapR = e.wrapR),
                        e.magFilter !== void 0 && (t.magFilter = e.magFilter),
                        e.minFilter !== void 0 && (t.minFilter = e.minFilter),
                        e.format !== void 0 && (t.format = e.format),
                        e.type !== void 0 && (t.type = e.type),
                        e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
                        e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
                        e.flipY !== void 0 && (t.flipY = e.flipY),
                        e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
                        e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
                        for (let n = 0; n < this.textures.length; n++)
                            this.textures[n].setValues(t)
                    }
                    get texture() {
                        return this.textures[0]
                    }
                    set texture(e) {
                        this.textures[0] = e
                    }
                    set depthTexture(e) {
                        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
                        e !== null && (e.renderTarget = this),
                        this._depthTexture = e
                    }
                    get depthTexture() {
                        return this._depthTexture
                    }
                    setSize(e, t, n=1) {
                        if (this.width !== e || this.height !== t || this.depth !== n) {
                            this.width = e,
                            this.height = t,
                            this.depth = n;
                            for (let a = 0, r = this.textures.length; a < r; a++)
                                this.textures[a].image.width = e,
                                this.textures[a].image.height = t,
                                this.textures[a].image.depth = n,
                                this.textures[a].isData3DTexture !== !0 && (this.textures[a].isArrayTexture = this.textures[a].image.depth > 1);
                            this.dispose()
                        }
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.width = e.width,
                        this.height = e.height,
                        this.depth = e.depth,
                        this.scissor.copy(e.scissor),
                        this.scissorTest = e.scissorTest,
                        this.viewport.copy(e.viewport),
                        this.textures.length = 0;
                        for (let t = 0, n = e.textures.length; t < n; t++) {
                            this.textures[t] = e.textures[t].clone(),
                            this.textures[t].isRenderTargetTexture = !0,
                            this.textures[t].renderTarget = this;
                            const a = Object.assign({}, e.textures[t].image);
                            this.textures[t].source = new bc(a)
                        }
                        return this.depthBuffer = e.depthBuffer,
                        this.stencilBuffer = e.stencilBuffer,
                        this.resolveDepthBuffer = e.resolveDepthBuffer,
                        this.resolveStencilBuffer = e.resolveStencilBuffer,
                        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                        this.samples = e.samples,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                  , Vs = class extends R_ {
                    constructor(e=1, t=1, n={}) {
                        super(e, t, n),
                        this.isWebGLRenderTarget = !0
                    }
                }
                  , r0 = class extends oa {
                    constructor(e=null, t=1, n=1, a=1) {
                        super(null),
                        this.isDataArrayTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n,
                            depth: a
                        },
                        this.magFilter = Oi,
                        this.minFilter = Oi,
                        this.wrapR = Ss,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(e) {
                        this.layerUpdates.add(e)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , mC = class extends Vs {
                    constructor(e=1, t=1, n=1, a={}) {
                        super(e, t, a),
                        this.isWebGLArrayRenderTarget = !0,
                        this.depth = n,
                        this.texture = new r0(null,e,t,n),
                        this._setTextureOptions(a),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , o0 = class extends oa {
                    constructor(e=null, t=1, n=1, a=1) {
                        super(null),
                        this.isData3DTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n,
                            depth: a
                        },
                        this.magFilter = Oi,
                        this.minFilter = Oi,
                        this.wrapR = Ss,
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                  , gC = class extends Vs {
                    constructor(e=1, t=1, n=1, a={}) {
                        super(e, t, a),
                        this.isWebGL3DRenderTarget = !0,
                        this.depth = n,
                        this.texture = new o0(null,e,t,n),
                        this._setTextureOptions(a),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , Ra = class {
                    constructor(e=new Y(1 / 0,1 / 0,1 / 0), t=new Y(-1 / 0,-1 / 0,-1 / 0)) {
                        this.isBox3 = !0,
                        this.min = e,
                        this.max = t
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromArray(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t += 3)
                            this.expandByPoint(Vr.fromArray(e, t));
                        return this
                    }
                    setFromBufferAttribute(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.count; t < n; t++)
                            this.expandByPoint(Vr.fromBufferAttribute(e, t));
                        return this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = Vr.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    setFromObject(e, t=!1) {
                        return this.makeEmpty(),
                        this.expandByObject(e, t)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0,
                        this.max.x = this.max.y = this.max.z = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(e) {
                        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    expandByObject(e, t=!1) {
                        e.updateWorldMatrix(!1, !1);
                        const n = e.geometry;
                        if (n !== void 0) {
                            const r = n.getAttribute("position");
                            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                                for (let c = 0, f = r.count; c < f; c++)
                                    e.isMesh === !0 ? e.getVertexPosition(c, Vr) : Vr.fromBufferAttribute(r, c),
                                    Vr.applyMatrix4(e.matrixWorld),
                                    this.expandByPoint(Vr);
                            else
                                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                                l0.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                                l0.copy(n.boundingBox)),
                                l0.applyMatrix4(e.matrixWorld),
                                this.union(l0)
                        }
                        const a = e.children;
                        for (let r = 0, c = a.length; r < c; r++)
                            this.expandByObject(a[r], t);
                        return this
                    }
                    containsPoint(e) {
                        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                    }
                    getParameter(e, t) {
                        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(e) {
                        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                    }
                    intersectsSphere(e) {
                        return this.clampPoint(e.center, Vr),
                        Vr.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                    intersectsPlane(e) {
                        let t, n;
                        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                        n = e.normal.x * this.min.x),
                        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                        n += e.normal.y * this.min.y),
                        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                        n += e.normal.z * this.min.z),
                        t <= -e.constant && n >= -e.constant
                    }
                    intersectsTriangle(e) {
                        if (this.isEmpty())
                            return !1;
                        this.getCenter(Yp),
                        c0.subVectors(this.max, Yp),
                        bh.subVectors(e.a, Yp),
                        Mh.subVectors(e.b, Yp),
                        Th.subVectors(e.c, Yp),
                        Mc.subVectors(Mh, bh),
                        Tc.subVectors(Th, Mh),
                        Vu.subVectors(bh, Th);
                        let t = [0, -Mc.z, Mc.y, 0, -Tc.z, Tc.y, 0, -Vu.z, Vu.y, Mc.z, 0, -Mc.x, Tc.z, 0, -Tc.x, Vu.z, 0, -Vu.x, -Mc.y, Mc.x, 0, -Tc.y, Tc.x, 0, -Vu.y, Vu.x, 0];
                        return !D_(t, bh, Mh, Th, c0) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        !D_(t, bh, Mh, Th, c0)) ? !1 : (u0.crossVectors(Mc, Tc),
                        t = [u0.x, u0.y, u0.z],
                        D_(t, bh, Mh, Th, c0))
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return this.clampPoint(e, Vr).distanceTo(e)
                    }
                    getBoundingSphere(e) {
                        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                        e.radius = this.getSize(Vr).length() * .5),
                        e
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    applyMatrix4(e) {
                        return this.isEmpty() ? this : (Sl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                        Sl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                        Sl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                        Sl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                        Sl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                        Sl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                        Sl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                        Sl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                        this.setFromPoints(Sl),
                        this)
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                    toJSON() {
                        return {
                            min: this.min.toArray(),
                            max: this.max.toArray()
                        }
                    }
                    fromJSON(e) {
                        return this.min.fromArray(e.min),
                        this.max.fromArray(e.max),
                        this
                    }
                }
                ;
                const Sl = [new Y, new Y, new Y, new Y, new Y, new Y, new Y, new Y]
                  , Vr = new Y
                  , l0 = new Ra
                  , bh = new Y
                  , Mh = new Y
                  , Th = new Y
                  , Mc = new Y
                  , Tc = new Y
                  , Vu = new Y
                  , Yp = new Y
                  , c0 = new Y
                  , u0 = new Y
                  , ku = new Y;
                function D_(e, t, n, a, r) {
                    for (let c = 0, f = e.length - 3; c <= f; c += 3) {
                        ku.fromArray(e, c);
                        const p = r.x * Math.abs(ku.x) + r.y * Math.abs(ku.y) + r.z * Math.abs(ku.z)
                          , m = t.dot(ku)
                          , g = n.dot(ku)
                          , v = a.dot(ku);
                        if (Math.max(-Math.max(m, g, v), Math.min(m, g, v)) > p)
                            return !1
                    }
                    return !0
                }
                const vC = new Ra
                  , jp = new Y
                  , N_ = new Y;
                var Sa = class {
                    constructor(e=new Y, t=-1) {
                        this.isSphere = !0,
                        this.center = e,
                        this.radius = t
                    }
                    set(e, t) {
                        return this.center.copy(e),
                        this.radius = t,
                        this
                    }
                    setFromPoints(e, t) {
                        const n = this.center;
                        t !== void 0 ? n.copy(t) : vC.setFromPoints(e).getCenter(n);
                        let a = 0;
                        for (let r = 0, c = e.length; r < c; r++)
                            a = Math.max(a, n.distanceToSquared(e[r]));
                        return this.radius = Math.sqrt(a),
                        this
                    }
                    copy(e) {
                        return this.center.copy(e.center),
                        this.radius = e.radius,
                        this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0),
                        this.radius = -1,
                        this
                    }
                    containsPoint(e) {
                        return e.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(e) {
                        return e.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(e) {
                        const t = this.radius + e.radius;
                        return e.center.distanceToSquared(this.center) <= t * t
                    }
                    intersectsBox(e) {
                        return e.intersectsSphere(this)
                    }
                    intersectsPlane(e) {
                        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(e, t) {
                        const n = this.center.distanceToSquared(e);
                        return t.copy(e),
                        n > this.radius * this.radius && (t.sub(this.center).normalize(),
                        t.multiplyScalar(this.radius).add(this.center)),
                        t
                    }
                    getBoundingBox(e) {
                        return this.isEmpty() ? (e.makeEmpty(),
                        e) : (e.set(this.center, this.center),
                        e.expandByScalar(this.radius),
                        e)
                    }
                    applyMatrix4(e) {
                        return this.center.applyMatrix4(e),
                        this.radius = this.radius * e.getMaxScaleOnAxis(),
                        this
                    }
                    translate(e) {
                        return this.center.add(e),
                        this
                    }
                    expandByPoint(e) {
                        if (this.isEmpty())
                            return this.center.copy(e),
                            this.radius = 0,
                            this;
                        jp.subVectors(e, this.center);
                        const t = jp.lengthSq();
                        if (t > this.radius * this.radius) {
                            const n = Math.sqrt(t)
                              , a = (n - this.radius) * .5;
                            this.center.addScaledVector(jp, a / n),
                            this.radius += a
                        }
                        return this
                    }
                    union(e) {
                        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (N_.subVectors(e.center, this.center).setLength(e.radius),
                        this.expandByPoint(jp.copy(e.center).add(N_)),
                        this.expandByPoint(jp.copy(e.center).sub(N_))),
                        this)
                    }
                    equals(e) {
                        return e.center.equals(this.center) && e.radius === this.radius
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        return {
                            radius: this.radius,
                            center: this.center.toArray()
                        }
                    }
                    fromJSON(e) {
                        return this.radius = e.radius,
                        this.center.fromArray(e.center),
                        this
                    }
                }
                ;
                const xl = new Y
                  , L_ = new Y
                  , f0 = new Y
                  , Ec = new Y
                  , U_ = new Y
                  , h0 = new Y
                  , I_ = new Y;
                var Eh = class {
                    constructor(e=new Y, t=new Y(0,0,-1)) {
                        this.origin = e,
                        this.direction = t
                    }
                    set(e, t) {
                        return this.origin.copy(e),
                        this.direction.copy(t),
                        this
                    }
                    copy(e) {
                        return this.origin.copy(e.origin),
                        this.direction.copy(e.direction),
                        this
                    }
                    at(e, t) {
                        return t.copy(this.origin).addScaledVector(this.direction, e)
                    }
                    lookAt(e) {
                        return this.direction.copy(e).sub(this.origin).normalize(),
                        this
                    }
                    recast(e) {
                        return this.origin.copy(this.at(e, xl)),
                        this
                    }
                    closestPointToPoint(e, t) {
                        t.subVectors(e, this.origin);
                        const n = t.dot(this.direction);
                        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                    }
                    distanceToPoint(e) {
                        return Math.sqrt(this.distanceSqToPoint(e))
                    }
                    distanceSqToPoint(e) {
                        const t = xl.subVectors(e, this.origin).dot(this.direction);
                        return t < 0 ? this.origin.distanceToSquared(e) : (xl.copy(this.origin).addScaledVector(this.direction, t),
                        xl.distanceToSquared(e))
                    }
                    distanceSqToSegment(e, t, n, a) {
                        L_.copy(e).add(t).multiplyScalar(.5),
                        f0.copy(t).sub(e).normalize(),
                        Ec.copy(this.origin).sub(L_);
                        const r = e.distanceTo(t) * .5
                          , c = -this.direction.dot(f0)
                          , f = Ec.dot(this.direction)
                          , p = -Ec.dot(f0)
                          , m = Ec.lengthSq()
                          , g = Math.abs(1 - c * c);
                        let v, _, x, M;
                        if (g > 0)
                            if (v = c * p - f,
                            _ = c * f - p,
                            M = r * g,
                            v >= 0)
                                if (_ >= -M)
                                    if (_ <= M) {
                                        const C = 1 / g;
                                        v *= C,
                                        _ *= C,
                                        x = v * (v + c * _ + 2 * f) + _ * (c * v + _ + 2 * p) + m
                                    } else
                                        _ = r,
                                        v = Math.max(0, -(c * _ + f)),
                                        x = -v * v + _ * (_ + 2 * p) + m;
                                else
                                    _ = -r,
                                    v = Math.max(0, -(c * _ + f)),
                                    x = -v * v + _ * (_ + 2 * p) + m;
                            else
                                _ <= -M ? (v = Math.max(0, -(-c * r + f)),
                                _ = v > 0 ? -r : Math.min(Math.max(-r, -p), r),
                                x = -v * v + _ * (_ + 2 * p) + m) : _ <= M ? (v = 0,
                                _ = Math.min(Math.max(-r, -p), r),
                                x = _ * (_ + 2 * p) + m) : (v = Math.max(0, -(c * r + f)),
                                _ = v > 0 ? r : Math.min(Math.max(-r, -p), r),
                                x = -v * v + _ * (_ + 2 * p) + m);
                        else
                            _ = c > 0 ? -r : r,
                            v = Math.max(0, -(c * _ + f)),
                            x = -v * v + _ * (_ + 2 * p) + m;
                        return n && n.copy(this.origin).addScaledVector(this.direction, v),
                        a && a.copy(L_).addScaledVector(f0, _),
                        x
                    }
                    intersectSphere(e, t) {
                        xl.subVectors(e.center, this.origin);
                        const n = xl.dot(this.direction)
                          , a = xl.dot(xl) - n * n
                          , r = e.radius * e.radius;
                        if (a > r)
                            return null;
                        const c = Math.sqrt(r - a)
                          , f = n - c
                          , p = n + c;
                        return p < 0 ? null : f < 0 ? this.at(p, t) : this.at(f, t)
                    }
                    intersectsSphere(e) {
                        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
                    }
                    distanceToPlane(e) {
                        const t = e.normal.dot(this.direction);
                        if (t === 0)
                            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                        const n = -(this.origin.dot(e.normal) + e.constant) / t;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(e, t) {
                        const n = this.distanceToPlane(e);
                        return n === null ? null : this.at(n, t)
                    }
                    intersectsPlane(e) {
                        const t = e.distanceToPoint(this.origin);
                        return t === 0 || e.normal.dot(this.direction) * t < 0
                    }
                    intersectBox(e, t) {
                        let n, a, r, c, f, p;
                        const m = 1 / this.direction.x
                          , g = 1 / this.direction.y
                          , v = 1 / this.direction.z
                          , _ = this.origin;
                        return m >= 0 ? (n = (e.min.x - _.x) * m,
                        a = (e.max.x - _.x) * m) : (n = (e.max.x - _.x) * m,
                        a = (e.min.x - _.x) * m),
                        g >= 0 ? (r = (e.min.y - _.y) * g,
                        c = (e.max.y - _.y) * g) : (r = (e.max.y - _.y) * g,
                        c = (e.min.y - _.y) * g),
                        n > c || r > a || ((r > n || isNaN(n)) && (n = r),
                        (c < a || isNaN(a)) && (a = c),
                        v >= 0 ? (f = (e.min.z - _.z) * v,
                        p = (e.max.z - _.z) * v) : (f = (e.max.z - _.z) * v,
                        p = (e.min.z - _.z) * v),
                        n > p || f > a) || ((f > n || n !== n) && (n = f),
                        (p < a || a !== a) && (a = p),
                        a < 0) ? null : this.at(n >= 0 ? n : a, t)
                    }
                    intersectsBox(e) {
                        return this.intersectBox(e, xl) !== null
                    }
                    intersectTriangle(e, t, n, a, r) {
                        U_.subVectors(t, e),
                        h0.subVectors(n, e),
                        I_.crossVectors(U_, h0);
                        let c = this.direction.dot(I_), f;
                        if (c > 0) {
                            if (a)
                                return null;
                            f = 1
                        } else if (c < 0)
                            f = -1,
                            c = -c;
                        else
                            return null;
                        Ec.subVectors(this.origin, e);
                        const p = f * this.direction.dot(h0.crossVectors(Ec, h0));
                        if (p < 0)
                            return null;
                        const m = f * this.direction.dot(U_.cross(Ec));
                        if (m < 0 || p + m > c)
                            return null;
                        const g = -f * Ec.dot(I_);
                        return g < 0 ? null : this.at(g / c, r)
                    }
                    applyMatrix4(e) {
                        return this.origin.applyMatrix4(e),
                        this.direction.transformDirection(e),
                        this
                    }
                    equals(e) {
                        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , Wt = class xx {
                    constructor(t, n, a, r, c, f, p, m, g, v, _, x, M, C, R, A) {
                        xx.prototype.isMatrix4 = !0,
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                        t !== void 0 && this.set(t, n, a, r, c, f, p, m, g, v, _, x, M, C, R, A)
                    }
                    set(t, n, a, r, c, f, p, m, g, v, _, x, M, C, R, A) {
                        const E = this.elements;
                        return E[0] = t,
                        E[4] = n,
                        E[8] = a,
                        E[12] = r,
                        E[1] = c,
                        E[5] = f,
                        E[9] = p,
                        E[13] = m,
                        E[2] = g,
                        E[6] = v,
                        E[10] = _,
                        E[14] = x,
                        E[3] = M,
                        E[7] = C,
                        E[11] = R,
                        E[15] = A,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    clone() {
                        return new xx().fromArray(this.elements)
                    }
                    copy(t) {
                        const n = this.elements
                          , a = t.elements;
                        return n[0] = a[0],
                        n[1] = a[1],
                        n[2] = a[2],
                        n[3] = a[3],
                        n[4] = a[4],
                        n[5] = a[5],
                        n[6] = a[6],
                        n[7] = a[7],
                        n[8] = a[8],
                        n[9] = a[9],
                        n[10] = a[10],
                        n[11] = a[11],
                        n[12] = a[12],
                        n[13] = a[13],
                        n[14] = a[14],
                        n[15] = a[15],
                        this
                    }
                    copyPosition(t) {
                        const n = this.elements
                          , a = t.elements;
                        return n[12] = a[12],
                        n[13] = a[13],
                        n[14] = a[14],
                        this
                    }
                    setFromMatrix3(t) {
                        const n = t.elements;
                        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1),
                        this
                    }
                    extractBasis(t, n, a) {
                        return this.determinant() === 0 ? (t.set(1, 0, 0),
                        n.set(0, 1, 0),
                        a.set(0, 0, 1),
                        this) : (t.setFromMatrixColumn(this, 0),
                        n.setFromMatrixColumn(this, 1),
                        a.setFromMatrixColumn(this, 2),
                        this)
                    }
                    makeBasis(t, n, a) {
                        return this.set(t.x, n.x, a.x, 0, t.y, n.y, a.y, 0, t.z, n.z, a.z, 0, 0, 0, 0, 1),
                        this
                    }
                    extractRotation(t) {
                        if (t.determinant() === 0)
                            return this.identity();
                        const n = this.elements
                          , a = t.elements
                          , r = 1 / Ah.setFromMatrixColumn(t, 0).length()
                          , c = 1 / Ah.setFromMatrixColumn(t, 1).length()
                          , f = 1 / Ah.setFromMatrixColumn(t, 2).length();
                        return n[0] = a[0] * r,
                        n[1] = a[1] * r,
                        n[2] = a[2] * r,
                        n[3] = 0,
                        n[4] = a[4] * c,
                        n[5] = a[5] * c,
                        n[6] = a[6] * c,
                        n[7] = 0,
                        n[8] = a[8] * f,
                        n[9] = a[9] * f,
                        n[10] = a[10] * f,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromEuler(t) {
                        const n = this.elements
                          , a = t.x
                          , r = t.y
                          , c = t.z
                          , f = Math.cos(a)
                          , p = Math.sin(a)
                          , m = Math.cos(r)
                          , g = Math.sin(r)
                          , v = Math.cos(c)
                          , _ = Math.sin(c);
                        if (t.order === "XYZ") {
                            const x = f * v
                              , M = f * _
                              , C = p * v
                              , R = p * _;
                            n[0] = m * v,
                            n[4] = -m * _,
                            n[8] = g,
                            n[1] = M + C * g,
                            n[5] = x - R * g,
                            n[9] = -p * m,
                            n[2] = R - x * g,
                            n[6] = C + M * g,
                            n[10] = f * m
                        } else if (t.order === "YXZ") {
                            const x = m * v
                              , M = m * _
                              , C = g * v
                              , R = g * _;
                            n[0] = x + R * p,
                            n[4] = C * p - M,
                            n[8] = f * g,
                            n[1] = f * _,
                            n[5] = f * v,
                            n[9] = -p,
                            n[2] = M * p - C,
                            n[6] = R + x * p,
                            n[10] = f * m
                        } else if (t.order === "ZXY") {
                            const x = m * v
                              , M = m * _
                              , C = g * v
                              , R = g * _;
                            n[0] = x - R * p,
                            n[4] = -f * _,
                            n[8] = C + M * p,
                            n[1] = M + C * p,
                            n[5] = f * v,
                            n[9] = R - x * p,
                            n[2] = -f * g,
                            n[6] = p,
                            n[10] = f * m
                        } else if (t.order === "ZYX") {
                            const x = f * v
                              , M = f * _
                              , C = p * v
                              , R = p * _;
                            n[0] = m * v,
                            n[4] = C * g - M,
                            n[8] = x * g + R,
                            n[1] = m * _,
                            n[5] = R * g + x,
                            n[9] = M * g - C,
                            n[2] = -g,
                            n[6] = p * m,
                            n[10] = f * m
                        } else if (t.order === "YZX") {
                            const x = f * m
                              , M = f * g
                              , C = p * m
                              , R = p * g;
                            n[0] = m * v,
                            n[4] = R - x * _,
                            n[8] = C * _ + M,
                            n[1] = _,
                            n[5] = f * v,
                            n[9] = -p * v,
                            n[2] = -g * v,
                            n[6] = M * _ + C,
                            n[10] = x - R * _
                        } else if (t.order === "XZY") {
                            const x = f * m
                              , M = f * g
                              , C = p * m
                              , R = p * g;
                            n[0] = m * v,
                            n[4] = -_,
                            n[8] = g * v,
                            n[1] = x * _ + R,
                            n[5] = f * v,
                            n[9] = M * _ - C,
                            n[2] = C * _ - M,
                            n[6] = p * v,
                            n[10] = R * _ + x
                        }
                        return n[3] = 0,
                        n[7] = 0,
                        n[11] = 0,
                        n[12] = 0,
                        n[13] = 0,
                        n[14] = 0,
                        n[15] = 1,
                        this
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(yC, t, _C)
                    }
                    lookAt(t, n, a) {
                        const r = this.elements;
                        return ks.subVectors(t, n),
                        ks.lengthSq() === 0 && (ks.z = 1),
                        ks.normalize(),
                        Ac.crossVectors(a, ks),
                        Ac.lengthSq() === 0 && (Math.abs(a.z) === 1 ? ks.x += 1e-4 : ks.z += 1e-4,
                        ks.normalize(),
                        Ac.crossVectors(a, ks)),
                        Ac.normalize(),
                        d0.crossVectors(ks, Ac),
                        r[0] = Ac.x,
                        r[4] = d0.x,
                        r[8] = ks.x,
                        r[1] = Ac.y,
                        r[5] = d0.y,
                        r[9] = ks.y,
                        r[2] = Ac.z,
                        r[6] = d0.z,
                        r[10] = ks.z,
                        this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, n) {
                        const a = t.elements
                          , r = n.elements
                          , c = this.elements
                          , f = a[0]
                          , p = a[4]
                          , m = a[8]
                          , g = a[12]
                          , v = a[1]
                          , _ = a[5]
                          , x = a[9]
                          , M = a[13]
                          , C = a[2]
                          , R = a[6]
                          , A = a[10]
                          , E = a[14]
                          , N = a[3]
                          , I = a[7]
                          , L = a[11]
                          , k = a[15]
                          , B = r[0]
                          , X = r[4]
                          , G = r[8]
                          , P = r[12]
                          , U = r[1]
                          , W = r[5]
                          , K = r[9]
                          , q = r[13]
                          , te = r[2]
                          , ce = r[6]
                          , J = r[10]
                          , Q = r[14]
                          , se = r[3]
                          , Te = r[7]
                          , Ee = r[11]
                          , Be = r[15];
                        return c[0] = f * B + p * U + m * te + g * se,
                        c[4] = f * X + p * W + m * ce + g * Te,
                        c[8] = f * G + p * K + m * J + g * Ee,
                        c[12] = f * P + p * q + m * Q + g * Be,
                        c[1] = v * B + _ * U + x * te + M * se,
                        c[5] = v * X + _ * W + x * ce + M * Te,
                        c[9] = v * G + _ * K + x * J + M * Ee,
                        c[13] = v * P + _ * q + x * Q + M * Be,
                        c[2] = C * B + R * U + A * te + E * se,
                        c[6] = C * X + R * W + A * ce + E * Te,
                        c[10] = C * G + R * K + A * J + E * Ee,
                        c[14] = C * P + R * q + A * Q + E * Be,
                        c[3] = N * B + I * U + L * te + k * se,
                        c[7] = N * X + I * W + L * ce + k * Te,
                        c[11] = N * G + I * K + L * J + k * Ee,
                        c[15] = N * P + I * q + L * Q + k * Be,
                        this
                    }
                    multiplyScalar(t) {
                        const n = this.elements;
                        return n[0] *= t,
                        n[4] *= t,
                        n[8] *= t,
                        n[12] *= t,
                        n[1] *= t,
                        n[5] *= t,
                        n[9] *= t,
                        n[13] *= t,
                        n[2] *= t,
                        n[6] *= t,
                        n[10] *= t,
                        n[14] *= t,
                        n[3] *= t,
                        n[7] *= t,
                        n[11] *= t,
                        n[15] *= t,
                        this
                    }
                    determinant() {
                        const t = this.elements
                          , n = t[0]
                          , a = t[4]
                          , r = t[8]
                          , c = t[12]
                          , f = t[1]
                          , p = t[5]
                          , m = t[9]
                          , g = t[13]
                          , v = t[2]
                          , _ = t[6]
                          , x = t[10]
                          , M = t[14]
                          , C = t[3]
                          , R = t[7]
                          , A = t[11]
                          , E = t[15]
                          , N = m * M - g * x
                          , I = p * M - g * _
                          , L = p * x - m * _
                          , k = f * M - g * v
                          , B = f * x - m * v
                          , X = f * _ - p * v;
                        return n * (R * N - A * I + E * L) - a * (C * N - A * k + E * B) + r * (C * I - R * k + E * X) - c * (C * L - R * B + A * X)
                    }
                    transpose() {
                        const t = this.elements;
                        let n;
                        return n = t[1],
                        t[1] = t[4],
                        t[4] = n,
                        n = t[2],
                        t[2] = t[8],
                        t[8] = n,
                        n = t[6],
                        t[6] = t[9],
                        t[9] = n,
                        n = t[3],
                        t[3] = t[12],
                        t[12] = n,
                        n = t[7],
                        t[7] = t[13],
                        t[13] = n,
                        n = t[11],
                        t[11] = t[14],
                        t[14] = n,
                        this
                    }
                    setPosition(t, n, a) {
                        const r = this.elements;
                        return t.isVector3 ? (r[12] = t.x,
                        r[13] = t.y,
                        r[14] = t.z) : (r[12] = t,
                        r[13] = n,
                        r[14] = a),
                        this
                    }
                    invert() {
                        const t = this.elements
                          , n = t[0]
                          , a = t[1]
                          , r = t[2]
                          , c = t[3]
                          , f = t[4]
                          , p = t[5]
                          , m = t[6]
                          , g = t[7]
                          , v = t[8]
                          , _ = t[9]
                          , x = t[10]
                          , M = t[11]
                          , C = t[12]
                          , R = t[13]
                          , A = t[14]
                          , E = t[15]
                          , N = _ * A * g - R * x * g + R * m * M - p * A * M - _ * m * E + p * x * E
                          , I = C * x * g - v * A * g - C * m * M + f * A * M + v * m * E - f * x * E
                          , L = v * R * g - C * _ * g + C * p * M - f * R * M - v * p * E + f * _ * E
                          , k = C * _ * m - v * R * m - C * p * x + f * R * x + v * p * A - f * _ * A
                          , B = n * N + a * I + r * L + c * k;
                        if (B === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const X = 1 / B;
                        return t[0] = N * X,
                        t[1] = (R * x * c - _ * A * c - R * r * M + a * A * M + _ * r * E - a * x * E) * X,
                        t[2] = (p * A * c - R * m * c + R * r * g - a * A * g - p * r * E + a * m * E) * X,
                        t[3] = (_ * m * c - p * x * c - _ * r * g + a * x * g + p * r * M - a * m * M) * X,
                        t[4] = I * X,
                        t[5] = (v * A * c - C * x * c + C * r * M - n * A * M - v * r * E + n * x * E) * X,
                        t[6] = (C * m * c - f * A * c - C * r * g + n * A * g + f * r * E - n * m * E) * X,
                        t[7] = (f * x * c - v * m * c + v * r * g - n * x * g - f * r * M + n * m * M) * X,
                        t[8] = L * X,
                        t[9] = (C * _ * c - v * R * c - C * a * M + n * R * M + v * a * E - n * _ * E) * X,
                        t[10] = (f * R * c - C * p * c + C * a * g - n * R * g - f * a * E + n * p * E) * X,
                        t[11] = (v * p * c - f * _ * c - v * a * g + n * _ * g + f * a * M - n * p * M) * X,
                        t[12] = k * X,
                        t[13] = (v * R * r - C * _ * r + C * a * x - n * R * x - v * a * A + n * _ * A) * X,
                        t[14] = (C * p * r - f * R * r - C * a * m + n * R * m + f * a * A - n * p * A) * X,
                        t[15] = (f * _ * r - v * p * r + v * a * m - n * _ * m - f * a * x + n * p * x) * X,
                        this
                    }
                    scale(t) {
                        const n = this.elements
                          , a = t.x
                          , r = t.y
                          , c = t.z;
                        return n[0] *= a,
                        n[4] *= r,
                        n[8] *= c,
                        n[1] *= a,
                        n[5] *= r,
                        n[9] *= c,
                        n[2] *= a,
                        n[6] *= r,
                        n[10] *= c,
                        n[3] *= a,
                        n[7] *= r,
                        n[11] *= c,
                        this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements
                          , n = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                          , a = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                          , r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(n, a, r))
                    }
                    makeTranslation(t, n, a) {
                        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, n, 0, 0, 1, a, 0, 0, 0, 1),
                        this
                    }
                    makeRotationX(t) {
                        const n = Math.cos(t)
                          , a = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, n, -a, 0, 0, a, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationY(t) {
                        const n = Math.cos(t)
                          , a = Math.sin(t);
                        return this.set(n, 0, a, 0, 0, 1, 0, 0, -a, 0, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationZ(t) {
                        const n = Math.cos(t)
                          , a = Math.sin(t);
                        return this.set(n, -a, 0, 0, a, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationAxis(t, n) {
                        const a = Math.cos(n)
                          , r = Math.sin(n)
                          , c = 1 - a
                          , f = t.x
                          , p = t.y
                          , m = t.z
                          , g = c * f
                          , v = c * p;
                        return this.set(g * f + a, g * p - r * m, g * m + r * p, 0, g * p + r * m, v * p + a, v * m - r * f, 0, g * m - r * p, v * m + r * f, c * m * m + a, 0, 0, 0, 0, 1),
                        this
                    }
                    makeScale(t, n, a) {
                        return this.set(t, 0, 0, 0, 0, n, 0, 0, 0, 0, a, 0, 0, 0, 0, 1),
                        this
                    }
                    makeShear(t, n, a, r, c, f) {
                        return this.set(1, a, c, 0, t, 1, f, 0, n, r, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    compose(t, n, a) {
                        const r = this.elements
                          , c = n._x
                          , f = n._y
                          , p = n._z
                          , m = n._w
                          , g = c + c
                          , v = f + f
                          , _ = p + p
                          , x = c * g
                          , M = c * v
                          , C = c * _
                          , R = f * v
                          , A = f * _
                          , E = p * _
                          , N = m * g
                          , I = m * v
                          , L = m * _
                          , k = a.x
                          , B = a.y
                          , X = a.z;
                        return r[0] = (1 - (R + E)) * k,
                        r[1] = (M + L) * k,
                        r[2] = (C - I) * k,
                        r[3] = 0,
                        r[4] = (M - L) * B,
                        r[5] = (1 - (x + E)) * B,
                        r[6] = (A + N) * B,
                        r[7] = 0,
                        r[8] = (C + I) * X,
                        r[9] = (A - N) * X,
                        r[10] = (1 - (x + R)) * X,
                        r[11] = 0,
                        r[12] = t.x,
                        r[13] = t.y,
                        r[14] = t.z,
                        r[15] = 1,
                        this
                    }
                    decompose(t, n, a) {
                        const r = this.elements;
                        if (t.x = r[12],
                        t.y = r[13],
                        t.z = r[14],
                        this.determinant() === 0)
                            return a.set(1, 1, 1),
                            n.identity(),
                            this;
                        let c = Ah.set(r[0], r[1], r[2]).length();
                        const f = Ah.set(r[4], r[5], r[6]).length()
                          , p = Ah.set(r[8], r[9], r[10]).length();
                        this.determinant() < 0 && (c = -c),
                        kr.copy(this);
                        const m = 1 / c
                          , g = 1 / f
                          , v = 1 / p;
                        return kr.elements[0] *= m,
                        kr.elements[1] *= m,
                        kr.elements[2] *= m,
                        kr.elements[4] *= g,
                        kr.elements[5] *= g,
                        kr.elements[6] *= g,
                        kr.elements[8] *= v,
                        kr.elements[9] *= v,
                        kr.elements[10] *= v,
                        n.setFromRotationMatrix(kr),
                        a.x = c,
                        a.y = f,
                        a.z = p,
                        this
                    }
                    makePerspective(t, n, a, r, c, f, p=Bs, m=!1) {
                        const g = this.elements
                          , v = 2 * c / (n - t)
                          , _ = 2 * c / (a - r)
                          , x = (n + t) / (n - t)
                          , M = (a + r) / (a - r);
                        let C, R;
                        if (m)
                            C = c / (f - c),
                            R = f * c / (f - c);
                        else if (p === Bs)
                            C = -(f + c) / (f - c),
                            R = -2 * f * c / (f - c);
                        else if (p === gh)
                            C = -f / (f - c),
                            R = -f * c / (f - c);
                        else
                            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + p);
                        return g[0] = v,
                        g[4] = 0,
                        g[8] = x,
                        g[12] = 0,
                        g[1] = 0,
                        g[5] = _,
                        g[9] = M,
                        g[13] = 0,
                        g[2] = 0,
                        g[6] = 0,
                        g[10] = C,
                        g[14] = R,
                        g[3] = 0,
                        g[7] = 0,
                        g[11] = -1,
                        g[15] = 0,
                        this
                    }
                    makeOrthographic(t, n, a, r, c, f, p=Bs, m=!1) {
                        const g = this.elements
                          , v = 2 / (n - t)
                          , _ = 2 / (a - r)
                          , x = -(n + t) / (n - t)
                          , M = -(a + r) / (a - r);
                        let C, R;
                        if (m)
                            C = 1 / (f - c),
                            R = f / (f - c);
                        else if (p === Bs)
                            C = -2 / (f - c),
                            R = -(f + c) / (f - c);
                        else if (p === gh)
                            C = -1 / (f - c),
                            R = -c / (f - c);
                        else
                            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + p);
                        return g[0] = v,
                        g[4] = 0,
                        g[8] = 0,
                        g[12] = x,
                        g[1] = 0,
                        g[5] = _,
                        g[9] = 0,
                        g[13] = M,
                        g[2] = 0,
                        g[6] = 0,
                        g[10] = C,
                        g[14] = R,
                        g[3] = 0,
                        g[7] = 0,
                        g[11] = 0,
                        g[15] = 1,
                        this
                    }
                    equals(t) {
                        const n = this.elements
                          , a = t.elements;
                        for (let r = 0; r < 16; r++)
                            if (n[r] !== a[r])
                                return !1;
                        return !0
                    }
                    fromArray(t, n=0) {
                        for (let a = 0; a < 16; a++)
                            this.elements[a] = t[a + n];
                        return this
                    }
                    toArray(t=[], n=0) {
                        const a = this.elements;
                        return t[n] = a[0],
                        t[n + 1] = a[1],
                        t[n + 2] = a[2],
                        t[n + 3] = a[3],
                        t[n + 4] = a[4],
                        t[n + 5] = a[5],
                        t[n + 6] = a[6],
                        t[n + 7] = a[7],
                        t[n + 8] = a[8],
                        t[n + 9] = a[9],
                        t[n + 10] = a[10],
                        t[n + 11] = a[11],
                        t[n + 12] = a[12],
                        t[n + 13] = a[13],
                        t[n + 14] = a[14],
                        t[n + 15] = a[15],
                        t
                    }
                }
                ;
                const Ah = new Y
                  , kr = new Wt
                  , yC = new Y(0,0,0)
                  , _C = new Y(1,1,1)
                  , Ac = new Y
                  , d0 = new Y
                  , ks = new Y
                  , Yb = new Wt
                  , jb = new xs;
                var es = class wA {
                    constructor(t=0, n=0, a=0, r=wA.DEFAULT_ORDER) {
                        this.isEuler = !0,
                        this._x = t,
                        this._y = n,
                        this._z = a,
                        this._order = r
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t,
                        this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(t) {
                        this._order = t,
                        this._onChangeCallback()
                    }
                    set(t, n, a, r=this._order) {
                        return this._x = t,
                        this._y = n,
                        this._z = a,
                        this._order = r,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._order)
                    }
                    copy(t) {
                        return this._x = t._x,
                        this._y = t._y,
                        this._z = t._z,
                        this._order = t._order,
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(t, n=this._order, a=!0) {
                        const r = t.elements
                          , c = r[0]
                          , f = r[4]
                          , p = r[8]
                          , m = r[1]
                          , g = r[5]
                          , v = r[9]
                          , _ = r[2]
                          , x = r[6]
                          , M = r[10];
                        switch (n) {
                        case "XYZ":
                            this._y = Math.asin(Bt(p, -1, 1)),
                            Math.abs(p) < .9999999 ? (this._x = Math.atan2(-v, M),
                            this._z = Math.atan2(-f, c)) : (this._x = Math.atan2(x, g),
                            this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-Bt(v, -1, 1)),
                            Math.abs(v) < .9999999 ? (this._y = Math.atan2(p, M),
                            this._z = Math.atan2(m, g)) : (this._y = Math.atan2(-_, c),
                            this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(Bt(x, -1, 1)),
                            Math.abs(x) < .9999999 ? (this._y = Math.atan2(-_, M),
                            this._z = Math.atan2(-f, g)) : (this._y = 0,
                            this._z = Math.atan2(m, c));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-Bt(_, -1, 1)),
                            Math.abs(_) < .9999999 ? (this._x = Math.atan2(x, M),
                            this._z = Math.atan2(m, c)) : (this._x = 0,
                            this._z = Math.atan2(-f, g));
                            break;
                        case "YZX":
                            this._z = Math.asin(Bt(m, -1, 1)),
                            Math.abs(m) < .9999999 ? (this._x = Math.atan2(-v, g),
                            this._y = Math.atan2(-_, c)) : (this._x = 0,
                            this._y = Math.atan2(p, M));
                            break;
                        case "XZY":
                            this._z = Math.asin(-Bt(f, -1, 1)),
                            Math.abs(f) < .9999999 ? (this._x = Math.atan2(x, g),
                            this._y = Math.atan2(p, c)) : (this._x = Math.atan2(-v, M),
                            this._y = 0);
                            break;
                        default:
                            ot("Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
                        }
                        return this._order = n,
                        a === !0 && this._onChangeCallback(),
                        this
                    }
                    setFromQuaternion(t, n, a) {
                        return Yb.makeRotationFromQuaternion(t),
                        this.setFromRotationMatrix(Yb, n, a)
                    }
                    setFromVector3(t, n=this._order) {
                        return this.set(t.x, t.y, t.z, n)
                    }
                    reorder(t) {
                        return jb.setFromEuler(this),
                        this.setFromQuaternion(jb, t)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                    fromArray(t) {
                        return this._x = t[0],
                        this._y = t[1],
                        this._z = t[2],
                        t[3] !== void 0 && (this._order = t[3]),
                        this._onChangeCallback(),
                        this
                    }
                    toArray(t=[], n=0) {
                        return t[n] = this._x,
                        t[n + 1] = this._y,
                        t[n + 2] = this._z,
                        t[n + 3] = this._order,
                        t
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t,
                        this
                    }
                    _onChangeCallback() {}
                    *[Symbol.iterator]() {
                        yield this._x,
                        yield this._y,
                        yield this._z,
                        yield this._order
                    }
                }
                ;
                es.DEFAULT_ORDER = "XYZ";
                var wh = class {
                    constructor() {
                        this.mask = 1
                    }
                    set(e) {
                        this.mask = (1 << e | 0) >>> 0
                    }
                    enable(e) {
                        this.mask |= 1 << e | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(e) {
                        this.mask ^= 1 << e | 0
                    }
                    disable(e) {
                        this.mask &= ~(1 << e | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(e) {
                        return (this.mask & e.mask) !== 0
                    }
                    isEnabled(e) {
                        return (this.mask & (1 << e | 0)) !== 0
                    }
                }
                ;
                let SC = 0;
                const Zb = new Y
                  , Ch = new xs
                  , bl = new Wt
                  , p0 = new Y
                  , Zp = new Y
                  , xC = new Y
                  , bC = new xs
                  , Qb = new Y(1,0,0)
                  , Kb = new Y(0,1,0)
                  , Jb = new Y(0,0,1)
                  , $b = {
                    type: "added"
                }
                  , MC = {
                    type: "removed"
                }
                  , Rh = {
                    type: "childadded",
                    child: null
                }
                  , O_ = {
                    type: "childremoved",
                    child: null
                };
                var Fn = class xy extends Uo {
                    constructor() {
                        super(),
                        this.isObject3D = !0,
                        Object.defineProperty(this, "id", {
                            value: SC++
                        }),
                        this.uuid = Fs(),
                        this.name = "",
                        this.type = "Object3D",
                        this.parent = null,
                        this.children = [],
                        this.up = xy.DEFAULT_UP.clone();
                        const t = new Y
                          , n = new es
                          , a = new xs
                          , r = new Y(1,1,1);
                        function c() {
                            a.setFromEuler(n, !1)
                        }
                        function f() {
                            n.setFromQuaternion(a, void 0, !1)
                        }
                        n._onChange(c),
                        a._onChange(f),
                        Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: t
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: a
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: r
                            },
                            modelViewMatrix: {
                                value: new Wt
                            },
                            normalMatrix: {
                                value: new en
                            }
                        }),
                        this.matrix = new Wt,
                        this.matrixWorld = new Wt,
                        this.matrixAutoUpdate = xy.DEFAULT_MATRIX_AUTO_UPDATE,
                        this.matrixWorldAutoUpdate = xy.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                        this.matrixWorldNeedsUpdate = !1,
                        this.layers = new wh,
                        this.visible = !0,
                        this.castShadow = !1,
                        this.receiveShadow = !1,
                        this.frustumCulled = !0,
                        this.renderOrder = 0,
                        this.animations = [],
                        this.customDepthMaterial = void 0,
                        this.customDistanceMaterial = void 0,
                        this.userData = {}
                    }
                    onBeforeShadow() {}
                    onAfterShadow() {}
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(t),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t),
                        this
                    }
                    setRotationFromAxisAngle(t, n) {
                        this.quaternion.setFromAxisAngle(t, n)
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0)
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t)
                    }
                    rotateOnAxis(t, n) {
                        return Ch.setFromAxisAngle(t, n),
                        this.quaternion.multiply(Ch),
                        this
                    }
                    rotateOnWorldAxis(t, n) {
                        return Ch.setFromAxisAngle(t, n),
                        this.quaternion.premultiply(Ch),
                        this
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(Qb, t)
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(Kb, t)
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(Jb, t)
                    }
                    translateOnAxis(t, n) {
                        return Zb.copy(t).applyQuaternion(this.quaternion),
                        this.position.add(Zb.multiplyScalar(n)),
                        this
                    }
                    translateX(t) {
                        return this.translateOnAxis(Qb, t)
                    }
                    translateY(t) {
                        return this.translateOnAxis(Kb, t)
                    }
                    translateZ(t) {
                        return this.translateOnAxis(Jb, t)
                    }
                    localToWorld(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.applyMatrix4(bl.copy(this.matrixWorld).invert())
                    }
                    lookAt(t, n, a) {
                        t.isVector3 ? p0.copy(t) : p0.set(t, n, a);
                        const r = this.parent;
                        this.updateWorldMatrix(!0, !1),
                        Zp.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? bl.lookAt(Zp, p0, this.up) : bl.lookAt(p0, Zp, this.up),
                        this.quaternion.setFromRotationMatrix(bl),
                        r && (bl.extractRotation(r.matrixWorld),
                        Ch.setFromRotationMatrix(bl),
                        this.quaternion.premultiply(Ch.invert()))
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let n = 0; n < arguments.length; n++)
                                this.add(arguments[n]);
                            return this
                        }
                        return t === this ? (Et("Object3D.add: object can't be added as a child of itself.", t),
                        this) : (t && t.isObject3D ? (t.removeFromParent(),
                        t.parent = this,
                        this.children.push(t),
                        t.dispatchEvent($b),
                        Rh.child = t,
                        this.dispatchEvent(Rh),
                        Rh.child = null) : Et("Object3D.add: object not an instance of THREE.Object3D.", t),
                        this)
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let a = 0; a < arguments.length; a++)
                                this.remove(arguments[a]);
                            return this
                        }
                        const n = this.children.indexOf(t);
                        return n !== -1 && (t.parent = null,
                        this.children.splice(n, 1),
                        t.dispatchEvent(MC),
                        O_.child = t,
                        this.dispatchEvent(O_),
                        O_.child = null),
                        this
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return t !== null && t.remove(this),
                        this
                    }
                    clear() {
                        return this.remove(...this.children)
                    }
                    attach(t) {
                        return this.updateWorldMatrix(!0, !1),
                        bl.copy(this.matrixWorld).invert(),
                        t.parent !== null && (t.parent.updateWorldMatrix(!0, !1),
                        bl.multiply(t.parent.matrixWorld)),
                        t.applyMatrix4(bl),
                        t.removeFromParent(),
                        t.parent = this,
                        this.children.push(t),
                        t.updateWorldMatrix(!1, !0),
                        t.dispatchEvent($b),
                        Rh.child = t,
                        this.dispatchEvent(Rh),
                        Rh.child = null,
                        this
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t)
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t)
                    }
                    getObjectByProperty(t, n) {
                        if (this[t] === n)
                            return this;
                        for (let a = 0, r = this.children.length; a < r; a++) {
                            const c = this.children[a].getObjectByProperty(t, n);
                            if (c !== void 0)
                                return c
                        }
                    }
                    getObjectsByProperty(t, n, a=[]) {
                        this[t] === n && a.push(this);
                        const r = this.children;
                        for (let c = 0, f = r.length; c < f; c++)
                            r[c].getObjectsByProperty(t, n, a);
                        return a
                    }
                    getWorldPosition(t) {
                        return this.updateWorldMatrix(!0, !1),
                        t.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(t) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(Zp, t, xC),
                        t
                    }
                    getWorldScale(t) {
                        return this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(Zp, bC, t),
                        t
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const n = this.matrixWorld.elements;
                        return t.set(n[8], n[9], n[10]).normalize()
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const n = this.children;
                        for (let a = 0, r = n.length; a < r; a++)
                            n[a].traverse(t)
                    }
                    traverseVisible(t) {
                        if (this.visible === !1)
                            return;
                        t(this);
                        const n = this.children;
                        for (let a = 0, r = n.length; a < r; a++)
                            n[a].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const n = this.parent;
                        n !== null && (t(n),
                        n.traverseAncestors(t))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        this.matrixWorldNeedsUpdate = !1,
                        t = !0);
                        const n = this.children;
                        for (let a = 0, r = n.length; a < r; a++)
                            n[a].updateMatrixWorld(t)
                    }
                    updateWorldMatrix(t, n) {
                        const a = this.parent;
                        if (t === !0 && a !== null && a.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                        n === !0) {
                            const r = this.children;
                            for (let c = 0, f = r.length; c < f; c++)
                                r[c].updateWorldMatrix(!1, !0)
                        }
                    }
                    toJSON(t) {
                        const n = t === void 0 || typeof t == "string"
                          , a = {};
                        n && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {},
                            nodes: {}
                        },
                        a.metadata = {
                            version: 4.7,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const r = {};
                        r.uuid = this.uuid,
                        r.type = this.type,
                        this.name !== "" && (r.name = this.name),
                        this.castShadow === !0 && (r.castShadow = !0),
                        this.receiveShadow === !0 && (r.receiveShadow = !0),
                        this.visible === !1 && (r.visible = !1),
                        this.frustumCulled === !1 && (r.frustumCulled = !1),
                        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
                        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
                        r.layers = this.layers.mask,
                        r.matrix = this.matrix.toArray(),
                        r.up = this.up.toArray(),
                        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
                        this.isInstancedMesh && (r.type = "InstancedMesh",
                        r.count = this.count,
                        r.instanceMatrix = this.instanceMatrix.toJSON(),
                        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
                        this.isBatchedMesh && (r.type = "BatchedMesh",
                        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
                        r.sortObjects = this.sortObjects,
                        r.drawRanges = this._drawRanges,
                        r.reservedRanges = this._reservedRanges,
                        r.geometryInfo = this._geometryInfo.map(p => ({
                            ...p,
                            boundingBox: p.boundingBox ? p.boundingBox.toJSON() : void 0,
                            boundingSphere: p.boundingSphere ? p.boundingSphere.toJSON() : void 0
                        })),
                        r.instanceInfo = this._instanceInfo.map(p => ({
                            ...p
                        })),
                        r.availableInstanceIds = this._availableInstanceIds.slice(),
                        r.availableGeometryIds = this._availableGeometryIds.slice(),
                        r.nextIndexStart = this._nextIndexStart,
                        r.nextVertexStart = this._nextVertexStart,
                        r.geometryCount = this._geometryCount,
                        r.maxInstanceCount = this._maxInstanceCount,
                        r.maxVertexCount = this._maxVertexCount,
                        r.maxIndexCount = this._maxIndexCount,
                        r.geometryInitialized = this._geometryInitialized,
                        r.matricesTexture = this._matricesTexture.toJSON(t),
                        r.indirectTexture = this._indirectTexture.toJSON(t),
                        this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(t)),
                        this.boundingSphere !== null && (r.boundingSphere = this.boundingSphere.toJSON()),
                        this.boundingBox !== null && (r.boundingBox = this.boundingBox.toJSON()));
                        function c(p, m) {
                            return p[m.uuid] === void 0 && (p[m.uuid] = m.toJSON(t)),
                            m.uuid
                        }
                        if (this.isScene)
                            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)),
                            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            r.geometry = c(t.geometries, this.geometry);
                            const p = this.geometry.parameters;
                            if (p !== void 0 && p.shapes !== void 0) {
                                const m = p.shapes;
                                if (Array.isArray(m))
                                    for (let g = 0, v = m.length; g < v; g++) {
                                        const _ = m[g];
                                        c(t.shapes, _)
                                    }
                                else
                                    c(t.shapes, m)
                            }
                        }
                        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
                        r.bindMatrix = this.bindMatrix.toArray(),
                        this.skeleton !== void 0 && (c(t.skeletons, this.skeleton),
                        r.skeleton = this.skeleton.uuid)),
                        this.material !== void 0)
                            if (Array.isArray(this.material)) {
                                const p = [];
                                for (let m = 0, g = this.material.length; m < g; m++)
                                    p.push(c(t.materials, this.material[m]));
                                r.material = p
                            } else
                                r.material = c(t.materials, this.material);
                        if (this.children.length > 0) {
                            r.children = [];
                            for (let p = 0; p < this.children.length; p++)
                                r.children.push(this.children[p].toJSON(t).object)
                        }
                        if (this.animations.length > 0) {
                            r.animations = [];
                            for (let p = 0; p < this.animations.length; p++) {
                                const m = this.animations[p];
                                r.animations.push(c(t.animations, m))
                            }
                        }
                        if (n) {
                            const p = f(t.geometries)
                              , m = f(t.materials)
                              , g = f(t.textures)
                              , v = f(t.images)
                              , _ = f(t.shapes)
                              , x = f(t.skeletons)
                              , M = f(t.animations)
                              , C = f(t.nodes);
                            p.length > 0 && (a.geometries = p),
                            m.length > 0 && (a.materials = m),
                            g.length > 0 && (a.textures = g),
                            v.length > 0 && (a.images = v),
                            _.length > 0 && (a.shapes = _),
                            x.length > 0 && (a.skeletons = x),
                            M.length > 0 && (a.animations = M),
                            C.length > 0 && (a.nodes = C)
                        }
                        return a.object = r,
                        a;
                        function f(p) {
                            const m = [];
                            for (const g in p) {
                                const v = p[g];
                                delete v.metadata,
                                m.push(v)
                            }
                            return m
                        }
                    }
                    clone(t) {
                        return new this.constructor().copy(this, t)
                    }
                    copy(t, n=!0) {
                        if (this.name = t.name,
                        this.up.copy(t.up),
                        this.position.copy(t.position),
                        this.rotation.order = t.rotation.order,
                        this.quaternion.copy(t.quaternion),
                        this.scale.copy(t.scale),
                        this.matrix.copy(t.matrix),
                        this.matrixWorld.copy(t.matrixWorld),
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate,
                        this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                        this.layers.mask = t.layers.mask,
                        this.visible = t.visible,
                        this.castShadow = t.castShadow,
                        this.receiveShadow = t.receiveShadow,
                        this.frustumCulled = t.frustumCulled,
                        this.renderOrder = t.renderOrder,
                        this.animations = t.animations.slice(),
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        n === !0)
                            for (let a = 0; a < t.children.length; a++) {
                                const r = t.children[a];
                                this.add(r.clone())
                            }
                        return this
                    }
                }
                ;
                Fn.DEFAULT_UP = new Y(0,1,0),
                Fn.DEFAULT_MATRIX_AUTO_UPDATE = !0,
                Fn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                const Hr = new Y
                  , Ml = new Y
                  , P_ = new Y
                  , Tl = new Y
                  , Dh = new Y
                  , Nh = new Y
                  , eM = new Y
                  , z_ = new Y
                  , B_ = new Y
                  , F_ = new Y
                  , V_ = new ti
                  , k_ = new ti
                  , H_ = new ti;
                var wc = class ad {
                    constructor(t=new Y, n=new Y, a=new Y) {
                        this.a = t,
                        this.b = n,
                        this.c = a
                    }
                    static getNormal(t, n, a, r) {
                        r.subVectors(a, n),
                        Hr.subVectors(t, n),
                        r.cross(Hr);
                        const c = r.lengthSq();
                        return c > 0 ? r.multiplyScalar(1 / Math.sqrt(c)) : r.set(0, 0, 0)
                    }
                    static getBarycoord(t, n, a, r, c) {
                        Hr.subVectors(r, n),
                        Ml.subVectors(a, n),
                        P_.subVectors(t, n);
                        const f = Hr.dot(Hr)
                          , p = Hr.dot(Ml)
                          , m = Hr.dot(P_)
                          , g = Ml.dot(Ml)
                          , v = Ml.dot(P_)
                          , _ = f * g - p * p;
                        if (_ === 0)
                            return c.set(0, 0, 0),
                            null;
                        const x = 1 / _
                          , M = (g * m - p * v) * x
                          , C = (f * v - p * m) * x;
                        return c.set(1 - M - C, C, M)
                    }
                    static containsPoint(t, n, a, r) {
                        return this.getBarycoord(t, n, a, r, Tl) === null ? !1 : Tl.x >= 0 && Tl.y >= 0 && Tl.x + Tl.y <= 1
                    }
                    static getInterpolation(t, n, a, r, c, f, p, m) {
                        return this.getBarycoord(t, n, a, r, Tl) === null ? (m.x = 0,
                        m.y = 0,
                        "z"in m && (m.z = 0),
                        "w"in m && (m.w = 0),
                        null) : (m.setScalar(0),
                        m.addScaledVector(c, Tl.x),
                        m.addScaledVector(f, Tl.y),
                        m.addScaledVector(p, Tl.z),
                        m)
                    }
                    static getInterpolatedAttribute(t, n, a, r, c, f) {
                        return V_.setScalar(0),
                        k_.setScalar(0),
                        H_.setScalar(0),
                        V_.fromBufferAttribute(t, n),
                        k_.fromBufferAttribute(t, a),
                        H_.fromBufferAttribute(t, r),
                        f.setScalar(0),
                        f.addScaledVector(V_, c.x),
                        f.addScaledVector(k_, c.y),
                        f.addScaledVector(H_, c.z),
                        f
                    }
                    static isFrontFacing(t, n, a, r) {
                        return Hr.subVectors(a, n),
                        Ml.subVectors(t, n),
                        Hr.cross(Ml).dot(r) < 0
                    }
                    set(t, n, a) {
                        return this.a.copy(t),
                        this.b.copy(n),
                        this.c.copy(a),
                        this
                    }
                    setFromPointsAndIndices(t, n, a, r) {
                        return this.a.copy(t[n]),
                        this.b.copy(t[a]),
                        this.c.copy(t[r]),
                        this
                    }
                    setFromAttributeAndIndices(t, n, a, r) {
                        return this.a.fromBufferAttribute(t, n),
                        this.b.fromBufferAttribute(t, a),
                        this.c.fromBufferAttribute(t, r),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        return this.a.copy(t.a),
                        this.b.copy(t.b),
                        this.c.copy(t.c),
                        this
                    }
                    getArea() {
                        return Hr.subVectors(this.c, this.b),
                        Ml.subVectors(this.a, this.b),
                        Hr.cross(Ml).length() * .5
                    }
                    getMidpoint(t) {
                        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(t) {
                        return ad.getNormal(this.a, this.b, this.c, t)
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(t, n) {
                        return ad.getBarycoord(t, this.a, this.b, this.c, n)
                    }
                    getInterpolation(t, n, a, r, c) {
                        return ad.getInterpolation(t, this.a, this.b, this.c, n, a, r, c)
                    }
                    containsPoint(t) {
                        return ad.containsPoint(t, this.a, this.b, this.c)
                    }
                    isFrontFacing(t) {
                        return ad.isFrontFacing(this.a, this.b, this.c, t)
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this)
                    }
                    closestPointToPoint(t, n) {
                        const a = this.a
                          , r = this.b
                          , c = this.c;
                        let f, p;
                        Dh.subVectors(r, a),
                        Nh.subVectors(c, a),
                        z_.subVectors(t, a);
                        const m = Dh.dot(z_)
                          , g = Nh.dot(z_);
                        if (m <= 0 && g <= 0)
                            return n.copy(a);
                        B_.subVectors(t, r);
                        const v = Dh.dot(B_)
                          , _ = Nh.dot(B_);
                        if (v >= 0 && _ <= v)
                            return n.copy(r);
                        const x = m * _ - v * g;
                        if (x <= 0 && m >= 0 && v <= 0)
                            return f = m / (m - v),
                            n.copy(a).addScaledVector(Dh, f);
                        F_.subVectors(t, c);
                        const M = Dh.dot(F_)
                          , C = Nh.dot(F_);
                        if (C >= 0 && M <= C)
                            return n.copy(c);
                        const R = M * g - m * C;
                        if (R <= 0 && g >= 0 && C <= 0)
                            return p = g / (g - C),
                            n.copy(a).addScaledVector(Nh, p);
                        const A = v * C - M * _;
                        if (A <= 0 && _ - v >= 0 && M - C >= 0)
                            return eM.subVectors(c, r),
                            p = (_ - v) / (_ - v + (M - C)),
                            n.copy(r).addScaledVector(eM, p);
                        const E = 1 / (A + R + x);
                        return f = R * E,
                        p = x * E,
                        n.copy(a).addScaledVector(Dh, f).addScaledVector(Nh, p)
                    }
                    equals(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }
                ;
                const tM = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                }
                  , Cc = {
                    h: 0,
                    s: 0,
                    l: 0
                }
                  , m0 = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                function G_(e, t, n) {
                    return n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e
                }
                var dt = class {
                    constructor(e, t, n) {
                        return this.isColor = !0,
                        this.r = 1,
                        this.g = 1,
                        this.b = 1,
                        this.set(e, t, n)
                    }
                    set(e, t, n) {
                        if (t === void 0 && n === void 0) {
                            const a = e;
                            a && a.isColor ? this.copy(a) : typeof a == "number" ? this.setHex(a) : typeof a == "string" && this.setStyle(a)
                        } else
                            this.setRGB(e, t, n);
                        return this
                    }
                    setScalar(e) {
                        return this.r = e,
                        this.g = e,
                        this.b = e,
                        this
                    }
                    setHex(e, t=wa) {
                        return e = Math.floor(e),
                        this.r = (e >> 16 & 255) / 255,
                        this.g = (e >> 8 & 255) / 255,
                        this.b = (e & 255) / 255,
                        Sn.colorSpaceToWorking(this, t),
                        this
                    }
                    setRGB(e, t, n, a=Sn.workingColorSpace) {
                        return this.r = e,
                        this.g = t,
                        this.b = n,
                        Sn.colorSpaceToWorking(this, a),
                        this
                    }
                    setHSL(e, t, n, a=Sn.workingColorSpace) {
                        if (e = T_(e, 1),
                        t = Bt(t, 0, 1),
                        n = Bt(n, 0, 1),
                        t === 0)
                            this.r = this.g = this.b = n;
                        else {
                            const r = n <= .5 ? n * (1 + t) : n + t - n * t
                              , c = 2 * n - r;
                            this.r = G_(c, r, e + 1 / 3),
                            this.g = G_(c, r, e),
                            this.b = G_(c, r, e - 1 / 3)
                        }
                        return Sn.colorSpaceToWorking(this, a),
                        this
                    }
                    setStyle(e, t=wa) {
                        function n(r) {
                            r !== void 0 && parseFloat(r) < 1 && ot("Color: Alpha component of " + e + " will be ignored.")
                        }
                        let a;
                        if (a = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                            let r;
                            const c = a[1]
                              , f = a[2];
                            switch (c) {
                            case "rgb":
                            case "rgba":
                                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                                    return n(r[4]),
                                    this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                                    return n(r[4]),
                                    this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                                    return n(r[4]),
                                    this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                                break;
                            default:
                                ot("Color: Unknown color model " + e)
                            }
                        } else if (a = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                            const r = a[1]
                              , c = r.length;
                            if (c === 3)
                                return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
                            if (c === 6)
                                return this.setHex(parseInt(r, 16), t);
                            ot("Color: Invalid hex color " + e)
                        } else if (e && e.length > 0)
                            return this.setColorName(e, t);
                        return this
                    }
                    setColorName(e, t=wa) {
                        const n = tM[e.toLowerCase()];
                        return n !== void 0 ? this.setHex(n, t) : ot("Color: Unknown color " + e),
                        this
                    }
                    clone() {
                        return new this.constructor(this.r,this.g,this.b)
                    }
                    copy(e) {
                        return this.r = e.r,
                        this.g = e.g,
                        this.b = e.b,
                        this
                    }
                    copySRGBToLinear(e) {
                        return this.r = _l(e.r),
                        this.g = _l(e.g),
                        this.b = _l(e.b),
                        this
                    }
                    copyLinearToSRGB(e) {
                        return this.r = Sh(e.r),
                        this.g = Sh(e.g),
                        this.b = Sh(e.b),
                        this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this),
                        this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this),
                        this
                    }
                    getHex(e=wa) {
                        return Sn.workingToColorSpace(Da.copy(this), e),
                        Math.round(Bt(Da.r * 255, 0, 255)) * 65536 + Math.round(Bt(Da.g * 255, 0, 255)) * 256 + Math.round(Bt(Da.b * 255, 0, 255))
                    }
                    getHexString(e=wa) {
                        return ("000000" + this.getHex(e).toString(16)).slice(-6)
                    }
                    getHSL(e, t=Sn.workingColorSpace) {
                        Sn.workingToColorSpace(Da.copy(this), t);
                        const n = Da.r
                          , a = Da.g
                          , r = Da.b
                          , c = Math.max(n, a, r)
                          , f = Math.min(n, a, r);
                        let p, m;
                        const g = (f + c) / 2;
                        if (f === c)
                            p = 0,
                            m = 0;
                        else {
                            const v = c - f;
                            switch (m = g <= .5 ? v / (c + f) : v / (2 - c - f),
                            c) {
                            case n:
                                p = (a - r) / v + (a < r ? 6 : 0);
                                break;
                            case a:
                                p = (r - n) / v + 2;
                                break;
                            case r:
                                p = (n - a) / v + 4;
                                break
                            }
                            p /= 6
                        }
                        return e.h = p,
                        e.s = m,
                        e.l = g,
                        e
                    }
                    getRGB(e, t=Sn.workingColorSpace) {
                        return Sn.workingToColorSpace(Da.copy(this), t),
                        e.r = Da.r,
                        e.g = Da.g,
                        e.b = Da.b,
                        e
                    }
                    getStyle(e=wa) {
                        Sn.workingToColorSpace(Da.copy(this), e);
                        const t = Da.r
                          , n = Da.g
                          , a = Da.b;
                        return e !== wa ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${a.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(a * 255)})`
                    }
                    offsetHSL(e, t, n) {
                        return this.getHSL(Cc),
                        this.setHSL(Cc.h + e, Cc.s + t, Cc.l + n)
                    }
                    add(e) {
                        return this.r += e.r,
                        this.g += e.g,
                        this.b += e.b,
                        this
                    }
                    addColors(e, t) {
                        return this.r = e.r + t.r,
                        this.g = e.g + t.g,
                        this.b = e.b + t.b,
                        this
                    }
                    addScalar(e) {
                        return this.r += e,
                        this.g += e,
                        this.b += e,
                        this
                    }
                    sub(e) {
                        return this.r = Math.max(0, this.r - e.r),
                        this.g = Math.max(0, this.g - e.g),
                        this.b = Math.max(0, this.b - e.b),
                        this
                    }
                    multiply(e) {
                        return this.r *= e.r,
                        this.g *= e.g,
                        this.b *= e.b,
                        this
                    }
                    multiplyScalar(e) {
                        return this.r *= e,
                        this.g *= e,
                        this.b *= e,
                        this
                    }
                    lerp(e, t) {
                        return this.r += (e.r - this.r) * t,
                        this.g += (e.g - this.g) * t,
                        this.b += (e.b - this.b) * t,
                        this
                    }
                    lerpColors(e, t, n) {
                        return this.r = e.r + (t.r - e.r) * n,
                        this.g = e.g + (t.g - e.g) * n,
                        this.b = e.b + (t.b - e.b) * n,
                        this
                    }
                    lerpHSL(e, t) {
                        this.getHSL(Cc),
                        e.getHSL(m0);
                        const n = qp(Cc.h, m0.h, t)
                          , a = qp(Cc.s, m0.s, t)
                          , r = qp(Cc.l, m0.l, t);
                        return this.setHSL(n, a, r),
                        this
                    }
                    setFromVector3(e) {
                        return this.r = e.x,
                        this.g = e.y,
                        this.b = e.z,
                        this
                    }
                    applyMatrix3(e) {
                        const t = this.r
                          , n = this.g
                          , a = this.b
                          , r = e.elements;
                        return this.r = r[0] * t + r[3] * n + r[6] * a,
                        this.g = r[1] * t + r[4] * n + r[7] * a,
                        this.b = r[2] * t + r[5] * n + r[8] * a,
                        this
                    }
                    equals(e) {
                        return e.r === this.r && e.g === this.g && e.b === this.b
                    }
                    fromArray(e, t=0) {
                        return this.r = e[t],
                        this.g = e[t + 1],
                        this.b = e[t + 2],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.r,
                        e[t + 1] = this.g,
                        e[t + 2] = this.b,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this.r = e.getX(t),
                        this.g = e.getY(t),
                        this.b = e.getZ(t),
                        this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                    *[Symbol.iterator]() {
                        yield this.r,
                        yield this.g,
                        yield this.b
                    }
                }
                ;
                const Da = new dt;
                dt.NAMES = tM;
                let TC = 0;
                var Na = class extends Uo {
                    constructor() {
                        super(),
                        this.isMaterial = !0,
                        Object.defineProperty(this, "id", {
                            value: TC++
                        }),
                        this.uuid = Fs(),
                        this.name = "",
                        this.type = "Material",
                        this.blending = Uu,
                        this.side = vl,
                        this.vertexColors = !1,
                        this.opacity = 1,
                        this.transparent = !1,
                        this.alphaHash = !1,
                        this.blendSrc = rv,
                        this.blendDst = ov,
                        this.blendEquation = gc,
                        this.blendSrcAlpha = null,
                        this.blendDstAlpha = null,
                        this.blendEquationAlpha = null,
                        this.blendColor = new dt(0,0,0),
                        this.blendAlpha = 0,
                        this.depthFunc = Iu,
                        this.depthTest = !0,
                        this.depthWrite = !0,
                        this.stencilWriteMask = 255,
                        this.stencilFunc = b_,
                        this.stencilRef = 0,
                        this.stencilFuncMask = 255,
                        this.stencilFail = Bu,
                        this.stencilZFail = Bu,
                        this.stencilZPass = Bu,
                        this.stencilWrite = !1,
                        this.clippingPlanes = null,
                        this.clipIntersection = !1,
                        this.clipShadows = !1,
                        this.shadowSide = null,
                        this.colorWrite = !0,
                        this.precision = null,
                        this.polygonOffset = !1,
                        this.polygonOffsetFactor = 0,
                        this.polygonOffsetUnits = 0,
                        this.dithering = !1,
                        this.alphaToCoverage = !1,
                        this.premultipliedAlpha = !1,
                        this.forceSinglePass = !1,
                        this.allowOverride = !0,
                        this.visible = !0,
                        this.toneMapped = !0,
                        this.userData = {},
                        this.version = 0,
                        this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(e) {
                        this._alphaTest > 0 != e > 0 && this.version++,
                        this._alphaTest = e
                    }
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(e) {
                        if (e !== void 0)
                            for (const t in e) {
                                const n = e[t];
                                if (n === void 0) {
                                    ot(`Material: parameter '${t}' has value of undefined.`);
                                    continue
                                }
                                const a = this[t];
                                if (a === void 0) {
                                    ot(`Material: '${t}' is not a property of THREE.${this.type}.`);
                                    continue
                                }
                                a && a.isColor ? a.set(n) : a && a.isVector3 && n && n.isVector3 ? a.copy(n) : this[t] = n
                            }
                    }
                    toJSON(e) {
                        const t = e === void 0 || typeof e == "string";
                        t && (e = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.7,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        n.uuid = this.uuid,
                        n.type = this.type,
                        this.name !== "" && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        this.roughness !== void 0 && (n.roughness = this.roughness),
                        this.metalness !== void 0 && (n.metalness = this.metalness),
                        this.sheen !== void 0 && (n.sheen = this.sheen),
                        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
                        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                        this.shininess !== void 0 && (n.shininess = this.shininess),
                        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
                        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                        this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
                        this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
                        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
                        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
                        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
                        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
                        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
                        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                        n.lightMapIntensity = this.lightMapIntensity),
                        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                        n.aoMapIntensity = this.aoMapIntensity),
                        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                        n.bumpScale = this.bumpScale),
                        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                        n.normalMapType = this.normalMapType,
                        n.normalScale = this.normalScale.toArray()),
                        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                        n.displacementScale = this.displacementScale,
                        n.displacementBias = this.displacementBias),
                        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                        this.combine !== void 0 && (n.combine = this.combine)),
                        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
                        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
                        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
                        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
                        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                        this.transmission !== void 0 && (n.transmission = this.transmission),
                        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                        this.thickness !== void 0 && (n.thickness = this.thickness),
                        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
                        this.size !== void 0 && (n.size = this.size),
                        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
                        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== Uu && (n.blending = this.blending),
                        this.side !== vl && (n.side = this.side),
                        this.vertexColors === !0 && (n.vertexColors = !0),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        this.transparent === !0 && (n.transparent = !0),
                        this.blendSrc !== rv && (n.blendSrc = this.blendSrc),
                        this.blendDst !== ov && (n.blendDst = this.blendDst),
                        this.blendEquation !== gc && (n.blendEquation = this.blendEquation),
                        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
                        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
                        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
                        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
                        this.depthFunc !== Iu && (n.depthFunc = this.depthFunc),
                        this.depthTest === !1 && (n.depthTest = this.depthTest),
                        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
                        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
                        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
                        this.stencilFunc !== b_ && (n.stencilFunc = this.stencilFunc),
                        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
                        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
                        this.stencilFail !== Bu && (n.stencilFail = this.stencilFail),
                        this.stencilZFail !== Bu && (n.stencilZFail = this.stencilZFail),
                        this.stencilZPass !== Bu && (n.stencilZPass = this.stencilZPass),
                        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
                        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
                        this.polygonOffset === !0 && (n.polygonOffset = !0),
                        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
                        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
                        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
                        this.scale !== void 0 && (n.scale = this.scale),
                        this.dithering === !0 && (n.dithering = !0),
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        this.alphaHash === !0 && (n.alphaHash = !0),
                        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
                        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
                        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
                        this.allowOverride === !1 && (n.allowOverride = !1),
                        this.wireframe === !0 && (n.wireframe = !0),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
                        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
                        this.flatShading === !0 && (n.flatShading = !0),
                        this.visible === !1 && (n.visible = !1),
                        this.toneMapped === !1 && (n.toneMapped = !1),
                        this.fog === !1 && (n.fog = !1),
                        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
                        function a(r) {
                            const c = [];
                            for (const f in r) {
                                const p = r[f];
                                delete p.metadata,
                                c.push(p)
                            }
                            return c
                        }
                        if (t) {
                            const r = a(e.textures)
                              , c = a(e.images);
                            r.length > 0 && (n.textures = r),
                            c.length > 0 && (n.images = c)
                        }
                        return n
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        this.name = e.name,
                        this.blending = e.blending,
                        this.side = e.side,
                        this.vertexColors = e.vertexColors,
                        this.opacity = e.opacity,
                        this.transparent = e.transparent,
                        this.blendSrc = e.blendSrc,
                        this.blendDst = e.blendDst,
                        this.blendEquation = e.blendEquation,
                        this.blendSrcAlpha = e.blendSrcAlpha,
                        this.blendDstAlpha = e.blendDstAlpha,
                        this.blendEquationAlpha = e.blendEquationAlpha,
                        this.blendColor.copy(e.blendColor),
                        this.blendAlpha = e.blendAlpha,
                        this.depthFunc = e.depthFunc,
                        this.depthTest = e.depthTest,
                        this.depthWrite = e.depthWrite,
                        this.stencilWriteMask = e.stencilWriteMask,
                        this.stencilFunc = e.stencilFunc,
                        this.stencilRef = e.stencilRef,
                        this.stencilFuncMask = e.stencilFuncMask,
                        this.stencilFail = e.stencilFail,
                        this.stencilZFail = e.stencilZFail,
                        this.stencilZPass = e.stencilZPass,
                        this.stencilWrite = e.stencilWrite;
                        const t = e.clippingPlanes;
                        let n = null;
                        if (t !== null) {
                            const a = t.length;
                            n = new Array(a);
                            for (let r = 0; r !== a; ++r)
                                n[r] = t[r].clone()
                        }
                        return this.clippingPlanes = n,
                        this.clipIntersection = e.clipIntersection,
                        this.clipShadows = e.clipShadows,
                        this.shadowSide = e.shadowSide,
                        this.colorWrite = e.colorWrite,
                        this.precision = e.precision,
                        this.polygonOffset = e.polygonOffset,
                        this.polygonOffsetFactor = e.polygonOffsetFactor,
                        this.polygonOffsetUnits = e.polygonOffsetUnits,
                        this.dithering = e.dithering,
                        this.alphaTest = e.alphaTest,
                        this.alphaHash = e.alphaHash,
                        this.alphaToCoverage = e.alphaToCoverage,
                        this.premultipliedAlpha = e.premultipliedAlpha,
                        this.forceSinglePass = e.forceSinglePass,
                        this.allowOverride = e.allowOverride,
                        this.visible = e.visible,
                        this.toneMapped = e.toneMapped,
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                }
                  , Rc = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshBasicMaterial = !0,
                        this.type = "MeshBasicMaterial",
                        this.color = new dt(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new es,
                        this.combine = Rp,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const El = EC();
                function EC() {
                    const e = new ArrayBuffer(4)
                      , t = new Float32Array(e)
                      , n = new Uint32Array(e)
                      , a = new Uint32Array(512)
                      , r = new Uint32Array(512);
                    for (let m = 0; m < 256; ++m) {
                        const g = m - 127;
                        g < -27 ? (a[m] = 0,
                        a[m | 256] = 32768,
                        r[m] = 24,
                        r[m | 256] = 24) : g < -14 ? (a[m] = 1024 >> -g - 14,
                        a[m | 256] = 1024 >> -g - 14 | 32768,
                        r[m] = -g - 1,
                        r[m | 256] = -g - 1) : g <= 15 ? (a[m] = g + 15 << 10,
                        a[m | 256] = g + 15 << 10 | 32768,
                        r[m] = 13,
                        r[m | 256] = 13) : g < 128 ? (a[m] = 31744,
                        a[m | 256] = 64512,
                        r[m] = 24,
                        r[m | 256] = 24) : (a[m] = 31744,
                        a[m | 256] = 64512,
                        r[m] = 13,
                        r[m | 256] = 13)
                    }
                    const c = new Uint32Array(2048)
                      , f = new Uint32Array(64)
                      , p = new Uint32Array(64);
                    for (let m = 1; m < 1024; ++m) {
                        let g = m << 13
                          , v = 0;
                        for (; (g & 8388608) === 0; )
                            g <<= 1,
                            v -= 8388608;
                        g &= -8388609,
                        v += 947912704,
                        c[m] = g | v
                    }
                    for (let m = 1024; m < 2048; ++m)
                        c[m] = 939524096 + (m - 1024 << 13);
                    for (let m = 1; m < 31; ++m)
                        f[m] = m << 23;
                    f[31] = 1199570944,
                    f[32] = 2147483648;
                    for (let m = 33; m < 63; ++m)
                        f[m] = 2147483648 + (m - 32 << 23);
                    f[63] = 3347054592;
                    for (let m = 1; m < 64; ++m)
                        m !== 32 && (p[m] = 1024);
                    return {
                        floatView: t,
                        uint32View: n,
                        baseTable: a,
                        shiftTable: r,
                        mantissaTable: c,
                        exponentTable: f,
                        offsetTable: p
                    }
                }
                function bs(e) {
                    Math.abs(e) > 65504 && ot("DataUtils.toHalfFloat(): Value out of range."),
                    e = Bt(e, -65504, 65504),
                    El.floatView[0] = e;
                    const t = El.uint32View[0]
                      , n = t >> 23 & 511;
                    return El.baseTable[n] + ((t & 8388607) >> El.shiftTable[n])
                }
                function Qp(e) {
                    const t = e >> 10;
                    return El.uint32View[0] = El.mantissaTable[El.offsetTable[t] + (e & 1023)] + El.exponentTable[t],
                    El.floatView[0]
                }
                var AC = class {
                    static toHalfFloat(e) {
                        return bs(e)
                    }
                    static fromHalfFloat(e) {
                        return Qp(e)
                    }
                }
                ;
                const ki = new Y
                  , g0 = new Pe;
                let wC = 0;
                var Vn = class {
                    constructor(e, t, n=!1) {
                        if (Array.isArray(e))
                            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0,
                        Object.defineProperty(this, "id", {
                            value: wC++
                        }),
                        this.name = "",
                        this.array = e,
                        this.itemSize = t,
                        this.count = e !== void 0 ? e.length / t : 0,
                        this.normalized = n,
                        this.usage = Gp,
                        this.updateRanges = [],
                        this.gpuType = Ja,
                        this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    addUpdateRange(e, t) {
                        this.updateRanges.push({
                            start: e,
                            count: t
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(e) {
                        return this.name = e.name,
                        this.array = new e.array.constructor(e.array),
                        this.itemSize = e.itemSize,
                        this.count = e.count,
                        this.normalized = e.normalized,
                        this.usage = e.usage,
                        this.gpuType = e.gpuType,
                        this
                    }
                    copyAt(e, t, n) {
                        e *= this.itemSize,
                        n *= t.itemSize;
                        for (let a = 0, r = this.itemSize; a < r; a++)
                            this.array[e + a] = t.array[n + a];
                        return this
                    }
                    copyArray(e) {
                        return this.array.set(e),
                        this
                    }
                    applyMatrix3(e) {
                        if (this.itemSize === 2)
                            for (let t = 0, n = this.count; t < n; t++)
                                g0.fromBufferAttribute(this, t),
                                g0.applyMatrix3(e),
                                this.setXY(t, g0.x, g0.y);
                        else if (this.itemSize === 3)
                            for (let t = 0, n = this.count; t < n; t++)
                                ki.fromBufferAttribute(this, t),
                                ki.applyMatrix3(e),
                                this.setXYZ(t, ki.x, ki.y, ki.z);
                        return this
                    }
                    applyMatrix4(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            ki.fromBufferAttribute(this, t),
                            ki.applyMatrix4(e),
                            this.setXYZ(t, ki.x, ki.y, ki.z);
                        return this
                    }
                    applyNormalMatrix(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            ki.fromBufferAttribute(this, t),
                            ki.applyNormalMatrix(e),
                            this.setXYZ(t, ki.x, ki.y, ki.z);
                        return this
                    }
                    transformDirection(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            ki.fromBufferAttribute(this, t),
                            ki.transformDirection(e),
                            this.setXYZ(t, ki.x, ki.y, ki.z);
                        return this
                    }
                    set(e, t=0) {
                        return this.array.set(e, t),
                        this
                    }
                    getComponent(e, t) {
                        let n = this.array[e * this.itemSize + t];
                        return this.normalized && (n = $a(n, this.array)),
                        n
                    }
                    setComponent(e, t, n) {
                        return this.normalized && (n = Zt(n, this.array)),
                        this.array[e * this.itemSize + t] = n,
                        this
                    }
                    getX(e) {
                        let t = this.array[e * this.itemSize];
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setX(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize] = t,
                        this
                    }
                    getY(e) {
                        let t = this.array[e * this.itemSize + 1];
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setY(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize + 1] = t,
                        this
                    }
                    getZ(e) {
                        let t = this.array[e * this.itemSize + 2];
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setZ(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize + 2] = t,
                        this
                    }
                    getW(e) {
                        let t = this.array[e * this.itemSize + 3];
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setW(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize + 3] = t,
                        this
                    }
                    setXY(e, t, n) {
                        return e *= this.itemSize,
                        this.normalized && (t = Zt(t, this.array),
                        n = Zt(n, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this
                    }
                    setXYZ(e, t, n, a) {
                        return e *= this.itemSize,
                        this.normalized && (t = Zt(t, this.array),
                        n = Zt(n, this.array),
                        a = Zt(a, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = a,
                        this
                    }
                    setXYZW(e, t, n, a, r) {
                        return e *= this.itemSize,
                        this.normalized && (t = Zt(t, this.array),
                        n = Zt(n, this.array),
                        a = Zt(a, this.array),
                        r = Zt(r, this.array)),
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = a,
                        this.array[e + 3] = r,
                        this
                    }
                    onUpload(e) {
                        return this.onUploadCallback = e,
                        this
                    }
                    clone() {
                        return new this.constructor(this.array,this.itemSize).copy(this)
                    }
                    toJSON() {
                        const e = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        return this.name !== "" && (e.name = this.name),
                        this.usage !== Gp && (e.usage = this.usage),
                        e
                    }
                }
                  , CC = class extends Vn {
                    constructor(e, t, n) {
                        super(new Int8Array(e), t, n)
                    }
                }
                  , RC = class extends Vn {
                    constructor(e, t, n) {
                        super(new Uint8Array(e), t, n)
                    }
                }
                  , DC = class extends Vn {
                    constructor(e, t, n) {
                        super(new Uint8ClampedArray(e), t, n)
                    }
                }
                  , NC = class extends Vn {
                    constructor(e, t, n) {
                        super(new Int16Array(e), t, n)
                    }
                }
                  , W_ = class extends Vn {
                    constructor(e, t, n) {
                        super(new Uint16Array(e), t, n)
                    }
                }
                  , LC = class extends Vn {
                    constructor(e, t, n) {
                        super(new Int32Array(e), t, n)
                    }
                }
                  , X_ = class extends Vn {
                    constructor(e, t, n) {
                        super(new Uint32Array(e), t, n)
                    }
                }
                  , UC = class extends Vn {
                    constructor(e, t, n) {
                        super(new Uint16Array(e), t, n),
                        this.isFloat16BufferAttribute = !0
                    }
                    getX(e) {
                        let t = Qp(this.array[e * this.itemSize]);
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setX(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize] = bs(t),
                        this
                    }
                    getY(e) {
                        let t = Qp(this.array[e * this.itemSize + 1]);
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setY(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize + 1] = bs(t),
                        this
                    }
                    getZ(e) {
                        let t = Qp(this.array[e * this.itemSize + 2]);
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setZ(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize + 2] = bs(t),
                        this
                    }
                    getW(e) {
                        let t = Qp(this.array[e * this.itemSize + 3]);
                        return this.normalized && (t = $a(t, this.array)),
                        t
                    }
                    setW(e, t) {
                        return this.normalized && (t = Zt(t, this.array)),
                        this.array[e * this.itemSize + 3] = bs(t),
                        this
                    }
                    setXY(e, t, n) {
                        return e *= this.itemSize,
                        this.normalized && (t = Zt(t, this.array),
                        n = Zt(n, this.array)),
                        this.array[e + 0] = bs(t),
                        this.array[e + 1] = bs(n),
                        this
                    }
                    setXYZ(e, t, n, a) {
                        return e *= this.itemSize,
                        this.normalized && (t = Zt(t, this.array),
                        n = Zt(n, this.array),
                        a = Zt(a, this.array)),
                        this.array[e + 0] = bs(t),
                        this.array[e + 1] = bs(n),
                        this.array[e + 2] = bs(a),
                        this
                    }
                    setXYZW(e, t, n, a, r) {
                        return e *= this.itemSize,
                        this.normalized && (t = Zt(t, this.array),
                        n = Zt(n, this.array),
                        a = Zt(a, this.array),
                        r = Zt(r, this.array)),
                        this.array[e + 0] = bs(t),
                        this.array[e + 1] = bs(n),
                        this.array[e + 2] = bs(a),
                        this.array[e + 3] = bs(r),
                        this
                    }
                }
                  , vt = class extends Vn {
                    constructor(e, t, n) {
                        super(new Float32Array(e), t, n)
                    }
                }
                ;
                let IC = 0;
                const hr = new Wt
                  , q_ = new Fn
                  , Lh = new Y
                  , Hs = new Ra
                  , Kp = new Ra
                  , la = new Y;
                var Xt = class CA extends Uo {
                    constructor() {
                        super(),
                        this.isBufferGeometry = !0,
                        Object.defineProperty(this, "id", {
                            value: IC++
                        }),
                        this.uuid = Fs(),
                        this.name = "",
                        this.type = "BufferGeometry",
                        this.index = null,
                        this.indirect = null,
                        this.indirectOffset = 0,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.morphTargetsRelative = !1,
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        },
                        this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(t) {
                        return Array.isArray(t) ? this.index = new (Bb(t) ? X_ : W_)(t,1) : this.index = t,
                        this
                    }
                    setIndirect(t, n=0) {
                        return this.indirect = t,
                        this.indirectOffset = n,
                        this
                    }
                    getIndirect() {
                        return this.indirect
                    }
                    getAttribute(t) {
                        return this.attributes[t]
                    }
                    setAttribute(t, n) {
                        return this.attributes[t] = n,
                        this
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t],
                        this
                    }
                    hasAttribute(t) {
                        return this.attributes[t] !== void 0
                    }
                    addGroup(t, n, a=0) {
                        this.groups.push({
                            start: t,
                            count: n,
                            materialIndex: a
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(t, n) {
                        this.drawRange.start = t,
                        this.drawRange.count = n
                    }
                    applyMatrix4(t) {
                        const n = this.attributes.position;
                        n !== void 0 && (n.applyMatrix4(t),
                        n.needsUpdate = !0);
                        const a = this.attributes.normal;
                        if (a !== void 0) {
                            const c = new en().getNormalMatrix(t);
                            a.applyNormalMatrix(c),
                            a.needsUpdate = !0
                        }
                        const r = this.attributes.tangent;
                        return r !== void 0 && (r.transformDirection(t),
                        r.needsUpdate = !0),
                        this.boundingBox !== null && this.computeBoundingBox(),
                        this.boundingSphere !== null && this.computeBoundingSphere(),
                        this
                    }
                    applyQuaternion(t) {
                        return hr.makeRotationFromQuaternion(t),
                        this.applyMatrix4(hr),
                        this
                    }
                    rotateX(t) {
                        return hr.makeRotationX(t),
                        this.applyMatrix4(hr),
                        this
                    }
                    rotateY(t) {
                        return hr.makeRotationY(t),
                        this.applyMatrix4(hr),
                        this
                    }
                    rotateZ(t) {
                        return hr.makeRotationZ(t),
                        this.applyMatrix4(hr),
                        this
                    }
                    translate(t, n, a) {
                        return hr.makeTranslation(t, n, a),
                        this.applyMatrix4(hr),
                        this
                    }
                    scale(t, n, a) {
                        return hr.makeScale(t, n, a),
                        this.applyMatrix4(hr),
                        this
                    }
                    lookAt(t) {
                        return q_.lookAt(t),
                        q_.updateMatrix(),
                        this.applyMatrix4(q_.matrix),
                        this
                    }
                    center() {
                        return this.computeBoundingBox(),
                        this.boundingBox.getCenter(Lh).negate(),
                        this.translate(Lh.x, Lh.y, Lh.z),
                        this
                    }
                    setFromPoints(t) {
                        const n = this.getAttribute("position");
                        if (n === void 0) {
                            const a = [];
                            for (let r = 0, c = t.length; r < c; r++) {
                                const f = t[r];
                                a.push(f.x, f.y, f.z || 0)
                            }
                            this.setAttribute("position", new vt(a,3))
                        } else {
                            const a = Math.min(t.length, n.count);
                            for (let r = 0; r < a; r++) {
                                const c = t[r];
                                n.setXYZ(r, c.x, c.y, c.z || 0)
                            }
                            t.length > n.count && ot("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                            n.needsUpdate = !0
                        }
                        return this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new Ra);
                        const t = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) {
                            Et("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                            this.boundingBox.set(new Y(-1 / 0,-1 / 0,-1 / 0), new Y(1 / 0,1 / 0,1 / 0));
                            return
                        }
                        if (t !== void 0) {
                            if (this.boundingBox.setFromBufferAttribute(t),
                            n)
                                for (let a = 0, r = n.length; a < r; a++) {
                                    const c = n[a];
                                    Hs.setFromBufferAttribute(c),
                                    this.morphTargetsRelative ? (la.addVectors(this.boundingBox.min, Hs.min),
                                    this.boundingBox.expandByPoint(la),
                                    la.addVectors(this.boundingBox.max, Hs.max),
                                    this.boundingBox.expandByPoint(la)) : (this.boundingBox.expandByPoint(Hs.min),
                                    this.boundingBox.expandByPoint(Hs.max))
                                }
                        } else
                            this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && Et('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new Sa);
                        const t = this.attributes.position
                          , n = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) {
                            Et("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                            this.boundingSphere.set(new Y, 1 / 0);
                            return
                        }
                        if (t) {
                            const a = this.boundingSphere.center;
                            if (Hs.setFromBufferAttribute(t),
                            n)
                                for (let c = 0, f = n.length; c < f; c++) {
                                    const p = n[c];
                                    Kp.setFromBufferAttribute(p),
                                    this.morphTargetsRelative ? (la.addVectors(Hs.min, Kp.min),
                                    Hs.expandByPoint(la),
                                    la.addVectors(Hs.max, Kp.max),
                                    Hs.expandByPoint(la)) : (Hs.expandByPoint(Kp.min),
                                    Hs.expandByPoint(Kp.max))
                                }
                            Hs.getCenter(a);
                            let r = 0;
                            for (let c = 0, f = t.count; c < f; c++)
                                la.fromBufferAttribute(t, c),
                                r = Math.max(r, a.distanceToSquared(la));
                            if (n)
                                for (let c = 0, f = n.length; c < f; c++) {
                                    const p = n[c]
                                      , m = this.morphTargetsRelative;
                                    for (let g = 0, v = p.count; g < v; g++)
                                        la.fromBufferAttribute(p, g),
                                        m && (Lh.fromBufferAttribute(t, g),
                                        la.add(Lh)),
                                        r = Math.max(r, a.distanceToSquared(la))
                                }
                            this.boundingSphere.radius = Math.sqrt(r),
                            isNaN(this.boundingSphere.radius) && Et('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const t = this.index
                          , n = this.attributes;
                        if (t === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
                            Et("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            return
                        }
                        const a = n.position
                          , r = n.normal
                          , c = n.uv;
                        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Vn(new Float32Array(4 * a.count),4));
                        const f = this.getAttribute("tangent")
                          , p = []
                          , m = [];
                        for (let G = 0; G < a.count; G++)
                            p[G] = new Y,
                            m[G] = new Y;
                        const g = new Y
                          , v = new Y
                          , _ = new Y
                          , x = new Pe
                          , M = new Pe
                          , C = new Pe
                          , R = new Y
                          , A = new Y;
                        function E(G, P, U) {
                            g.fromBufferAttribute(a, G),
                            v.fromBufferAttribute(a, P),
                            _.fromBufferAttribute(a, U),
                            x.fromBufferAttribute(c, G),
                            M.fromBufferAttribute(c, P),
                            C.fromBufferAttribute(c, U),
                            v.sub(g),
                            _.sub(g),
                            M.sub(x),
                            C.sub(x);
                            const W = 1 / (M.x * C.y - C.x * M.y);
                            isFinite(W) && (R.copy(v).multiplyScalar(C.y).addScaledVector(_, -M.y).multiplyScalar(W),
                            A.copy(_).multiplyScalar(M.x).addScaledVector(v, -C.x).multiplyScalar(W),
                            p[G].add(R),
                            p[P].add(R),
                            p[U].add(R),
                            m[G].add(A),
                            m[P].add(A),
                            m[U].add(A))
                        }
                        let N = this.groups;
                        N.length === 0 && (N = [{
                            start: 0,
                            count: t.count
                        }]);
                        for (let G = 0, P = N.length; G < P; ++G) {
                            const U = N[G]
                              , W = U.start
                              , K = U.count;
                            for (let q = W, te = W + K; q < te; q += 3)
                                E(t.getX(q + 0), t.getX(q + 1), t.getX(q + 2))
                        }
                        const I = new Y
                          , L = new Y
                          , k = new Y
                          , B = new Y;
                        function X(G) {
                            k.fromBufferAttribute(r, G),
                            B.copy(k);
                            const P = p[G];
                            I.copy(P),
                            I.sub(k.multiplyScalar(k.dot(P))).normalize(),
                            L.crossVectors(B, P);
                            const U = L.dot(m[G]) < 0 ? -1 : 1;
                            f.setXYZW(G, I.x, I.y, I.z, U)
                        }
                        for (let G = 0, P = N.length; G < P; ++G) {
                            const U = N[G]
                              , W = U.start
                              , K = U.count;
                            for (let q = W, te = W + K; q < te; q += 3)
                                X(t.getX(q + 0)),
                                X(t.getX(q + 1)),
                                X(t.getX(q + 2))
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index
                          , n = this.getAttribute("position");
                        if (n !== void 0) {
                            let a = this.getAttribute("normal");
                            if (a === void 0)
                                a = new Vn(new Float32Array(n.count * 3),3),
                                this.setAttribute("normal", a);
                            else
                                for (let x = 0, M = a.count; x < M; x++)
                                    a.setXYZ(x, 0, 0, 0);
                            const r = new Y
                              , c = new Y
                              , f = new Y
                              , p = new Y
                              , m = new Y
                              , g = new Y
                              , v = new Y
                              , _ = new Y;
                            if (t)
                                for (let x = 0, M = t.count; x < M; x += 3) {
                                    const C = t.getX(x + 0)
                                      , R = t.getX(x + 1)
                                      , A = t.getX(x + 2);
                                    r.fromBufferAttribute(n, C),
                                    c.fromBufferAttribute(n, R),
                                    f.fromBufferAttribute(n, A),
                                    v.subVectors(f, c),
                                    _.subVectors(r, c),
                                    v.cross(_),
                                    p.fromBufferAttribute(a, C),
                                    m.fromBufferAttribute(a, R),
                                    g.fromBufferAttribute(a, A),
                                    p.add(v),
                                    m.add(v),
                                    g.add(v),
                                    a.setXYZ(C, p.x, p.y, p.z),
                                    a.setXYZ(R, m.x, m.y, m.z),
                                    a.setXYZ(A, g.x, g.y, g.z)
                                }
                            else
                                for (let x = 0, M = n.count; x < M; x += 3)
                                    r.fromBufferAttribute(n, x + 0),
                                    c.fromBufferAttribute(n, x + 1),
                                    f.fromBufferAttribute(n, x + 2),
                                    v.subVectors(f, c),
                                    _.subVectors(r, c),
                                    v.cross(_),
                                    a.setXYZ(x + 0, v.x, v.y, v.z),
                                    a.setXYZ(x + 1, v.x, v.y, v.z),
                                    a.setXYZ(x + 2, v.x, v.y, v.z);
                            this.normalizeNormals(),
                            a.needsUpdate = !0
                        }
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let n = 0, a = t.count; n < a; n++)
                            la.fromBufferAttribute(t, n),
                            la.normalize(),
                            t.setXYZ(n, la.x, la.y, la.z)
                    }
                    toNonIndexed() {
                        function t(p, m) {
                            const g = p.array
                              , v = p.itemSize
                              , _ = p.normalized
                              , x = new g.constructor(m.length * v);
                            let M = 0
                              , C = 0;
                            for (let R = 0, A = m.length; R < A; R++) {
                                p.isInterleavedBufferAttribute ? M = m[R] * p.data.stride + p.offset : M = m[R] * v;
                                for (let E = 0; E < v; E++)
                                    x[C++] = g[M++]
                            }
                            return new Vn(x,v,_)
                        }
                        if (this.index === null)
                            return ot("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                            this;
                        const n = new CA
                          , a = this.index.array
                          , r = this.attributes;
                        for (const p in r) {
                            const m = r[p]
                              , g = t(m, a);
                            n.setAttribute(p, g)
                        }
                        const c = this.morphAttributes;
                        for (const p in c) {
                            const m = []
                              , g = c[p];
                            for (let v = 0, _ = g.length; v < _; v++) {
                                const x = g[v]
                                  , M = t(x, a);
                                m.push(M)
                            }
                            n.morphAttributes[p] = m
                        }
                        n.morphTargetsRelative = this.morphTargetsRelative;
                        const f = this.groups;
                        for (let p = 0, m = f.length; p < m; p++) {
                            const g = f[p];
                            n.addGroup(g.start, g.count, g.materialIndex)
                        }
                        return n
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid,
                        t.type = this.type,
                        this.name !== "" && (t.name = this.name),
                        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                        this.parameters !== void 0) {
                            const m = this.parameters;
                            for (const g in m)
                                m[g] !== void 0 && (t[g] = m[g]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        const n = this.index;
                        n !== null && (t.data.index = {
                            type: n.array.constructor.name,
                            array: Array.prototype.slice.call(n.array)
                        });
                        const a = this.attributes;
                        for (const m in a) {
                            const g = a[m];
                            t.data.attributes[m] = g.toJSON(t.data)
                        }
                        const r = {};
                        let c = !1;
                        for (const m in this.morphAttributes) {
                            const g = this.morphAttributes[m]
                              , v = [];
                            for (let _ = 0, x = g.length; _ < x; _++) {
                                const M = g[_];
                                v.push(M.toJSON(t.data))
                            }
                            v.length > 0 && (r[m] = v,
                            c = !0)
                        }
                        c && (t.data.morphAttributes = r,
                        t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const f = this.groups;
                        f.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(f)));
                        const p = this.boundingSphere;
                        return p !== null && (t.data.boundingSphere = p.toJSON()),
                        t
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(t) {
                        this.index = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        const n = {};
                        this.name = t.name;
                        const a = t.index;
                        a !== null && this.setIndex(a.clone());
                        const r = t.attributes;
                        for (const g in r) {
                            const v = r[g];
                            this.setAttribute(g, v.clone(n))
                        }
                        const c = t.morphAttributes;
                        for (const g in c) {
                            const v = []
                              , _ = c[g];
                            for (let x = 0, M = _.length; x < M; x++)
                                v.push(_[x].clone(n));
                            this.morphAttributes[g] = v
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const f = t.groups;
                        for (let g = 0, v = f.length; g < v; g++) {
                            const _ = f[g];
                            this.addGroup(_.start, _.count, _.materialIndex)
                        }
                        const p = t.boundingBox;
                        p !== null && (this.boundingBox = p.clone());
                        const m = t.boundingSphere;
                        return m !== null && (this.boundingSphere = m.clone()),
                        this.drawRange.start = t.drawRange.start,
                        this.drawRange.count = t.drawRange.count,
                        this.userData = t.userData,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                ;
                const nM = new Wt
                  , Hu = new Eh
                  , v0 = new Sa
                  , iM = new Y
                  , y0 = new Y
                  , _0 = new Y
                  , S0 = new Y
                  , Y_ = new Y
                  , x0 = new Y
                  , aM = new Y
                  , b0 = new Y;
                var Hi = class extends Fn {
                    constructor(e=new Xt, t=new Rc) {
                        super(),
                        this.isMesh = !0,
                        this.type = "Mesh",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.count = 1,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let a = 0, r = n.length; a < r; a++) {
                                    const c = n[a].name || String(a);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[c] = a
                                }
                            }
                        }
                    }
                    getVertexPosition(e, t) {
                        const n = this.geometry
                          , a = n.attributes.position
                          , r = n.morphAttributes.position
                          , c = n.morphTargetsRelative;
                        t.fromBufferAttribute(a, e);
                        const f = this.morphTargetInfluences;
                        if (r && f) {
                            x0.set(0, 0, 0);
                            for (let p = 0, m = r.length; p < m; p++) {
                                const g = f[p]
                                  , v = r[p];
                                g !== 0 && (Y_.fromBufferAttribute(v, e),
                                c ? x0.addScaledVector(Y_, g) : x0.addScaledVector(Y_.sub(t), g))
                            }
                            t.add(x0)
                        }
                        return t
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , a = this.material
                          , r = this.matrixWorld;
                        a !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
                        v0.copy(n.boundingSphere),
                        v0.applyMatrix4(r),
                        Hu.copy(e.ray).recast(e.near),
                        !(v0.containsPoint(Hu.origin) === !1 && (Hu.intersectSphere(v0, iM) === null || Hu.origin.distanceToSquared(iM) > (e.far - e.near) ** 2)) && (nM.copy(r).invert(),
                        Hu.copy(e.ray).applyMatrix4(nM),
                        !(n.boundingBox !== null && Hu.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Hu)))
                    }
                    _computeIntersections(e, t, n) {
                        let a;
                        const r = this.geometry
                          , c = this.material
                          , f = r.index
                          , p = r.attributes.position
                          , m = r.attributes.uv
                          , g = r.attributes.uv1
                          , v = r.attributes.normal
                          , _ = r.groups
                          , x = r.drawRange;
                        if (f !== null)
                            if (Array.isArray(c))
                                for (let M = 0, C = _.length; M < C; M++) {
                                    const R = _[M]
                                      , A = c[R.materialIndex]
                                      , E = Math.max(R.start, x.start)
                                      , N = Math.min(f.count, Math.min(R.start + R.count, x.start + x.count));
                                    for (let I = E, L = N; I < L; I += 3) {
                                        const k = f.getX(I)
                                          , B = f.getX(I + 1)
                                          , X = f.getX(I + 2);
                                        a = M0(this, A, e, n, m, g, v, k, B, X),
                                        a && (a.faceIndex = Math.floor(I / 3),
                                        a.face.materialIndex = R.materialIndex,
                                        t.push(a))
                                    }
                                }
                            else {
                                const M = Math.max(0, x.start)
                                  , C = Math.min(f.count, x.start + x.count);
                                for (let R = M, A = C; R < A; R += 3) {
                                    const E = f.getX(R)
                                      , N = f.getX(R + 1)
                                      , I = f.getX(R + 2);
                                    a = M0(this, c, e, n, m, g, v, E, N, I),
                                    a && (a.faceIndex = Math.floor(R / 3),
                                    t.push(a))
                                }
                            }
                        else if (p !== void 0)
                            if (Array.isArray(c))
                                for (let M = 0, C = _.length; M < C; M++) {
                                    const R = _[M]
                                      , A = c[R.materialIndex]
                                      , E = Math.max(R.start, x.start)
                                      , N = Math.min(p.count, Math.min(R.start + R.count, x.start + x.count));
                                    for (let I = E, L = N; I < L; I += 3) {
                                        const k = I
                                          , B = I + 1
                                          , X = I + 2;
                                        a = M0(this, A, e, n, m, g, v, k, B, X),
                                        a && (a.faceIndex = Math.floor(I / 3),
                                        a.face.materialIndex = R.materialIndex,
                                        t.push(a))
                                    }
                                }
                            else {
                                const M = Math.max(0, x.start)
                                  , C = Math.min(p.count, x.start + x.count);
                                for (let R = M, A = C; R < A; R += 3) {
                                    const E = R
                                      , N = R + 1
                                      , I = R + 2;
                                    a = M0(this, c, e, n, m, g, v, E, N, I),
                                    a && (a.faceIndex = Math.floor(R / 3),
                                    t.push(a))
                                }
                            }
                    }
                }
                ;
                function OC(e, t, n, a, r, c, f, p) {
                    let m;
                    if (t.side === Qa ? m = a.intersectTriangle(f, c, r, !0, p) : m = a.intersectTriangle(r, c, f, t.side === vl, p),
                    m === null)
                        return null;
                    b0.copy(p),
                    b0.applyMatrix4(e.matrixWorld);
                    const g = n.ray.origin.distanceTo(b0);
                    return g < n.near || g > n.far ? null : {
                        distance: g,
                        point: b0.clone(),
                        object: e
                    }
                }
                function M0(e, t, n, a, r, c, f, p, m, g) {
                    e.getVertexPosition(p, y0),
                    e.getVertexPosition(m, _0),
                    e.getVertexPosition(g, S0);
                    const v = OC(e, t, n, a, y0, _0, S0, aM);
                    if (v) {
                        const _ = new Y;
                        wc.getBarycoord(aM, y0, _0, S0, _),
                        r && (v.uv = wc.getInterpolatedAttribute(r, p, m, g, _, new Pe)),
                        c && (v.uv1 = wc.getInterpolatedAttribute(c, p, m, g, _, new Pe)),
                        f && (v.normal = wc.getInterpolatedAttribute(f, p, m, g, _, new Y),
                        v.normal.dot(a.direction) > 0 && v.normal.multiplyScalar(-1));
                        const x = {
                            a: p,
                            b: m,
                            c: g,
                            normal: new Y,
                            materialIndex: 0
                        };
                        wc.getNormal(y0, _0, S0, x.normal),
                        v.face = x,
                        v.barycoord = _
                    }
                    return v
                }
                var Jp = class RA extends Xt {
                    constructor(t=1, n=1, a=1, r=1, c=1, f=1) {
                        super(),
                        this.type = "BoxGeometry",
                        this.parameters = {
                            width: t,
                            height: n,
                            depth: a,
                            widthSegments: r,
                            heightSegments: c,
                            depthSegments: f
                        };
                        const p = this;
                        r = Math.floor(r),
                        c = Math.floor(c),
                        f = Math.floor(f);
                        const m = []
                          , g = []
                          , v = []
                          , _ = [];
                        let x = 0
                          , M = 0;
                        C("z", "y", "x", -1, -1, a, n, t, f, c, 0),
                        C("z", "y", "x", 1, -1, a, n, -t, f, c, 1),
                        C("x", "z", "y", 1, 1, t, a, n, r, f, 2),
                        C("x", "z", "y", 1, -1, t, a, -n, r, f, 3),
                        C("x", "y", "z", 1, -1, t, n, a, r, c, 4),
                        C("x", "y", "z", -1, -1, t, n, -a, r, c, 5),
                        this.setIndex(m),
                        this.setAttribute("position", new vt(g,3)),
                        this.setAttribute("normal", new vt(v,3)),
                        this.setAttribute("uv", new vt(_,2));
                        function C(R, A, E, N, I, L, k, B, X, G, P) {
                            const U = L / X
                              , W = k / G
                              , K = L / 2
                              , q = k / 2
                              , te = B / 2
                              , ce = X + 1
                              , J = G + 1;
                            let Q = 0
                              , se = 0;
                            const Te = new Y;
                            for (let Ee = 0; Ee < J; Ee++) {
                                const Be = Ee * W - q;
                                for (let j = 0; j < ce; j++)
                                    Te[R] = (j * U - K) * N,
                                    Te[A] = Be * I,
                                    Te[E] = te,
                                    g.push(Te.x, Te.y, Te.z),
                                    Te[R] = 0,
                                    Te[A] = 0,
                                    Te[E] = B > 0 ? 1 : -1,
                                    v.push(Te.x, Te.y, Te.z),
                                    _.push(j / X),
                                    _.push(1 - Ee / G),
                                    Q += 1
                            }
                            for (let Ee = 0; Ee < G; Ee++)
                                for (let Be = 0; Be < X; Be++) {
                                    const j = x + Be + ce * Ee
                                      , ve = x + Be + ce * (Ee + 1)
                                      , Re = x + (Be + 1) + ce * (Ee + 1)
                                      , le = x + (Be + 1) + ce * Ee;
                                    m.push(j, ve, le),
                                    m.push(ve, Re, le),
                                    se += 6
                                }
                            p.addGroup(M, se, P),
                            M += se,
                            x += Q
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new RA(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
                    }
                }
                ;
                function Uh(e) {
                    const t = {};
                    for (const n in e) {
                        t[n] = {};
                        for (const a in e[n]) {
                            const r = e[n][a];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (ot("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                            t[n][a] = null) : t[n][a] = r.clone() : Array.isArray(r) ? t[n][a] = r.slice() : t[n][a] = r
                        }
                    }
                    return t
                }
                function ts(e) {
                    const t = {};
                    for (let n = 0; n < e.length; n++) {
                        const a = Uh(e[n]);
                        for (const r in a)
                            t[r] = a[r]
                    }
                    return t
                }
                function PC(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }
                function sM(e) {
                    const t = e.getRenderTarget();
                    return t === null ? e.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : Sn.workingColorSpace
                }
                const rM = {
                    clone: Uh,
                    merge: ts
                };
                var zC = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
                  , BC = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
                  , dr = class extends Na {
                    constructor(e) {
                        super(),
                        this.isShaderMaterial = !0,
                        this.type = "ShaderMaterial",
                        this.defines = {},
                        this.uniforms = {},
                        this.uniformsGroups = [],
                        this.vertexShader = zC,
                        this.fragmentShader = BC,
                        this.linewidth = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.fog = !1,
                        this.lights = !1,
                        this.clipping = !1,
                        this.forceSinglePass = !0,
                        this.extensions = {
                            clipCullDistance: !1,
                            multiDraw: !1
                        },
                        this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv1: [0, 0]
                        },
                        this.index0AttributeName = void 0,
                        this.uniformsNeedUpdate = !1,
                        this.glslVersion = null,
                        e !== void 0 && this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.fragmentShader = e.fragmentShader,
                        this.vertexShader = e.vertexShader,
                        this.uniforms = Uh(e.uniforms),
                        this.uniformsGroups = PC(e.uniformsGroups),
                        this.defines = Object.assign({}, e.defines),
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.fog = e.fog,
                        this.lights = e.lights,
                        this.clipping = e.clipping,
                        this.extensions = Object.assign({}, e.extensions),
                        this.glslVersion = e.glslVersion,
                        this.defaultAttributeValues = Object.assign({}, e.defaultAttributeValues),
                        this.index0AttributeName = e.index0AttributeName,
                        this.uniformsNeedUpdate = e.uniformsNeedUpdate,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        t.glslVersion = this.glslVersion,
                        t.uniforms = {};
                        for (const a in this.uniforms) {
                            const r = this.uniforms[a].value;
                            r && r.isTexture ? t.uniforms[a] = {
                                type: "t",
                                value: r.toJSON(e).uuid
                            } : r && r.isColor ? t.uniforms[a] = {
                                type: "c",
                                value: r.getHex()
                            } : r && r.isVector2 ? t.uniforms[a] = {
                                type: "v2",
                                value: r.toArray()
                            } : r && r.isVector3 ? t.uniforms[a] = {
                                type: "v3",
                                value: r.toArray()
                            } : r && r.isVector4 ? t.uniforms[a] = {
                                type: "v4",
                                value: r.toArray()
                            } : r && r.isMatrix3 ? t.uniforms[a] = {
                                type: "m3",
                                value: r.toArray()
                            } : r && r.isMatrix4 ? t.uniforms[a] = {
                                type: "m4",
                                value: r.toArray()
                            } : t.uniforms[a] = {
                                value: r
                            }
                        }
                        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                        t.vertexShader = this.vertexShader,
                        t.fragmentShader = this.fragmentShader,
                        t.lights = this.lights,
                        t.clipping = this.clipping;
                        const n = {};
                        for (const a in this.extensions)
                            this.extensions[a] === !0 && (n[a] = !0);
                        return Object.keys(n).length > 0 && (t.extensions = n),
                        t
                    }
                }
                  , T0 = class extends Fn {
                    constructor() {
                        super(),
                        this.isCamera = !0,
                        this.type = "Camera",
                        this.matrixWorldInverse = new Wt,
                        this.projectionMatrix = new Wt,
                        this.projectionMatrixInverse = new Wt,
                        this.coordinateSystem = Bs,
                        this._reversedDepth = !1
                    }
                    get reversedDepth() {
                        return this._reversedDepth
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.matrixWorldInverse.copy(e.matrixWorldInverse),
                        this.projectionMatrix.copy(e.projectionMatrix),
                        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                        this.coordinateSystem = e.coordinateSystem,
                        this
                    }
                    getWorldDirection(e) {
                        return super.getWorldDirection(e).negate()
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(e, t) {
                        super.updateWorldMatrix(e, t),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const Dc = new Y
                  , oM = new Pe
                  , lM = new Pe;
                var ca = class extends T0 {
                    constructor(e=50, t=1, n=.1, a=2e3) {
                        super(),
                        this.isPerspectiveCamera = !0,
                        this.type = "PerspectiveCamera",
                        this.fov = e,
                        this.zoom = 1,
                        this.near = n,
                        this.far = a,
                        this.focus = 10,
                        this.aspect = t,
                        this.view = null,
                        this.filmGauge = 35,
                        this.filmOffset = 0,
                        this.updateProjectionMatrix()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.fov = e.fov,
                        this.zoom = e.zoom,
                        this.near = e.near,
                        this.far = e.far,
                        this.focus = e.focus,
                        this.aspect = e.aspect,
                        this.view = e.view === null ? null : Object.assign({}, e.view),
                        this.filmGauge = e.filmGauge,
                        this.filmOffset = e.filmOffset,
                        this
                    }
                    setFocalLength(e) {
                        const t = .5 * this.getFilmHeight() / e;
                        this.fov = _h * 2 * Math.atan(t),
                        this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const e = Math.tan(Fu * .5 * this.fov);
                        return .5 * this.getFilmHeight() / e
                    }
                    getEffectiveFOV() {
                        return _h * 2 * Math.atan(Math.tan(Fu * .5 * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    getViewBounds(e, t, n) {
                        Dc.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                        t.set(Dc.x, Dc.y).multiplyScalar(-e / Dc.z),
                        Dc.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                        n.set(Dc.x, Dc.y).multiplyScalar(-e / Dc.z)
                    }
                    getViewSize(e, t) {
                        return this.getViewBounds(e, oM, lM),
                        t.subVectors(lM, oM)
                    }
                    setViewOffset(e, t, n, a, r, c) {
                        this.aspect = e / t,
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = a,
                        this.view.width = r,
                        this.view.height = c,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const e = this.near;
                        let t = e * Math.tan(Fu * .5 * this.fov) / this.zoom
                          , n = 2 * t
                          , a = this.aspect * n
                          , r = -.5 * a;
                        const c = this.view;
                        if (this.view !== null && this.view.enabled) {
                            const p = c.fullWidth
                              , m = c.fullHeight;
                            r += c.offsetX * a / p,
                            t -= c.offsetY * n / m,
                            a *= c.width / p,
                            n *= c.height / m
                        }
                        const f = this.filmOffset;
                        f !== 0 && (r += e * f / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(r, r + a, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.fov = this.fov,
                        t.object.zoom = this.zoom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        t.object.focus = this.focus,
                        t.object.aspect = this.aspect,
                        this.view !== null && (t.object.view = Object.assign({}, this.view)),
                        t.object.filmGauge = this.filmGauge,
                        t.object.filmOffset = this.filmOffset,
                        t
                    }
                }
                ;
                const Ih = -90
                  , Oh = 1;
                var cM = class extends Fn {
                    constructor(e, t, n) {
                        super(),
                        this.type = "CubeCamera",
                        this.renderTarget = n,
                        this.coordinateSystem = null,
                        this.activeMipmapLevel = 0;
                        const a = new ca(Ih,Oh,e,t);
                        a.layers = this.layers,
                        this.add(a);
                        const r = new ca(Ih,Oh,e,t);
                        r.layers = this.layers,
                        this.add(r);
                        const c = new ca(Ih,Oh,e,t);
                        c.layers = this.layers,
                        this.add(c);
                        const f = new ca(Ih,Oh,e,t);
                        f.layers = this.layers,
                        this.add(f);
                        const p = new ca(Ih,Oh,e,t);
                        p.layers = this.layers,
                        this.add(p);
                        const m = new ca(Ih,Oh,e,t);
                        m.layers = this.layers,
                        this.add(m)
                    }
                    updateCoordinateSystem() {
                        const e = this.coordinateSystem
                          , t = this.children.concat()
                          , [n,a,r,c,f,p] = t;
                        for (const m of t)
                            this.remove(m);
                        if (e === Bs)
                            n.up.set(0, 1, 0),
                            n.lookAt(1, 0, 0),
                            a.up.set(0, 1, 0),
                            a.lookAt(-1, 0, 0),
                            r.up.set(0, 0, -1),
                            r.lookAt(0, 1, 0),
                            c.up.set(0, 0, 1),
                            c.lookAt(0, -1, 0),
                            f.up.set(0, 1, 0),
                            f.lookAt(0, 0, 1),
                            p.up.set(0, 1, 0),
                            p.lookAt(0, 0, -1);
                        else if (e === gh)
                            n.up.set(0, -1, 0),
                            n.lookAt(-1, 0, 0),
                            a.up.set(0, -1, 0),
                            a.lookAt(1, 0, 0),
                            r.up.set(0, 0, 1),
                            r.lookAt(0, 1, 0),
                            c.up.set(0, 0, -1),
                            c.lookAt(0, -1, 0),
                            f.up.set(0, -1, 0),
                            f.lookAt(0, 0, 1),
                            p.up.set(0, -1, 0),
                            p.lookAt(0, 0, -1);
                        else
                            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                        for (const m of t)
                            this.add(m),
                            m.updateMatrixWorld()
                    }
                    update(e, t) {
                        this.parent === null && this.updateMatrixWorld();
                        const {renderTarget: n, activeMipmapLevel: a} = this;
                        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                        this.updateCoordinateSystem());
                        const [r,c,f,p,m,g] = this.children
                          , v = e.getRenderTarget()
                          , _ = e.getActiveCubeFace()
                          , x = e.getActiveMipmapLevel()
                          , M = e.xr.enabled;
                        e.xr.enabled = !1;
                        const C = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1,
                        e.setRenderTarget(n, 0, a),
                        e.render(t, r),
                        e.setRenderTarget(n, 1, a),
                        e.render(t, c),
                        e.setRenderTarget(n, 2, a),
                        e.render(t, f),
                        e.setRenderTarget(n, 3, a),
                        e.render(t, p),
                        e.setRenderTarget(n, 4, a),
                        e.render(t, m),
                        n.texture.generateMipmaps = C,
                        e.setRenderTarget(n, 5, a),
                        e.render(t, g),
                        e.setRenderTarget(v, _, x),
                        e.xr.enabled = M,
                        n.texture.needsPMREMUpdate = !0
                    }
                }
                  , $p = class extends oa {
                    constructor(e=[], t=Ro, n, a, r, c, f, p, m, g) {
                        super(e, t, n, a, r, c, f, p, m, g),
                        this.isCubeTexture = !0,
                        this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(e) {
                        this.image = e
                    }
                }
                  , j_ = class extends Vs {
                    constructor(e=1, t={}) {
                        super(e, e, t),
                        this.isWebGLCubeRenderTarget = !0;
                        const n = {
                            width: e,
                            height: e,
                            depth: 1
                        };
                        this.texture = new $p([n, n, n, n, n, n]),
                        this._setTextureOptions(t),
                        this.texture.isRenderTargetTexture = !0
                    }
                    fromEquirectangularTexture(e, t) {
                        this.texture.type = t.type,
                        this.texture.colorSpace = t.colorSpace,
                        this.texture.generateMipmaps = t.generateMipmaps,
                        this.texture.minFilter = t.minFilter,
                        this.texture.magFilter = t.magFilter;
                        const n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        }
                          , a = new Jp(5,5,5)
                          , r = new dr({
                            name: "CubemapFromEquirect",
                            uniforms: Uh(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: Qa,
                            blending: Co
                        });
                        r.uniforms.tEquirect.value = t;
                        const c = new Hi(a,r)
                          , f = t.minFilter;
                        return t.minFilter === Do && (t.minFilter = ei),
                        new cM(1,10,this).update(e, c),
                        t.minFilter = f,
                        c.geometry.dispose(),
                        c.material.dispose(),
                        this
                    }
                    clear(e, t=!0, n=!0, a=!0) {
                        const r = e.getRenderTarget();
                        for (let c = 0; c < 6; c++)
                            e.setRenderTarget(this, c),
                            e.clear(t, n, a);
                        e.setRenderTarget(r)
                    }
                }
                  , Ph = class extends Fn {
                    constructor() {
                        super(),
                        this.isGroup = !0,
                        this.type = "Group"
                    }
                }
                ;
                const FC = {
                    type: "move"
                };
                var E0 = class {
                    constructor() {
                        this._targetRay = null,
                        this._grip = null,
                        this._hand = null
                    }
                    getHandSpace() {
                        return this._hand === null && (this._hand = new Ph,
                        this._hand.matrixAutoUpdate = !1,
                        this._hand.visible = !1,
                        this._hand.joints = {},
                        this._hand.inputState = {
                            pinching: !1
                        }),
                        this._hand
                    }
                    getTargetRaySpace() {
                        return this._targetRay === null && (this._targetRay = new Ph,
                        this._targetRay.matrixAutoUpdate = !1,
                        this._targetRay.visible = !1,
                        this._targetRay.hasLinearVelocity = !1,
                        this._targetRay.linearVelocity = new Y,
                        this._targetRay.hasAngularVelocity = !1,
                        this._targetRay.angularVelocity = new Y),
                        this._targetRay
                    }
                    getGripSpace() {
                        return this._grip === null && (this._grip = new Ph,
                        this._grip.matrixAutoUpdate = !1,
                        this._grip.visible = !1,
                        this._grip.hasLinearVelocity = !1,
                        this._grip.linearVelocity = new Y,
                        this._grip.hasAngularVelocity = !1,
                        this._grip.angularVelocity = new Y),
                        this._grip
                    }
                    dispatchEvent(e) {
                        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
                        this._grip !== null && this._grip.dispatchEvent(e),
                        this._hand !== null && this._hand.dispatchEvent(e),
                        this
                    }
                    connect(e) {
                        if (e && e.hand) {
                            const t = this._hand;
                            if (t)
                                for (const n of e.hand.values())
                                    this._getHandJoint(t, n)
                        }
                        return this.dispatchEvent({
                            type: "connected",
                            data: e
                        }),
                        this
                    }
                    disconnect(e) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }),
                        this._targetRay !== null && (this._targetRay.visible = !1),
                        this._grip !== null && (this._grip.visible = !1),
                        this._hand !== null && (this._hand.visible = !1),
                        this
                    }
                    update(e, t, n) {
                        let a = null
                          , r = null
                          , c = null;
                        const f = this._targetRay
                          , p = this._grip
                          , m = this._hand;
                        if (e && t.session.visibilityState !== "visible-blurred") {
                            if (m && e.hand) {
                                c = !0;
                                for (const C of e.hand.values()) {
                                    const R = t.getJointPose(C, n)
                                      , A = this._getHandJoint(m, C);
                                    R !== null && (A.matrix.fromArray(R.transform.matrix),
                                    A.matrix.decompose(A.position, A.rotation, A.scale),
                                    A.matrixWorldNeedsUpdate = !0,
                                    A.jointRadius = R.radius),
                                    A.visible = R !== null
                                }
                                const g = m.joints["index-finger-tip"]
                                  , v = m.joints["thumb-tip"]
                                  , _ = g.position.distanceTo(v.position)
                                  , x = .02
                                  , M = .005;
                                m.inputState.pinching && _ > x + M ? (m.inputState.pinching = !1,
                                this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: e.handedness,
                                    target: this
                                })) : !m.inputState.pinching && _ <= x - M && (m.inputState.pinching = !0,
                                this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: e.handedness,
                                    target: this
                                }))
                            } else
                                p !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                                r !== null && (p.matrix.fromArray(r.transform.matrix),
                                p.matrix.decompose(p.position, p.rotation, p.scale),
                                p.matrixWorldNeedsUpdate = !0,
                                r.linearVelocity ? (p.hasLinearVelocity = !0,
                                p.linearVelocity.copy(r.linearVelocity)) : p.hasLinearVelocity = !1,
                                r.angularVelocity ? (p.hasAngularVelocity = !0,
                                p.angularVelocity.copy(r.angularVelocity)) : p.hasAngularVelocity = !1));
                            f !== null && (a = t.getPose(e.targetRaySpace, n),
                            a === null && r !== null && (a = r),
                            a !== null && (f.matrix.fromArray(a.transform.matrix),
                            f.matrix.decompose(f.position, f.rotation, f.scale),
                            f.matrixWorldNeedsUpdate = !0,
                            a.linearVelocity ? (f.hasLinearVelocity = !0,
                            f.linearVelocity.copy(a.linearVelocity)) : f.hasLinearVelocity = !1,
                            a.angularVelocity ? (f.hasAngularVelocity = !0,
                            f.angularVelocity.copy(a.angularVelocity)) : f.hasAngularVelocity = !1,
                            this.dispatchEvent(FC)))
                        }
                        return f !== null && (f.visible = a !== null),
                        p !== null && (p.visible = r !== null),
                        m !== null && (m.visible = c !== null),
                        this
                    }
                    _getHandJoint(e, t) {
                        if (e.joints[t.jointName] === void 0) {
                            const n = new Ph;
                            n.matrixAutoUpdate = !1,
                            n.visible = !1,
                            e.joints[t.jointName] = n,
                            e.add(n)
                        }
                        return e.joints[t.jointName]
                    }
                }
                  , uM = class DA {
                    constructor(t, n=25e-5) {
                        this.isFogExp2 = !0,
                        this.name = "",
                        this.color = new dt(t),
                        this.density = n
                    }
                    clone() {
                        return new DA(this.color,this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            name: this.name,
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                  , fM = class NA {
                    constructor(t, n=1, a=1e3) {
                        this.isFog = !0,
                        this.name = "",
                        this.color = new dt(t),
                        this.near = n,
                        this.far = a
                    }
                    clone() {
                        return new NA(this.color,this.near,this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            name: this.name,
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                  , Z_ = class extends Fn {
                    constructor() {
                        super(),
                        this.isScene = !0,
                        this.type = "Scene",
                        this.background = null,
                        this.environment = null,
                        this.fog = null,
                        this.backgroundBlurriness = 0,
                        this.backgroundIntensity = 1,
                        this.backgroundRotation = new es,
                        this.environmentIntensity = 1,
                        this.environmentRotation = new es,
                        this.overrideMaterial = null,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.background !== null && (this.background = e.background.clone()),
                        e.environment !== null && (this.environment = e.environment.clone()),
                        e.fog !== null && (this.fog = e.fog.clone()),
                        this.backgroundBlurriness = e.backgroundBlurriness,
                        this.backgroundIntensity = e.backgroundIntensity,
                        this.backgroundRotation.copy(e.backgroundRotation),
                        this.environmentIntensity = e.environmentIntensity,
                        this.environmentRotation.copy(e.environmentRotation),
                        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
                        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
                        t.object.backgroundRotation = this.backgroundRotation.toArray(),
                        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
                        t.object.environmentRotation = this.environmentRotation.toArray(),
                        t
                    }
                }
                  , A0 = class {
                    constructor(e, t) {
                        this.isInterleavedBuffer = !0,
                        this.array = e,
                        this.stride = t,
                        this.count = e !== void 0 ? e.length / t : 0,
                        this.usage = Gp,
                        this.updateRanges = [],
                        this.version = 0,
                        this.uuid = Fs()
                    }
                    onUploadCallback() {}
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    addUpdateRange(e, t) {
                        this.updateRanges.push({
                            start: e,
                            count: t
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(e) {
                        return this.array = new e.array.constructor(e.array),
                        this.count = e.count,
                        this.stride = e.stride,
                        this.usage = e.usage,
                        this
                    }
                    copyAt(e, t, n) {
                        e *= this.stride,
                        n *= t.stride;
                        for (let a = 0, r = this.stride; a < r; a++)
                            this.array[e + a] = t.array[n + a];
                        return this
                    }
                    set(e, t=0) {
                        return this.array.set(e, t),
                        this
                    }
                    clone(e) {
                        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Fs()),
                        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                          , n = new this.constructor(t,this.stride);
                        return n.setUsage(this.usage),
                        n
                    }
                    onUpload(e) {
                        return this.onUploadCallback = e,
                        this
                    }
                    toJSON(e) {
                        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Fs()),
                        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                ;
                const ns = new Y;
                var em = class LA {
                    constructor(t, n, a, r=!1) {
                        this.isInterleavedBufferAttribute = !0,
                        this.name = "",
                        this.data = t,
                        this.itemSize = n,
                        this.offset = a,
                        this.normalized = r
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(t) {
                        this.data.needsUpdate = t
                    }
                    applyMatrix4(t) {
                        for (let n = 0, a = this.data.count; n < a; n++)
                            ns.fromBufferAttribute(this, n),
                            ns.applyMatrix4(t),
                            this.setXYZ(n, ns.x, ns.y, ns.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let n = 0, a = this.count; n < a; n++)
                            ns.fromBufferAttribute(this, n),
                            ns.applyNormalMatrix(t),
                            this.setXYZ(n, ns.x, ns.y, ns.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let n = 0, a = this.count; n < a; n++)
                            ns.fromBufferAttribute(this, n),
                            ns.transformDirection(t),
                            this.setXYZ(n, ns.x, ns.y, ns.z);
                        return this
                    }
                    getComponent(t, n) {
                        let a = this.array[t * this.data.stride + this.offset + n];
                        return this.normalized && (a = $a(a, this.array)),
                        a
                    }
                    setComponent(t, n, a) {
                        return this.normalized && (a = Zt(a, this.array)),
                        this.data.array[t * this.data.stride + this.offset + n] = a,
                        this
                    }
                    setX(t, n) {
                        return this.normalized && (n = Zt(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset] = n,
                        this
                    }
                    setY(t, n) {
                        return this.normalized && (n = Zt(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 1] = n,
                        this
                    }
                    setZ(t, n) {
                        return this.normalized && (n = Zt(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 2] = n,
                        this
                    }
                    setW(t, n) {
                        return this.normalized && (n = Zt(n, this.array)),
                        this.data.array[t * this.data.stride + this.offset + 3] = n,
                        this
                    }
                    getX(t) {
                        let n = this.data.array[t * this.data.stride + this.offset];
                        return this.normalized && (n = $a(n, this.array)),
                        n
                    }
                    getY(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 1];
                        return this.normalized && (n = $a(n, this.array)),
                        n
                    }
                    getZ(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 2];
                        return this.normalized && (n = $a(n, this.array)),
                        n
                    }
                    getW(t) {
                        let n = this.data.array[t * this.data.stride + this.offset + 3];
                        return this.normalized && (n = $a(n, this.array)),
                        n
                    }
                    setXY(t, n, a) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = Zt(n, this.array),
                        a = Zt(a, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = a,
                        this
                    }
                    setXYZ(t, n, a, r) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = Zt(n, this.array),
                        a = Zt(a, this.array),
                        r = Zt(r, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = a,
                        this.data.array[t + 2] = r,
                        this
                    }
                    setXYZW(t, n, a, r, c) {
                        return t = t * this.data.stride + this.offset,
                        this.normalized && (n = Zt(n, this.array),
                        a = Zt(a, this.array),
                        r = Zt(r, this.array),
                        c = Zt(c, this.array)),
                        this.data.array[t + 0] = n,
                        this.data.array[t + 1] = a,
                        this.data.array[t + 2] = r,
                        this.data.array[t + 3] = c,
                        this
                    }
                    clone(t) {
                        if (t === void 0) {
                            Xp("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let a = 0; a < this.count; a++) {
                                const r = a * this.data.stride + this.offset;
                                for (let c = 0; c < this.itemSize; c++)
                                    n.push(this.data.array[r + c])
                            }
                            return new Vn(new this.array.constructor(n),this.itemSize,this.normalized)
                        } else
                            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
                            t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                            new LA(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                    }
                    toJSON(t) {
                        if (t === void 0) {
                            Xp("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                            const n = [];
                            for (let a = 0; a < this.count; a++) {
                                const r = a * this.data.stride + this.offset;
                                for (let c = 0; c < this.itemSize; c++)
                                    n.push(this.data.array[r + c])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: n,
                                normalized: this.normalized
                            }
                        } else
                            return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
                            t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                            {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                    }
                }
                  , Q_ = class extends Na {
                    constructor(e) {
                        super(),
                        this.isSpriteMaterial = !0,
                        this.type = "SpriteMaterial",
                        this.color = new dt(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.rotation = 0,
                        this.sizeAttenuation = !0,
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.rotation = e.rotation,
                        this.sizeAttenuation = e.sizeAttenuation,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                let zh;
                const tm = new Y
                  , Bh = new Y
                  , Fh = new Y
                  , Vh = new Pe
                  , nm = new Pe
                  , hM = new Wt
                  , w0 = new Y
                  , im = new Y
                  , C0 = new Y
                  , dM = new Pe
                  , K_ = new Pe
                  , pM = new Pe;
                var mM = class extends Fn {
                    constructor(e=new Q_) {
                        if (super(),
                        this.isSprite = !0,
                        this.type = "Sprite",
                        zh === void 0) {
                            zh = new Xt;
                            const t = new A0(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
                            zh.setIndex([0, 1, 2, 0, 2, 3]),
                            zh.setAttribute("position", new em(t,3,0,!1)),
                            zh.setAttribute("uv", new em(t,2,3,!1))
                        }
                        this.geometry = zh,
                        this.material = e,
                        this.center = new Pe(.5,.5),
                        this.count = 1
                    }
                    raycast(e, t) {
                        e.camera === null && Et('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                        Bh.setFromMatrixScale(this.matrixWorld),
                        hM.copy(e.camera.matrixWorld),
                        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                        Fh.setFromMatrixPosition(this.modelViewMatrix),
                        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Bh.multiplyScalar(-Fh.z);
                        const n = this.material.rotation;
                        let a, r;
                        n !== 0 && (r = Math.cos(n),
                        a = Math.sin(n));
                        const c = this.center;
                        R0(w0.set(-.5, -.5, 0), Fh, c, Bh, a, r),
                        R0(im.set(.5, -.5, 0), Fh, c, Bh, a, r),
                        R0(C0.set(.5, .5, 0), Fh, c, Bh, a, r),
                        dM.set(0, 0),
                        K_.set(1, 0),
                        pM.set(1, 1);
                        let f = e.ray.intersectTriangle(w0, im, C0, !1, tm);
                        if (f === null && (R0(im.set(-.5, .5, 0), Fh, c, Bh, a, r),
                        K_.set(0, 1),
                        f = e.ray.intersectTriangle(w0, C0, im, !1, tm),
                        f === null))
                            return;
                        const p = e.ray.origin.distanceTo(tm);
                        p < e.near || p > e.far || t.push({
                            distance: p,
                            point: tm.clone(),
                            uv: wc.getInterpolation(tm, w0, im, C0, dM, K_, pM, new Pe),
                            face: null,
                            object: this
                        })
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.center !== void 0 && this.center.copy(e.center),
                        this.material = e.material,
                        this
                    }
                }
                ;
                function R0(e, t, n, a, r, c) {
                    Vh.subVectors(e, n).addScalar(.5).multiply(a),
                    r !== void 0 ? (nm.x = c * Vh.x - r * Vh.y,
                    nm.y = r * Vh.x + c * Vh.y) : nm.copy(Vh),
                    e.copy(t),
                    e.x += nm.x,
                    e.y += nm.y,
                    e.applyMatrix4(hM)
                }
                const D0 = new Y
                  , gM = new Y;
                var vM = class extends Fn {
                    constructor() {
                        super(),
                        this.isLOD = !0,
                        this._currentLevel = 0,
                        this.type = "LOD",
                        Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            }
                        }),
                        this.autoUpdate = !0
                    }
                    copy(e) {
                        super.copy(e, !1);
                        const t = e.levels;
                        for (let n = 0, a = t.length; n < a; n++) {
                            const r = t[n];
                            this.addLevel(r.object.clone(), r.distance, r.hysteresis)
                        }
                        return this.autoUpdate = e.autoUpdate,
                        this
                    }
                    addLevel(e, t=0, n=0) {
                        t = Math.abs(t);
                        const a = this.levels;
                        let r;
                        for (r = 0; r < a.length && !(t < a[r].distance); r++)
                            ;
                        return a.splice(r, 0, {
                            distance: t,
                            hysteresis: n,
                            object: e
                        }),
                        this.add(e),
                        this
                    }
                    removeLevel(e) {
                        const t = this.levels;
                        for (let n = 0; n < t.length; n++)
                            if (t[n].distance === e) {
                                const a = t.splice(n, 1);
                                return this.remove(a[0].object),
                                !0
                            }
                        return !1
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(e) {
                        const t = this.levels;
                        if (t.length > 0) {
                            let n, a;
                            for (n = 1,
                            a = t.length; n < a; n++) {
                                let r = t[n].distance;
                                if (t[n].object.visible && (r -= r * t[n].hysteresis),
                                e < r)
                                    break
                            }
                            return t[n - 1].object
                        }
                        return null
                    }
                    raycast(e, t) {
                        if (this.levels.length > 0) {
                            D0.setFromMatrixPosition(this.matrixWorld);
                            const n = e.ray.origin.distanceTo(D0);
                            this.getObjectForDistance(n).raycast(e, t)
                        }
                    }
                    update(e) {
                        const t = this.levels;
                        if (t.length > 1) {
                            D0.setFromMatrixPosition(e.matrixWorld),
                            gM.setFromMatrixPosition(this.matrixWorld);
                            const n = D0.distanceTo(gM) / e.zoom;
                            t[0].object.visible = !0;
                            let a, r;
                            for (a = 1,
                            r = t.length; a < r; a++) {
                                let c = t[a].distance;
                                if (t[a].object.visible && (c -= c * t[a].hysteresis),
                                n >= c)
                                    t[a - 1].object.visible = !1,
                                    t[a].object.visible = !0;
                                else
                                    break
                            }
                            for (this._currentLevel = a - 1; a < r; a++)
                                t[a].object.visible = !1
                        }
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
                        t.object.levels = [];
                        const n = this.levels;
                        for (let a = 0, r = n.length; a < r; a++) {
                            const c = n[a];
                            t.object.levels.push({
                                object: c.object.uuid,
                                distance: c.distance,
                                hysteresis: c.hysteresis
                            })
                        }
                        return t
                    }
                }
                ;
                const yM = new Y
                  , _M = new ti
                  , SM = new ti
                  , VC = new Y
                  , xM = new Wt
                  , N0 = new Y
                  , J_ = new Sa
                  , bM = new Wt
                  , $_ = new Eh;
                var MM = class extends Hi {
                    constructor(e, t) {
                        super(e, t),
                        this.isSkinnedMesh = !0,
                        this.type = "SkinnedMesh",
                        this.bindMode = d_,
                        this.bindMatrix = new Wt,
                        this.bindMatrixInverse = new Wt,
                        this.boundingBox = null,
                        this.boundingSphere = null
                    }
                    computeBoundingBox() {
                        const e = this.geometry;
                        this.boundingBox === null && (this.boundingBox = new Ra),
                        this.boundingBox.makeEmpty();
                        const t = e.getAttribute("position");
                        for (let n = 0; n < t.count; n++)
                            this.getVertexPosition(n, N0),
                            this.boundingBox.expandByPoint(N0)
                    }
                    computeBoundingSphere() {
                        const e = this.geometry;
                        this.boundingSphere === null && (this.boundingSphere = new Sa),
                        this.boundingSphere.makeEmpty();
                        const t = e.getAttribute("position");
                        for (let n = 0; n < t.count; n++)
                            this.getVertexPosition(n, N0),
                            this.boundingSphere.expandByPoint(N0)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.bindMode = e.bindMode,
                        this.bindMatrix.copy(e.bindMatrix),
                        this.bindMatrixInverse.copy(e.bindMatrixInverse),
                        this.skeleton = e.skeleton,
                        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
                        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
                        this
                    }
                    raycast(e, t) {
                        const n = this.material
                          , a = this.matrixWorld;
                        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        J_.copy(this.boundingSphere),
                        J_.applyMatrix4(a),
                        e.ray.intersectsSphere(J_) !== !1 && (bM.copy(a).invert(),
                        $_.copy(e.ray).applyMatrix4(bM),
                        !(this.boundingBox !== null && $_.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, $_)))
                    }
                    getVertexPosition(e, t) {
                        return super.getVertexPosition(e, t),
                        this.applyBoneTransform(e, t),
                        t
                    }
                    bind(e, t) {
                        this.skeleton = e,
                        t === void 0 && (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        t = this.matrixWorld),
                        this.bindMatrix.copy(t),
                        this.bindMatrixInverse.copy(t).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const e = new ti
                          , t = this.geometry.attributes.skinWeight;
                        for (let n = 0, a = t.count; n < a; n++) {
                            e.fromBufferAttribute(t, n);
                            const r = 1 / e.manhattanLength();
                            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                            t.setXYZW(n, e.x, e.y, e.z, e.w)
                        }
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e),
                        this.bindMode === d_ ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Ab ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : ot("SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    applyBoneTransform(e, t) {
                        const n = this.skeleton
                          , a = this.geometry;
                        _M.fromBufferAttribute(a.attributes.skinIndex, e),
                        SM.fromBufferAttribute(a.attributes.skinWeight, e),
                        yM.copy(t).applyMatrix4(this.bindMatrix),
                        t.set(0, 0, 0);
                        for (let r = 0; r < 4; r++) {
                            const c = SM.getComponent(r);
                            if (c !== 0) {
                                const f = _M.getComponent(r);
                                xM.multiplyMatrices(n.bones[f].matrixWorld, n.boneInverses[f]),
                                t.addScaledVector(VC.copy(yM).applyMatrix4(xM), c)
                            }
                        }
                        return t.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                  , eS = class extends Fn {
                    constructor() {
                        super(),
                        this.isBone = !0,
                        this.type = "Bone"
                    }
                }
                  , Gr = class extends oa {
                    constructor(e=null, t=1, n=1, a, r, c, f, p, m=Oi, g=Oi, v, _) {
                        super(null, c, f, p, m, g, a, r, v, _),
                        this.isDataTexture = !0,
                        this.image = {
                            data: e,
                            width: t,
                            height: n
                        },
                        this.generateMipmaps = !1,
                        this.flipY = !1,
                        this.unpackAlignment = 1
                    }
                }
                ;
                const TM = new Wt
                  , kC = new Wt;
                var EM = class UA {
                    constructor(t=[], n=[]) {
                        this.uuid = Fs(),
                        this.bones = t.slice(0),
                        this.boneInverses = n,
                        this.boneMatrices = null,
                        this.previousBoneMatrices = null,
                        this.boneTexture = null,
                        this.init()
                    }
                    init() {
                        const t = this.bones
                          , n = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(t.length * 16),
                        n.length === 0)
                            this.calculateInverses();
                        else if (t.length !== n.length) {
                            ot("Skeleton: Number of inverse bone matrices does not match amount of bones."),
                            this.boneInverses = [];
                            for (let a = 0, r = this.bones.length; a < r; a++)
                                this.boneInverses.push(new Wt)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const a = new Wt;
                            this.bones[t] && a.copy(this.bones[t].matrixWorld).invert(),
                            this.boneInverses.push(a)
                        }
                    }
                    pose() {
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const a = this.bones[t];
                            a && a.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const a = this.bones[t];
                            a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(),
                            a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld),
                            a.matrix.decompose(a.position, a.quaternion, a.scale))
                        }
                    }
                    update() {
                        const t = this.bones
                          , n = this.boneInverses
                          , a = this.boneMatrices
                          , r = this.boneTexture;
                        for (let c = 0, f = t.length; c < f; c++) {
                            const p = t[c] ? t[c].matrixWorld : kC;
                            TM.multiplyMatrices(p, n[c]),
                            TM.toArray(a, c * 16)
                        }
                        r !== null && (r.needsUpdate = !0)
                    }
                    clone() {
                        return new UA(this.bones,this.boneInverses)
                    }
                    computeBoneTexture() {
                        let t = Math.sqrt(this.bones.length * 4);
                        t = Math.ceil(t / 4) * 4,
                        t = Math.max(t, 4);
                        const n = new Float32Array(t * t * 4);
                        n.set(this.boneMatrices);
                        const a = new Gr(n,t,t,Aa,Ja);
                        return a.needsUpdate = !0,
                        this.boneMatrices = n,
                        this.boneTexture = a,
                        this
                    }
                    getBoneByName(t) {
                        for (let n = 0, a = this.bones.length; n < a; n++) {
                            const r = this.bones[n];
                            if (r.name === t)
                                return r
                        }
                    }
                    dispose() {
                        this.boneTexture !== null && (this.boneTexture.dispose(),
                        this.boneTexture = null)
                    }
                    fromJSON(t, n) {
                        this.uuid = t.uuid;
                        for (let a = 0, r = t.bones.length; a < r; a++) {
                            const c = t.bones[a];
                            let f = n[c];
                            f === void 0 && (ot("Skeleton: No bone found with UUID:", c),
                            f = new eS),
                            this.bones.push(f),
                            this.boneInverses.push(new Wt().fromArray(t.boneInverses[a]))
                        }
                        return this.init(),
                        this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.7,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        t.uuid = this.uuid;
                        const n = this.bones
                          , a = this.boneInverses;
                        for (let r = 0, c = n.length; r < c; r++) {
                            const f = n[r];
                            t.bones.push(f.uuid);
                            const p = a[r];
                            t.boneInverses.push(p.toArray())
                        }
                        return t
                    }
                }
                  , kh = class extends Vn {
                    constructor(e, t, n, a=1) {
                        super(e, t, n),
                        this.isInstancedBufferAttribute = !0,
                        this.meshPerAttribute = a
                    }
                    copy(e) {
                        return super.copy(e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.meshPerAttribute = this.meshPerAttribute,
                        e.isInstancedBufferAttribute = !0,
                        e
                    }
                }
                ;
                const Hh = new Wt
                  , AM = new Wt
                  , L0 = []
                  , wM = new Ra
                  , HC = new Wt
                  , am = new Hi
                  , sm = new Sa;
                var CM = class extends Hi {
                    constructor(e, t, n) {
                        super(e, t),
                        this.isInstancedMesh = !0,
                        this.instanceMatrix = new kh(new Float32Array(n * 16),16),
                        this.instanceColor = null,
                        this.morphTexture = null,
                        this.count = n,
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        for (let a = 0; a < n; a++)
                            this.setMatrixAt(a, HC)
                    }
                    computeBoundingBox() {
                        const e = this.geometry
                          , t = this.count;
                        this.boundingBox === null && (this.boundingBox = new Ra),
                        e.boundingBox === null && e.computeBoundingBox(),
                        this.boundingBox.makeEmpty();
                        for (let n = 0; n < t; n++)
                            this.getMatrixAt(n, Hh),
                            wM.copy(e.boundingBox).applyMatrix4(Hh),
                            this.boundingBox.union(wM)
                    }
                    computeBoundingSphere() {
                        const e = this.geometry
                          , t = this.count;
                        this.boundingSphere === null && (this.boundingSphere = new Sa),
                        e.boundingSphere === null && e.computeBoundingSphere(),
                        this.boundingSphere.makeEmpty();
                        for (let n = 0; n < t; n++)
                            this.getMatrixAt(n, Hh),
                            sm.copy(e.boundingSphere).applyMatrix4(Hh),
                            this.boundingSphere.union(sm)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.instanceMatrix.copy(e.instanceMatrix),
                        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
                        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
                        this.count = e.count,
                        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
                        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
                        this
                    }
                    getColorAt(e, t) {
                        t.fromArray(this.instanceColor.array, e * 3)
                    }
                    getMatrixAt(e, t) {
                        t.fromArray(this.instanceMatrix.array, e * 16)
                    }
                    getMorphAt(e, t) {
                        const n = t.morphTargetInfluences
                          , a = this.morphTexture.source.data.data
                          , r = e * (n.length + 1) + 1;
                        for (let c = 0; c < n.length; c++)
                            n[c] = a[r + c]
                    }
                    raycast(e, t) {
                        const n = this.matrixWorld
                          , a = this.count;
                        if (am.geometry = this.geometry,
                        am.material = this.material,
                        am.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                        sm.copy(this.boundingSphere),
                        sm.applyMatrix4(n),
                        e.ray.intersectsSphere(sm) !== !1))
                            for (let r = 0; r < a; r++) {
                                this.getMatrixAt(r, Hh),
                                AM.multiplyMatrices(n, Hh),
                                am.matrixWorld = AM,
                                am.raycast(e, L0);
                                for (let c = 0, f = L0.length; c < f; c++) {
                                    const p = L0[c];
                                    p.instanceId = r,
                                    p.object = this,
                                    t.push(p)
                                }
                                L0.length = 0
                            }
                    }
                    setColorAt(e, t) {
                        this.instanceColor === null && (this.instanceColor = new kh(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
                        t.toArray(this.instanceColor.array, e * 3)
                    }
                    setMatrixAt(e, t) {
                        t.toArray(this.instanceMatrix.array, e * 16)
                    }
                    setMorphAt(e, t) {
                        const n = t.morphTargetInfluences
                          , a = n.length + 1;
                        this.morphTexture === null && (this.morphTexture = new Gr(new Float32Array(a * this.count),a,this.count,Sv,Ja));
                        const r = this.morphTexture.source.data.data;
                        let c = 0;
                        for (let m = 0; m < n.length; m++)
                            c += n[m];
                        const f = this.geometry.morphTargetsRelative ? 1 : 1 - c
                          , p = a * e;
                        r[p] = f,
                        r.set(n, p + 1)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        }),
                        this.morphTexture !== null && (this.morphTexture.dispose(),
                        this.morphTexture = null)
                    }
                }
                ;
                const tS = new Y
                  , GC = new Y
                  , WC = new en;
                var Nc = class {
                    constructor(e=new Y(1,0,0), t=0) {
                        this.isPlane = !0,
                        this.normal = e,
                        this.constant = t
                    }
                    set(e, t) {
                        return this.normal.copy(e),
                        this.constant = t,
                        this
                    }
                    setComponents(e, t, n, a) {
                        return this.normal.set(e, t, n),
                        this.constant = a,
                        this
                    }
                    setFromNormalAndCoplanarPoint(e, t) {
                        return this.normal.copy(e),
                        this.constant = -t.dot(this.normal),
                        this
                    }
                    setFromCoplanarPoints(e, t, n) {
                        const a = tS.subVectors(n, t).cross(GC.subVectors(e, t)).normalize();
                        return this.setFromNormalAndCoplanarPoint(a, e),
                        this
                    }
                    copy(e) {
                        return this.normal.copy(e.normal),
                        this.constant = e.constant,
                        this
                    }
                    normalize() {
                        const e = 1 / this.normal.length();
                        return this.normal.multiplyScalar(e),
                        this.constant *= e,
                        this
                    }
                    negate() {
                        return this.constant *= -1,
                        this.normal.negate(),
                        this
                    }
                    distanceToPoint(e) {
                        return this.normal.dot(e) + this.constant
                    }
                    distanceToSphere(e) {
                        return this.distanceToPoint(e.center) - e.radius
                    }
                    projectPoint(e, t) {
                        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                    }
                    intersectLine(e, t) {
                        const n = e.delta(tS)
                          , a = this.normal.dot(n);
                        if (a === 0)
                            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
                        const r = -(e.start.dot(this.normal) + this.constant) / a;
                        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
                    }
                    intersectsLine(e) {
                        const t = this.distanceToPoint(e.start)
                          , n = this.distanceToPoint(e.end);
                        return t < 0 && n > 0 || n < 0 && t > 0
                    }
                    intersectsBox(e) {
                        return e.intersectsPlane(this)
                    }
                    intersectsSphere(e) {
                        return e.intersectsPlane(this)
                    }
                    coplanarPoint(e) {
                        return e.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(e, t) {
                        const n = t || WC.getNormalMatrix(e)
                          , a = this.coplanarPoint(tS).applyMatrix4(e)
                          , r = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -a.dot(r),
                        this
                    }
                    translate(e) {
                        return this.constant -= e.dot(this.normal),
                        this
                    }
                    equals(e) {
                        return e.normal.equals(this.normal) && e.constant === this.constant
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const Gu = new Sa
                  , XC = new Pe(.5,.5)
                  , U0 = new Y;
                var Gh = class {
                    constructor(e=new Nc, t=new Nc, n=new Nc, a=new Nc, r=new Nc, c=new Nc) {
                        this.planes = [e, t, n, a, r, c]
                    }
                    set(e, t, n, a, r, c) {
                        const f = this.planes;
                        return f[0].copy(e),
                        f[1].copy(t),
                        f[2].copy(n),
                        f[3].copy(a),
                        f[4].copy(r),
                        f[5].copy(c),
                        this
                    }
                    copy(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            t[n].copy(e.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(e, t=Bs, n=!1) {
                        const a = this.planes
                          , r = e.elements
                          , c = r[0]
                          , f = r[1]
                          , p = r[2]
                          , m = r[3]
                          , g = r[4]
                          , v = r[5]
                          , _ = r[6]
                          , x = r[7]
                          , M = r[8]
                          , C = r[9]
                          , R = r[10]
                          , A = r[11]
                          , E = r[12]
                          , N = r[13]
                          , I = r[14]
                          , L = r[15];
                        if (a[0].setComponents(m - c, x - g, A - M, L - E).normalize(),
                        a[1].setComponents(m + c, x + g, A + M, L + E).normalize(),
                        a[2].setComponents(m + f, x + v, A + C, L + N).normalize(),
                        a[3].setComponents(m - f, x - v, A - C, L - N).normalize(),
                        n)
                            a[4].setComponents(p, _, R, I).normalize(),
                            a[5].setComponents(m - p, x - _, A - R, L - I).normalize();
                        else if (a[4].setComponents(m - p, x - _, A - R, L - I).normalize(),
                        t === Bs)
                            a[5].setComponents(m + p, x + _, A + R, L + I).normalize();
                        else if (t === gh)
                            a[5].setComponents(p, _, R, I).normalize();
                        else
                            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                        return this
                    }
                    intersectsObject(e) {
                        if (e.boundingSphere !== void 0)
                            e.boundingSphere === null && e.computeBoundingSphere(),
                            Gu.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                        else {
                            const t = e.geometry;
                            t.boundingSphere === null && t.computeBoundingSphere(),
                            Gu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                        }
                        return this.intersectsSphere(Gu)
                    }
                    intersectsSprite(e) {
                        return Gu.center.set(0, 0, 0),
                        Gu.radius = .7071067811865476 + XC.distanceTo(e.center),
                        Gu.applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(Gu)
                    }
                    intersectsSphere(e) {
                        const t = this.planes
                          , n = e.center
                          , a = -e.radius;
                        for (let r = 0; r < 6; r++)
                            if (t[r].distanceToPoint(n) < a)
                                return !1;
                        return !0
                    }
                    intersectsBox(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const a = t[n];
                            if (U0.x = a.normal.x > 0 ? e.max.x : e.min.x,
                            U0.y = a.normal.y > 0 ? e.max.y : e.min.y,
                            U0.z = a.normal.z > 0 ? e.max.z : e.min.z,
                            a.distanceToPoint(U0) < 0)
                                return !1
                        }
                        return !0
                    }
                    containsPoint(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (t[n].distanceToPoint(e) < 0)
                                return !1;
                        return !0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const Io = new Wt
                  , Oo = new Gh;
                var RM = class IA {
                    constructor() {
                        this.coordinateSystem = Bs
                    }
                    intersectsObject(t, n) {
                        if (!n.isArrayCamera || n.cameras.length === 0)
                            return !1;
                        for (let a = 0; a < n.cameras.length; a++) {
                            const r = n.cameras[a];
                            if (Io.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
                            Oo.setFromProjectionMatrix(Io, r.coordinateSystem, r.reversedDepth),
                            Oo.intersectsObject(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsSprite(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let a = 0; a < n.cameras.length; a++) {
                            const r = n.cameras[a];
                            if (Io.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
                            Oo.setFromProjectionMatrix(Io, r.coordinateSystem, r.reversedDepth),
                            Oo.intersectsSprite(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsSphere(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let a = 0; a < n.cameras.length; a++) {
                            const r = n.cameras[a];
                            if (Io.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
                            Oo.setFromProjectionMatrix(Io, r.coordinateSystem, r.reversedDepth),
                            Oo.intersectsSphere(t))
                                return !0
                        }
                        return !1
                    }
                    intersectsBox(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let a = 0; a < n.cameras.length; a++) {
                            const r = n.cameras[a];
                            if (Io.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
                            Oo.setFromProjectionMatrix(Io, r.coordinateSystem, r.reversedDepth),
                            Oo.intersectsBox(t))
                                return !0
                        }
                        return !1
                    }
                    containsPoint(t, n) {
                        if (!n || !n.cameras || n.cameras.length === 0)
                            return !1;
                        for (let a = 0; a < n.cameras.length; a++) {
                            const r = n.cameras[a];
                            if (Io.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
                            Oo.setFromProjectionMatrix(Io, r.coordinateSystem, r.reversedDepth),
                            Oo.containsPoint(t))
                                return !0
                        }
                        return !1
                    }
                    clone() {
                        return new IA
                    }
                }
                ;
                function nS(e, t) {
                    return e - t
                }
                function qC(e, t) {
                    return e.z - t.z
                }
                function YC(e, t) {
                    return t.z - e.z
                }
                var jC = class {
                    constructor() {
                        this.index = 0,
                        this.pool = [],
                        this.list = []
                    }
                    push(e, t, n, a) {
                        const r = this.pool
                          , c = this.list;
                        this.index >= r.length && r.push({
                            start: -1,
                            count: -1,
                            z: -1,
                            index: -1
                        });
                        const f = r[this.index];
                        c.push(f),
                        this.index++,
                        f.start = e,
                        f.count = t,
                        f.z = n,
                        f.index = a
                    }
                    reset() {
                        this.list.length = 0,
                        this.index = 0
                    }
                }
                ;
                const Ms = new Wt
                  , ZC = new dt(1,1,1)
                  , DM = new Gh
                  , QC = new RM
                  , I0 = new Ra
                  , Wu = new Sa
                  , rm = new Y
                  , NM = new Y
                  , KC = new Y
                  , iS = new jC
                  , La = new Hi
                  , O0 = [];
                function JC(e, t, n=0) {
                    const a = t.itemSize;
                    if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                        const r = e.count;
                        for (let c = 0; c < r; c++)
                            for (let f = 0; f < a; f++)
                                t.setComponent(c + n, f, e.getComponent(c, f))
                    } else
                        t.array.set(e.array, n * a);
                    t.needsUpdate = !0
                }
                function Xu(e, t) {
                    if (e.constructor !== t.constructor) {
                        const n = Math.min(e.length, t.length);
                        for (let a = 0; a < n; a++)
                            t[a] = e[a]
                    } else {
                        const n = Math.min(e.length, t.length);
                        t.set(new e.constructor(e.buffer,0,n))
                    }
                }
                var LM = class extends Hi {
                    constructor(e, t, n=t * 2, a) {
                        super(new Xt, a),
                        this.isBatchedMesh = !0,
                        this.perObjectFrustumCulled = !0,
                        this.sortObjects = !0,
                        this.boundingBox = null,
                        this.boundingSphere = null,
                        this.customSort = null,
                        this._instanceInfo = [],
                        this._geometryInfo = [],
                        this._availableInstanceIds = [],
                        this._availableGeometryIds = [],
                        this._nextIndexStart = 0,
                        this._nextVertexStart = 0,
                        this._geometryCount = 0,
                        this._visibilityChanged = !0,
                        this._geometryInitialized = !1,
                        this._maxInstanceCount = e,
                        this._maxVertexCount = t,
                        this._maxIndexCount = n,
                        this._multiDrawCounts = new Int32Array(e),
                        this._multiDrawStarts = new Int32Array(e),
                        this._multiDrawCount = 0,
                        this._multiDrawInstances = null,
                        this._matricesTexture = null,
                        this._indirectTexture = null,
                        this._colorsTexture = null,
                        this._initMatricesTexture(),
                        this._initIndirectTexture()
                    }
                    get maxInstanceCount() {
                        return this._maxInstanceCount
                    }
                    get instanceCount() {
                        return this._instanceInfo.length - this._availableInstanceIds.length
                    }
                    get unusedVertexCount() {
                        return this._maxVertexCount - this._nextVertexStart
                    }
                    get unusedIndexCount() {
                        return this._maxIndexCount - this._nextIndexStart
                    }
                    _initMatricesTexture() {
                        let e = Math.sqrt(this._maxInstanceCount * 4);
                        e = Math.ceil(e / 4) * 4,
                        e = Math.max(e, 4),
                        this._matricesTexture = new Gr(new Float32Array(e * e * 4),e,e,Aa,Ja)
                    }
                    _initIndirectTexture() {
                        let e = Math.sqrt(this._maxInstanceCount);
                        e = Math.ceil(e),
                        this._indirectTexture = new Gr(new Uint32Array(e * e),e,e,Op,fr)
                    }
                    _initColorsTexture() {
                        let e = Math.sqrt(this._maxInstanceCount);
                        e = Math.ceil(e);
                        const t = new Gr(new Float32Array(e * e * 4).fill(1),e,e,Aa,Ja);
                        t.colorSpace = Sn.workingColorSpace,
                        this._colorsTexture = t
                    }
                    _initializeGeometry(e) {
                        const t = this.geometry
                          , n = this._maxVertexCount
                          , a = this._maxIndexCount;
                        if (this._geometryInitialized === !1) {
                            for (const r in e.attributes) {
                                const {array: c, itemSize: f, normalized: p} = e.getAttribute(r)
                                  , m = new Vn(new c.constructor(n * f),f,p);
                                t.setAttribute(r, m)
                            }
                            if (e.getIndex() !== null) {
                                const r = n > 65535 ? new Uint32Array(a) : new Uint16Array(a);
                                t.setIndex(new Vn(r,1))
                            }
                            this._geometryInitialized = !0
                        }
                    }
                    _validateGeometry(e) {
                        const t = this.geometry;
                        if (!!e.getIndex() != !!t.getIndex())
                            throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
                        for (const n in t.attributes) {
                            if (!e.hasAttribute(n))
                                throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                            const a = e.getAttribute(n)
                              , r = t.getAttribute(n);
                            if (a.itemSize !== r.itemSize || a.normalized !== r.normalized)
                                throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                        }
                    }
                    validateInstanceId(e) {
                        const t = this._instanceInfo;
                        if (e < 0 || e >= t.length || t[e].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
                    }
                    validateGeometryId(e) {
                        const t = this._geometryInfo;
                        if (e < 0 || e >= t.length || t[e].active === !1)
                            throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
                    }
                    setCustomSort(e) {
                        return this.customSort = e,
                        this
                    }
                    computeBoundingBox() {
                        this.boundingBox === null && (this.boundingBox = new Ra);
                        const e = this.boundingBox
                          , t = this._instanceInfo;
                        e.makeEmpty();
                        for (let n = 0, a = t.length; n < a; n++) {
                            if (t[n].active === !1)
                                continue;
                            const r = t[n].geometryIndex;
                            this.getMatrixAt(n, Ms),
                            this.getBoundingBoxAt(r, I0).applyMatrix4(Ms),
                            e.union(I0)
                        }
                    }
                    computeBoundingSphere() {
                        this.boundingSphere === null && (this.boundingSphere = new Sa);
                        const e = this.boundingSphere
                          , t = this._instanceInfo;
                        e.makeEmpty();
                        for (let n = 0, a = t.length; n < a; n++) {
                            if (t[n].active === !1)
                                continue;
                            const r = t[n].geometryIndex;
                            this.getMatrixAt(n, Ms),
                            this.getBoundingSphereAt(r, Wu).applyMatrix4(Ms),
                            e.union(Wu)
                        }
                    }
                    addInstance(e) {
                        if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
                            throw new Error("THREE.BatchedMesh: Maximum item count reached.");
                        const t = {
                            visible: !0,
                            active: !0,
                            geometryIndex: e
                        };
                        let n = null;
                        this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(nS),
                        n = this._availableInstanceIds.shift(),
                        this._instanceInfo[n] = t) : (n = this._instanceInfo.length,
                        this._instanceInfo.push(t));
                        const a = this._matricesTexture;
                        Ms.identity().toArray(a.image.data, n * 16),
                        a.needsUpdate = !0;
                        const r = this._colorsTexture;
                        return r && (ZC.toArray(r.image.data, n * 4),
                        r.needsUpdate = !0),
                        this._visibilityChanged = !0,
                        n
                    }
                    addGeometry(e, t=-1, n=-1) {
                        this._initializeGeometry(e),
                        this._validateGeometry(e);
                        const a = {
                            vertexStart: -1,
                            vertexCount: -1,
                            reservedVertexCount: -1,
                            indexStart: -1,
                            indexCount: -1,
                            reservedIndexCount: -1,
                            start: -1,
                            count: -1,
                            boundingBox: null,
                            boundingSphere: null,
                            active: !0
                        }
                          , r = this._geometryInfo;
                        a.vertexStart = this._nextVertexStart,
                        a.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
                        const c = e.getIndex();
                        if (c !== null && (a.indexStart = this._nextIndexStart,
                        a.reservedIndexCount = n === -1 ? c.count : n),
                        a.indexStart !== -1 && a.indexStart + a.reservedIndexCount > this._maxIndexCount || a.vertexStart + a.reservedVertexCount > this._maxVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                        let f;
                        return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(nS),
                        f = this._availableGeometryIds.shift(),
                        r[f] = a) : (f = this._geometryCount,
                        this._geometryCount++,
                        r.push(a)),
                        this.setGeometryAt(f, e),
                        this._nextIndexStart = a.indexStart + a.reservedIndexCount,
                        this._nextVertexStart = a.vertexStart + a.reservedVertexCount,
                        f
                    }
                    setGeometryAt(e, t) {
                        if (e >= this._geometryCount)
                            throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
                        this._validateGeometry(t);
                        const n = this.geometry
                          , a = n.getIndex() !== null
                          , r = n.getIndex()
                          , c = t.getIndex()
                          , f = this._geometryInfo[e];
                        if (a && c.count > f.reservedIndexCount || t.attributes.position.count > f.reservedVertexCount)
                            throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
                        const p = f.vertexStart
                          , m = f.reservedVertexCount;
                        f.vertexCount = t.getAttribute("position").count;
                        for (const g in n.attributes) {
                            const v = t.getAttribute(g)
                              , _ = n.getAttribute(g);
                            JC(v, _, p);
                            const x = v.itemSize;
                            for (let M = v.count, C = m; M < C; M++) {
                                const R = p + M;
                                for (let A = 0; A < x; A++)
                                    _.setComponent(R, A, 0)
                            }
                            _.needsUpdate = !0,
                            _.addUpdateRange(p * x, m * x)
                        }
                        if (a) {
                            const g = f.indexStart
                              , v = f.reservedIndexCount;
                            f.indexCount = t.getIndex().count;
                            for (let _ = 0; _ < c.count; _++)
                                r.setX(g + _, p + c.getX(_));
                            for (let _ = c.count, x = v; _ < x; _++)
                                r.setX(g + _, p);
                            r.needsUpdate = !0,
                            r.addUpdateRange(g, f.reservedIndexCount)
                        }
                        return f.start = a ? f.indexStart : f.vertexStart,
                        f.count = a ? f.indexCount : f.vertexCount,
                        f.boundingBox = null,
                        t.boundingBox !== null && (f.boundingBox = t.boundingBox.clone()),
                        f.boundingSphere = null,
                        t.boundingSphere !== null && (f.boundingSphere = t.boundingSphere.clone()),
                        this._visibilityChanged = !0,
                        e
                    }
                    deleteGeometry(e) {
                        const t = this._geometryInfo;
                        if (e >= t.length || t[e].active === !1)
                            return this;
                        const n = this._instanceInfo;
                        for (let a = 0, r = n.length; a < r; a++)
                            n[a].active && n[a].geometryIndex === e && this.deleteInstance(a);
                        return t[e].active = !1,
                        this._availableGeometryIds.push(e),
                        this._visibilityChanged = !0,
                        this
                    }
                    deleteInstance(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].active = !1,
                        this._availableInstanceIds.push(e),
                        this._visibilityChanged = !0,
                        this
                    }
                    optimize() {
                        let e = 0
                          , t = 0;
                        const n = this._geometryInfo
                          , a = n.map( (c, f) => f).sort( (c, f) => n[c].vertexStart - n[f].vertexStart)
                          , r = this.geometry;
                        for (let c = 0, f = n.length; c < f; c++) {
                            const p = n[a[c]];
                            if (p.active !== !1) {
                                if (r.index !== null) {
                                    if (p.indexStart !== t) {
                                        const {indexStart: m, vertexStart: g, reservedIndexCount: v} = p
                                          , _ = r.index
                                          , x = _.array
                                          , M = e - g;
                                        for (let C = m; C < m + v; C++)
                                            x[C] = x[C] + M;
                                        _.array.copyWithin(t, m, m + v),
                                        _.addUpdateRange(t, v),
                                        _.needsUpdate = !0,
                                        p.indexStart = t
                                    }
                                    t += p.reservedIndexCount
                                }
                                if (p.vertexStart !== e) {
                                    const {vertexStart: m, reservedVertexCount: g} = p
                                      , v = r.attributes;
                                    for (const _ in v) {
                                        const x = v[_]
                                          , {array: M, itemSize: C} = x;
                                        M.copyWithin(e * C, m * C, (m + g) * C),
                                        x.addUpdateRange(e * C, g * C),
                                        x.needsUpdate = !0
                                    }
                                    p.vertexStart = e
                                }
                                e += p.reservedVertexCount,
                                p.start = r.index ? p.indexStart : p.vertexStart,
                                this._nextIndexStart = r.index ? p.indexStart + p.reservedIndexCount : 0,
                                this._nextVertexStart = p.vertexStart + p.reservedVertexCount
                            }
                        }
                        return this._visibilityChanged = !0,
                        this
                    }
                    getBoundingBoxAt(e, t) {
                        if (e >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , a = this._geometryInfo[e];
                        if (a.boundingBox === null) {
                            const r = new Ra
                              , c = n.index
                              , f = n.attributes.position;
                            for (let p = a.start, m = a.start + a.count; p < m; p++) {
                                let g = p;
                                c && (g = c.getX(g)),
                                r.expandByPoint(rm.fromBufferAttribute(f, g))
                            }
                            a.boundingBox = r
                        }
                        return t.copy(a.boundingBox),
                        t
                    }
                    getBoundingSphereAt(e, t) {
                        if (e >= this._geometryCount)
                            return null;
                        const n = this.geometry
                          , a = this._geometryInfo[e];
                        if (a.boundingSphere === null) {
                            const r = new Sa;
                            this.getBoundingBoxAt(e, I0),
                            I0.getCenter(r.center);
                            const c = n.index
                              , f = n.attributes.position;
                            let p = 0;
                            for (let m = a.start, g = a.start + a.count; m < g; m++) {
                                let v = m;
                                c && (v = c.getX(v)),
                                rm.fromBufferAttribute(f, v),
                                p = Math.max(p, r.center.distanceToSquared(rm))
                            }
                            r.radius = Math.sqrt(p),
                            a.boundingSphere = r
                        }
                        return t.copy(a.boundingSphere),
                        t
                    }
                    setMatrixAt(e, t) {
                        this.validateInstanceId(e);
                        const n = this._matricesTexture
                          , a = this._matricesTexture.image.data;
                        return t.toArray(a, e * 16),
                        n.needsUpdate = !0,
                        this
                    }
                    getMatrixAt(e, t) {
                        return this.validateInstanceId(e),
                        t.fromArray(this._matricesTexture.image.data, e * 16)
                    }
                    setColorAt(e, t) {
                        return this.validateInstanceId(e),
                        this._colorsTexture === null && this._initColorsTexture(),
                        t.toArray(this._colorsTexture.image.data, e * 4),
                        this._colorsTexture.needsUpdate = !0,
                        this
                    }
                    getColorAt(e, t) {
                        return this.validateInstanceId(e),
                        t.fromArray(this._colorsTexture.image.data, e * 4)
                    }
                    setVisibleAt(e, t) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t,
                        this._visibilityChanged = !0,
                        this)
                    }
                    getVisibleAt(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].visible
                    }
                    setGeometryIdAt(e, t) {
                        return this.validateInstanceId(e),
                        this.validateGeometryId(t),
                        this._instanceInfo[e].geometryIndex = t,
                        this
                    }
                    getGeometryIdAt(e) {
                        return this.validateInstanceId(e),
                        this._instanceInfo[e].geometryIndex
                    }
                    getGeometryRangeAt(e, t={}) {
                        this.validateGeometryId(e);
                        const n = this._geometryInfo[e];
                        return t.vertexStart = n.vertexStart,
                        t.vertexCount = n.vertexCount,
                        t.reservedVertexCount = n.reservedVertexCount,
                        t.indexStart = n.indexStart,
                        t.indexCount = n.indexCount,
                        t.reservedIndexCount = n.reservedIndexCount,
                        t.start = n.start,
                        t.count = n.count,
                        t
                    }
                    setInstanceCount(e) {
                        const t = this._availableInstanceIds
                          , n = this._instanceInfo;
                        for (t.sort(nS); t[t.length - 1] === n.length - 1; )
                            n.pop(),
                            t.pop();
                        if (e < n.length)
                            throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
                        const a = new Int32Array(e)
                          , r = new Int32Array(e);
                        Xu(this._multiDrawCounts, a),
                        Xu(this._multiDrawStarts, r),
                        this._multiDrawCounts = a,
                        this._multiDrawStarts = r,
                        this._maxInstanceCount = e;
                        const c = this._indirectTexture
                          , f = this._matricesTexture
                          , p = this._colorsTexture;
                        c.dispose(),
                        this._initIndirectTexture(),
                        Xu(c.image.data, this._indirectTexture.image.data),
                        f.dispose(),
                        this._initMatricesTexture(),
                        Xu(f.image.data, this._matricesTexture.image.data),
                        p && (p.dispose(),
                        this._initColorsTexture(),
                        Xu(p.image.data, this._colorsTexture.image.data))
                    }
                    setGeometrySize(e, t) {
                        const n = [...this._geometryInfo].filter(c => c.active);
                        if (Math.max(...n.map(c => c.vertexStart + c.reservedVertexCount)) > e)
                            throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
                        if (this.geometry.index && Math.max(...n.map(c => c.indexStart + c.reservedIndexCount)) > t)
                            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
                        const a = this.geometry;
                        a.dispose(),
                        this._maxVertexCount = e,
                        this._maxIndexCount = t,
                        this._geometryInitialized && (this._geometryInitialized = !1,
                        this.geometry = new Xt,
                        this._initializeGeometry(a));
                        const r = this.geometry;
                        a.index && Xu(a.index.array, r.index.array);
                        for (const c in a.attributes)
                            Xu(a.attributes[c].array, r.attributes[c].array)
                    }
                    raycast(e, t) {
                        const n = this._instanceInfo
                          , a = this._geometryInfo
                          , r = this.matrixWorld
                          , c = this.geometry;
                        La.material = this.material,
                        La.geometry.index = c.index,
                        La.geometry.attributes = c.attributes,
                        La.geometry.boundingBox === null && (La.geometry.boundingBox = new Ra),
                        La.geometry.boundingSphere === null && (La.geometry.boundingSphere = new Sa);
                        for (let f = 0, p = n.length; f < p; f++) {
                            if (!n[f].visible || !n[f].active)
                                continue;
                            const m = n[f].geometryIndex
                              , g = a[m];
                            La.geometry.setDrawRange(g.start, g.count),
                            this.getMatrixAt(f, La.matrixWorld).premultiply(r),
                            this.getBoundingBoxAt(m, La.geometry.boundingBox),
                            this.getBoundingSphereAt(m, La.geometry.boundingSphere),
                            La.raycast(e, O0);
                            for (let v = 0, _ = O0.length; v < _; v++) {
                                const x = O0[v];
                                x.object = this,
                                x.batchId = f,
                                t.push(x)
                            }
                            O0.length = 0
                        }
                        La.material = null,
                        La.geometry.index = null,
                        La.geometry.attributes = {},
                        La.geometry.setDrawRange(0, 1 / 0)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.geometry = e.geometry.clone(),
                        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
                        this.sortObjects = e.sortObjects,
                        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
                        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
                        this._geometryInfo = e._geometryInfo.map(t => ({
                            ...t,
                            boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
                            boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
                        })),
                        this._instanceInfo = e._instanceInfo.map(t => ({
                            ...t
                        })),
                        this._availableInstanceIds = e._availableInstanceIds.slice(),
                        this._availableGeometryIds = e._availableGeometryIds.slice(),
                        this._nextIndexStart = e._nextIndexStart,
                        this._nextVertexStart = e._nextVertexStart,
                        this._geometryCount = e._geometryCount,
                        this._maxInstanceCount = e._maxInstanceCount,
                        this._maxVertexCount = e._maxVertexCount,
                        this._maxIndexCount = e._maxIndexCount,
                        this._geometryInitialized = e._geometryInitialized,
                        this._multiDrawCounts = e._multiDrawCounts.slice(),
                        this._multiDrawStarts = e._multiDrawStarts.slice(),
                        this._indirectTexture = e._indirectTexture.clone(),
                        this._indirectTexture.image.data = this._indirectTexture.image.data.slice(),
                        this._matricesTexture = e._matricesTexture.clone(),
                        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
                        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
                        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this._matricesTexture.dispose(),
                        this._matricesTexture = null,
                        this._indirectTexture.dispose(),
                        this._indirectTexture = null,
                        this._colorsTexture !== null && (this._colorsTexture.dispose(),
                        this._colorsTexture = null)
                    }
                    onBeforeRender(e, t, n, a, r) {
                        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                            return;
                        const c = a.getIndex()
                          , f = c === null ? 1 : c.array.BYTES_PER_ELEMENT
                          , p = this._instanceInfo
                          , m = this._multiDrawStarts
                          , g = this._multiDrawCounts
                          , v = this._geometryInfo
                          , _ = this.perObjectFrustumCulled
                          , x = this._indirectTexture
                          , M = x.image.data
                          , C = n.isArrayCamera ? QC : DM;
                        _ && !n.isArrayCamera && (Ms.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
                        DM.setFromProjectionMatrix(Ms, n.coordinateSystem, n.reversedDepth));
                        let R = 0;
                        if (this.sortObjects) {
                            Ms.copy(this.matrixWorld).invert(),
                            rm.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Ms),
                            NM.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(Ms);
                            for (let N = 0, I = p.length; N < I; N++)
                                if (p[N].visible && p[N].active) {
                                    const L = p[N].geometryIndex;
                                    this.getMatrixAt(N, Ms),
                                    this.getBoundingSphereAt(L, Wu).applyMatrix4(Ms);
                                    let k = !1;
                                    if (_ && (k = !C.intersectsSphere(Wu, n)),
                                    !k) {
                                        const B = v[L]
                                          , X = KC.subVectors(Wu.center, rm).dot(NM);
                                        iS.push(B.start, B.count, X, N)
                                    }
                                }
                            const A = iS.list
                              , E = this.customSort;
                            E === null ? A.sort(r.transparent ? YC : qC) : E.call(this, A, n);
                            for (let N = 0, I = A.length; N < I; N++) {
                                const L = A[N];
                                m[R] = L.start * f,
                                g[R] = L.count,
                                M[R] = L.index,
                                R++
                            }
                            iS.reset()
                        } else
                            for (let A = 0, E = p.length; A < E; A++)
                                if (p[A].visible && p[A].active) {
                                    const N = p[A].geometryIndex;
                                    let I = !1;
                                    if (_ && (this.getMatrixAt(A, Ms),
                                    this.getBoundingSphereAt(N, Wu).applyMatrix4(Ms),
                                    I = !C.intersectsSphere(Wu, n)),
                                    !I) {
                                        const L = v[N];
                                        m[R] = L.start * f,
                                        g[R] = L.count,
                                        M[R] = A,
                                        R++
                                    }
                                }
                        x.needsUpdate = !0,
                        this._multiDrawCount = R,
                        this._visibilityChanged = !1
                    }
                    onBeforeShadow(e, t, n, a, r, c) {
                        this.onBeforeRender(e, null, a, r, c)
                    }
                }
                  , is = class extends Na {
                    constructor(e) {
                        super(),
                        this.isLineBasicMaterial = !0,
                        this.type = "LineBasicMaterial",
                        this.color = new dt(16777215),
                        this.map = null,
                        this.linewidth = 1,
                        this.linecap = "round",
                        this.linejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.linewidth = e.linewidth,
                        this.linecap = e.linecap,
                        this.linejoin = e.linejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const P0 = new Y
                  , z0 = new Y
                  , UM = new Wt
                  , om = new Eh
                  , B0 = new Sa
                  , aS = new Y
                  , IM = new Y;
                var Lc = class extends Fn {
                    constructor(e=new Xt, t=new is) {
                        super(),
                        this.isLine = !0,
                        this.type = "Line",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.index === null) {
                            const t = e.attributes.position
                              , n = [0];
                            for (let a = 1, r = t.count; a < r; a++)
                                P0.fromBufferAttribute(t, a - 1),
                                z0.fromBufferAttribute(t, a),
                                n[a] = n[a - 1],
                                n[a] += P0.distanceTo(z0);
                            e.setAttribute("lineDistance", new vt(n,1))
                        } else
                            ot("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , a = this.matrixWorld
                          , r = e.params.Line.threshold
                          , c = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        B0.copy(n.boundingSphere),
                        B0.applyMatrix4(a),
                        B0.radius += r,
                        e.ray.intersectsSphere(B0) === !1)
                            return;
                        UM.copy(a).invert(),
                        om.copy(e.ray).applyMatrix4(UM);
                        const f = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , p = f * f
                          , m = this.isLineSegments ? 2 : 1
                          , g = n.index
                          , v = n.attributes.position;
                        if (g !== null) {
                            const _ = Math.max(0, c.start)
                              , x = Math.min(g.count, c.start + c.count);
                            for (let M = _, C = x - 1; M < C; M += m) {
                                const R = g.getX(M)
                                  , A = g.getX(M + 1)
                                  , E = F0(this, e, om, p, R, A, M);
                                E && t.push(E)
                            }
                            if (this.isLineLoop) {
                                const M = g.getX(x - 1)
                                  , C = g.getX(_)
                                  , R = F0(this, e, om, p, M, C, x - 1);
                                R && t.push(R)
                            }
                        } else {
                            const _ = Math.max(0, c.start)
                              , x = Math.min(v.count, c.start + c.count);
                            for (let M = _, C = x - 1; M < C; M += m) {
                                const R = F0(this, e, om, p, M, M + 1, M);
                                R && t.push(R)
                            }
                            if (this.isLineLoop) {
                                const M = F0(this, e, om, p, x - 1, _, x - 1);
                                M && t.push(M)
                            }
                        }
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let a = 0, r = n.length; a < r; a++) {
                                    const c = n[a].name || String(a);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[c] = a
                                }
                            }
                        }
                    }
                }
                ;
                function F0(e, t, n, a, r, c, f) {
                    const p = e.geometry.attributes.position;
                    if (P0.fromBufferAttribute(p, r),
                    z0.fromBufferAttribute(p, c),
                    n.distanceSqToSegment(P0, z0, aS, IM) > a)
                        return;
                    aS.applyMatrix4(e.matrixWorld);
                    const m = t.ray.origin.distanceTo(aS);
                    if (!(m < t.near || m > t.far))
                        return {
                            distance: m,
                            point: IM.clone().applyMatrix4(e.matrixWorld),
                            index: f,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: e
                        }
                }
                const OM = new Y
                  , PM = new Y;
                var Po = class extends Lc {
                    constructor(e, t) {
                        super(e, t),
                        this.isLineSegments = !0,
                        this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const e = this.geometry;
                        if (e.index === null) {
                            const t = e.attributes.position
                              , n = [];
                            for (let a = 0, r = t.count; a < r; a += 2)
                                OM.fromBufferAttribute(t, a),
                                PM.fromBufferAttribute(t, a + 1),
                                n[a] = a === 0 ? 0 : n[a - 1],
                                n[a + 1] = n[a] + OM.distanceTo(PM);
                            e.setAttribute("lineDistance", new vt(n,1))
                        } else
                            ot("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        return this
                    }
                }
                  , zM = class extends Lc {
                    constructor(e, t) {
                        super(e, t),
                        this.isLineLoop = !0,
                        this.type = "LineLoop"
                    }
                }
                  , sS = class extends Na {
                    constructor(e) {
                        super(),
                        this.isPointsMaterial = !0,
                        this.type = "PointsMaterial",
                        this.color = new dt(16777215),
                        this.map = null,
                        this.alphaMap = null,
                        this.size = 1,
                        this.sizeAttenuation = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.size = e.size,
                        this.sizeAttenuation = e.sizeAttenuation,
                        this.fog = e.fog,
                        this
                    }
                }
                ;
                const BM = new Wt
                  , rS = new Eh
                  , V0 = new Sa
                  , k0 = new Y;
                var FM = class extends Fn {
                    constructor(e=new Xt, t=new sS) {
                        super(),
                        this.isPoints = !0,
                        this.type = "Points",
                        this.geometry = e,
                        this.material = t,
                        this.morphTargetDictionary = void 0,
                        this.morphTargetInfluences = void 0,
                        this.updateMorphTargets()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                        this.geometry = e.geometry,
                        this
                    }
                    raycast(e, t) {
                        const n = this.geometry
                          , a = this.matrixWorld
                          , r = e.params.Points.threshold
                          , c = n.drawRange;
                        if (n.boundingSphere === null && n.computeBoundingSphere(),
                        V0.copy(n.boundingSphere),
                        V0.applyMatrix4(a),
                        V0.radius += r,
                        e.ray.intersectsSphere(V0) === !1)
                            return;
                        BM.copy(a).invert(),
                        rS.copy(e.ray).applyMatrix4(BM);
                        const f = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , p = f * f
                          , m = n.index
                          , g = n.attributes.position;
                        if (m !== null) {
                            const v = Math.max(0, c.start)
                              , _ = Math.min(m.count, c.start + c.count);
                            for (let x = v, M = _; x < M; x++) {
                                const C = m.getX(x);
                                k0.fromBufferAttribute(g, C),
                                VM(k0, C, p, a, e, t, this)
                            }
                        } else {
                            const v = Math.max(0, c.start)
                              , _ = Math.min(g.count, c.start + c.count);
                            for (let x = v, M = _; x < M; x++)
                                k0.fromBufferAttribute(g, x),
                                VM(k0, x, p, a, e, t, this)
                        }
                    }
                    updateMorphTargets() {
                        const e = this.geometry.morphAttributes
                          , t = Object.keys(e);
                        if (t.length > 0) {
                            const n = e[t[0]];
                            if (n !== void 0) {
                                this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                                for (let a = 0, r = n.length; a < r; a++) {
                                    const c = n[a].name || String(a);
                                    this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[c] = a
                                }
                            }
                        }
                    }
                }
                ;
                function VM(e, t, n, a, r, c, f) {
                    const p = rS.distanceSqToPoint(e);
                    if (p < n) {
                        const m = new Y;
                        rS.closestPointToPoint(e, m),
                        m.applyMatrix4(a);
                        const g = r.ray.origin.distanceTo(m);
                        if (g < r.near || g > r.far)
                            return;
                        c.push({
                            distance: g,
                            distanceToRay: Math.sqrt(p),
                            point: m,
                            index: t,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: f
                        })
                    }
                }
                var kM = class extends oa {
                    constructor(e, t, n, a, r=ei, c=ei, f, p, m) {
                        super(e, t, n, a, r, c, f, p, m),
                        this.isVideoTexture = !0,
                        this.generateMipmaps = !1,
                        this._requestVideoFrameCallbackId = 0;
                        const g = this;
                        function v() {
                            g.needsUpdate = !0,
                            g._requestVideoFrameCallbackId = e.requestVideoFrameCallback(v)
                        }
                        "requestVideoFrameCallback"in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(v))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const e = this.image;
                        !("requestVideoFrameCallback"in e) && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                    dispose() {
                        this._requestVideoFrameCallbackId !== 0 && (this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),
                        this._requestVideoFrameCallbackId = 0),
                        super.dispose()
                    }
                }
                  , $C = class extends kM {
                    constructor(e, t, n, a, r, c, f, p) {
                        super({}, e, t, n, a, r, c, f, p),
                        this.isVideoFrameTexture = !0
                    }
                    update() {}
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    setFrame(e) {
                        this.image = e,
                        this.needsUpdate = !0
                    }
                }
                  , e3 = class extends oa {
                    constructor(e, t) {
                        super({
                            width: e,
                            height: t
                        }),
                        this.isFramebufferTexture = !0,
                        this.magFilter = Oi,
                        this.minFilter = Oi,
                        this.generateMipmaps = !1,
                        this.needsUpdate = !0
                    }
                }
                  , H0 = class extends oa {
                    constructor(e, t, n, a, r, c, f, p, m, g, v, _) {
                        super(null, c, f, p, m, g, a, r, v, _),
                        this.isCompressedTexture = !0,
                        this.image = {
                            width: t,
                            height: n
                        },
                        this.mipmaps = e,
                        this.flipY = !1,
                        this.generateMipmaps = !1
                    }
                }
                  , t3 = class extends H0 {
                    constructor(e, t, n, a, r, c) {
                        super(e, t, n, r, c),
                        this.isCompressedArrayTexture = !0,
                        this.image.depth = a,
                        this.wrapR = Ss,
                        this.layerUpdates = new Set
                    }
                    addLayerUpdate(e) {
                        this.layerUpdates.add(e)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                  , n3 = class extends H0 {
                    constructor(e, t, n) {
                        super(void 0, e[0].width, e[0].height, t, n, Ro),
                        this.isCompressedCubeTexture = !0,
                        this.isCubeTexture = !0,
                        this.image = e
                    }
                }
                  , i3 = class extends oa {
                    constructor(e, t, n, a, r, c, f, p, m) {
                        super(e, t, n, a, r, c, f, p, m),
                        this.isCanvasTexture = !0,
                        this.needsUpdate = !0
                    }
                }
                  , Wh = class extends oa {
                    constructor(e, t, n=fr, a, r, c, f=Oi, p=Oi, m, g=Lo, v=1) {
                        if (g !== Lo && g !== yc)
                            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        super({
                            width: e,
                            height: t,
                            depth: v
                        }, a, r, c, f, p, g, n, m),
                        this.isDepthTexture = !0,
                        this.flipY = !1,
                        this.generateMipmaps = !1,
                        this.compareFunction = null
                    }
                    copy(e) {
                        return super.copy(e),
                        this.source = new bc(Object.assign({}, e.image)),
                        this.compareFunction = e.compareFunction,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
                        t
                    }
                }
                  , HM = class extends Wh {
                    constructor(e, t=fr, n=Ro, a, r, c=Oi, f=Oi, p, m=Lo) {
                        const g = {
                            width: e,
                            height: e,
                            depth: 1
                        }
                          , v = [g, g, g, g, g, g];
                        super(e, e, t, n, a, r, c, f, p, m),
                        this.image = v,
                        this.isCubeDepthTexture = !0,
                        this.isCubeTexture = !0
                    }
                    get images() {
                        return this.image
                    }
                    set images(e) {
                        this.image = e
                    }
                }
                  , oS = class extends oa {
                    constructor(e=null) {
                        super(),
                        this.sourceTexture = e,
                        this.isExternalTexture = !0
                    }
                    copy(e) {
                        return super.copy(e),
                        this.sourceTexture = e.sourceTexture,
                        this
                    }
                }
                  , GM = class OA extends Xt {
                    constructor(t=1, n=1, a=4, r=8, c=1) {
                        super(),
                        this.type = "CapsuleGeometry",
                        this.parameters = {
                            radius: t,
                            height: n,
                            capSegments: a,
                            radialSegments: r,
                            heightSegments: c
                        },
                        n = Math.max(0, n),
                        a = Math.max(1, Math.floor(a)),
                        r = Math.max(3, Math.floor(r)),
                        c = Math.max(1, Math.floor(c));
                        const f = []
                          , p = []
                          , m = []
                          , g = []
                          , v = n / 2
                          , _ = Math.PI / 2 * t
                          , x = n
                          , M = 2 * _ + x
                          , C = a * 2 + c
                          , R = r + 1
                          , A = new Y
                          , E = new Y;
                        for (let N = 0; N <= C; N++) {
                            let I = 0
                              , L = 0
                              , k = 0
                              , B = 0;
                            if (N <= a) {
                                const P = N / a
                                  , U = P * Math.PI / 2;
                                L = -v - t * Math.cos(U),
                                k = t * Math.sin(U),
                                B = -t * Math.cos(U),
                                I = P * _
                            } else if (N <= a + c) {
                                const P = (N - a) / c;
                                L = -v + P * n,
                                k = t,
                                B = 0,
                                I = _ + P * x
                            } else {
                                const P = (N - a - c) / a
                                  , U = P * Math.PI / 2;
                                L = v + t * Math.sin(U),
                                k = t * Math.cos(U),
                                B = t * Math.sin(U),
                                I = _ + x + P * _
                            }
                            const X = Math.max(0, Math.min(1, I / M));
                            let G = 0;
                            N === 0 ? G = .5 / r : N === C && (G = -.5 / r);
                            for (let P = 0; P <= r; P++) {
                                const U = P / r
                                  , W = U * Math.PI * 2
                                  , K = Math.sin(W)
                                  , q = Math.cos(W);
                                E.x = -k * q,
                                E.y = L,
                                E.z = k * K,
                                p.push(E.x, E.y, E.z),
                                A.set(-k * q, B, k * K),
                                A.normalize(),
                                m.push(A.x, A.y, A.z),
                                g.push(U + G, X)
                            }
                            if (N > 0) {
                                const P = (N - 1) * R;
                                for (let U = 0; U < r; U++) {
                                    const W = P + U
                                      , K = P + U + 1
                                      , q = N * R + U
                                      , te = N * R + U + 1;
                                    f.push(W, K, q),
                                    f.push(K, te, q)
                                }
                            }
                        }
                        this.setIndex(f),
                        this.setAttribute("position", new vt(p,3)),
                        this.setAttribute("normal", new vt(m,3)),
                        this.setAttribute("uv", new vt(g,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new OA(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)
                    }
                }
                  , WM = class PA extends Xt {
                    constructor(t=1, n=32, a=0, r=Math.PI * 2) {
                        super(),
                        this.type = "CircleGeometry",
                        this.parameters = {
                            radius: t,
                            segments: n,
                            thetaStart: a,
                            thetaLength: r
                        },
                        n = Math.max(3, n);
                        const c = []
                          , f = []
                          , p = []
                          , m = []
                          , g = new Y
                          , v = new Pe;
                        f.push(0, 0, 0),
                        p.push(0, 0, 1),
                        m.push(.5, .5);
                        for (let _ = 0, x = 3; _ <= n; _++,
                        x += 3) {
                            const M = a + _ / n * r;
                            g.x = t * Math.cos(M),
                            g.y = t * Math.sin(M),
                            f.push(g.x, g.y, g.z),
                            p.push(0, 0, 1),
                            v.x = (f[x] / t + 1) / 2,
                            v.y = (f[x + 1] / t + 1) / 2,
                            m.push(v.x, v.y)
                        }
                        for (let _ = 1; _ <= n; _++)
                            c.push(_, _ + 1, 0);
                        this.setIndex(c),
                        this.setAttribute("position", new vt(f,3)),
                        this.setAttribute("normal", new vt(p,3)),
                        this.setAttribute("uv", new vt(m,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new PA(t.radius,t.segments,t.thetaStart,t.thetaLength)
                    }
                }
                  , lS = class zA extends Xt {
                    constructor(t=1, n=1, a=1, r=32, c=1, f=!1, p=0, m=Math.PI * 2) {
                        super(),
                        this.type = "CylinderGeometry",
                        this.parameters = {
                            radiusTop: t,
                            radiusBottom: n,
                            height: a,
                            radialSegments: r,
                            heightSegments: c,
                            openEnded: f,
                            thetaStart: p,
                            thetaLength: m
                        };
                        const g = this;
                        r = Math.floor(r),
                        c = Math.floor(c);
                        const v = []
                          , _ = []
                          , x = []
                          , M = [];
                        let C = 0;
                        const R = []
                          , A = a / 2;
                        let E = 0;
                        N(),
                        f === !1 && (t > 0 && I(!0),
                        n > 0 && I(!1)),
                        this.setIndex(v),
                        this.setAttribute("position", new vt(_,3)),
                        this.setAttribute("normal", new vt(x,3)),
                        this.setAttribute("uv", new vt(M,2));
                        function N() {
                            const L = new Y
                              , k = new Y;
                            let B = 0;
                            const X = (n - t) / a;
                            for (let G = 0; G <= c; G++) {
                                const P = []
                                  , U = G / c
                                  , W = U * (n - t) + t;
                                for (let K = 0; K <= r; K++) {
                                    const q = K / r
                                      , te = q * m + p
                                      , ce = Math.sin(te)
                                      , J = Math.cos(te);
                                    k.x = W * ce,
                                    k.y = -U * a + A,
                                    k.z = W * J,
                                    _.push(k.x, k.y, k.z),
                                    L.set(ce, X, J).normalize(),
                                    x.push(L.x, L.y, L.z),
                                    M.push(q, 1 - U),
                                    P.push(C++)
                                }
                                R.push(P)
                            }
                            for (let G = 0; G < r; G++)
                                for (let P = 0; P < c; P++) {
                                    const U = R[P][G]
                                      , W = R[P + 1][G]
                                      , K = R[P + 1][G + 1]
                                      , q = R[P][G + 1];
                                    (t > 0 || P !== 0) && (v.push(U, W, q),
                                    B += 3),
                                    (n > 0 || P !== c - 1) && (v.push(W, K, q),
                                    B += 3)
                                }
                            g.addGroup(E, B, 0),
                            E += B
                        }
                        function I(L) {
                            const k = C
                              , B = new Pe
                              , X = new Y;
                            let G = 0;
                            const P = L === !0 ? t : n
                              , U = L === !0 ? 1 : -1;
                            for (let K = 1; K <= r; K++)
                                _.push(0, A * U, 0),
                                x.push(0, U, 0),
                                M.push(.5, .5),
                                C++;
                            const W = C;
                            for (let K = 0; K <= r; K++) {
                                const q = K / r * m + p
                                  , te = Math.cos(q)
                                  , ce = Math.sin(q);
                                X.x = P * ce,
                                X.y = A * U,
                                X.z = P * te,
                                _.push(X.x, X.y, X.z),
                                x.push(0, U, 0),
                                B.x = te * .5 + .5,
                                B.y = ce * .5 * U + .5,
                                M.push(B.x, B.y),
                                C++
                            }
                            for (let K = 0; K < r; K++) {
                                const q = k + K
                                  , te = W + K;
                                L === !0 ? v.push(te, te + 1, q) : v.push(te + 1, te, q),
                                G += 3
                            }
                            g.addGroup(E, G, L === !0 ? 1 : 2),
                            E += G
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new zA(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)
                    }
                }
                  , cS = class BA extends lS {
                    constructor(t=1, n=1, a=32, r=1, c=!1, f=0, p=Math.PI * 2) {
                        super(0, t, n, a, r, c, f, p),
                        this.type = "ConeGeometry",
                        this.parameters = {
                            radius: t,
                            height: n,
                            radialSegments: a,
                            heightSegments: r,
                            openEnded: c,
                            thetaStart: f,
                            thetaLength: p
                        }
                    }
                    static fromJSON(t) {
                        return new BA(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)
                    }
                }
                  , Xh = class FA extends Xt {
                    constructor(t=[], n=[], a=1, r=0) {
                        super(),
                        this.type = "PolyhedronGeometry",
                        this.parameters = {
                            vertices: t,
                            indices: n,
                            radius: a,
                            detail: r
                        };
                        const c = []
                          , f = [];
                        p(r),
                        g(a),
                        v(),
                        this.setAttribute("position", new vt(c,3)),
                        this.setAttribute("normal", new vt(c.slice(),3)),
                        this.setAttribute("uv", new vt(f,2)),
                        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
                        function p(N) {
                            const I = new Y
                              , L = new Y
                              , k = new Y;
                            for (let B = 0; B < n.length; B += 3)
                                M(n[B + 0], I),
                                M(n[B + 1], L),
                                M(n[B + 2], k),
                                m(I, L, k, N)
                        }
                        function m(N, I, L, k) {
                            const B = k + 1
                              , X = [];
                            for (let G = 0; G <= B; G++) {
                                X[G] = [];
                                const P = N.clone().lerp(L, G / B)
                                  , U = I.clone().lerp(L, G / B)
                                  , W = B - G;
                                for (let K = 0; K <= W; K++)
                                    K === 0 && G === B ? X[G][K] = P : X[G][K] = P.clone().lerp(U, K / W)
                            }
                            for (let G = 0; G < B; G++)
                                for (let P = 0; P < 2 * (B - G) - 1; P++) {
                                    const U = Math.floor(P / 2);
                                    P % 2 === 0 ? (x(X[G][U + 1]),
                                    x(X[G + 1][U]),
                                    x(X[G][U])) : (x(X[G][U + 1]),
                                    x(X[G + 1][U + 1]),
                                    x(X[G + 1][U]))
                                }
                        }
                        function g(N) {
                            const I = new Y;
                            for (let L = 0; L < c.length; L += 3)
                                I.x = c[L + 0],
                                I.y = c[L + 1],
                                I.z = c[L + 2],
                                I.normalize().multiplyScalar(N),
                                c[L + 0] = I.x,
                                c[L + 1] = I.y,
                                c[L + 2] = I.z
                        }
                        function v() {
                            const N = new Y;
                            for (let I = 0; I < c.length; I += 3) {
                                N.x = c[I + 0],
                                N.y = c[I + 1],
                                N.z = c[I + 2];
                                const L = A(N) / 2 / Math.PI + .5
                                  , k = E(N) / Math.PI + .5;
                                f.push(L, 1 - k)
                            }
                            C(),
                            _()
                        }
                        function _() {
                            for (let N = 0; N < f.length; N += 6) {
                                const I = f[N + 0]
                                  , L = f[N + 2]
                                  , k = f[N + 4];
                                Math.max(I, L, k) > .9 && Math.min(I, L, k) < .1 && (I < .2 && (f[N + 0] += 1),
                                L < .2 && (f[N + 2] += 1),
                                k < .2 && (f[N + 4] += 1))
                            }
                        }
                        function x(N) {
                            c.push(N.x, N.y, N.z)
                        }
                        function M(N, I) {
                            const L = N * 3;
                            I.x = t[L + 0],
                            I.y = t[L + 1],
                            I.z = t[L + 2]
                        }
                        function C() {
                            const N = new Y
                              , I = new Y
                              , L = new Y
                              , k = new Y
                              , B = new Pe
                              , X = new Pe
                              , G = new Pe;
                            for (let P = 0, U = 0; P < c.length; P += 9,
                            U += 6) {
                                N.set(c[P + 0], c[P + 1], c[P + 2]),
                                I.set(c[P + 3], c[P + 4], c[P + 5]),
                                L.set(c[P + 6], c[P + 7], c[P + 8]),
                                B.set(f[U + 0], f[U + 1]),
                                X.set(f[U + 2], f[U + 3]),
                                G.set(f[U + 4], f[U + 5]),
                                k.copy(N).add(I).add(L).divideScalar(3);
                                const W = A(k);
                                R(B, U + 0, N, W),
                                R(X, U + 2, I, W),
                                R(G, U + 4, L, W)
                            }
                        }
                        function R(N, I, L, k) {
                            k < 0 && N.x === 1 && (f[I] = N.x - 1),
                            L.x === 0 && L.z === 0 && (f[I] = k / 2 / Math.PI + .5)
                        }
                        function A(N) {
                            return Math.atan2(N.z, -N.x)
                        }
                        function E(N) {
                            return Math.atan2(-N.y, Math.sqrt(N.x * N.x + N.z * N.z))
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new FA(t.vertices,t.indices,t.radius,t.detail)
                    }
                }
                  , XM = class VA extends Xh {
                    constructor(t=1, n=0) {
                        const a = (1 + Math.sqrt(5)) / 2
                          , r = 1 / a
                          , c = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -a, 0, -r, a, 0, r, -a, 0, r, a, -r, -a, 0, -r, a, 0, r, -a, 0, r, a, 0, -a, 0, -r, a, 0, -r, -a, 0, r, a, 0, r];
                        super(c, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, n),
                        this.type = "DodecahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new VA(t.radius,t.detail)
                    }
                }
                ;
                const G0 = new Y
                  , W0 = new Y
                  , uS = new Y
                  , X0 = new wc;
                var qM = class extends Xt {
                    constructor(e=null, t=1) {
                        if (super(),
                        this.type = "EdgesGeometry",
                        this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        },
                        e !== null) {
                            const n = Math.pow(10, 4)
                              , a = Math.cos(Fu * t)
                              , r = e.getIndex()
                              , c = e.getAttribute("position")
                              , f = r ? r.count : c.count
                              , p = [0, 0, 0]
                              , m = ["a", "b", "c"]
                              , g = new Array(3)
                              , v = {}
                              , _ = [];
                            for (let x = 0; x < f; x += 3) {
                                r ? (p[0] = r.getX(x),
                                p[1] = r.getX(x + 1),
                                p[2] = r.getX(x + 2)) : (p[0] = x,
                                p[1] = x + 1,
                                p[2] = x + 2);
                                const {a: M, b: C, c: R} = X0;
                                if (M.fromBufferAttribute(c, p[0]),
                                C.fromBufferAttribute(c, p[1]),
                                R.fromBufferAttribute(c, p[2]),
                                X0.getNormal(uS),
                                g[0] = `${Math.round(M.x * n)},${Math.round(M.y * n)},${Math.round(M.z * n)}`,
                                g[1] = `${Math.round(C.x * n)},${Math.round(C.y * n)},${Math.round(C.z * n)}`,
                                g[2] = `${Math.round(R.x * n)},${Math.round(R.y * n)},${Math.round(R.z * n)}`,
                                !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
                                    for (let A = 0; A < 3; A++) {
                                        const E = (A + 1) % 3
                                          , N = g[A]
                                          , I = g[E]
                                          , L = X0[m[A]]
                                          , k = X0[m[E]]
                                          , B = `${N}_${I}`
                                          , X = `${I}_${N}`;
                                        X in v && v[X] ? (uS.dot(v[X].normal) <= a && (_.push(L.x, L.y, L.z),
                                        _.push(k.x, k.y, k.z)),
                                        v[X] = null) : B in v || (v[B] = {
                                            index0: p[A],
                                            index1: p[E],
                                            normal: uS.clone()
                                        })
                                    }
                            }
                            for (const x in v)
                                if (v[x]) {
                                    const {index0: M, index1: C} = v[x];
                                    G0.fromBufferAttribute(c, M),
                                    W0.fromBufferAttribute(c, C),
                                    _.push(G0.x, G0.y, G0.z),
                                    _.push(W0.x, W0.y, W0.z)
                                }
                            this.setAttribute("position", new vt(_,3))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                }
                  , Wr = class {
                    constructor() {
                        this.type = "Curve",
                        this.arcLengthDivisions = 200,
                        this.needsUpdate = !1,
                        this.cacheArcLengths = null
                    }
                    getPoint() {
                        ot("Curve: .getPoint() not implemented.")
                    }
                    getPointAt(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getPoint(n, t)
                    }
                    getPoints(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return t
                    }
                    getSpacedPoints(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPointAt(n / e));
                        return t
                    }
                    getLength() {
                        const e = this.getLengths();
                        return e[e.length - 1]
                    }
                    getLengths(e=this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const t = [];
                        let n, a = this.getPoint(0), r = 0;
                        t.push(0);
                        for (let c = 1; c <= e; c++)
                            n = this.getPoint(c / e),
                            r += n.distanceTo(a),
                            t.push(r),
                            a = n;
                        return this.cacheArcLengths = t,
                        t
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.getLengths()
                    }
                    getUtoTmapping(e, t=null) {
                        const n = this.getLengths();
                        let a = 0;
                        const r = n.length;
                        let c;
                        t ? c = t : c = e * n[r - 1];
                        let f = 0, p = r - 1, m;
                        for (; f <= p; )
                            if (a = Math.floor(f + (p - f) / 2),
                            m = n[a] - c,
                            m < 0)
                                f = a + 1;
                            else if (m > 0)
                                p = a - 1;
                            else {
                                p = a;
                                break
                            }
                        if (a = p,
                        n[a] === c)
                            return a / (r - 1);
                        const g = n[a]
                          , v = n[a + 1] - g
                          , _ = (c - g) / v;
                        return (a + _) / (r - 1)
                    }
                    getTangent(e, t) {
                        let a = e - 1e-4
                          , r = e + 1e-4;
                        a < 0 && (a = 0),
                        r > 1 && (r = 1);
                        const c = this.getPoint(a)
                          , f = this.getPoint(r)
                          , p = t || (c.isVector2 ? new Pe : new Y);
                        return p.copy(f).sub(c).normalize(),
                        p
                    }
                    getTangentAt(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getTangent(n, t)
                    }
                    computeFrenetFrames(e, t=!1) {
                        const n = new Y
                          , a = []
                          , r = []
                          , c = []
                          , f = new Y
                          , p = new Wt;
                        for (let x = 0; x <= e; x++) {
                            const M = x / e;
                            a[x] = this.getTangentAt(M, new Y)
                        }
                        r[0] = new Y,
                        c[0] = new Y;
                        let m = Number.MAX_VALUE;
                        const g = Math.abs(a[0].x)
                          , v = Math.abs(a[0].y)
                          , _ = Math.abs(a[0].z);
                        g <= m && (m = g,
                        n.set(1, 0, 0)),
                        v <= m && (m = v,
                        n.set(0, 1, 0)),
                        _ <= m && n.set(0, 0, 1),
                        f.crossVectors(a[0], n).normalize(),
                        r[0].crossVectors(a[0], f),
                        c[0].crossVectors(a[0], r[0]);
                        for (let x = 1; x <= e; x++) {
                            if (r[x] = r[x - 1].clone(),
                            c[x] = c[x - 1].clone(),
                            f.crossVectors(a[x - 1], a[x]),
                            f.length() > Number.EPSILON) {
                                f.normalize();
                                const M = Math.acos(Bt(a[x - 1].dot(a[x]), -1, 1));
                                r[x].applyMatrix4(p.makeRotationAxis(f, M))
                            }
                            c[x].crossVectors(a[x], r[x])
                        }
                        if (t === !0) {
                            let x = Math.acos(Bt(r[0].dot(r[e]), -1, 1));
                            x /= e,
                            a[0].dot(f.crossVectors(r[0], r[e])) > 0 && (x = -x);
                            for (let M = 1; M <= e; M++)
                                r[M].applyMatrix4(p.makeRotationAxis(a[M], x * M)),
                                c[M].crossVectors(a[M], r[M])
                        }
                        return {
                            tangents: a,
                            normals: r,
                            binormals: c
                        }
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                    toJSON() {
                        const e = {
                            metadata: {
                                version: 4.7,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return e.arcLengthDivisions = this.arcLengthDivisions,
                        e.type = this.type,
                        e
                    }
                    fromJSON(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                }
                  , q0 = class extends Wr {
                    constructor(e=0, t=0, n=1, a=1, r=0, c=Math.PI * 2, f=!1, p=0) {
                        super(),
                        this.isEllipseCurve = !0,
                        this.type = "EllipseCurve",
                        this.aX = e,
                        this.aY = t,
                        this.xRadius = n,
                        this.yRadius = a,
                        this.aStartAngle = r,
                        this.aEndAngle = c,
                        this.aClockwise = f,
                        this.aRotation = p
                    }
                    getPoint(e, t=new Pe) {
                        const n = t
                          , a = Math.PI * 2;
                        let r = this.aEndAngle - this.aStartAngle;
                        const c = Math.abs(r) < Number.EPSILON;
                        for (; r < 0; )
                            r += a;
                        for (; r > a; )
                            r -= a;
                        r < Number.EPSILON && (c ? r = 0 : r = a),
                        this.aClockwise === !0 && !c && (r === a ? r = -a : r = r - a);
                        const f = this.aStartAngle + e * r;
                        let p = this.aX + this.xRadius * Math.cos(f)
                          , m = this.aY + this.yRadius * Math.sin(f);
                        if (this.aRotation !== 0) {
                            const g = Math.cos(this.aRotation)
                              , v = Math.sin(this.aRotation)
                              , _ = p - this.aX
                              , x = m - this.aY;
                            p = _ * g - x * v + this.aX,
                            m = _ * v + x * g + this.aY
                        }
                        return n.set(p, m)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.aX = e.aX,
                        this.aY = e.aY,
                        this.xRadius = e.xRadius,
                        this.yRadius = e.yRadius,
                        this.aStartAngle = e.aStartAngle,
                        this.aEndAngle = e.aEndAngle,
                        this.aClockwise = e.aClockwise,
                        this.aRotation = e.aRotation,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.aX = this.aX,
                        e.aY = this.aY,
                        e.xRadius = this.xRadius,
                        e.yRadius = this.yRadius,
                        e.aStartAngle = this.aStartAngle,
                        e.aEndAngle = this.aEndAngle,
                        e.aClockwise = this.aClockwise,
                        e.aRotation = this.aRotation,
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.aX = e.aX,
                        this.aY = e.aY,
                        this.xRadius = e.xRadius,
                        this.yRadius = e.yRadius,
                        this.aStartAngle = e.aStartAngle,
                        this.aEndAngle = e.aEndAngle,
                        this.aClockwise = e.aClockwise,
                        this.aRotation = e.aRotation,
                        this
                    }
                }
                  , YM = class extends q0 {
                    constructor(e, t, n, a, r, c) {
                        super(e, t, n, n, a, r, c),
                        this.isArcCurve = !0,
                        this.type = "ArcCurve"
                    }
                }
                ;
                function fS() {
                    let e = 0
                      , t = 0
                      , n = 0
                      , a = 0;
                    function r(c, f, p, m) {
                        e = c,
                        t = p,
                        n = -3 * c + 3 * f - 2 * p - m,
                        a = 2 * c - 2 * f + p + m
                    }
                    return {
                        initCatmullRom: function(c, f, p, m, g) {
                            r(f, p, g * (p - c), g * (m - f))
                        },
                        initNonuniformCatmullRom: function(c, f, p, m, g, v, _) {
                            let x = (f - c) / g - (p - c) / (g + v) + (p - f) / v
                              , M = (p - f) / v - (m - f) / (v + _) + (m - p) / _;
                            x *= v,
                            M *= v,
                            r(f, p, x, M)
                        },
                        calc: function(c) {
                            const f = c * c
                              , p = f * c;
                            return e + t * c + n * f + a * p
                        }
                    }
                }
                const Y0 = new Y
                  , hS = new fS
                  , dS = new fS
                  , pS = new fS;
                var jM = class extends Wr {
                    constructor(e=[], t=!1, n="centripetal", a=.5) {
                        super(),
                        this.isCatmullRomCurve3 = !0,
                        this.type = "CatmullRomCurve3",
                        this.points = e,
                        this.closed = t,
                        this.curveType = n,
                        this.tension = a
                    }
                    getPoint(e, t=new Y) {
                        const n = t
                          , a = this.points
                          , r = a.length
                          , c = (r - (this.closed ? 0 : 1)) * e;
                        let f = Math.floor(c)
                          , p = c - f;
                        this.closed ? f += f > 0 ? 0 : (Math.floor(Math.abs(f) / r) + 1) * r : p === 0 && f === r - 1 && (f = r - 2,
                        p = 1);
                        let m, g;
                        this.closed || f > 0 ? m = a[(f - 1) % r] : (Y0.subVectors(a[0], a[1]).add(a[0]),
                        m = Y0);
                        const v = a[f % r]
                          , _ = a[(f + 1) % r];
                        if (this.closed || f + 2 < r ? g = a[(f + 2) % r] : (Y0.subVectors(a[r - 1], a[r - 2]).add(a[r - 1]),
                        g = Y0),
                        this.curveType === "centripetal" || this.curveType === "chordal") {
                            const x = this.curveType === "chordal" ? .5 : .25;
                            let M = Math.pow(m.distanceToSquared(v), x)
                              , C = Math.pow(v.distanceToSquared(_), x)
                              , R = Math.pow(_.distanceToSquared(g), x);
                            C < 1e-4 && (C = 1),
                            M < 1e-4 && (M = C),
                            R < 1e-4 && (R = C),
                            hS.initNonuniformCatmullRom(m.x, v.x, _.x, g.x, M, C, R),
                            dS.initNonuniformCatmullRom(m.y, v.y, _.y, g.y, M, C, R),
                            pS.initNonuniformCatmullRom(m.z, v.z, _.z, g.z, M, C, R)
                        } else
                            this.curveType === "catmullrom" && (hS.initCatmullRom(m.x, v.x, _.x, g.x, this.tension),
                            dS.initCatmullRom(m.y, v.y, _.y, g.y, this.tension),
                            pS.initCatmullRom(m.z, v.z, _.z, g.z, this.tension));
                        return n.set(hS.calc(p), dS.calc(p), pS.calc(p)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const a = e.points[t];
                            this.points.push(a.clone())
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const a = this.points[t];
                            e.points.push(a.toArray())
                        }
                        return e.closed = this.closed,
                        e.curveType = this.curveType,
                        e.tension = this.tension,
                        e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const a = e.points[t];
                            this.points.push(new Y().fromArray(a))
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                }
                ;
                function ZM(e, t, n, a, r) {
                    const c = (a - t) * .5
                      , f = (r - n) * .5
                      , p = e * e
                      , m = e * p;
                    return (2 * n - 2 * a + c + f) * m + (-3 * n + 3 * a - 2 * c - f) * p + c * e + n
                }
                function a3(e, t) {
                    const n = 1 - e;
                    return n * n * t
                }
                function s3(e, t) {
                    return 2 * (1 - e) * e * t
                }
                function r3(e, t) {
                    return e * e * t
                }
                function lm(e, t, n, a) {
                    return a3(e, t) + s3(e, n) + r3(e, a)
                }
                function o3(e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }
                function l3(e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }
                function c3(e, t) {
                    return 3 * (1 - e) * e * e * t
                }
                function u3(e, t) {
                    return e * e * e * t
                }
                function cm(e, t, n, a, r) {
                    return o3(e, t) + l3(e, n) + c3(e, a) + u3(e, r)
                }
                var mS = class extends Wr {
                    constructor(e=new Pe, t=new Pe, n=new Pe, a=new Pe) {
                        super(),
                        this.isCubicBezierCurve = !0,
                        this.type = "CubicBezierCurve",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = a
                    }
                    getPoint(e, t=new Pe) {
                        const n = t
                          , a = this.v0
                          , r = this.v1
                          , c = this.v2
                          , f = this.v3;
                        return n.set(cm(e, a.x, r.x, c.x, f.x), cm(e, a.y, r.y, c.y, f.y)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                  , QM = class extends Wr {
                    constructor(e=new Y, t=new Y, n=new Y, a=new Y) {
                        super(),
                        this.isCubicBezierCurve3 = !0,
                        this.type = "CubicBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = a
                    }
                    getPoint(e, t=new Y) {
                        const n = t
                          , a = this.v0
                          , r = this.v1
                          , c = this.v2
                          , f = this.v3;
                        return n.set(cm(e, a.x, r.x, c.x, f.x), cm(e, a.y, r.y, c.y, f.y), cm(e, a.z, r.z, c.z, f.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                  , gS = class extends Wr {
                    constructor(e=new Pe, t=new Pe) {
                        super(),
                        this.isLineCurve = !0,
                        this.type = "LineCurve",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new Pe) {
                        const n = t;
                        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new Pe) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , KM = class extends Wr {
                    constructor(e=new Y, t=new Y) {
                        super(),
                        this.isLineCurve3 = !0,
                        this.type = "LineCurve3",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new Y) {
                        const n = t;
                        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new Y) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , vS = class extends Wr {
                    constructor(e=new Pe, t=new Pe, n=new Pe) {
                        super(),
                        this.isQuadraticBezierCurve = !0,
                        this.type = "QuadraticBezierCurve",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n
                    }
                    getPoint(e, t=new Pe) {
                        const n = t
                          , a = this.v0
                          , r = this.v1
                          , c = this.v2;
                        return n.set(lm(e, a.x, r.x, c.x), lm(e, a.y, r.y, c.y)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , yS = class extends Wr {
                    constructor(e=new Y, t=new Y, n=new Y) {
                        super(),
                        this.isQuadraticBezierCurve3 = !0,
                        this.type = "QuadraticBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n
                    }
                    getPoint(e, t=new Y) {
                        const n = t
                          , a = this.v0
                          , r = this.v1
                          , c = this.v2;
                        return n.set(lm(e, a.x, r.x, c.x), lm(e, a.y, r.y, c.y), lm(e, a.z, r.z, c.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                  , _S = class extends Wr {
                    constructor(e=[]) {
                        super(),
                        this.isSplineCurve = !0,
                        this.type = "SplineCurve",
                        this.points = e
                    }
                    getPoint(e, t=new Pe) {
                        const n = t
                          , a = this.points
                          , r = (a.length - 1) * e
                          , c = Math.floor(r)
                          , f = r - c
                          , p = a[c === 0 ? c : c - 1]
                          , m = a[c]
                          , g = a[c > a.length - 2 ? a.length - 1 : c + 1]
                          , v = a[c > a.length - 3 ? a.length - 1 : c + 2];
                        return n.set(ZM(f, p.x, m.x, g.x, v.x), ZM(f, p.y, m.y, g.y, v.y)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const a = e.points[t];
                            this.points.push(a.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const a = this.points[t];
                            e.points.push(a.toArray())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const a = e.points[t];
                            this.points.push(new Pe().fromArray(a))
                        }
                        return this
                    }
                }
                  , j0 = Object.freeze({
                    __proto__: null,
                    ArcCurve: YM,
                    CatmullRomCurve3: jM,
                    CubicBezierCurve: mS,
                    CubicBezierCurve3: QM,
                    EllipseCurve: q0,
                    LineCurve: gS,
                    LineCurve3: KM,
                    QuadraticBezierCurve: vS,
                    QuadraticBezierCurve3: yS,
                    SplineCurve: _S
                })
                  , JM = class extends Wr {
                    constructor() {
                        super(),
                        this.type = "CurvePath",
                        this.curves = [],
                        this.autoClose = !1
                    }
                    add(e) {
                        this.curves.push(e)
                    }
                    closePath() {
                        const e = this.curves[0].getPoint(0)
                          , t = this.curves[this.curves.length - 1].getPoint(1);
                        if (!e.equals(t)) {
                            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                            this.curves.push(new j0[n](t,e))
                        }
                        return this
                    }
                    getPoint(e, t) {
                        const n = e * this.getLength()
                          , a = this.getCurveLengths();
                        let r = 0;
                        for (; r < a.length; ) {
                            if (a[r] >= n) {
                                const c = a[r] - n
                                  , f = this.curves[r]
                                  , p = f.getLength()
                                  , m = p === 0 ? 0 : 1 - c / p;
                                return f.getPointAt(m, t)
                            }
                            r++
                        }
                        return null
                    }
                    getLength() {
                        const e = this.getCurveLengths();
                        return e[e.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0,
                        this.cacheLengths = null,
                        this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                            return this.cacheLengths;
                        const e = [];
                        let t = 0;
                        for (let n = 0, a = this.curves.length; n < a; n++)
                            t += this.curves[n].getLength(),
                            e.push(t);
                        return this.cacheLengths = e,
                        e
                    }
                    getSpacedPoints(e=40) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return this.autoClose && t.push(t[0]),
                        t
                    }
                    getPoints(e=12) {
                        const t = [];
                        let n;
                        for (let a = 0, r = this.curves; a < r.length; a++) {
                            const c = r[a]
                              , f = c.isEllipseCurve ? e * 2 : c.isLineCurve || c.isLineCurve3 ? 1 : c.isSplineCurve ? e * c.points.length : e
                              , p = c.getPoints(f);
                            for (let m = 0; m < p.length; m++) {
                                const g = p[m];
                                n && n.equals(g) || (t.push(g),
                                n = g)
                            }
                        }
                        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                        t
                    }
                    copy(e) {
                        super.copy(e),
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const a = e.curves[t];
                            this.curves.push(a.clone())
                        }
                        return this.autoClose = e.autoClose,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.autoClose = this.autoClose,
                        e.curves = [];
                        for (let t = 0, n = this.curves.length; t < n; t++) {
                            const a = this.curves[t];
                            e.curves.push(a.toJSON())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.autoClose = e.autoClose,
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const a = e.curves[t];
                            this.curves.push(new j0[a.type]().fromJSON(a))
                        }
                        return this
                    }
                }
                  , Z0 = class extends JM {
                    constructor(e) {
                        super(),
                        this.type = "Path",
                        this.currentPoint = new Pe,
                        e && this.setFromPoints(e)
                    }
                    setFromPoints(e) {
                        this.moveTo(e[0].x, e[0].y);
                        for (let t = 1, n = e.length; t < n; t++)
                            this.lineTo(e[t].x, e[t].y);
                        return this
                    }
                    moveTo(e, t) {
                        return this.currentPoint.set(e, t),
                        this
                    }
                    lineTo(e, t) {
                        const n = new gS(this.currentPoint.clone(),new Pe(e,t));
                        return this.curves.push(n),
                        this.currentPoint.set(e, t),
                        this
                    }
                    quadraticCurveTo(e, t, n, a) {
                        const r = new vS(this.currentPoint.clone(),new Pe(e,t),new Pe(n,a));
                        return this.curves.push(r),
                        this.currentPoint.set(n, a),
                        this
                    }
                    bezierCurveTo(e, t, n, a, r, c) {
                        const f = new mS(this.currentPoint.clone(),new Pe(e,t),new Pe(n,a),new Pe(r,c));
                        return this.curves.push(f),
                        this.currentPoint.set(r, c),
                        this
                    }
                    splineThru(e) {
                        const t = new _S([this.currentPoint.clone()].concat(e));
                        return this.curves.push(t),
                        this.currentPoint.copy(e[e.length - 1]),
                        this
                    }
                    arc(e, t, n, a, r, c) {
                        const f = this.currentPoint.x
                          , p = this.currentPoint.y;
                        return this.absarc(e + f, t + p, n, a, r, c),
                        this
                    }
                    absarc(e, t, n, a, r, c) {
                        return this.absellipse(e, t, n, n, a, r, c),
                        this
                    }
                    ellipse(e, t, n, a, r, c, f, p) {
                        const m = this.currentPoint.x
                          , g = this.currentPoint.y;
                        return this.absellipse(e + m, t + g, n, a, r, c, f, p),
                        this
                    }
                    absellipse(e, t, n, a, r, c, f, p) {
                        const m = new q0(e,t,n,a,r,c,f,p);
                        if (this.curves.length > 0) {
                            const v = m.getPoint(0);
                            v.equals(this.currentPoint) || this.lineTo(v.x, v.y)
                        }
                        this.curves.push(m);
                        const g = m.getPoint(1);
                        return this.currentPoint.copy(g),
                        this
                    }
                    copy(e) {
                        return super.copy(e),
                        this.currentPoint.copy(e.currentPoint),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.currentPoint = this.currentPoint.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.currentPoint.fromArray(e.currentPoint),
                        this
                    }
                }
                  , qu = class extends Z0 {
                    constructor(e) {
                        super(e),
                        this.uuid = Fs(),
                        this.type = "Shape",
                        this.holes = []
                    }
                    getPointsHoles(e) {
                        const t = [];
                        for (let n = 0, a = this.holes.length; n < a; n++)
                            t[n] = this.holes[n].getPoints(e);
                        return t
                    }
                    extractPoints(e) {
                        return {
                            shape: this.getPoints(e),
                            holes: this.getPointsHoles(e)
                        }
                    }
                    copy(e) {
                        super.copy(e),
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const a = e.holes[t];
                            this.holes.push(a.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.uuid = this.uuid,
                        e.holes = [];
                        for (let t = 0, n = this.holes.length; t < n; t++) {
                            const a = this.holes[t];
                            e.holes.push(a.toJSON())
                        }
                        return e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.uuid = e.uuid,
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const a = e.holes[t];
                            this.holes.push(new Z0().fromJSON(a))
                        }
                        return this
                    }
                }
                ;
                function f3(e, t, n=2) {
                    const a = t && t.length
                      , r = a ? t[0] * n : e.length;
                    let c = $M(e, 0, r, n, !0);
                    const f = [];
                    if (!c || c.next === c.prev)
                        return f;
                    let p, m, g;
                    if (a && (c = g3(e, t, c, n)),
                    e.length > 80 * n) {
                        p = e[0],
                        m = e[1];
                        let v = p
                          , _ = m;
                        for (let x = n; x < r; x += n) {
                            const M = e[x]
                              , C = e[x + 1];
                            M < p && (p = M),
                            C < m && (m = C),
                            M > v && (v = M),
                            C > _ && (_ = C)
                        }
                        g = Math.max(v - p, _ - m),
                        g = g !== 0 ? 32767 / g : 0
                    }
                    return um(c, f, n, p, m, g, 0),
                    f
                }
                function $M(e, t, n, a, r) {
                    let c;
                    if (r === w3(e, t, n, a) > 0)
                        for (let f = t; f < n; f += a)
                            c = iT(f / a | 0, e[f], e[f + 1], c);
                    else
                        for (let f = n - a; f >= t; f -= a)
                            c = iT(f / a | 0, e[f], e[f + 1], c);
                    return c && qh(c, c.next) && (dm(c),
                    c = c.next),
                    c
                }
                function Yu(e, t) {
                    if (!e)
                        return e;
                    t || (t = e);
                    let n = e, a;
                    do
                        if (a = !1,
                        !n.steiner && (qh(n, n.next) || _i(n.prev, n, n.next) === 0)) {
                            if (dm(n),
                            n = t = n.prev,
                            n === n.next)
                                break;
                            a = !0
                        } else
                            n = n.next;
                    while (a || n !== t);
                    return t
                }
                function um(e, t, n, a, r, c, f) {
                    if (!e)
                        return;
                    !f && c && x3(e, a, r, c);
                    let p = e;
                    for (; e.prev !== e.next; ) {
                        const m = e.prev
                          , g = e.next;
                        if (c ? d3(e, a, r, c) : h3(e)) {
                            t.push(m.i, e.i, g.i),
                            dm(e),
                            e = g.next,
                            p = g.next;
                            continue
                        }
                        if (e = g,
                        e === p) {
                            f ? f === 1 ? (e = p3(Yu(e), t),
                            um(e, t, n, a, r, c, 2)) : f === 2 && m3(e, t, n, a, r, c) : um(Yu(e), t, n, a, r, c, 1);
                            break
                        }
                    }
                }
                function h3(e) {
                    const t = e.prev
                      , n = e
                      , a = e.next;
                    if (_i(t, n, a) >= 0)
                        return !1;
                    const r = t.x
                      , c = n.x
                      , f = a.x
                      , p = t.y
                      , m = n.y
                      , g = a.y
                      , v = Math.min(r, c, f)
                      , _ = Math.min(p, m, g)
                      , x = Math.max(r, c, f)
                      , M = Math.max(p, m, g);
                    let C = a.next;
                    for (; C !== t; ) {
                        if (C.x >= v && C.x <= x && C.y >= _ && C.y <= M && fm(r, p, c, m, f, g, C.x, C.y) && _i(C.prev, C, C.next) >= 0)
                            return !1;
                        C = C.next
                    }
                    return !0
                }
                function d3(e, t, n, a) {
                    const r = e.prev
                      , c = e
                      , f = e.next;
                    if (_i(r, c, f) >= 0)
                        return !1;
                    const p = r.x
                      , m = c.x
                      , g = f.x
                      , v = r.y
                      , _ = c.y
                      , x = f.y
                      , M = Math.min(p, m, g)
                      , C = Math.min(v, _, x)
                      , R = Math.max(p, m, g)
                      , A = Math.max(v, _, x)
                      , E = SS(M, C, t, n, a)
                      , N = SS(R, A, t, n, a);
                    let I = e.prevZ
                      , L = e.nextZ;
                    for (; I && I.z >= E && L && L.z <= N; ) {
                        if (I.x >= M && I.x <= R && I.y >= C && I.y <= A && I !== r && I !== f && fm(p, v, m, _, g, x, I.x, I.y) && _i(I.prev, I, I.next) >= 0 || (I = I.prevZ,
                        L.x >= M && L.x <= R && L.y >= C && L.y <= A && L !== r && L !== f && fm(p, v, m, _, g, x, L.x, L.y) && _i(L.prev, L, L.next) >= 0))
                            return !1;
                        L = L.nextZ
                    }
                    for (; I && I.z >= E; ) {
                        if (I.x >= M && I.x <= R && I.y >= C && I.y <= A && I !== r && I !== f && fm(p, v, m, _, g, x, I.x, I.y) && _i(I.prev, I, I.next) >= 0)
                            return !1;
                        I = I.prevZ
                    }
                    for (; L && L.z <= N; ) {
                        if (L.x >= M && L.x <= R && L.y >= C && L.y <= A && L !== r && L !== f && fm(p, v, m, _, g, x, L.x, L.y) && _i(L.prev, L, L.next) >= 0)
                            return !1;
                        L = L.nextZ
                    }
                    return !0
                }
                function p3(e, t) {
                    let n = e;
                    do {
                        const a = n.prev
                          , r = n.next.next;
                        !qh(a, r) && tT(a, n, n.next, r) && hm(a, r) && hm(r, a) && (t.push(a.i, n.i, r.i),
                        dm(n),
                        dm(n.next),
                        n = e = r),
                        n = n.next
                    } while (n !== e);
                    return Yu(n)
                }
                function m3(e, t, n, a, r, c) {
                    let f = e;
                    do {
                        let p = f.next.next;
                        for (; p !== f.prev; ) {
                            if (f.i !== p.i && T3(f, p)) {
                                let m = nT(f, p);
                                f = Yu(f, f.next),
                                m = Yu(m, m.next),
                                um(f, t, n, a, r, c, 0),
                                um(m, t, n, a, r, c, 0);
                                return
                            }
                            p = p.next
                        }
                        f = f.next
                    } while (f !== e)
                }
                function g3(e, t, n, a) {
                    const r = [];
                    for (let c = 0, f = t.length; c < f; c++) {
                        const p = $M(e, t[c] * a, c < f - 1 ? t[c + 1] * a : e.length, a, !1);
                        p === p.next && (p.steiner = !0),
                        r.push(M3(p))
                    }
                    r.sort(v3);
                    for (let c = 0; c < r.length; c++)
                        n = y3(r[c], n);
                    return n
                }
                function v3(e, t) {
                    let n = e.x - t.x;
                    return n === 0 && (n = e.y - t.y,
                    n === 0 && (n = (e.next.y - e.y) / (e.next.x - e.x) - (t.next.y - t.y) / (t.next.x - t.x))),
                    n
                }
                function y3(e, t) {
                    const n = _3(e, t);
                    if (!n)
                        return t;
                    const a = nT(n, e);
                    return Yu(a, a.next),
                    Yu(n, n.next)
                }
                function _3(e, t) {
                    let n = t;
                    const a = e.x
                      , r = e.y;
                    let c = -1 / 0, f;
                    if (qh(e, n))
                        return n;
                    do {
                        if (qh(e, n.next))
                            return n.next;
                        if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                            const _ = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (_ <= a && _ > c && (c = _,
                            f = n.x < n.next.x ? n : n.next,
                            _ === a))
                                return f
                        }
                        n = n.next
                    } while (n !== t);
                    if (!f)
                        return null;
                    const p = f
                      , m = f.x
                      , g = f.y;
                    let v = 1 / 0;
                    n = f;
                    do {
                        if (a >= n.x && n.x >= m && a !== n.x && eT(r < g ? a : c, r, m, g, r < g ? c : a, r, n.x, n.y)) {
                            const _ = Math.abs(r - n.y) / (a - n.x);
                            hm(n, e) && (_ < v || _ === v && (n.x > f.x || n.x === f.x && S3(f, n))) && (f = n,
                            v = _)
                        }
                        n = n.next
                    } while (n !== p);
                    return f
                }
                function S3(e, t) {
                    return _i(e.prev, e, t.prev) < 0 && _i(t.next, e, e.next) < 0
                }
                function x3(e, t, n, a) {
                    let r = e;
                    do
                        r.z === 0 && (r.z = SS(r.x, r.y, t, n, a)),
                        r.prevZ = r.prev,
                        r.nextZ = r.next,
                        r = r.next;
                    while (r !== e);
                    r.prevZ.nextZ = null,
                    r.prevZ = null,
                    b3(r)
                }
                function b3(e) {
                    let t, n = 1;
                    do {
                        let a = e, r;
                        e = null;
                        let c = null;
                        for (t = 0; a; ) {
                            t++;
                            let f = a
                              , p = 0;
                            for (let g = 0; g < n && (p++,
                            f = f.nextZ,
                            !!f); g++)
                                ;
                            let m = n;
                            for (; p > 0 || m > 0 && f; )
                                p !== 0 && (m === 0 || !f || a.z <= f.z) ? (r = a,
                                a = a.nextZ,
                                p--) : (r = f,
                                f = f.nextZ,
                                m--),
                                c ? c.nextZ = r : e = r,
                                r.prevZ = c,
                                c = r;
                            a = f
                        }
                        c.nextZ = null,
                        n *= 2
                    } while (t > 1);
                    return e
                }
                function SS(e, t, n, a, r) {
                    return e = (e - n) * r | 0,
                    t = (t - a) * r | 0,
                    e = (e | e << 8) & 16711935,
                    e = (e | e << 4) & 252645135,
                    e = (e | e << 2) & 858993459,
                    e = (e | e << 1) & 1431655765,
                    t = (t | t << 8) & 16711935,
                    t = (t | t << 4) & 252645135,
                    t = (t | t << 2) & 858993459,
                    t = (t | t << 1) & 1431655765,
                    e | t << 1
                }
                function M3(e) {
                    let t = e
                      , n = e;
                    do
                        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                        t = t.next;
                    while (t !== e);
                    return n
                }
                function eT(e, t, n, a, r, c, f, p) {
                    return (r - f) * (t - p) >= (e - f) * (c - p) && (e - f) * (a - p) >= (n - f) * (t - p) && (n - f) * (c - p) >= (r - f) * (a - p)
                }
                function fm(e, t, n, a, r, c, f, p) {
                    return !(e === f && t === p) && eT(e, t, n, a, r, c, f, p)
                }
                function T3(e, t) {
                    return e.next.i !== t.i && e.prev.i !== t.i && !E3(e, t) && (hm(e, t) && hm(t, e) && A3(e, t) && (_i(e.prev, e, t.prev) || _i(e, t.prev, t)) || qh(e, t) && _i(e.prev, e, e.next) > 0 && _i(t.prev, t, t.next) > 0)
                }
                function _i(e, t, n) {
                    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
                }
                function qh(e, t) {
                    return e.x === t.x && e.y === t.y
                }
                function tT(e, t, n, a) {
                    const r = K0(_i(e, t, n))
                      , c = K0(_i(e, t, a))
                      , f = K0(_i(n, a, e))
                      , p = K0(_i(n, a, t));
                    return !!(r !== c && f !== p || r === 0 && Q0(e, n, t) || c === 0 && Q0(e, a, t) || f === 0 && Q0(n, e, a) || p === 0 && Q0(n, t, a))
                }
                function Q0(e, t, n) {
                    return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
                }
                function K0(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0
                }
                function E3(e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && tT(n, n.next, e, t))
                            return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }
                function hm(e, t) {
                    return _i(e.prev, e, e.next) < 0 ? _i(e, t, e.next) >= 0 && _i(e, e.prev, t) >= 0 : _i(e, t, e.prev) < 0 || _i(e, e.next, t) < 0
                }
                function A3(e, t) {
                    let n = e
                      , a = !1;
                    const r = (e.x + t.x) / 2
                      , c = (e.y + t.y) / 2;
                    do
                        n.y > c != n.next.y > c && n.next.y !== n.y && r < (n.next.x - n.x) * (c - n.y) / (n.next.y - n.y) + n.x && (a = !a),
                        n = n.next;
                    while (n !== e);
                    return a
                }
                function nT(e, t) {
                    const n = xS(e.i, e.x, e.y)
                      , a = xS(t.i, t.x, t.y)
                      , r = e.next
                      , c = t.prev;
                    return e.next = t,
                    t.prev = e,
                    n.next = r,
                    r.prev = n,
                    a.next = n,
                    n.prev = a,
                    c.next = a,
                    a.prev = c,
                    a
                }
                function iT(e, t, n, a) {
                    const r = xS(e, t, n);
                    return a ? (r.next = a.next,
                    r.prev = a,
                    a.next.prev = r,
                    a.next = r) : (r.prev = r,
                    r.next = r),
                    r
                }
                function dm(e) {
                    e.next.prev = e.prev,
                    e.prev.next = e.next,
                    e.prevZ && (e.prevZ.nextZ = e.nextZ),
                    e.nextZ && (e.nextZ.prevZ = e.prevZ)
                }
                function xS(e, t, n) {
                    return {
                        i: e,
                        x: t,
                        y: n,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                function w3(e, t, n, a) {
                    let r = 0;
                    for (let c = t, f = n - a; c < n; c += a)
                        r += (e[f] - e[c]) * (e[c + 1] + e[f + 1]),
                        f = c;
                    return r
                }
                var C3 = class {
                    static triangulate(e, t, n=2) {
                        return f3(e, t, n)
                    }
                }
                  , Al = class kA {
                    static area(t) {
                        const n = t.length;
                        let a = 0;
                        for (let r = n - 1, c = 0; c < n; r = c++)
                            a += t[r].x * t[c].y - t[c].x * t[r].y;
                        return a * .5
                    }
                    static isClockWise(t) {
                        return kA.area(t) < 0
                    }
                    static triangulateShape(t, n) {
                        const a = []
                          , r = []
                          , c = [];
                        aT(t),
                        sT(a, t);
                        let f = t.length;
                        n.forEach(aT);
                        for (let m = 0; m < n.length; m++)
                            r.push(f),
                            f += n[m].length,
                            sT(a, n[m]);
                        const p = C3.triangulate(a, r);
                        for (let m = 0; m < p.length; m += 3)
                            c.push(p.slice(m, m + 3));
                        return c
                    }
                }
                ;
                function aT(e) {
                    const t = e.length;
                    t > 2 && e[t - 1].equals(e[0]) && e.pop()
                }
                function sT(e, t) {
                    for (let n = 0; n < t.length; n++)
                        e.push(t[n].x),
                        e.push(t[n].y)
                }
                var rT = class HA extends Xt {
                    constructor(t=new qu([new Pe(.5,.5), new Pe(-.5,.5), new Pe(-.5,-.5), new Pe(.5,-.5)]), n={}) {
                        super(),
                        this.type = "ExtrudeGeometry",
                        this.parameters = {
                            shapes: t,
                            options: n
                        },
                        t = Array.isArray(t) ? t : [t];
                        const a = this
                          , r = []
                          , c = [];
                        for (let p = 0, m = t.length; p < m; p++) {
                            const g = t[p];
                            f(g)
                        }
                        this.setAttribute("position", new vt(r,3)),
                        this.setAttribute("uv", new vt(c,2)),
                        this.computeVertexNormals();
                        function f(p) {
                            const m = []
                              , g = n.curveSegments !== void 0 ? n.curveSegments : 12
                              , v = n.steps !== void 0 ? n.steps : 1
                              , _ = n.depth !== void 0 ? n.depth : 1;
                            let x = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0
                              , M = n.bevelThickness !== void 0 ? n.bevelThickness : .2
                              , C = n.bevelSize !== void 0 ? n.bevelSize : M - .1
                              , R = n.bevelOffset !== void 0 ? n.bevelOffset : 0
                              , A = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
                            const E = n.extrudePath
                              , N = n.UVGenerator !== void 0 ? n.UVGenerator : R3;
                            let I, L = !1, k, B, X, G;
                            if (E) {
                                I = E.getSpacedPoints(v),
                                L = !0,
                                x = !1;
                                const we = E.isCatmullRomCurve3 ? E.closed : !1;
                                k = E.computeFrenetFrames(v, we),
                                B = new Y,
                                X = new Y,
                                G = new Y
                            }
                            x || (A = 0,
                            M = 0,
                            C = 0,
                            R = 0);
                            const P = p.extractPoints(g);
                            let U = P.shape;
                            const W = P.holes;
                            if (!Al.isClockWise(U)) {
                                U = U.reverse();
                                for (let we = 0, Ye = W.length; we < Ye; we++) {
                                    const Ve = W[we];
                                    Al.isClockWise(Ve) && (W[we] = Ve.reverse())
                                }
                            }
                            function K(we) {
                                const Ve = 10000000000000001e-36;
                                let tt = we[0];
                                for (let Z = 1; Z <= we.length; Z++) {
                                    const At = Z % we.length
                                      , $e = we[At]
                                      , xt = $e.x - tt.x
                                      , Ke = $e.y - tt.y
                                      , wt = xt * xt + Ke * Ke
                                      , H = Math.max(Math.abs($e.x), Math.abs($e.y), Math.abs(tt.x), Math.abs(tt.y));
                                    if (wt <= Ve * H * H) {
                                        we.splice(At, 1),
                                        Z--;
                                        continue
                                    }
                                    tt = $e
                                }
                            }
                            K(U),
                            W.forEach(K);
                            const q = W.length
                              , te = U;
                            for (let we = 0; we < q; we++) {
                                const Ye = W[we];
                                U = U.concat(Ye)
                            }
                            function ce(we, Ye, Ve) {
                                return Ye || Et("ExtrudeGeometry: vec does not exist"),
                                we.clone().addScaledVector(Ye, Ve)
                            }
                            const J = U.length;
                            function Q(we, Ye, Ve) {
                                let tt, Z, At;
                                const $e = we.x - Ye.x
                                  , xt = we.y - Ye.y
                                  , Ke = Ve.x - we.x
                                  , wt = Ve.y - we.y
                                  , H = $e * $e + xt * xt
                                  , O = $e * wt - xt * Ke;
                                if (Math.abs(O) > Number.EPSILON) {
                                    const oe = Math.sqrt(H)
                                      , Ce = Math.sqrt(Ke * Ke + wt * wt)
                                      , Ue = Ye.x - xt / oe
                                      , Me = Ye.y + $e / oe
                                      , st = Ve.x - wt / Ce
                                      , je = Ve.y + Ke / Ce
                                      , St = ((st - Ue) * wt - (je - Me) * Ke) / ($e * wt - xt * Ke);
                                    tt = Ue + $e * St - we.x,
                                    Z = Me + xt * St - we.y;
                                    const Ct = tt * tt + Z * Z;
                                    if (Ct <= 2)
                                        return new Pe(tt,Z);
                                    At = Math.sqrt(Ct / 2)
                                } else {
                                    let oe = !1;
                                    $e > Number.EPSILON ? Ke > Number.EPSILON && (oe = !0) : $e < -Number.EPSILON ? Ke < -Number.EPSILON && (oe = !0) : Math.sign(xt) === Math.sign(wt) && (oe = !0),
                                    oe ? (tt = -xt,
                                    Z = $e,
                                    At = Math.sqrt(H)) : (tt = $e,
                                    Z = xt,
                                    At = Math.sqrt(H / 2))
                                }
                                return new Pe(tt / At,Z / At)
                            }
                            const se = [];
                            for (let we = 0, Ye = te.length, Ve = Ye - 1, tt = we + 1; we < Ye; we++,
                            Ve++,
                            tt++)
                                Ve === Ye && (Ve = 0),
                                tt === Ye && (tt = 0),
                                se[we] = Q(te[we], te[Ve], te[tt]);
                            const Te = [];
                            let Ee, Be = se.concat();
                            for (let we = 0, Ye = q; we < Ye; we++) {
                                const Ve = W[we];
                                Ee = [];
                                for (let tt = 0, Z = Ve.length, At = Z - 1, $e = tt + 1; tt < Z; tt++,
                                At++,
                                $e++)
                                    At === Z && (At = 0),
                                    $e === Z && ($e = 0),
                                    Ee[tt] = Q(Ve[tt], Ve[At], Ve[$e]);
                                Te.push(Ee),
                                Be = Be.concat(Ee)
                            }
                            let j;
                            if (A === 0)
                                j = Al.triangulateShape(te, W);
                            else {
                                const we = []
                                  , Ye = [];
                                for (let Ve = 0; Ve < A; Ve++) {
                                    const tt = Ve / A
                                      , Z = M * Math.cos(tt * Math.PI / 2)
                                      , At = C * Math.sin(tt * Math.PI / 2) + R;
                                    for (let $e = 0, xt = te.length; $e < xt; $e++) {
                                        const Ke = ce(te[$e], se[$e], At);
                                        ke(Ke.x, Ke.y, -Z),
                                        tt === 0 && we.push(Ke)
                                    }
                                    for (let $e = 0, xt = q; $e < xt; $e++) {
                                        const Ke = W[$e];
                                        Ee = Te[$e];
                                        const wt = [];
                                        for (let H = 0, O = Ke.length; H < O; H++) {
                                            const oe = ce(Ke[H], Ee[H], At);
                                            ke(oe.x, oe.y, -Z),
                                            tt === 0 && wt.push(oe)
                                        }
                                        tt === 0 && Ye.push(wt)
                                    }
                                }
                                j = Al.triangulateShape(we, Ye)
                            }
                            const ve = j.length
                              , Re = C + R;
                            for (let we = 0; we < J; we++) {
                                const Ye = x ? ce(U[we], Be[we], Re) : U[we];
                                L ? (X.copy(k.normals[0]).multiplyScalar(Ye.x),
                                B.copy(k.binormals[0]).multiplyScalar(Ye.y),
                                G.copy(I[0]).add(X).add(B),
                                ke(G.x, G.y, G.z)) : ke(Ye.x, Ye.y, 0)
                            }
                            for (let we = 1; we <= v; we++)
                                for (let Ye = 0; Ye < J; Ye++) {
                                    const Ve = x ? ce(U[Ye], Be[Ye], Re) : U[Ye];
                                    L ? (X.copy(k.normals[we]).multiplyScalar(Ve.x),
                                    B.copy(k.binormals[we]).multiplyScalar(Ve.y),
                                    G.copy(I[we]).add(X).add(B),
                                    ke(G.x, G.y, G.z)) : ke(Ve.x, Ve.y, _ / v * we)
                                }
                            for (let we = A - 1; we >= 0; we--) {
                                const Ye = we / A
                                  , Ve = M * Math.cos(Ye * Math.PI / 2)
                                  , tt = C * Math.sin(Ye * Math.PI / 2) + R;
                                for (let Z = 0, At = te.length; Z < At; Z++) {
                                    const $e = ce(te[Z], se[Z], tt);
                                    ke($e.x, $e.y, _ + Ve)
                                }
                                for (let Z = 0, At = W.length; Z < At; Z++) {
                                    const $e = W[Z];
                                    Ee = Te[Z];
                                    for (let xt = 0, Ke = $e.length; xt < Ke; xt++) {
                                        const wt = ce($e[xt], Ee[xt], tt);
                                        L ? ke(wt.x, wt.y + I[v - 1].y, I[v - 1].x + Ve) : ke(wt.x, wt.y, _ + Ve)
                                    }
                                }
                            }
                            le(),
                            Ae();
                            function le() {
                                const we = r.length / 3;
                                if (x) {
                                    let Ye = 0
                                      , Ve = J * Ye;
                                    for (let tt = 0; tt < ve; tt++) {
                                        const Z = j[tt];
                                        at(Z[2] + Ve, Z[1] + Ve, Z[0] + Ve)
                                    }
                                    Ye = v + A * 2,
                                    Ve = J * Ye;
                                    for (let tt = 0; tt < ve; tt++) {
                                        const Z = j[tt];
                                        at(Z[0] + Ve, Z[1] + Ve, Z[2] + Ve)
                                    }
                                } else {
                                    for (let Ye = 0; Ye < ve; Ye++) {
                                        const Ve = j[Ye];
                                        at(Ve[2], Ve[1], Ve[0])
                                    }
                                    for (let Ye = 0; Ye < ve; Ye++) {
                                        const Ve = j[Ye];
                                        at(Ve[0] + J * v, Ve[1] + J * v, Ve[2] + J * v)
                                    }
                                }
                                a.addGroup(we, r.length / 3 - we, 0)
                            }
                            function Ae() {
                                const we = r.length / 3;
                                let Ye = 0;
                                Ne(te, Ye),
                                Ye += te.length;
                                for (let Ve = 0, tt = W.length; Ve < tt; Ve++) {
                                    const Z = W[Ve];
                                    Ne(Z, Ye),
                                    Ye += Z.length
                                }
                                a.addGroup(we, r.length / 3 - we, 1)
                            }
                            function Ne(we, Ye) {
                                let Ve = we.length;
                                for (; --Ve >= 0; ) {
                                    const tt = Ve;
                                    let Z = Ve - 1;
                                    Z < 0 && (Z = we.length - 1);
                                    for (let At = 0, $e = v + A * 2; At < $e; At++) {
                                        const xt = J * At
                                          , Ke = J * (At + 1);
                                        Je(Ye + tt + xt, Ye + Z + xt, Ye + Z + Ke, Ye + tt + Ke)
                                    }
                                }
                            }
                            function ke(we, Ye, Ve) {
                                m.push(we),
                                m.push(Ye),
                                m.push(Ve)
                            }
                            function at(we, Ye, Ve) {
                                Ft(we),
                                Ft(Ye),
                                Ft(Ve);
                                const tt = r.length / 3
                                  , Z = N.generateTopUV(a, r, tt - 3, tt - 2, tt - 1);
                                Vt(Z[0]),
                                Vt(Z[1]),
                                Vt(Z[2])
                            }
                            function Je(we, Ye, Ve, tt) {
                                Ft(we),
                                Ft(Ye),
                                Ft(tt),
                                Ft(Ye),
                                Ft(Ve),
                                Ft(tt);
                                const Z = r.length / 3
                                  , At = N.generateSideWallUV(a, r, Z - 6, Z - 3, Z - 2, Z - 1);
                                Vt(At[0]),
                                Vt(At[1]),
                                Vt(At[3]),
                                Vt(At[1]),
                                Vt(At[2]),
                                Vt(At[3])
                            }
                            function Ft(we) {
                                r.push(m[we * 3 + 0]),
                                r.push(m[we * 3 + 1]),
                                r.push(m[we * 3 + 2])
                            }
                            function Vt(we) {
                                c.push(we.x),
                                c.push(we.y)
                            }
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON()
                          , n = this.parameters.shapes
                          , a = this.parameters.options;
                        return D3(n, a, t)
                    }
                    static fromJSON(t, n) {
                        const a = [];
                        for (let c = 0, f = t.shapes.length; c < f; c++) {
                            const p = n[t.shapes[c]];
                            a.push(p)
                        }
                        const r = t.options.extrudePath;
                        return r !== void 0 && (t.options.extrudePath = new j0[r.type]().fromJSON(r)),
                        new HA(a,t.options)
                    }
                }
                ;
                const R3 = {
                    generateTopUV: function(e, t, n, a, r) {
                        const c = t[n * 3]
                          , f = t[n * 3 + 1]
                          , p = t[a * 3]
                          , m = t[a * 3 + 1]
                          , g = t[r * 3]
                          , v = t[r * 3 + 1];
                        return [new Pe(c,f), new Pe(p,m), new Pe(g,v)]
                    },
                    generateSideWallUV: function(e, t, n, a, r, c) {
                        const f = t[n * 3]
                          , p = t[n * 3 + 1]
                          , m = t[n * 3 + 2]
                          , g = t[a * 3]
                          , v = t[a * 3 + 1]
                          , _ = t[a * 3 + 2]
                          , x = t[r * 3]
                          , M = t[r * 3 + 1]
                          , C = t[r * 3 + 2]
                          , R = t[c * 3]
                          , A = t[c * 3 + 1]
                          , E = t[c * 3 + 2];
                        return Math.abs(p - v) < Math.abs(f - g) ? [new Pe(f,1 - m), new Pe(g,1 - _), new Pe(x,1 - C), new Pe(R,1 - E)] : [new Pe(p,1 - m), new Pe(v,1 - _), new Pe(M,1 - C), new Pe(A,1 - E)]
                    }
                };
                function D3(e, t, n) {
                    if (n.shapes = [],
                    Array.isArray(e))
                        for (let a = 0, r = e.length; a < r; a++) {
                            const c = e[a];
                            n.shapes.push(c.uuid)
                        }
                    else
                        n.shapes.push(e.uuid);
                    return n.options = Object.assign({}, t),
                    t.extrudePath !== void 0 && (n.options.extrudePath = t.extrudePath.toJSON()),
                    n
                }
                var oT = class GA extends Xh {
                    constructor(t=1, n=0) {
                        const a = (1 + Math.sqrt(5)) / 2
                          , r = [-1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, 0, 0, -1, a, 0, 1, a, 0, -1, -a, 0, 1, -a, a, 0, -1, a, 0, 1, -a, 0, -1, -a, 0, 1];
                        super(r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, n),
                        this.type = "IcosahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new GA(t.radius,t.detail)
                    }
                }
                  , lT = class WA extends Xt {
                    constructor(t=[new Pe(0,-.5), new Pe(.5,0), new Pe(0,.5)], n=12, a=0, r=Math.PI * 2) {
                        super(),
                        this.type = "LatheGeometry",
                        this.parameters = {
                            points: t,
                            segments: n,
                            phiStart: a,
                            phiLength: r
                        },
                        n = Math.floor(n),
                        r = Bt(r, 0, Math.PI * 2);
                        const c = []
                          , f = []
                          , p = []
                          , m = []
                          , g = []
                          , v = 1 / n
                          , _ = new Y
                          , x = new Pe
                          , M = new Y
                          , C = new Y
                          , R = new Y;
                        let A = 0
                          , E = 0;
                        for (let N = 0; N <= t.length - 1; N++)
                            switch (N) {
                            case 0:
                                A = t[N + 1].x - t[N].x,
                                E = t[N + 1].y - t[N].y,
                                M.x = E * 1,
                                M.y = -A,
                                M.z = E * 0,
                                R.copy(M),
                                M.normalize(),
                                m.push(M.x, M.y, M.z);
                                break;
                            case t.length - 1:
                                m.push(R.x, R.y, R.z);
                                break;
                            default:
                                A = t[N + 1].x - t[N].x,
                                E = t[N + 1].y - t[N].y,
                                M.x = E * 1,
                                M.y = -A,
                                M.z = E * 0,
                                C.copy(M),
                                M.x += R.x,
                                M.y += R.y,
                                M.z += R.z,
                                M.normalize(),
                                m.push(M.x, M.y, M.z),
                                R.copy(C)
                            }
                        for (let N = 0; N <= n; N++) {
                            const I = a + N * v * r
                              , L = Math.sin(I)
                              , k = Math.cos(I);
                            for (let B = 0; B <= t.length - 1; B++) {
                                _.x = t[B].x * L,
                                _.y = t[B].y,
                                _.z = t[B].x * k,
                                f.push(_.x, _.y, _.z),
                                x.x = N / n,
                                x.y = B / (t.length - 1),
                                p.push(x.x, x.y);
                                const X = m[3 * B + 0] * L
                                  , G = m[3 * B + 1]
                                  , P = m[3 * B + 0] * k;
                                g.push(X, G, P)
                            }
                        }
                        for (let N = 0; N < n; N++)
                            for (let I = 0; I < t.length - 1; I++) {
                                const L = I + N * t.length
                                  , k = L
                                  , B = L + t.length
                                  , X = L + t.length + 1
                                  , G = L + 1;
                                c.push(k, B, G),
                                c.push(X, G, B)
                            }
                        this.setIndex(c),
                        this.setAttribute("position", new vt(f,3)),
                        this.setAttribute("uv", new vt(p,2)),
                        this.setAttribute("normal", new vt(g,3))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new WA(t.points,t.segments,t.phiStart,t.phiLength)
                    }
                }
                  , bS = class XA extends Xh {
                    constructor(t=1, n=0) {
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, n),
                        this.type = "OctahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new XA(t.radius,t.detail)
                    }
                }
                  , J0 = class qA extends Xt {
                    constructor(t=1, n=1, a=1, r=1) {
                        super(),
                        this.type = "PlaneGeometry",
                        this.parameters = {
                            width: t,
                            height: n,
                            widthSegments: a,
                            heightSegments: r
                        };
                        const c = t / 2
                          , f = n / 2
                          , p = Math.floor(a)
                          , m = Math.floor(r)
                          , g = p + 1
                          , v = m + 1
                          , _ = t / p
                          , x = n / m
                          , M = []
                          , C = []
                          , R = []
                          , A = [];
                        for (let E = 0; E < v; E++) {
                            const N = E * x - f;
                            for (let I = 0; I < g; I++) {
                                const L = I * _ - c;
                                C.push(L, -N, 0),
                                R.push(0, 0, 1),
                                A.push(I / p),
                                A.push(1 - E / m)
                            }
                        }
                        for (let E = 0; E < m; E++)
                            for (let N = 0; N < p; N++) {
                                const I = N + g * E
                                  , L = N + g * (E + 1)
                                  , k = N + 1 + g * (E + 1)
                                  , B = N + 1 + g * E;
                                M.push(I, L, B),
                                M.push(L, k, B)
                            }
                        this.setIndex(M),
                        this.setAttribute("position", new vt(C,3)),
                        this.setAttribute("normal", new vt(R,3)),
                        this.setAttribute("uv", new vt(A,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new qA(t.width,t.height,t.widthSegments,t.heightSegments)
                    }
                }
                  , cT = class YA extends Xt {
                    constructor(t=.5, n=1, a=32, r=1, c=0, f=Math.PI * 2) {
                        super(),
                        this.type = "RingGeometry",
                        this.parameters = {
                            innerRadius: t,
                            outerRadius: n,
                            thetaSegments: a,
                            phiSegments: r,
                            thetaStart: c,
                            thetaLength: f
                        },
                        a = Math.max(3, a),
                        r = Math.max(1, r);
                        const p = []
                          , m = []
                          , g = []
                          , v = [];
                        let _ = t;
                        const x = (n - t) / r
                          , M = new Y
                          , C = new Pe;
                        for (let R = 0; R <= r; R++) {
                            for (let A = 0; A <= a; A++) {
                                const E = c + A / a * f;
                                M.x = _ * Math.cos(E),
                                M.y = _ * Math.sin(E),
                                m.push(M.x, M.y, M.z),
                                g.push(0, 0, 1),
                                C.x = (M.x / n + 1) / 2,
                                C.y = (M.y / n + 1) / 2,
                                v.push(C.x, C.y)
                            }
                            _ += x
                        }
                        for (let R = 0; R < r; R++) {
                            const A = R * (a + 1);
                            for (let E = 0; E < a; E++) {
                                const N = E + A
                                  , I = N
                                  , L = N + a + 1
                                  , k = N + a + 2
                                  , B = N + 1;
                                p.push(I, L, B),
                                p.push(L, k, B)
                            }
                        }
                        this.setIndex(p),
                        this.setAttribute("position", new vt(m,3)),
                        this.setAttribute("normal", new vt(g,3)),
                        this.setAttribute("uv", new vt(v,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new YA(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)
                    }
                }
                  , uT = class jA extends Xt {
                    constructor(t=new qu([new Pe(0,.5), new Pe(-.5,-.5), new Pe(.5,-.5)]), n=12) {
                        super(),
                        this.type = "ShapeGeometry",
                        this.parameters = {
                            shapes: t,
                            curveSegments: n
                        };
                        const a = []
                          , r = []
                          , c = []
                          , f = [];
                        let p = 0
                          , m = 0;
                        if (Array.isArray(t) === !1)
                            g(t);
                        else
                            for (let v = 0; v < t.length; v++)
                                g(t[v]),
                                this.addGroup(p, m, v),
                                p += m,
                                m = 0;
                        this.setIndex(a),
                        this.setAttribute("position", new vt(r,3)),
                        this.setAttribute("normal", new vt(c,3)),
                        this.setAttribute("uv", new vt(f,2));
                        function g(v) {
                            const _ = r.length / 3
                              , x = v.extractPoints(n);
                            let M = x.shape;
                            const C = x.holes;
                            Al.isClockWise(M) === !1 && (M = M.reverse());
                            for (let A = 0, E = C.length; A < E; A++) {
                                const N = C[A];
                                Al.isClockWise(N) === !0 && (C[A] = N.reverse())
                            }
                            const R = Al.triangulateShape(M, C);
                            for (let A = 0, E = C.length; A < E; A++) {
                                const N = C[A];
                                M = M.concat(N)
                            }
                            for (let A = 0, E = M.length; A < E; A++) {
                                const N = M[A];
                                r.push(N.x, N.y, 0),
                                c.push(0, 0, 1),
                                f.push(N.x, N.y)
                            }
                            for (let A = 0, E = R.length; A < E; A++) {
                                const N = R[A]
                                  , I = N[0] + _
                                  , L = N[1] + _
                                  , k = N[2] + _;
                                a.push(I, L, k),
                                m += 3
                            }
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON()
                          , n = this.parameters.shapes;
                        return N3(n, t)
                    }
                    static fromJSON(t, n) {
                        const a = [];
                        for (let r = 0, c = t.shapes.length; r < c; r++) {
                            const f = n[t.shapes[r]];
                            a.push(f)
                        }
                        return new jA(a,t.curveSegments)
                    }
                }
                ;
                function N3(e, t) {
                    if (t.shapes = [],
                    Array.isArray(e))
                        for (let n = 0, a = e.length; n < a; n++) {
                            const r = e[n];
                            t.shapes.push(r.uuid)
                        }
                    else
                        t.shapes.push(e.uuid);
                    return t
                }
                var MS = class ZA extends Xt {
                    constructor(t=1, n=32, a=16, r=0, c=Math.PI * 2, f=0, p=Math.PI) {
                        super(),
                        this.type = "SphereGeometry",
                        this.parameters = {
                            radius: t,
                            widthSegments: n,
                            heightSegments: a,
                            phiStart: r,
                            phiLength: c,
                            thetaStart: f,
                            thetaLength: p
                        },
                        n = Math.max(3, Math.floor(n)),
                        a = Math.max(2, Math.floor(a));
                        const m = Math.min(f + p, Math.PI);
                        let g = 0;
                        const v = []
                          , _ = new Y
                          , x = new Y
                          , M = []
                          , C = []
                          , R = []
                          , A = [];
                        for (let E = 0; E <= a; E++) {
                            const N = []
                              , I = E / a;
                            let L = 0;
                            E === 0 && f === 0 ? L = .5 / n : E === a && m === Math.PI && (L = -.5 / n);
                            for (let k = 0; k <= n; k++) {
                                const B = k / n;
                                _.x = -t * Math.cos(r + B * c) * Math.sin(f + I * p),
                                _.y = t * Math.cos(f + I * p),
                                _.z = t * Math.sin(r + B * c) * Math.sin(f + I * p),
                                C.push(_.x, _.y, _.z),
                                x.copy(_).normalize(),
                                R.push(x.x, x.y, x.z),
                                A.push(B + L, 1 - I),
                                N.push(g++)
                            }
                            v.push(N)
                        }
                        for (let E = 0; E < a; E++)
                            for (let N = 0; N < n; N++) {
                                const I = v[E][N + 1]
                                  , L = v[E][N]
                                  , k = v[E + 1][N]
                                  , B = v[E + 1][N + 1];
                                (E !== 0 || f > 0) && M.push(I, L, B),
                                (E !== a - 1 || m < Math.PI) && M.push(L, k, B)
                            }
                        this.setIndex(M),
                        this.setAttribute("position", new vt(C,3)),
                        this.setAttribute("normal", new vt(R,3)),
                        this.setAttribute("uv", new vt(A,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new ZA(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)
                    }
                }
                  , fT = class QA extends Xh {
                    constructor(t=1, n=0) {
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, n),
                        this.type = "TetrahedronGeometry",
                        this.parameters = {
                            radius: t,
                            detail: n
                        }
                    }
                    static fromJSON(t) {
                        return new QA(t.radius,t.detail)
                    }
                }
                  , hT = class KA extends Xt {
                    constructor(t=1, n=.4, a=12, r=48, c=Math.PI * 2) {
                        super(),
                        this.type = "TorusGeometry",
                        this.parameters = {
                            radius: t,
                            tube: n,
                            radialSegments: a,
                            tubularSegments: r,
                            arc: c
                        },
                        a = Math.floor(a),
                        r = Math.floor(r);
                        const f = []
                          , p = []
                          , m = []
                          , g = []
                          , v = new Y
                          , _ = new Y
                          , x = new Y;
                        for (let M = 0; M <= a; M++)
                            for (let C = 0; C <= r; C++) {
                                const R = C / r * c
                                  , A = M / a * Math.PI * 2;
                                _.x = (t + n * Math.cos(A)) * Math.cos(R),
                                _.y = (t + n * Math.cos(A)) * Math.sin(R),
                                _.z = n * Math.sin(A),
                                p.push(_.x, _.y, _.z),
                                v.x = t * Math.cos(R),
                                v.y = t * Math.sin(R),
                                x.subVectors(_, v).normalize(),
                                m.push(x.x, x.y, x.z),
                                g.push(C / r),
                                g.push(M / a)
                            }
                        for (let M = 1; M <= a; M++)
                            for (let C = 1; C <= r; C++) {
                                const R = (r + 1) * M + C - 1
                                  , A = (r + 1) * (M - 1) + C - 1
                                  , E = (r + 1) * (M - 1) + C
                                  , N = (r + 1) * M + C;
                                f.push(R, A, N),
                                f.push(A, E, N)
                            }
                        this.setIndex(f),
                        this.setAttribute("position", new vt(p,3)),
                        this.setAttribute("normal", new vt(m,3)),
                        this.setAttribute("uv", new vt(g,2))
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new KA(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)
                    }
                }
                  , dT = class JA extends Xt {
                    constructor(t=1, n=.4, a=64, r=8, c=2, f=3) {
                        super(),
                        this.type = "TorusKnotGeometry",
                        this.parameters = {
                            radius: t,
                            tube: n,
                            tubularSegments: a,
                            radialSegments: r,
                            p: c,
                            q: f
                        },
                        a = Math.floor(a),
                        r = Math.floor(r);
                        const p = []
                          , m = []
                          , g = []
                          , v = []
                          , _ = new Y
                          , x = new Y
                          , M = new Y
                          , C = new Y
                          , R = new Y
                          , A = new Y
                          , E = new Y;
                        for (let I = 0; I <= a; ++I) {
                            const L = I / a * c * Math.PI * 2;
                            N(L, c, f, t, M),
                            N(L + .01, c, f, t, C),
                            A.subVectors(C, M),
                            E.addVectors(C, M),
                            R.crossVectors(A, E),
                            E.crossVectors(R, A),
                            R.normalize(),
                            E.normalize();
                            for (let k = 0; k <= r; ++k) {
                                const B = k / r * Math.PI * 2
                                  , X = -n * Math.cos(B)
                                  , G = n * Math.sin(B);
                                _.x = M.x + (X * E.x + G * R.x),
                                _.y = M.y + (X * E.y + G * R.y),
                                _.z = M.z + (X * E.z + G * R.z),
                                m.push(_.x, _.y, _.z),
                                x.subVectors(_, M).normalize(),
                                g.push(x.x, x.y, x.z),
                                v.push(I / a),
                                v.push(k / r)
                            }
                        }
                        for (let I = 1; I <= a; I++)
                            for (let L = 1; L <= r; L++) {
                                const k = (r + 1) * (I - 1) + (L - 1)
                                  , B = (r + 1) * I + (L - 1)
                                  , X = (r + 1) * I + L
                                  , G = (r + 1) * (I - 1) + L;
                                p.push(k, B, G),
                                p.push(B, X, G)
                            }
                        this.setIndex(p),
                        this.setAttribute("position", new vt(m,3)),
                        this.setAttribute("normal", new vt(g,3)),
                        this.setAttribute("uv", new vt(v,2));
                        function N(I, L, k, B, X) {
                            const G = Math.cos(I)
                              , P = Math.sin(I)
                              , U = k / L * I
                              , W = Math.cos(U);
                            X.x = B * (2 + W) * .5 * G,
                            X.y = B * (2 + W) * P * .5,
                            X.z = B * Math.sin(U) * .5
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    static fromJSON(t) {
                        return new JA(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)
                    }
                }
                  , pT = class $A extends Xt {
                    constructor(t=new yS(new Y(-1,-1,0),new Y(-1,1,0),new Y(1,1,0)), n=64, a=1, r=8, c=!1) {
                        super(),
                        this.type = "TubeGeometry",
                        this.parameters = {
                            path: t,
                            tubularSegments: n,
                            radius: a,
                            radialSegments: r,
                            closed: c
                        };
                        const f = t.computeFrenetFrames(n, c);
                        this.tangents = f.tangents,
                        this.normals = f.normals,
                        this.binormals = f.binormals;
                        const p = new Y
                          , m = new Y
                          , g = new Pe;
                        let v = new Y;
                        const _ = []
                          , x = []
                          , M = []
                          , C = [];
                        R(),
                        this.setIndex(C),
                        this.setAttribute("position", new vt(_,3)),
                        this.setAttribute("normal", new vt(x,3)),
                        this.setAttribute("uv", new vt(M,2));
                        function R() {
                            for (let I = 0; I < n; I++)
                                A(I);
                            A(c === !1 ? n : 0),
                            N(),
                            E()
                        }
                        function A(I) {
                            v = t.getPointAt(I / n, v);
                            const L = f.normals[I]
                              , k = f.binormals[I];
                            for (let B = 0; B <= r; B++) {
                                const X = B / r * Math.PI * 2
                                  , G = Math.sin(X)
                                  , P = -Math.cos(X);
                                m.x = P * L.x + G * k.x,
                                m.y = P * L.y + G * k.y,
                                m.z = P * L.z + G * k.z,
                                m.normalize(),
                                x.push(m.x, m.y, m.z),
                                p.x = v.x + a * m.x,
                                p.y = v.y + a * m.y,
                                p.z = v.z + a * m.z,
                                _.push(p.x, p.y, p.z)
                            }
                        }
                        function E() {
                            for (let I = 1; I <= n; I++)
                                for (let L = 1; L <= r; L++) {
                                    const k = (r + 1) * (I - 1) + (L - 1)
                                      , B = (r + 1) * I + (L - 1)
                                      , X = (r + 1) * I + L
                                      , G = (r + 1) * (I - 1) + L;
                                    C.push(k, B, G),
                                    C.push(B, X, G)
                                }
                        }
                        function N() {
                            for (let I = 0; I <= n; I++)
                                for (let L = 0; L <= r; L++)
                                    g.x = I / n,
                                    g.y = L / r,
                                    M.push(g.x, g.y)
                        }
                    }
                    copy(t) {
                        return super.copy(t),
                        this.parameters = Object.assign({}, t.parameters),
                        this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.path = this.parameters.path.toJSON(),
                        t
                    }
                    static fromJSON(t) {
                        return new $A(new j0[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)
                    }
                }
                  , mT = class extends Xt {
                    constructor(e=null) {
                        if (super(),
                        this.type = "WireframeGeometry",
                        this.parameters = {
                            geometry: e
                        },
                        e !== null) {
                            const t = []
                              , n = new Set
                              , a = new Y
                              , r = new Y;
                            if (e.index !== null) {
                                const c = e.attributes.position
                                  , f = e.index;
                                let p = e.groups;
                                p.length === 0 && (p = [{
                                    start: 0,
                                    count: f.count,
                                    materialIndex: 0
                                }]);
                                for (let m = 0, g = p.length; m < g; ++m) {
                                    const v = p[m]
                                      , _ = v.start
                                      , x = v.count;
                                    for (let M = _, C = _ + x; M < C; M += 3)
                                        for (let R = 0; R < 3; R++) {
                                            const A = f.getX(M + R)
                                              , E = f.getX(M + (R + 1) % 3);
                                            a.fromBufferAttribute(c, A),
                                            r.fromBufferAttribute(c, E),
                                            gT(a, r, n) === !0 && (t.push(a.x, a.y, a.z),
                                            t.push(r.x, r.y, r.z))
                                        }
                                }
                            } else {
                                const c = e.attributes.position;
                                for (let f = 0, p = c.count / 3; f < p; f++)
                                    for (let m = 0; m < 3; m++) {
                                        const g = 3 * f + m
                                          , v = 3 * f + (m + 1) % 3;
                                        a.fromBufferAttribute(c, g),
                                        r.fromBufferAttribute(c, v),
                                        gT(a, r, n) === !0 && (t.push(a.x, a.y, a.z),
                                        t.push(r.x, r.y, r.z))
                                    }
                            }
                            this.setAttribute("position", new vt(t,3))
                        }
                    }
                    copy(e) {
                        return super.copy(e),
                        this.parameters = Object.assign({}, e.parameters),
                        this
                    }
                }
                ;
                function gT(e, t, n) {
                    const a = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`
                      , r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                    return n.has(a) === !0 || n.has(r) === !0 ? !1 : (n.add(a),
                    n.add(r),
                    !0)
                }
                var vT = Object.freeze({
                    __proto__: null,
                    BoxGeometry: Jp,
                    CapsuleGeometry: GM,
                    CircleGeometry: WM,
                    ConeGeometry: cS,
                    CylinderGeometry: lS,
                    DodecahedronGeometry: XM,
                    EdgesGeometry: qM,
                    ExtrudeGeometry: rT,
                    IcosahedronGeometry: oT,
                    LatheGeometry: lT,
                    OctahedronGeometry: bS,
                    PlaneGeometry: J0,
                    PolyhedronGeometry: Xh,
                    RingGeometry: cT,
                    ShapeGeometry: uT,
                    SphereGeometry: MS,
                    TetrahedronGeometry: fT,
                    TorusGeometry: hT,
                    TorusKnotGeometry: dT,
                    TubeGeometry: pT,
                    WireframeGeometry: mT
                })
                  , yT = class extends Na {
                    constructor(e) {
                        super(),
                        this.isShadowMaterial = !0,
                        this.type = "ShadowMaterial",
                        this.color = new dt(0),
                        this.transparent = !0,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.fog = e.fog,
                        this
                    }
                }
                  , TS = class extends dr {
                    constructor(e) {
                        super(e),
                        this.isRawShaderMaterial = !0,
                        this.type = "RawShaderMaterial"
                    }
                }
                  , ES = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshStandardMaterial = !0,
                        this.type = "MeshStandardMaterial",
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color = new dt(16777215),
                        this.roughness = 1,
                        this.metalness = 0,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new dt(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = _c,
                        this.normalScale = new Pe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.roughnessMap = null,
                        this.metalnessMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new es,
                        this.envMapIntensity = 1,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            STANDARD: ""
                        },
                        this.color.copy(e.color),
                        this.roughness = e.roughness,
                        this.metalness = e.metalness,
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.roughnessMap = e.roughnessMap,
                        this.metalnessMap = e.metalnessMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.envMapIntensity = e.envMapIntensity,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , _T = class extends ES {
                    constructor(e) {
                        super(),
                        this.isMeshPhysicalMaterial = !0,
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.type = "MeshPhysicalMaterial",
                        this.anisotropyRotation = 0,
                        this.anisotropyMap = null,
                        this.clearcoatMap = null,
                        this.clearcoatRoughness = 0,
                        this.clearcoatRoughnessMap = null,
                        this.clearcoatNormalScale = new Pe(1,1),
                        this.clearcoatNormalMap = null,
                        this.ior = 1.5,
                        Object.defineProperty(this, "reflectivity", {
                            get: function() {
                                return Bt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function(t) {
                                this.ior = (1 + .4 * t) / (1 - .4 * t)
                            }
                        }),
                        this.iridescenceMap = null,
                        this.iridescenceIOR = 1.3,
                        this.iridescenceThicknessRange = [100, 400],
                        this.iridescenceThicknessMap = null,
                        this.sheenColor = new dt(0),
                        this.sheenColorMap = null,
                        this.sheenRoughness = 1,
                        this.sheenRoughnessMap = null,
                        this.transmissionMap = null,
                        this.thickness = 0,
                        this.thicknessMap = null,
                        this.attenuationDistance = 1 / 0,
                        this.attenuationColor = new dt(1,1,1),
                        this.specularIntensity = 1,
                        this.specularIntensityMap = null,
                        this.specularColor = new dt(1,1,1),
                        this.specularColorMap = null,
                        this._anisotropy = 0,
                        this._clearcoat = 0,
                        this._dispersion = 0,
                        this._iridescence = 0,
                        this._sheen = 0,
                        this._transmission = 0,
                        this.setValues(e)
                    }
                    get anisotropy() {
                        return this._anisotropy
                    }
                    set anisotropy(e) {
                        this._anisotropy > 0 != e > 0 && this.version++,
                        this._anisotropy = e
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(e) {
                        this._clearcoat > 0 != e > 0 && this.version++,
                        this._clearcoat = e
                    }
                    get iridescence() {
                        return this._iridescence
                    }
                    set iridescence(e) {
                        this._iridescence > 0 != e > 0 && this.version++,
                        this._iridescence = e
                    }
                    get dispersion() {
                        return this._dispersion
                    }
                    set dispersion(e) {
                        this._dispersion > 0 != e > 0 && this.version++,
                        this._dispersion = e
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(e) {
                        this._sheen > 0 != e > 0 && this.version++,
                        this._sheen = e
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(e) {
                        this._transmission > 0 != e > 0 && this.version++,
                        this._transmission = e
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        },
                        this.anisotropy = e.anisotropy,
                        this.anisotropyRotation = e.anisotropyRotation,
                        this.anisotropyMap = e.anisotropyMap,
                        this.clearcoat = e.clearcoat,
                        this.clearcoatMap = e.clearcoatMap,
                        this.clearcoatRoughness = e.clearcoatRoughness,
                        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                        this.clearcoatNormalMap = e.clearcoatNormalMap,
                        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                        this.dispersion = e.dispersion,
                        this.ior = e.ior,
                        this.iridescence = e.iridescence,
                        this.iridescenceMap = e.iridescenceMap,
                        this.iridescenceIOR = e.iridescenceIOR,
                        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                        this.sheen = e.sheen,
                        this.sheenColor.copy(e.sheenColor),
                        this.sheenColorMap = e.sheenColorMap,
                        this.sheenRoughness = e.sheenRoughness,
                        this.sheenRoughnessMap = e.sheenRoughnessMap,
                        this.transmission = e.transmission,
                        this.transmissionMap = e.transmissionMap,
                        this.thickness = e.thickness,
                        this.thicknessMap = e.thicknessMap,
                        this.attenuationDistance = e.attenuationDistance,
                        this.attenuationColor.copy(e.attenuationColor),
                        this.specularIntensity = e.specularIntensity,
                        this.specularIntensityMap = e.specularIntensityMap,
                        this.specularColor.copy(e.specularColor),
                        this.specularColorMap = e.specularColorMap,
                        this
                    }
                }
                  , ST = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshPhongMaterial = !0,
                        this.type = "MeshPhongMaterial",
                        this.color = new dt(16777215),
                        this.specular = new dt(1118481),
                        this.shininess = 30,
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new dt(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = _c,
                        this.normalScale = new Pe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new es,
                        this.combine = Rp,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.specular.copy(e.specular),
                        this.shininess = e.shininess,
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , xT = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshToonMaterial = !0,
                        this.defines = {
                            TOON: ""
                        },
                        this.type = "MeshToonMaterial",
                        this.color = new dt(16777215),
                        this.map = null,
                        this.gradientMap = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new dt(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = _c,
                        this.normalScale = new Pe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.gradientMap = e.gradientMap,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.alphaMap = e.alphaMap,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.fog = e.fog,
                        this
                    }
                }
                  , bT = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshNormalMaterial = !0,
                        this.type = "MeshNormalMaterial",
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = _c,
                        this.normalScale = new Pe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.flatShading = !1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.flatShading = e.flatShading,
                        this
                    }
                }
                  , MT = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshLambertMaterial = !0,
                        this.type = "MeshLambertMaterial",
                        this.color = new dt(16777215),
                        this.map = null,
                        this.lightMap = null,
                        this.lightMapIntensity = 1,
                        this.aoMap = null,
                        this.aoMapIntensity = 1,
                        this.emissive = new dt(0),
                        this.emissiveIntensity = 1,
                        this.emissiveMap = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = _c,
                        this.normalScale = new Pe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.specularMap = null,
                        this.alphaMap = null,
                        this.envMap = null,
                        this.envMapRotation = new es,
                        this.combine = Rp,
                        this.reflectivity = 1,
                        this.refractionRatio = .98,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.wireframeLinecap = "round",
                        this.wireframeLinejoin = "round",
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.color.copy(e.color),
                        this.map = e.map,
                        this.lightMap = e.lightMap,
                        this.lightMapIntensity = e.lightMapIntensity,
                        this.aoMap = e.aoMap,
                        this.aoMapIntensity = e.aoMapIntensity,
                        this.emissive.copy(e.emissive),
                        this.emissiveMap = e.emissiveMap,
                        this.emissiveIntensity = e.emissiveIntensity,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.specularMap = e.specularMap,
                        this.alphaMap = e.alphaMap,
                        this.envMap = e.envMap,
                        this.envMapRotation.copy(e.envMapRotation),
                        this.combine = e.combine,
                        this.reflectivity = e.reflectivity,
                        this.refractionRatio = e.refractionRatio,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.wireframeLinecap = e.wireframeLinecap,
                        this.wireframeLinejoin = e.wireframeLinejoin,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , AS = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshDepthMaterial = !0,
                        this.type = "MeshDepthMaterial",
                        this.depthPacking = Db,
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.depthPacking = e.depthPacking,
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this
                    }
                }
                  , wS = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshDistanceMaterial = !0,
                        this.type = "MeshDistanceMaterial",
                        this.map = null,
                        this.alphaMap = null,
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.map = e.map,
                        this.alphaMap = e.alphaMap,
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this
                    }
                }
                  , TT = class extends Na {
                    constructor(e) {
                        super(),
                        this.isMeshMatcapMaterial = !0,
                        this.defines = {
                            MATCAP: ""
                        },
                        this.type = "MeshMatcapMaterial",
                        this.color = new dt(16777215),
                        this.matcap = null,
                        this.map = null,
                        this.bumpMap = null,
                        this.bumpScale = 1,
                        this.normalMap = null,
                        this.normalMapType = _c,
                        this.normalScale = new Pe(1,1),
                        this.displacementMap = null,
                        this.displacementScale = 1,
                        this.displacementBias = 0,
                        this.alphaMap = null,
                        this.wireframe = !1,
                        this.wireframeLinewidth = 1,
                        this.flatShading = !1,
                        this.fog = !0,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.defines = {
                            MATCAP: ""
                        },
                        this.color.copy(e.color),
                        this.matcap = e.matcap,
                        this.map = e.map,
                        this.bumpMap = e.bumpMap,
                        this.bumpScale = e.bumpScale,
                        this.normalMap = e.normalMap,
                        this.normalMapType = e.normalMapType,
                        this.normalScale.copy(e.normalScale),
                        this.displacementMap = e.displacementMap,
                        this.displacementScale = e.displacementScale,
                        this.displacementBias = e.displacementBias,
                        this.alphaMap = e.alphaMap,
                        this.wireframe = e.wireframe,
                        this.wireframeLinewidth = e.wireframeLinewidth,
                        this.flatShading = e.flatShading,
                        this.fog = e.fog,
                        this
                    }
                }
                  , ET = class extends is {
                    constructor(e) {
                        super(),
                        this.isLineDashedMaterial = !0,
                        this.type = "LineDashedMaterial",
                        this.scale = 1,
                        this.dashSize = 3,
                        this.gapSize = 1,
                        this.setValues(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.scale = e.scale,
                        this.dashSize = e.dashSize,
                        this.gapSize = e.gapSize,
                        this
                    }
                }
                ;
                function ju(e, t) {
                    return !e || e.constructor === t ? e : typeof t.BYTES_PER_ELEMENT == "number" ? new t(e) : Array.prototype.slice.call(e)
                }
                function AT(e) {
                    function t(r, c) {
                        return e[r] - e[c]
                    }
                    const n = e.length
                      , a = new Array(n);
                    for (let r = 0; r !== n; ++r)
                        a[r] = r;
                    return a.sort(t),
                    a
                }
                function CS(e, t, n) {
                    const a = e.length
                      , r = new e.constructor(a);
                    for (let c = 0, f = 0; f !== a; ++c) {
                        const p = n[c] * t;
                        for (let m = 0; m !== t; ++m)
                            r[f++] = e[p + m]
                    }
                    return r
                }
                function RS(e, t, n, a) {
                    let r = 1
                      , c = e[0];
                    for (; c !== void 0 && c[a] === void 0; )
                        c = e[r++];
                    if (c === void 0)
                        return;
                    let f = c[a];
                    if (f !== void 0)
                        if (Array.isArray(f))
                            do
                                f = c[a],
                                f !== void 0 && (t.push(c.time),
                                n.push(...f)),
                                c = e[r++];
                            while (c !== void 0);
                        else if (f.toArray !== void 0)
                            do
                                f = c[a],
                                f !== void 0 && (t.push(c.time),
                                f.toArray(n, n.length)),
                                c = e[r++];
                            while (c !== void 0);
                        else
                            do
                                f = c[a],
                                f !== void 0 && (t.push(c.time),
                                n.push(f)),
                                c = e[r++];
                            while (c !== void 0)
                }
                function L3(e, t, n, a, r=30) {
                    const c = e.clone();
                    c.name = t;
                    const f = [];
                    for (let m = 0; m < c.tracks.length; ++m) {
                        const g = c.tracks[m]
                          , v = g.getValueSize()
                          , _ = []
                          , x = [];
                        for (let M = 0; M < g.times.length; ++M) {
                            const C = g.times[M] * r;
                            if (!(C < n || C >= a)) {
                                _.push(g.times[M]);
                                for (let R = 0; R < v; ++R)
                                    x.push(g.values[M * v + R])
                            }
                        }
                        _.length !== 0 && (g.times = ju(_, g.times.constructor),
                        g.values = ju(x, g.values.constructor),
                        f.push(g))
                    }
                    c.tracks = f;
                    let p = 1 / 0;
                    for (let m = 0; m < c.tracks.length; ++m)
                        p > c.tracks[m].times[0] && (p = c.tracks[m].times[0]);
                    for (let m = 0; m < c.tracks.length; ++m)
                        c.tracks[m].shift(-1 * p);
                    return c.resetDuration(),
                    c
                }
                function U3(e, t=0, n=e, a=30) {
                    a <= 0 && (a = 30);
                    const r = n.tracks.length
                      , c = t / a;
                    for (let f = 0; f < r; ++f) {
                        const p = n.tracks[f]
                          , m = p.ValueTypeName;
                        if (m === "bool" || m === "string")
                            continue;
                        const g = e.tracks.find(function(E) {
                            return E.name === p.name && E.ValueTypeName === m
                        });
                        if (g === void 0)
                            continue;
                        let v = 0;
                        const _ = p.getValueSize();
                        p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (v = _ / 3);
                        let x = 0;
                        const M = g.getValueSize();
                        g.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (x = M / 3);
                        const C = p.times.length - 1;
                        let R;
                        if (c <= p.times[0]) {
                            const E = v
                              , N = _ - v;
                            R = p.values.slice(E, N)
                        } else if (c >= p.times[C]) {
                            const E = C * _ + v
                              , N = E + _ - v;
                            R = p.values.slice(E, N)
                        } else {
                            const E = p.createInterpolant()
                              , N = v
                              , I = _ - v;
                            E.evaluate(c),
                            R = E.resultBuffer.slice(N, I)
                        }
                        m === "quaternion" && new xs().fromArray(R).normalize().conjugate().toArray(R);
                        const A = g.times.length;
                        for (let E = 0; E < A; ++E) {
                            const N = E * M + x;
                            if (m === "quaternion")
                                xs.multiplyQuaternionsFlat(g.values, N, R, 0, g.values, N);
                            else {
                                const I = M - x * 2;
                                for (let L = 0; L < I; ++L)
                                    g.values[N + L] -= R[L]
                            }
                        }
                    }
                    return e.blendMode = x_,
                    e
                }
                var I3 = class {
                    static convertArray(e, t) {
                        return ju(e, t)
                    }
                    static isTypedArray(e) {
                        return Fb(e)
                    }
                    static getKeyframeOrder(e) {
                        return AT(e)
                    }
                    static sortedArray(e, t, n) {
                        return CS(e, t, n)
                    }
                    static flattenJSON(e, t, n, a) {
                        RS(e, t, n, a)
                    }
                    static subclip(e, t, n, a, r=30) {
                        return L3(e, t, n, a, r)
                    }
                    static makeClipAdditive(e, t=0, n=e, a=30) {
                        return U3(e, t, n, a)
                    }
                }
                  , pm = class {
                    constructor(e, t, n, a) {
                        this.parameterPositions = e,
                        this._cachedIndex = 0,
                        this.resultBuffer = a !== void 0 ? a : new t.constructor(n),
                        this.sampleValues = t,
                        this.valueSize = n,
                        this.settings = null,
                        this.DefaultSettings_ = {}
                    }
                    evaluate(e) {
                        const t = this.parameterPositions;
                        let n = this._cachedIndex
                          , a = t[n]
                          , r = t[n - 1];
                        e: {
                            t: {
                                let c;
                                n: {
                                    i: if (!(e < a)) {
                                        for (let f = n + 2; ; ) {
                                            if (a === void 0) {
                                                if (e < r)
                                                    break i;
                                                return n = t.length,
                                                this._cachedIndex = n,
                                                this.copySampleValue_(n - 1)
                                            }
                                            if (n === f)
                                                break;
                                            if (r = a,
                                            a = t[++n],
                                            e < a)
                                                break t
                                        }
                                        c = t.length;
                                        break n
                                    }
                                    if (!(e >= r)) {
                                        const f = t[1];
                                        e < f && (n = 2,
                                        r = f);
                                        for (let p = n - 2; ; ) {
                                            if (r === void 0)
                                                return this._cachedIndex = 0,
                                                this.copySampleValue_(0);
                                            if (n === p)
                                                break;
                                            if (a = r,
                                            r = t[--n - 1],
                                            e >= r)
                                                break t
                                        }
                                        c = n,
                                        n = 0;
                                        break n
                                    }
                                    break e
                                }
                                for (; n < c; ) {
                                    const f = n + c >>> 1;
                                    e < t[f] ? c = f : n = f + 1
                                }
                                if (a = t[n],
                                r = t[n - 1],
                                r === void 0)
                                    return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                if (a === void 0)
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.copySampleValue_(n - 1)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, a)
                        }
                        return this.interpolate_(n, r, e, a)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(e) {
                        const t = this.resultBuffer
                          , n = this.sampleValues
                          , a = this.valueSize
                          , r = e * a;
                        for (let c = 0; c !== a; ++c)
                            t[c] = n[r + c];
                        return t
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                  , wT = class extends pm {
                    constructor(e, t, n, a) {
                        super(e, t, n, a),
                        this._weightPrev = -0,
                        this._offsetPrev = -0,
                        this._weightNext = -0,
                        this._offsetNext = -0,
                        this.DefaultSettings_ = {
                            endingStart: Pu,
                            endingEnd: Pu
                        }
                    }
                    intervalChanged_(e, t, n) {
                        const a = this.parameterPositions;
                        let r = e - 2
                          , c = e + 1
                          , f = a[r]
                          , p = a[c];
                        if (f === void 0)
                            switch (this.getSettings_().endingStart) {
                            case zu:
                                r = e,
                                f = 2 * t - n;
                                break;
                            case kp:
                                r = a.length - 2,
                                f = t + a[r] - a[r + 1];
                                break;
                            default:
                                r = e,
                                f = n
                            }
                        if (p === void 0)
                            switch (this.getSettings_().endingEnd) {
                            case zu:
                                c = e,
                                p = 2 * n - t;
                                break;
                            case kp:
                                c = 1,
                                p = n + a[1] - a[0];
                                break;
                            default:
                                c = e - 1,
                                p = t
                            }
                        const m = (n - t) * .5
                          , g = this.valueSize;
                        this._weightPrev = m / (t - f),
                        this._weightNext = m / (p - n),
                        this._offsetPrev = r * g,
                        this._offsetNext = c * g
                    }
                    interpolate_(e, t, n, a) {
                        const r = this.resultBuffer
                          , c = this.sampleValues
                          , f = this.valueSize
                          , p = e * f
                          , m = p - f
                          , g = this._offsetPrev
                          , v = this._offsetNext
                          , _ = this._weightPrev
                          , x = this._weightNext
                          , M = (n - t) / (a - t)
                          , C = M * M
                          , R = C * M
                          , A = -_ * R + 2 * _ * C - _ * M
                          , E = (1 + _) * R + (-1.5 - 2 * _) * C + (-.5 + _) * M + 1
                          , N = (-1 - x) * R + (1.5 + x) * C + .5 * M
                          , I = x * R - x * C;
                        for (let L = 0; L !== f; ++L)
                            r[L] = A * c[g + L] + E * c[m + L] + N * c[p + L] + I * c[v + L];
                        return r
                    }
                }
                  , DS = class extends pm {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                    interpolate_(e, t, n, a) {
                        const r = this.resultBuffer
                          , c = this.sampleValues
                          , f = this.valueSize
                          , p = e * f
                          , m = p - f
                          , g = (n - t) / (a - t)
                          , v = 1 - g;
                        for (let _ = 0; _ !== f; ++_)
                            r[_] = c[m + _] * v + c[p + _] * g;
                        return r
                    }
                }
                  , CT = class extends pm {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                    interpolate_(e) {
                        return this.copySampleValue_(e - 1)
                    }
                }
                  , pr = class {
                    constructor(e, t, n, a) {
                        if (e === void 0)
                            throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (t === void 0 || t.length === 0)
                            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                        this.name = e,
                        this.times = ju(t, this.TimeBufferType),
                        this.values = ju(n, this.ValueBufferType),
                        this.setInterpolation(a || this.DefaultInterpolation)
                    }
                    static toJSON(e) {
                        const t = e.constructor;
                        let n;
                        if (t.toJSON !== this.toJSON)
                            n = t.toJSON(e);
                        else {
                            n = {
                                name: e.name,
                                times: ju(e.times, Array),
                                values: ju(e.values, Array)
                            };
                            const a = e.getInterpolation();
                            a !== e.DefaultInterpolation && (n.interpolation = a)
                        }
                        return n.type = e.ValueTypeName,
                        n
                    }
                    InterpolantFactoryMethodDiscrete(e) {
                        return new CT(this.times,this.values,this.getValueSize(),e)
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new DS(this.times,this.values,this.getValueSize(),e)
                    }
                    InterpolantFactoryMethodSmooth(e) {
                        return new wT(this.times,this.values,this.getValueSize(),e)
                    }
                    setInterpolation(e) {
                        let t;
                        switch (e) {
                        case Vp:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case t0:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case n0:
                            t = this.InterpolantFactoryMethodSmooth;
                            break
                        }
                        if (t === void 0) {
                            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (this.createInterpolant === void 0)
                                if (e !== this.DefaultInterpolation)
                                    this.setInterpolation(this.DefaultInterpolation);
                                else
                                    throw new Error(n);
                            return ot("KeyframeTrack:", n),
                            this
                        }
                        return this.createInterpolant = t,
                        this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Vp;
                        case this.InterpolantFactoryMethodLinear:
                            return t0;
                        case this.InterpolantFactoryMethodSmooth:
                            return n0
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(e) {
                        if (e !== 0) {
                            const t = this.times;
                            for (let n = 0, a = t.length; n !== a; ++n)
                                t[n] += e
                        }
                        return this
                    }
                    scale(e) {
                        if (e !== 1) {
                            const t = this.times;
                            for (let n = 0, a = t.length; n !== a; ++n)
                                t[n] *= e
                        }
                        return this
                    }
                    trim(e, t) {
                        const n = this.times
                          , a = n.length;
                        let r = 0
                          , c = a - 1;
                        for (; r !== a && n[r] < e; )
                            ++r;
                        for (; c !== -1 && n[c] > t; )
                            --c;
                        if (++c,
                        r !== 0 || c !== a) {
                            r >= c && (c = Math.max(c, 1),
                            r = c - 1);
                            const f = this.getValueSize();
                            this.times = n.slice(r, c),
                            this.values = this.values.slice(r * f, c * f)
                        }
                        return this
                    }
                    validate() {
                        let e = !0;
                        const t = this.getValueSize();
                        t - Math.floor(t) !== 0 && (Et("KeyframeTrack: Invalid value size in track.", this),
                        e = !1);
                        const n = this.times
                          , a = this.values
                          , r = n.length;
                        r === 0 && (Et("KeyframeTrack: Track is empty.", this),
                        e = !1);
                        let c = null;
                        for (let f = 0; f !== r; f++) {
                            const p = n[f];
                            if (typeof p == "number" && isNaN(p)) {
                                Et("KeyframeTrack: Time is not a valid number.", this, f, p),
                                e = !1;
                                break
                            }
                            if (c !== null && c > p) {
                                Et("KeyframeTrack: Out of order keys.", this, f, p, c),
                                e = !1;
                                break
                            }
                            c = p
                        }
                        if (a !== void 0 && Fb(a))
                            for (let f = 0, p = a.length; f !== p; ++f) {
                                const m = a[f];
                                if (isNaN(m)) {
                                    Et("KeyframeTrack: Value is not a valid number.", this, f, m),
                                    e = !1;
                                    break
                                }
                            }
                        return e
                    }
                    optimize() {
                        const e = this.times.slice()
                          , t = this.values.slice()
                          , n = this.getValueSize()
                          , a = this.getInterpolation() === n0
                          , r = e.length - 1;
                        let c = 1;
                        for (let f = 1; f < r; ++f) {
                            let p = !1;
                            const m = e[f];
                            if (m !== e[f + 1] && (f !== 1 || m !== e[0]))
                                if (a)
                                    p = !0;
                                else {
                                    const g = f * n
                                      , v = g - n
                                      , _ = g + n;
                                    for (let x = 0; x !== n; ++x) {
                                        const M = t[g + x];
                                        if (M !== t[v + x] || M !== t[_ + x]) {
                                            p = !0;
                                            break
                                        }
                                    }
                                }
                            if (p) {
                                if (f !== c) {
                                    e[c] = e[f];
                                    const g = f * n
                                      , v = c * n;
                                    for (let _ = 0; _ !== n; ++_)
                                        t[v + _] = t[g + _]
                                }
                                ++c
                            }
                        }
                        if (r > 0) {
                            e[c] = e[r];
                            for (let f = r * n, p = c * n, m = 0; m !== n; ++m)
                                t[p + m] = t[f + m];
                            ++c
                        }
                        return c !== e.length ? (this.times = e.slice(0, c),
                        this.values = t.slice(0, c * n)) : (this.times = e,
                        this.values = t),
                        this
                    }
                    clone() {
                        const e = this.times.slice()
                          , t = this.values.slice()
                          , n = this.constructor
                          , a = new n(this.name,e,t);
                        return a.createInterpolant = this.createInterpolant,
                        a
                    }
                }
                ;
                pr.prototype.ValueTypeName = "",
                pr.prototype.TimeBufferType = Float32Array,
                pr.prototype.ValueBufferType = Float32Array,
                pr.prototype.DefaultInterpolation = t0;
                var Zu = class extends pr {
                    constructor(e, t, n) {
                        super(e, t, n)
                    }
                }
                ;
                Zu.prototype.ValueTypeName = "bool",
                Zu.prototype.ValueBufferType = Array,
                Zu.prototype.DefaultInterpolation = Vp,
                Zu.prototype.InterpolantFactoryMethodLinear = void 0,
                Zu.prototype.InterpolantFactoryMethodSmooth = void 0;
                var NS = class extends pr {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                }
                ;
                NS.prototype.ValueTypeName = "color";
                var mm = class extends pr {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                }
                ;
                mm.prototype.ValueTypeName = "number";
                var RT = class extends pm {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                    interpolate_(e, t, n, a) {
                        const r = this.resultBuffer
                          , c = this.sampleValues
                          , f = this.valueSize
                          , p = (n - t) / (a - t);
                        let m = e * f;
                        for (let g = m + f; m !== g; m += 4)
                            xs.slerpFlat(r, 0, c, m - f, c, m, p);
                        return r
                    }
                }
                  , gm = class extends pr {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                    InterpolantFactoryMethodLinear(e) {
                        return new RT(this.times,this.values,this.getValueSize(),e)
                    }
                }
                ;
                gm.prototype.ValueTypeName = "quaternion",
                gm.prototype.InterpolantFactoryMethodSmooth = void 0;
                var Qu = class extends pr {
                    constructor(e, t, n) {
                        super(e, t, n)
                    }
                }
                ;
                Qu.prototype.ValueTypeName = "string",
                Qu.prototype.ValueBufferType = Array,
                Qu.prototype.DefaultInterpolation = Vp,
                Qu.prototype.InterpolantFactoryMethodLinear = void 0,
                Qu.prototype.InterpolantFactoryMethodSmooth = void 0;
                var vm = class extends pr {
                    constructor(e, t, n, a) {
                        super(e, t, n, a)
                    }
                }
                ;
                vm.prototype.ValueTypeName = "vector";
                var ym = class {
                    constructor(e="", t=-1, n=[], a=i0) {
                        this.name = e,
                        this.tracks = n,
                        this.duration = t,
                        this.blendMode = a,
                        this.uuid = Fs(),
                        this.userData = {},
                        this.duration < 0 && this.resetDuration()
                    }
                    static parse(e) {
                        const t = []
                          , n = e.tracks
                          , a = 1 / (e.fps || 1);
                        for (let c = 0, f = n.length; c !== f; ++c)
                            t.push(P3(n[c]).scale(a));
                        const r = new this(e.name,e.duration,t,e.blendMode);
                        return r.uuid = e.uuid,
                        r.userData = JSON.parse(e.userData || "{}"),
                        r
                    }
                    static toJSON(e) {
                        const t = []
                          , n = e.tracks
                          , a = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode,
                            userData: JSON.stringify(e.userData)
                        };
                        for (let r = 0, c = n.length; r !== c; ++r)
                            t.push(pr.toJSON(n[r]));
                        return a
                    }
                    static CreateFromMorphTargetSequence(e, t, n, a) {
                        const r = t.length
                          , c = [];
                        for (let f = 0; f < r; f++) {
                            let p = []
                              , m = [];
                            p.push((f + r - 1) % r, f, (f + 1) % r),
                            m.push(0, 1, 0);
                            const g = AT(p);
                            p = CS(p, 1, g),
                            m = CS(m, 1, g),
                            !a && p[0] === 0 && (p.push(r),
                            m.push(m[0])),
                            c.push(new mm(".morphTargetInfluences[" + t[f].name + "]",p,m).scale(1 / n))
                        }
                        return new this(e,-1,c)
                    }
                    static findByName(e, t) {
                        let n = e;
                        if (!Array.isArray(e)) {
                            const a = e;
                            n = a.geometry && a.geometry.animations || a.animations
                        }
                        for (let a = 0; a < n.length; a++)
                            if (n[a].name === t)
                                return n[a];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(e, t, n) {
                        const a = {}
                          , r = /^([\w-]*?)([\d]+)$/;
                        for (let f = 0, p = e.length; f < p; f++) {
                            const m = e[f]
                              , g = m.name.match(r);
                            if (g && g.length > 1) {
                                const v = g[1];
                                let _ = a[v];
                                _ || (a[v] = _ = []),
                                _.push(m)
                            }
                        }
                        const c = [];
                        for (const f in a)
                            c.push(this.CreateFromMorphTargetSequence(f, a[f], t, n));
                        return c
                    }
                    static parseAnimation(e, t) {
                        if (ot("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
                        !e)
                            return Et("AnimationClip: No animation in JSONLoader data."),
                            null;
                        const n = function(g, v, _, x, M) {
                            if (_.length !== 0) {
                                const C = []
                                  , R = [];
                                RS(_, C, R, x),
                                C.length !== 0 && M.push(new g(v,C,R))
                            }
                        }
                          , a = []
                          , r = e.name || "default"
                          , c = e.fps || 30
                          , f = e.blendMode;
                        let p = e.length || -1;
                        const m = e.hierarchy || [];
                        for (let g = 0; g < m.length; g++) {
                            const v = m[g].keys;
                            if (!(!v || v.length === 0))
                                if (v[0].morphTargets) {
                                    const _ = {};
                                    let x;
                                    for (x = 0; x < v.length; x++)
                                        if (v[x].morphTargets)
                                            for (let M = 0; M < v[x].morphTargets.length; M++)
                                                _[v[x].morphTargets[M]] = -1;
                                    for (const M in _) {
                                        const C = []
                                          , R = [];
                                        for (let A = 0; A !== v[x].morphTargets.length; ++A) {
                                            const E = v[x];
                                            C.push(E.time),
                                            R.push(E.morphTarget === M ? 1 : 0)
                                        }
                                        a.push(new mm(".morphTargetInfluence[" + M + "]",C,R))
                                    }
                                    p = _.length * c
                                } else {
                                    const _ = ".bones[" + t[g].name + "]";
                                    n(vm, _ + ".position", v, "pos", a),
                                    n(gm, _ + ".quaternion", v, "rot", a),
                                    n(vm, _ + ".scale", v, "scl", a)
                                }
                        }
                        return a.length === 0 ? null : new this(r,p,a,f)
                    }
                    resetDuration() {
                        const e = this.tracks;
                        let t = 0;
                        for (let n = 0, a = e.length; n !== a; ++n) {
                            const r = this.tracks[n];
                            t = Math.max(t, r.times[r.times.length - 1])
                        }
                        return this.duration = t,
                        this
                    }
                    trim() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let e = !0;
                        for (let t = 0; t < this.tracks.length; t++)
                            e = e && this.tracks[t].validate();
                        return e
                    }
                    optimize() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].optimize();
                        return this
                    }
                    clone() {
                        const e = [];
                        for (let n = 0; n < this.tracks.length; n++)
                            e.push(this.tracks[n].clone());
                        const t = new this.constructor(this.name,this.duration,e,this.blendMode);
                        return t.userData = JSON.parse(JSON.stringify(this.userData)),
                        t
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }
                ;
                function O3(e) {
                    switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return mm;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return vm;
                    case "color":
                        return NS;
                    case "quaternion":
                        return gm;
                    case "bool":
                    case "boolean":
                        return Zu;
                    case "string":
                        return Qu
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }
                function P3(e) {
                    if (e.type === void 0)
                        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const t = O3(e.type);
                    if (e.times === void 0) {
                        const n = []
                          , a = [];
                        RS(e.keys, n, a, "value"),
                        e.times = n,
                        e.values = a
                    }
                    return t.parse !== void 0 ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
                }
                const zo = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        this.enabled !== !1 && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (this.enabled !== !1)
                            return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                var LS = class {
                    constructor(e, t, n) {
                        const a = this;
                        let r = !1, c = 0, f = 0, p;
                        const m = [];
                        this.onStart = void 0,
                        this.onLoad = e,
                        this.onProgress = t,
                        this.onError = n,
                        this._abortController = null,
                        this.itemStart = function(g) {
                            f++,
                            r === !1 && a.onStart !== void 0 && a.onStart(g, c, f),
                            r = !0
                        }
                        ,
                        this.itemEnd = function(g) {
                            c++,
                            a.onProgress !== void 0 && a.onProgress(g, c, f),
                            c === f && (r = !1,
                            a.onLoad !== void 0 && a.onLoad())
                        }
                        ,
                        this.itemError = function(g) {
                            a.onError !== void 0 && a.onError(g)
                        }
                        ,
                        this.resolveURL = function(g) {
                            return p ? p(g) : g
                        }
                        ,
                        this.setURLModifier = function(g) {
                            return p = g,
                            this
                        }
                        ,
                        this.addHandler = function(g, v) {
                            return m.push(g, v),
                            this
                        }
                        ,
                        this.removeHandler = function(g) {
                            const v = m.indexOf(g);
                            return v !== -1 && m.splice(v, 2),
                            this
                        }
                        ,
                        this.getHandler = function(g) {
                            for (let v = 0, _ = m.length; v < _; v += 2) {
                                const x = m[v]
                                  , M = m[v + 1];
                                if (x.global && (x.lastIndex = 0),
                                x.test(g))
                                    return M
                            }
                            return null
                        }
                        ,
                        this.abort = function() {
                            return this.abortController.abort(),
                            this._abortController = null,
                            this
                        }
                    }
                    get abortController() {
                        return this._abortController || (this._abortController = new AbortController),
                        this._abortController
                    }
                }
                ;
                const DT = new LS;
                var Ts = class {
                    constructor(e) {
                        this.manager = e !== void 0 ? e : DT,
                        this.crossOrigin = "anonymous",
                        this.withCredentials = !1,
                        this.path = "",
                        this.resourcePath = "",
                        this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(e, t) {
                        const n = this;
                        return new Promise(function(a, r) {
                            n.load(e, a, t, r)
                        }
                        )
                    }
                    parse() {}
                    setCrossOrigin(e) {
                        return this.crossOrigin = e,
                        this
                    }
                    setWithCredentials(e) {
                        return this.withCredentials = e,
                        this
                    }
                    setPath(e) {
                        return this.path = e,
                        this
                    }
                    setResourcePath(e) {
                        return this.resourcePath = e,
                        this
                    }
                    setRequestHeader(e) {
                        return this.requestHeader = e,
                        this
                    }
                    abort() {
                        return this
                    }
                }
                ;
                Ts.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                const wl = {};
                var z3 = class extends Error {
                    constructor(e, t) {
                        super(e),
                        this.response = t
                    }
                }
                  , Cl = class extends Ts {
                    constructor(e) {
                        super(e),
                        this.mimeType = "",
                        this.responseType = "",
                        this._abortController = new AbortController
                    }
                    load(e, t, n, a) {
                        e === void 0 && (e = ""),
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const r = zo.get(`file:${e}`);
                        if (r !== void 0)
                            return this.manager.itemStart(e),
                            setTimeout( () => {
                                t && t(r),
                                this.manager.itemEnd(e)
                            }
                            , 0),
                            r;
                        if (wl[e] !== void 0) {
                            wl[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: a
                            });
                            return
                        }
                        wl[e] = [],
                        wl[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: a
                        });
                        const c = new Request(e,{
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin",
                            signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
                        })
                          , f = this.mimeType
                          , p = this.responseType;
                        fetch(c).then(m => {
                            if (m.status === 200 || m.status === 0) {
                                if (m.status === 0 && ot("FileLoader: HTTP Status 0 received."),
                                typeof ReadableStream > "u" || m.body === void 0 || m.body.getReader === void 0)
                                    return m;
                                const g = wl[e]
                                  , v = m.body.getReader()
                                  , _ = m.headers.get("X-File-Size") || m.headers.get("Content-Length")
                                  , x = _ ? parseInt(_) : 0
                                  , M = x !== 0;
                                let C = 0;
                                const R = new ReadableStream({
                                    start(A) {
                                        E();
                                        function E() {
                                            v.read().then( ({done: N, value: I}) => {
                                                if (N)
                                                    A.close();
                                                else {
                                                    C += I.byteLength;
                                                    const L = new ProgressEvent("progress",{
                                                        lengthComputable: M,
                                                        loaded: C,
                                                        total: x
                                                    });
                                                    for (let k = 0, B = g.length; k < B; k++) {
                                                        const X = g[k];
                                                        X.onProgress && X.onProgress(L)
                                                    }
                                                    A.enqueue(I),
                                                    E()
                                                }
                                            }
                                            , N => {
                                                A.error(N)
                                            }
                                            )
                                        }
                                    }
                                });
                                return new Response(R)
                            } else
                                throw new z3(`fetch for "${m.url}" responded with ${m.status}: ${m.statusText}`,m)
                        }
                        ).then(m => {
                            switch (p) {
                            case "arraybuffer":
                                return m.arrayBuffer();
                            case "blob":
                                return m.blob();
                            case "document":
                                return m.text().then(g => new DOMParser().parseFromString(g, f));
                            case "json":
                                return m.json();
                            default:
                                if (f === "")
                                    return m.text();
                                {
                                    const g = /charset="?([^;"\s]*)"?/i.exec(f)
                                      , v = g && g[1] ? g[1].toLowerCase() : void 0
                                      , _ = new TextDecoder(v);
                                    return m.arrayBuffer().then(x => _.decode(x))
                                }
                            }
                        }
                        ).then(m => {
                            zo.add(`file:${e}`, m);
                            const g = wl[e];
                            delete wl[e];
                            for (let v = 0, _ = g.length; v < _; v++) {
                                const x = g[v];
                                x.onLoad && x.onLoad(m)
                            }
                        }
                        ).catch(m => {
                            const g = wl[e];
                            if (g === void 0)
                                throw this.manager.itemError(e),
                                m;
                            delete wl[e];
                            for (let v = 0, _ = g.length; v < _; v++) {
                                const x = g[v];
                                x.onError && x.onError(m)
                            }
                            this.manager.itemError(e)
                        }
                        ).finally( () => {
                            this.manager.itemEnd(e)
                        }
                        ),
                        this.manager.itemStart(e)
                    }
                    setResponseType(e) {
                        return this.responseType = e,
                        this
                    }
                    setMimeType(e) {
                        return this.mimeType = e,
                        this
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                  , B3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = this
                          , c = new Cl(this.manager);
                        c.setPath(this.path),
                        c.setRequestHeader(this.requestHeader),
                        c.setWithCredentials(this.withCredentials),
                        c.load(e, function(f) {
                            try {
                                t(r.parse(JSON.parse(f)))
                            } catch (p) {
                                a ? a(p) : Et(p),
                                r.manager.itemError(e)
                            }
                        }, n, a)
                    }
                    parse(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const a = ym.parse(e[n]);
                            t.push(a)
                        }
                        return t
                    }
                }
                  , F3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = this
                          , c = []
                          , f = new H0
                          , p = new Cl(this.manager);
                        p.setPath(this.path),
                        p.setResponseType("arraybuffer"),
                        p.setRequestHeader(this.requestHeader),
                        p.setWithCredentials(r.withCredentials);
                        let m = 0;
                        function g(v) {
                            p.load(e[v], function(_) {
                                const x = r.parse(_, !0);
                                c[v] = {
                                    width: x.width,
                                    height: x.height,
                                    format: x.format,
                                    mipmaps: x.mipmaps
                                },
                                m += 1,
                                m === 6 && (x.mipmapCount === 1 && (f.minFilter = ei),
                                f.image = c,
                                f.format = x.format,
                                f.needsUpdate = !0,
                                t && t(f))
                            }, n, a)
                        }
                        if (Array.isArray(e))
                            for (let v = 0, _ = e.length; v < _; ++v)
                                g(v);
                        else
                            p.load(e, function(v) {
                                const _ = r.parse(v, !0);
                                if (_.isCubemap) {
                                    const x = _.mipmaps.length / _.mipmapCount;
                                    for (let M = 0; M < x; M++) {
                                        c[M] = {
                                            mipmaps: []
                                        };
                                        for (let C = 0; C < _.mipmapCount; C++)
                                            c[M].mipmaps.push(_.mipmaps[M * _.mipmapCount + C]),
                                            c[M].format = _.format,
                                            c[M].width = _.width,
                                            c[M].height = _.height
                                    }
                                    f.image = c
                                } else
                                    f.image.width = _.width,
                                    f.image.height = _.height,
                                    f.mipmaps = _.mipmaps;
                                _.mipmapCount === 1 && (f.minFilter = ei),
                                f.format = _.format,
                                f.needsUpdate = !0,
                                t && t(f)
                            }, n, a);
                        return f
                    }
                }
                ;
                const Yh = new WeakMap;
                var _m = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const r = this
                          , c = zo.get(`image:${e}`);
                        if (c !== void 0) {
                            if (c.complete === !0)
                                r.manager.itemStart(e),
                                setTimeout(function() {
                                    t && t(c),
                                    r.manager.itemEnd(e)
                                }, 0);
                            else {
                                let v = Yh.get(c);
                                v === void 0 && (v = [],
                                Yh.set(c, v)),
                                v.push({
                                    onLoad: t,
                                    onError: a
                                })
                            }
                            return c
                        }
                        const f = Wp("img");
                        function p() {
                            g(),
                            t && t(this);
                            const v = Yh.get(this) || [];
                            for (let _ = 0; _ < v.length; _++) {
                                const x = v[_];
                                x.onLoad && x.onLoad(this)
                            }
                            Yh.delete(this),
                            r.manager.itemEnd(e)
                        }
                        function m(v) {
                            g(),
                            a && a(v),
                            zo.remove(`image:${e}`);
                            const _ = Yh.get(this) || [];
                            for (let x = 0; x < _.length; x++) {
                                const M = _[x];
                                M.onError && M.onError(v)
                            }
                            Yh.delete(this),
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        }
                        function g() {
                            f.removeEventListener("load", p, !1),
                            f.removeEventListener("error", m, !1)
                        }
                        return f.addEventListener("load", p, !1),
                        f.addEventListener("error", m, !1),
                        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (f.crossOrigin = this.crossOrigin),
                        zo.add(`image:${e}`, f),
                        r.manager.itemStart(e),
                        f.src = e,
                        f
                    }
                }
                  , V3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = new $p;
                        r.colorSpace = wa;
                        const c = new _m(this.manager);
                        c.setCrossOrigin(this.crossOrigin),
                        c.setPath(this.path);
                        let f = 0;
                        function p(m) {
                            c.load(e[m], function(g) {
                                r.images[m] = g,
                                f++,
                                f === 6 && (r.needsUpdate = !0,
                                t && t(r))
                            }, void 0, a)
                        }
                        for (let m = 0; m < e.length; ++m)
                            p(m);
                        return r
                    }
                }
                  , k3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = this
                          , c = new Gr
                          , f = new Cl(this.manager);
                        return f.setResponseType("arraybuffer"),
                        f.setRequestHeader(this.requestHeader),
                        f.setPath(this.path),
                        f.setWithCredentials(r.withCredentials),
                        f.load(e, function(p) {
                            let m;
                            try {
                                m = r.parse(p)
                            } catch (g) {
                                if (a !== void 0)
                                    a(g);
                                else {
                                    g(g);
                                    return
                                }
                            }
                            m.image !== void 0 ? c.image = m.image : m.data !== void 0 && (c.image.width = m.width,
                            c.image.height = m.height,
                            c.image.data = m.data),
                            c.wrapS = m.wrapS !== void 0 ? m.wrapS : Ss,
                            c.wrapT = m.wrapT !== void 0 ? m.wrapT : Ss,
                            c.magFilter = m.magFilter !== void 0 ? m.magFilter : ei,
                            c.minFilter = m.minFilter !== void 0 ? m.minFilter : ei,
                            c.anisotropy = m.anisotropy !== void 0 ? m.anisotropy : 1,
                            m.colorSpace !== void 0 && (c.colorSpace = m.colorSpace),
                            m.flipY !== void 0 && (c.flipY = m.flipY),
                            m.format !== void 0 && (c.format = m.format),
                            m.type !== void 0 && (c.type = m.type),
                            m.mipmaps !== void 0 && (c.mipmaps = m.mipmaps,
                            c.minFilter = Do),
                            m.mipmapCount === 1 && (c.minFilter = ei),
                            m.generateMipmaps !== void 0 && (c.generateMipmaps = m.generateMipmaps),
                            c.needsUpdate = !0,
                            t && t(c, m)
                        }, n, a),
                        c
                    }
                }
                  , H3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = new oa
                          , c = new _m(this.manager);
                        return c.setCrossOrigin(this.crossOrigin),
                        c.setPath(this.path),
                        c.load(e, function(f) {
                            r.image = f,
                            r.needsUpdate = !0,
                            t !== void 0 && t(r)
                        }, n, a),
                        r
                    }
                }
                  , Uc = class extends Fn {
                    constructor(e, t=1) {
                        super(),
                        this.isLight = !0,
                        this.type = "Light",
                        this.color = new dt(e),
                        this.intensity = t
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.color.copy(e.color),
                        this.intensity = e.intensity,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.color = this.color.getHex(),
                        t.object.intensity = this.intensity,
                        t
                    }
                }
                  , NT = class extends Uc {
                    constructor(e, t, n) {
                        super(e, n),
                        this.isHemisphereLight = !0,
                        this.type = "HemisphereLight",
                        this.position.copy(Fn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.groundColor = new dt(t)
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.groundColor.copy(e.groundColor),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.groundColor = this.groundColor.getHex(),
                        t
                    }
                }
                ;
                const US = new Wt
                  , LT = new Y
                  , UT = new Y;
                var IS = class {
                    constructor(e) {
                        this.camera = e,
                        this.intensity = 1,
                        this.bias = 0,
                        this.normalBias = 0,
                        this.radius = 1,
                        this.blurSamples = 8,
                        this.mapSize = new Pe(512,512),
                        this.mapType = Ka,
                        this.map = null,
                        this.mapPass = null,
                        this.matrix = new Wt,
                        this.autoUpdate = !0,
                        this.needsUpdate = !1,
                        this._frustum = new Gh,
                        this._frameExtents = new Pe(1,1),
                        this._viewportCount = 1,
                        this._viewports = [new ti(0,0,1,1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(e) {
                        const t = this.camera
                          , n = this.matrix;
                        LT.setFromMatrixPosition(e.matrixWorld),
                        t.position.copy(LT),
                        UT.setFromMatrixPosition(e.target.matrixWorld),
                        t.lookAt(UT),
                        t.updateMatrixWorld(),
                        US.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(US, t.coordinateSystem, t.reversedDepth),
                        t.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        n.multiply(US)
                    }
                    getViewport(e) {
                        return this._viewports[e]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(),
                        this.mapPass && this.mapPass.dispose()
                    }
                    copy(e) {
                        return this.camera = e.camera.clone(),
                        this.intensity = e.intensity,
                        this.bias = e.bias,
                        this.radius = e.radius,
                        this.autoUpdate = e.autoUpdate,
                        this.needsUpdate = e.needsUpdate,
                        this.normalBias = e.normalBias,
                        this.blurSamples = e.blurSamples,
                        this.mapSize.copy(e.mapSize),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        const e = {};
                        return this.intensity !== 1 && (e.intensity = this.intensity),
                        this.bias !== 0 && (e.bias = this.bias),
                        this.normalBias !== 0 && (e.normalBias = this.normalBias),
                        this.radius !== 1 && (e.radius = this.radius),
                        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
                        e.camera = this.camera.toJSON(!1).object,
                        delete e.camera.matrix,
                        e
                    }
                }
                  , G3 = class extends IS {
                    constructor() {
                        super(new ca(50,1,.5,500)),
                        this.isSpotLightShadow = !0,
                        this.focus = 1,
                        this.aspect = 1
                    }
                    updateMatrices(e) {
                        const t = this.camera
                          , n = _h * 2 * e.angle * this.focus
                          , a = this.mapSize.width / this.mapSize.height * this.aspect
                          , r = e.distance || t.far;
                        (n !== t.fov || a !== t.aspect || r !== t.far) && (t.fov = n,
                        t.aspect = a,
                        t.far = r,
                        t.updateProjectionMatrix()),
                        super.updateMatrices(e)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.focus = e.focus,
                        this
                    }
                }
                  , IT = class extends Uc {
                    constructor(e, t, n=0, a=Math.PI / 3, r=0, c=2) {
                        super(e, t),
                        this.isSpotLight = !0,
                        this.type = "SpotLight",
                        this.position.copy(Fn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new Fn,
                        this.distance = n,
                        this.angle = a,
                        this.penumbra = r,
                        this.decay = c,
                        this.map = null,
                        this.shadow = new G3
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / Math.PI
                    }
                    dispose() {
                        super.dispose(),
                        this.shadow.dispose()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.distance = e.distance,
                        this.angle = e.angle,
                        this.penumbra = e.penumbra,
                        this.decay = e.decay,
                        this.target = e.target.clone(),
                        this.map = e.map,
                        this.shadow = e.shadow.clone(),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.distance = this.distance,
                        t.object.angle = this.angle,
                        t.object.decay = this.decay,
                        t.object.penumbra = this.penumbra,
                        t.object.target = this.target.uuid,
                        this.map && this.map.isTexture && (t.object.map = this.map.toJSON(e).uuid),
                        t.object.shadow = this.shadow.toJSON(),
                        t
                    }
                }
                  , W3 = class extends IS {
                    constructor() {
                        super(new ca(90,1,.5,500)),
                        this.isPointLightShadow = !0
                    }
                }
                  , OT = class extends Uc {
                    constructor(e, t, n=0, a=2) {
                        super(e, t),
                        this.isPointLight = !0,
                        this.type = "PointLight",
                        this.distance = n,
                        this.decay = a,
                        this.shadow = new W3
                    }
                    get power() {
                        return this.intensity * 4 * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                    dispose() {
                        super.dispose(),
                        this.shadow.dispose()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.distance = e.distance,
                        this.decay = e.decay,
                        this.shadow = e.shadow.clone(),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.distance = this.distance,
                        t.object.decay = this.decay,
                        t.object.shadow = this.shadow.toJSON(),
                        t
                    }
                }
                  , jh = class extends T0 {
                    constructor(e=-1, t=1, n=1, a=-1, r=.1, c=2e3) {
                        super(),
                        this.isOrthographicCamera = !0,
                        this.type = "OrthographicCamera",
                        this.zoom = 1,
                        this.view = null,
                        this.left = e,
                        this.right = t,
                        this.top = n,
                        this.bottom = a,
                        this.near = r,
                        this.far = c,
                        this.updateProjectionMatrix()
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.left = e.left,
                        this.right = e.right,
                        this.top = e.top,
                        this.bottom = e.bottom,
                        this.near = e.near,
                        this.far = e.far,
                        this.zoom = e.zoom,
                        this.view = e.view === null ? null : Object.assign({}, e.view),
                        this
                    }
                    setViewOffset(e, t, n, a, r, c) {
                        this.view === null && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = a,
                        this.view.width = r,
                        this.view.height = c,
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        this.view !== null && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const e = (this.right - this.left) / (2 * this.zoom)
                          , t = (this.top - this.bottom) / (2 * this.zoom)
                          , n = (this.right + this.left) / 2
                          , a = (this.top + this.bottom) / 2;
                        let r = n - e
                          , c = n + e
                          , f = a + t
                          , p = a - t;
                        if (this.view !== null && this.view.enabled) {
                            const m = (this.right - this.left) / this.view.fullWidth / this.zoom
                              , g = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            r += m * this.view.offsetX,
                            c = r + m * this.view.width,
                            f -= g * this.view.offsetY,
                            p = f - g * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(r, c, f, p, this.near, this.far, this.coordinateSystem, this.reversedDepth),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.zoom = this.zoom,
                        t.object.left = this.left,
                        t.object.right = this.right,
                        t.object.top = this.top,
                        t.object.bottom = this.bottom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        this.view !== null && (t.object.view = Object.assign({}, this.view)),
                        t
                    }
                }
                  , X3 = class extends IS {
                    constructor() {
                        super(new jh(-5,5,5,-5,.5,500)),
                        this.isDirectionalLightShadow = !0
                    }
                }
                  , PT = class extends Uc {
                    constructor(e, t) {
                        super(e, t),
                        this.isDirectionalLight = !0,
                        this.type = "DirectionalLight",
                        this.position.copy(Fn.DEFAULT_UP),
                        this.updateMatrix(),
                        this.target = new Fn,
                        this.shadow = new X3
                    }
                    dispose() {
                        super.dispose(),
                        this.shadow.dispose()
                    }
                    copy(e) {
                        return super.copy(e),
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.shadow = this.shadow.toJSON(),
                        t.object.target = this.target.uuid,
                        t
                    }
                }
                  , zT = class extends Uc {
                    constructor(e, t) {
                        super(e, t),
                        this.isAmbientLight = !0,
                        this.type = "AmbientLight"
                    }
                }
                  , BT = class extends Uc {
                    constructor(e, t, n=10, a=10) {
                        super(e, t),
                        this.isRectAreaLight = !0,
                        this.type = "RectAreaLight",
                        this.width = n,
                        this.height = a
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(e) {
                        this.intensity = e / (this.width * this.height * Math.PI)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.width = e.width,
                        this.height = e.height,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.width = this.width,
                        t.object.height = this.height,
                        t
                    }
                }
                  , OS = class {
                    constructor() {
                        this.isSphericalHarmonics3 = !0,
                        this.coefficients = [];
                        for (let e = 0; e < 9; e++)
                            this.coefficients.push(new Y)
                    }
                    set(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].copy(e[t]);
                        return this
                    }
                    zero() {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].set(0, 0, 0);
                        return this
                    }
                    getAt(e, t) {
                        const n = e.x
                          , a = e.y
                          , r = e.z
                          , c = this.coefficients;
                        return t.copy(c[0]).multiplyScalar(.282095),
                        t.addScaledVector(c[1], .488603 * a),
                        t.addScaledVector(c[2], .488603 * r),
                        t.addScaledVector(c[3], .488603 * n),
                        t.addScaledVector(c[4], 1.092548 * (n * a)),
                        t.addScaledVector(c[5], 1.092548 * (a * r)),
                        t.addScaledVector(c[6], .315392 * (3 * r * r - 1)),
                        t.addScaledVector(c[7], 1.092548 * (n * r)),
                        t.addScaledVector(c[8], .546274 * (n * n - a * a)),
                        t
                    }
                    getIrradianceAt(e, t) {
                        const n = e.x
                          , a = e.y
                          , r = e.z
                          , c = this.coefficients;
                        return t.copy(c[0]).multiplyScalar(.886227),
                        t.addScaledVector(c[1], 2 * .511664 * a),
                        t.addScaledVector(c[2], 2 * .511664 * r),
                        t.addScaledVector(c[3], 2 * .511664 * n),
                        t.addScaledVector(c[4], 2 * .429043 * n * a),
                        t.addScaledVector(c[5], 2 * .429043 * a * r),
                        t.addScaledVector(c[6], .743125 * r * r - .247708),
                        t.addScaledVector(c[7], 2 * .429043 * n * r),
                        t.addScaledVector(c[8], .429043 * (n * n - a * a)),
                        t
                    }
                    add(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].add(e.coefficients[t]);
                        return this
                    }
                    addScaledSH(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].addScaledVector(e.coefficients[n], t);
                        return this
                    }
                    scale(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].multiplyScalar(e);
                        return this
                    }
                    lerp(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].lerp(e.coefficients[n], t);
                        return this
                    }
                    equals(e) {
                        for (let t = 0; t < 9; t++)
                            if (!this.coefficients[t].equals(e.coefficients[t]))
                                return !1;
                        return !0
                    }
                    copy(e) {
                        return this.set(e.coefficients)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    fromArray(e, t=0) {
                        const n = this.coefficients;
                        for (let a = 0; a < 9; a++)
                            n[a].fromArray(e, t + a * 3);
                        return this
                    }
                    toArray(e=[], t=0) {
                        const n = this.coefficients;
                        for (let a = 0; a < 9; a++)
                            n[a].toArray(e, t + a * 3);
                        return e
                    }
                    static getBasisAt(e, t) {
                        const n = e.x
                          , a = e.y
                          , r = e.z;
                        t[0] = .282095,
                        t[1] = .488603 * a,
                        t[2] = .488603 * r,
                        t[3] = .488603 * n,
                        t[4] = 1.092548 * n * a,
                        t[5] = 1.092548 * a * r,
                        t[6] = .315392 * (3 * r * r - 1),
                        t[7] = 1.092548 * n * r,
                        t[8] = .546274 * (n * n - a * a)
                    }
                }
                  , FT = class extends Uc {
                    constructor(e=new OS, t=1) {
                        super(void 0, t),
                        this.isLightProbe = !0,
                        this.sh = e
                    }
                    copy(e) {
                        return super.copy(e),
                        this.sh.copy(e.sh),
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.object.sh = this.sh.toArray(),
                        t
                    }
                }
                  , VT = class e2 extends Ts {
                    constructor(t) {
                        super(t),
                        this.textures = {}
                    }
                    load(t, n, a, r) {
                        const c = this
                          , f = new Cl(c.manager);
                        f.setPath(c.path),
                        f.setRequestHeader(c.requestHeader),
                        f.setWithCredentials(c.withCredentials),
                        f.load(t, function(p) {
                            try {
                                n(c.parse(JSON.parse(p)))
                            } catch (m) {
                                r ? r(m) : Et(m),
                                c.manager.itemError(t)
                            }
                        }, a, r)
                    }
                    parse(t) {
                        const n = this.textures;
                        function a(c) {
                            return n[c] === void 0 && ot("MaterialLoader: Undefined texture", c),
                            n[c]
                        }
                        const r = this.createMaterialFromType(t.type);
                        if (t.uuid !== void 0 && (r.uuid = t.uuid),
                        t.name !== void 0 && (r.name = t.name),
                        t.color !== void 0 && r.color !== void 0 && r.color.setHex(t.color),
                        t.roughness !== void 0 && (r.roughness = t.roughness),
                        t.metalness !== void 0 && (r.metalness = t.metalness),
                        t.sheen !== void 0 && (r.sheen = t.sheen),
                        t.sheenColor !== void 0 && (r.sheenColor = new dt().setHex(t.sheenColor)),
                        t.sheenRoughness !== void 0 && (r.sheenRoughness = t.sheenRoughness),
                        t.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(t.emissive),
                        t.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(t.specular),
                        t.specularIntensity !== void 0 && (r.specularIntensity = t.specularIntensity),
                        t.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(t.specularColor),
                        t.shininess !== void 0 && (r.shininess = t.shininess),
                        t.clearcoat !== void 0 && (r.clearcoat = t.clearcoat),
                        t.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = t.clearcoatRoughness),
                        t.dispersion !== void 0 && (r.dispersion = t.dispersion),
                        t.iridescence !== void 0 && (r.iridescence = t.iridescence),
                        t.iridescenceIOR !== void 0 && (r.iridescenceIOR = t.iridescenceIOR),
                        t.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = t.iridescenceThicknessRange),
                        t.transmission !== void 0 && (r.transmission = t.transmission),
                        t.thickness !== void 0 && (r.thickness = t.thickness),
                        t.attenuationDistance !== void 0 && (r.attenuationDistance = t.attenuationDistance),
                        t.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(t.attenuationColor),
                        t.anisotropy !== void 0 && (r.anisotropy = t.anisotropy),
                        t.anisotropyRotation !== void 0 && (r.anisotropyRotation = t.anisotropyRotation),
                        t.fog !== void 0 && (r.fog = t.fog),
                        t.flatShading !== void 0 && (r.flatShading = t.flatShading),
                        t.blending !== void 0 && (r.blending = t.blending),
                        t.combine !== void 0 && (r.combine = t.combine),
                        t.side !== void 0 && (r.side = t.side),
                        t.shadowSide !== void 0 && (r.shadowSide = t.shadowSide),
                        t.opacity !== void 0 && (r.opacity = t.opacity),
                        t.transparent !== void 0 && (r.transparent = t.transparent),
                        t.alphaTest !== void 0 && (r.alphaTest = t.alphaTest),
                        t.alphaHash !== void 0 && (r.alphaHash = t.alphaHash),
                        t.depthFunc !== void 0 && (r.depthFunc = t.depthFunc),
                        t.depthTest !== void 0 && (r.depthTest = t.depthTest),
                        t.depthWrite !== void 0 && (r.depthWrite = t.depthWrite),
                        t.colorWrite !== void 0 && (r.colorWrite = t.colorWrite),
                        t.blendSrc !== void 0 && (r.blendSrc = t.blendSrc),
                        t.blendDst !== void 0 && (r.blendDst = t.blendDst),
                        t.blendEquation !== void 0 && (r.blendEquation = t.blendEquation),
                        t.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = t.blendSrcAlpha),
                        t.blendDstAlpha !== void 0 && (r.blendDstAlpha = t.blendDstAlpha),
                        t.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = t.blendEquationAlpha),
                        t.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(t.blendColor),
                        t.blendAlpha !== void 0 && (r.blendAlpha = t.blendAlpha),
                        t.stencilWriteMask !== void 0 && (r.stencilWriteMask = t.stencilWriteMask),
                        t.stencilFunc !== void 0 && (r.stencilFunc = t.stencilFunc),
                        t.stencilRef !== void 0 && (r.stencilRef = t.stencilRef),
                        t.stencilFuncMask !== void 0 && (r.stencilFuncMask = t.stencilFuncMask),
                        t.stencilFail !== void 0 && (r.stencilFail = t.stencilFail),
                        t.stencilZFail !== void 0 && (r.stencilZFail = t.stencilZFail),
                        t.stencilZPass !== void 0 && (r.stencilZPass = t.stencilZPass),
                        t.stencilWrite !== void 0 && (r.stencilWrite = t.stencilWrite),
                        t.wireframe !== void 0 && (r.wireframe = t.wireframe),
                        t.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = t.wireframeLinewidth),
                        t.wireframeLinecap !== void 0 && (r.wireframeLinecap = t.wireframeLinecap),
                        t.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = t.wireframeLinejoin),
                        t.rotation !== void 0 && (r.rotation = t.rotation),
                        t.linewidth !== void 0 && (r.linewidth = t.linewidth),
                        t.dashSize !== void 0 && (r.dashSize = t.dashSize),
                        t.gapSize !== void 0 && (r.gapSize = t.gapSize),
                        t.scale !== void 0 && (r.scale = t.scale),
                        t.polygonOffset !== void 0 && (r.polygonOffset = t.polygonOffset),
                        t.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = t.polygonOffsetFactor),
                        t.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = t.polygonOffsetUnits),
                        t.dithering !== void 0 && (r.dithering = t.dithering),
                        t.alphaToCoverage !== void 0 && (r.alphaToCoverage = t.alphaToCoverage),
                        t.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = t.premultipliedAlpha),
                        t.forceSinglePass !== void 0 && (r.forceSinglePass = t.forceSinglePass),
                        t.allowOverride !== void 0 && (r.allowOverride = t.allowOverride),
                        t.visible !== void 0 && (r.visible = t.visible),
                        t.toneMapped !== void 0 && (r.toneMapped = t.toneMapped),
                        t.userData !== void 0 && (r.userData = t.userData),
                        t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors),
                        t.uniforms !== void 0)
                            for (const c in t.uniforms) {
                                const f = t.uniforms[c];
                                switch (r.uniforms[c] = {},
                                f.type) {
                                case "t":
                                    r.uniforms[c].value = a(f.value);
                                    break;
                                case "c":
                                    r.uniforms[c].value = new dt().setHex(f.value);
                                    break;
                                case "v2":
                                    r.uniforms[c].value = new Pe().fromArray(f.value);
                                    break;
                                case "v3":
                                    r.uniforms[c].value = new Y().fromArray(f.value);
                                    break;
                                case "v4":
                                    r.uniforms[c].value = new ti().fromArray(f.value);
                                    break;
                                case "m3":
                                    r.uniforms[c].value = new en().fromArray(f.value);
                                    break;
                                case "m4":
                                    r.uniforms[c].value = new Wt().fromArray(f.value);
                                    break;
                                default:
                                    r.uniforms[c].value = f.value
                                }
                            }
                        if (t.defines !== void 0 && (r.defines = t.defines),
                        t.vertexShader !== void 0 && (r.vertexShader = t.vertexShader),
                        t.fragmentShader !== void 0 && (r.fragmentShader = t.fragmentShader),
                        t.glslVersion !== void 0 && (r.glslVersion = t.glslVersion),
                        t.extensions !== void 0)
                            for (const c in t.extensions)
                                r.extensions[c] = t.extensions[c];
                        if (t.lights !== void 0 && (r.lights = t.lights),
                        t.clipping !== void 0 && (r.clipping = t.clipping),
                        t.size !== void 0 && (r.size = t.size),
                        t.sizeAttenuation !== void 0 && (r.sizeAttenuation = t.sizeAttenuation),
                        t.map !== void 0 && (r.map = a(t.map)),
                        t.matcap !== void 0 && (r.matcap = a(t.matcap)),
                        t.alphaMap !== void 0 && (r.alphaMap = a(t.alphaMap)),
                        t.bumpMap !== void 0 && (r.bumpMap = a(t.bumpMap)),
                        t.bumpScale !== void 0 && (r.bumpScale = t.bumpScale),
                        t.normalMap !== void 0 && (r.normalMap = a(t.normalMap)),
                        t.normalMapType !== void 0 && (r.normalMapType = t.normalMapType),
                        t.normalScale !== void 0) {
                            let c = t.normalScale;
                            Array.isArray(c) === !1 && (c = [c, c]),
                            r.normalScale = new Pe().fromArray(c)
                        }
                        return t.displacementMap !== void 0 && (r.displacementMap = a(t.displacementMap)),
                        t.displacementScale !== void 0 && (r.displacementScale = t.displacementScale),
                        t.displacementBias !== void 0 && (r.displacementBias = t.displacementBias),
                        t.roughnessMap !== void 0 && (r.roughnessMap = a(t.roughnessMap)),
                        t.metalnessMap !== void 0 && (r.metalnessMap = a(t.metalnessMap)),
                        t.emissiveMap !== void 0 && (r.emissiveMap = a(t.emissiveMap)),
                        t.emissiveIntensity !== void 0 && (r.emissiveIntensity = t.emissiveIntensity),
                        t.specularMap !== void 0 && (r.specularMap = a(t.specularMap)),
                        t.specularIntensityMap !== void 0 && (r.specularIntensityMap = a(t.specularIntensityMap)),
                        t.specularColorMap !== void 0 && (r.specularColorMap = a(t.specularColorMap)),
                        t.envMap !== void 0 && (r.envMap = a(t.envMap)),
                        t.envMapRotation !== void 0 && r.envMapRotation.fromArray(t.envMapRotation),
                        t.envMapIntensity !== void 0 && (r.envMapIntensity = t.envMapIntensity),
                        t.reflectivity !== void 0 && (r.reflectivity = t.reflectivity),
                        t.refractionRatio !== void 0 && (r.refractionRatio = t.refractionRatio),
                        t.lightMap !== void 0 && (r.lightMap = a(t.lightMap)),
                        t.lightMapIntensity !== void 0 && (r.lightMapIntensity = t.lightMapIntensity),
                        t.aoMap !== void 0 && (r.aoMap = a(t.aoMap)),
                        t.aoMapIntensity !== void 0 && (r.aoMapIntensity = t.aoMapIntensity),
                        t.gradientMap !== void 0 && (r.gradientMap = a(t.gradientMap)),
                        t.clearcoatMap !== void 0 && (r.clearcoatMap = a(t.clearcoatMap)),
                        t.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = a(t.clearcoatRoughnessMap)),
                        t.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = a(t.clearcoatNormalMap)),
                        t.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Pe().fromArray(t.clearcoatNormalScale)),
                        t.iridescenceMap !== void 0 && (r.iridescenceMap = a(t.iridescenceMap)),
                        t.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = a(t.iridescenceThicknessMap)),
                        t.transmissionMap !== void 0 && (r.transmissionMap = a(t.transmissionMap)),
                        t.thicknessMap !== void 0 && (r.thicknessMap = a(t.thicknessMap)),
                        t.anisotropyMap !== void 0 && (r.anisotropyMap = a(t.anisotropyMap)),
                        t.sheenColorMap !== void 0 && (r.sheenColorMap = a(t.sheenColorMap)),
                        t.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = a(t.sheenRoughnessMap)),
                        r
                    }
                    setTextures(t) {
                        return this.textures = t,
                        this
                    }
                    createMaterialFromType(t) {
                        return e2.createMaterialFromType(t)
                    }
                    static createMaterialFromType(t) {
                        return new {
                            ShadowMaterial: yT,
                            SpriteMaterial: Q_,
                            RawShaderMaterial: TS,
                            ShaderMaterial: dr,
                            PointsMaterial: sS,
                            MeshPhysicalMaterial: _T,
                            MeshStandardMaterial: ES,
                            MeshPhongMaterial: ST,
                            MeshToonMaterial: xT,
                            MeshNormalMaterial: bT,
                            MeshLambertMaterial: MT,
                            MeshDepthMaterial: AS,
                            MeshDistanceMaterial: wS,
                            MeshBasicMaterial: Rc,
                            MeshMatcapMaterial: TT,
                            LineDashedMaterial: ET,
                            LineBasicMaterial: is,
                            Material: Na
                        }[t]
                    }
                }
                  , PS = class {
                    static extractUrlBase(e) {
                        const t = e.lastIndexOf("/");
                        return t === -1 ? "./" : e.slice(0, t + 1)
                    }
                    static resolveURL(e, t) {
                        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                    }
                }
                  , kT = class extends Xt {
                    constructor() {
                        super(),
                        this.isInstancedBufferGeometry = !0,
                        this.type = "InstancedBufferGeometry",
                        this.instanceCount = 1 / 0
                    }
                    copy(e) {
                        return super.copy(e),
                        this.instanceCount = e.instanceCount,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.instanceCount = this.instanceCount,
                        e.isInstancedBufferGeometry = !0,
                        e
                    }
                }
                  , HT = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = this
                          , c = new Cl(r.manager);
                        c.setPath(r.path),
                        c.setRequestHeader(r.requestHeader),
                        c.setWithCredentials(r.withCredentials),
                        c.load(e, function(f) {
                            try {
                                t(r.parse(JSON.parse(f)))
                            } catch (p) {
                                a ? a(p) : Et(p),
                                r.manager.itemError(e)
                            }
                        }, n, a)
                    }
                    parse(e) {
                        const t = {}
                          , n = {};
                        function a(_, x) {
                            if (t[x] !== void 0)
                                return t[x];
                            const M = _.interleavedBuffers[x]
                              , C = r(_, M.buffer)
                              , R = new A0(vh(M.type, C),M.stride);
                            return R.uuid = M.uuid,
                            t[x] = R,
                            R
                        }
                        function r(_, x) {
                            if (n[x] !== void 0)
                                return n[x];
                            const M = _.arrayBuffers[x]
                              , C = new Uint32Array(M).buffer;
                            return n[x] = C,
                            C
                        }
                        const c = e.isInstancedBufferGeometry ? new kT : new Xt
                          , f = e.data.index;
                        if (f !== void 0) {
                            const _ = vh(f.type, f.array);
                            c.setIndex(new Vn(_,1))
                        }
                        const p = e.data.attributes;
                        for (const _ in p) {
                            const x = p[_];
                            let M;
                            if (x.isInterleavedBufferAttribute)
                                M = new em(a(e.data, x.data),x.itemSize,x.offset,x.normalized);
                            else {
                                const C = vh(x.type, x.array);
                                M = new (x.isInstancedBufferAttribute ? kh : Vn)(C,x.itemSize,x.normalized)
                            }
                            x.name !== void 0 && (M.name = x.name),
                            x.usage !== void 0 && M.setUsage(x.usage),
                            c.setAttribute(_, M)
                        }
                        const m = e.data.morphAttributes;
                        if (m)
                            for (const _ in m) {
                                const x = m[_]
                                  , M = [];
                                for (let C = 0, R = x.length; C < R; C++) {
                                    const A = x[C];
                                    let E;
                                    A.isInterleavedBufferAttribute ? E = new em(a(e.data, A.data),A.itemSize,A.offset,A.normalized) : E = new Vn(vh(A.type, A.array),A.itemSize,A.normalized),
                                    A.name !== void 0 && (E.name = A.name),
                                    M.push(E)
                                }
                                c.morphAttributes[_] = M
                            }
                        e.data.morphTargetsRelative && (c.morphTargetsRelative = !0);
                        const g = e.data.groups || e.data.drawcalls || e.data.offsets;
                        if (g !== void 0)
                            for (let _ = 0, x = g.length; _ !== x; ++_) {
                                const M = g[_];
                                c.addGroup(M.start, M.count, M.materialIndex)
                            }
                        const v = e.data.boundingSphere;
                        return v !== void 0 && (c.boundingSphere = new Sa().fromJSON(v)),
                        e.name && (c.name = e.name),
                        e.userData && (c.userData = e.userData),
                        c
                    }
                }
                  , q3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = this
                          , c = this.path === "" ? PS.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || c;
                        const f = new Cl(this.manager);
                        f.setPath(this.path),
                        f.setRequestHeader(this.requestHeader),
                        f.setWithCredentials(this.withCredentials),
                        f.load(e, function(p) {
                            let m = null;
                            try {
                                m = JSON.parse(p)
                            } catch (v) {
                                a !== void 0 && a(v),
                                v("ObjectLoader: Can't parse " + e + ".", v.message);
                                return
                            }
                            const g = m.metadata;
                            if (g === void 0 || g.type === void 0 || g.type.toLowerCase() === "geometry") {
                                a !== void 0 && a(new Error("THREE.ObjectLoader: Can't load " + e)),
                                Et("ObjectLoader: Can't load " + e);
                                return
                            }
                            r.parse(m, t)
                        }, n, a)
                    }
                    async loadAsync(e, t) {
                        const n = this
                          , a = this.path === "" ? PS.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || a;
                        const r = new Cl(this.manager);
                        r.setPath(this.path),
                        r.setRequestHeader(this.requestHeader),
                        r.setWithCredentials(this.withCredentials);
                        const c = await r.loadAsync(e, t)
                          , f = JSON.parse(c)
                          , p = f.metadata;
                        if (p === void 0 || p.type === void 0 || p.type.toLowerCase() === "geometry")
                            throw new Error("THREE.ObjectLoader: Can't load " + e);
                        return await n.parseAsync(f)
                    }
                    parse(e, t) {
                        const n = this.parseAnimations(e.animations)
                          , a = this.parseShapes(e.shapes)
                          , r = this.parseGeometries(e.geometries, a)
                          , c = this.parseImages(e.images, function() {
                            t !== void 0 && t(m)
                        })
                          , f = this.parseTextures(e.textures, c)
                          , p = this.parseMaterials(e.materials, f)
                          , m = this.parseObject(e.object, r, p, f, n)
                          , g = this.parseSkeletons(e.skeletons, m);
                        if (this.bindSkeletons(m, g),
                        this.bindLightTargets(m),
                        t !== void 0) {
                            let v = !1;
                            for (const _ in c)
                                if (c[_].data instanceof HTMLImageElement) {
                                    v = !0;
                                    break
                                }
                            v === !1 && t(m)
                        }
                        return m
                    }
                    async parseAsync(e) {
                        const t = this.parseAnimations(e.animations)
                          , n = this.parseShapes(e.shapes)
                          , a = this.parseGeometries(e.geometries, n)
                          , r = await this.parseImagesAsync(e.images)
                          , c = this.parseTextures(e.textures, r)
                          , f = this.parseMaterials(e.materials, c)
                          , p = this.parseObject(e.object, a, f, c, t)
                          , m = this.parseSkeletons(e.skeletons, p);
                        return this.bindSkeletons(p, m),
                        this.bindLightTargets(p),
                        p
                    }
                    parseShapes(e) {
                        const t = {};
                        if (e !== void 0)
                            for (let n = 0, a = e.length; n < a; n++) {
                                const r = new qu().fromJSON(e[n]);
                                t[r.uuid] = r
                            }
                        return t
                    }
                    parseSkeletons(e, t) {
                        const n = {}
                          , a = {};
                        if (t.traverse(function(r) {
                            r.isBone && (a[r.uuid] = r)
                        }),
                        e !== void 0)
                            for (let r = 0, c = e.length; r < c; r++) {
                                const f = new EM().fromJSON(e[r], a);
                                n[f.uuid] = f
                            }
                        return n
                    }
                    parseGeometries(e, t) {
                        const n = {};
                        if (e !== void 0) {
                            const a = new HT;
                            for (let r = 0, c = e.length; r < c; r++) {
                                let f;
                                const p = e[r];
                                switch (p.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    f = a.parse(p);
                                    break;
                                default:
                                    p.type in vT ? f = vT[p.type].fromJSON(p, t) : ot(`ObjectLoader: Unsupported geometry type "${p.type}"`)
                                }
                                f.uuid = p.uuid,
                                p.name !== void 0 && (f.name = p.name),
                                p.userData !== void 0 && (f.userData = p.userData),
                                n[p.uuid] = f
                            }
                        }
                        return n
                    }
                    parseMaterials(e, t) {
                        const n = {}
                          , a = {};
                        if (e !== void 0) {
                            const r = new VT;
                            r.setTextures(t);
                            for (let c = 0, f = e.length; c < f; c++) {
                                const p = e[c];
                                n[p.uuid] === void 0 && (n[p.uuid] = r.parse(p)),
                                a[p.uuid] = n[p.uuid]
                            }
                        }
                        return a
                    }
                    parseAnimations(e) {
                        const t = {};
                        if (e !== void 0)
                            for (let n = 0; n < e.length; n++) {
                                const a = e[n]
                                  , r = ym.parse(a);
                                t[r.uuid] = r
                            }
                        return t
                    }
                    parseImages(e, t) {
                        const n = this
                          , a = {};
                        let r;
                        function c(p) {
                            return n.manager.itemStart(p),
                            r.load(p, function() {
                                n.manager.itemEnd(p)
                            }, void 0, function() {
                                n.manager.itemError(p),
                                n.manager.itemEnd(p)
                            })
                        }
                        function f(p) {
                            if (typeof p == "string") {
                                const m = p;
                                return c(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(m) ? m : n.resourcePath + m)
                            } else
                                return p.data ? {
                                    data: vh(p.type, p.data),
                                    width: p.width,
                                    height: p.height
                                } : null
                        }
                        if (e !== void 0 && e.length > 0) {
                            r = new _m(new LS(t)),
                            r.setCrossOrigin(this.crossOrigin);
                            for (let p = 0, m = e.length; p < m; p++) {
                                const g = e[p]
                                  , v = g.url;
                                if (Array.isArray(v)) {
                                    const _ = [];
                                    for (let x = 0, M = v.length; x < M; x++) {
                                        const C = v[x]
                                          , R = f(C);
                                        R !== null && (R instanceof HTMLImageElement ? _.push(R) : _.push(new Gr(R.data,R.width,R.height)))
                                    }
                                    a[g.uuid] = new bc(_)
                                } else {
                                    const _ = f(g.url);
                                    a[g.uuid] = new bc(_)
                                }
                            }
                        }
                        return a
                    }
                    async parseImagesAsync(e) {
                        const t = this
                          , n = {};
                        let a;
                        async function r(c) {
                            if (typeof c == "string") {
                                const f = c
                                  , p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : t.resourcePath + f;
                                return await a.loadAsync(p)
                            } else
                                return c.data ? {
                                    data: vh(c.type, c.data),
                                    width: c.width,
                                    height: c.height
                                } : null
                        }
                        if (e !== void 0 && e.length > 0) {
                            a = new _m(this.manager),
                            a.setCrossOrigin(this.crossOrigin);
                            for (let c = 0, f = e.length; c < f; c++) {
                                const p = e[c]
                                  , m = p.url;
                                if (Array.isArray(m)) {
                                    const g = [];
                                    for (let v = 0, _ = m.length; v < _; v++) {
                                        const x = m[v]
                                          , M = await r(x);
                                        M !== null && (M instanceof HTMLImageElement ? g.push(M) : g.push(new Gr(M.data,M.width,M.height)))
                                    }
                                    n[p.uuid] = new bc(g)
                                } else {
                                    const g = await r(p.url);
                                    n[p.uuid] = new bc(g)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(e, t) {
                        function n(r, c) {
                            return typeof r == "number" ? r : (ot("ObjectLoader.parseTexture: Constant should be in numeric form.", r),
                            c[r])
                        }
                        const a = {};
                        if (e !== void 0)
                            for (let r = 0, c = e.length; r < c; r++) {
                                const f = e[r];
                                f.image === void 0 && ot('ObjectLoader: No "image" specified for', f.uuid),
                                t[f.image] === void 0 && ot("ObjectLoader: Undefined image", f.image);
                                const p = t[f.image]
                                  , m = p.data;
                                let g;
                                Array.isArray(m) ? (g = new $p,
                                m.length === 6 && (g.needsUpdate = !0)) : (m && m.data ? g = new Gr : g = new oa,
                                m && (g.needsUpdate = !0)),
                                g.source = p,
                                g.uuid = f.uuid,
                                f.name !== void 0 && (g.name = f.name),
                                f.mapping !== void 0 && (g.mapping = n(f.mapping, Y3)),
                                f.channel !== void 0 && (g.channel = f.channel),
                                f.offset !== void 0 && g.offset.fromArray(f.offset),
                                f.repeat !== void 0 && g.repeat.fromArray(f.repeat),
                                f.center !== void 0 && g.center.fromArray(f.center),
                                f.rotation !== void 0 && (g.rotation = f.rotation),
                                f.wrap !== void 0 && (g.wrapS = n(f.wrap[0], GT),
                                g.wrapT = n(f.wrap[1], GT)),
                                f.format !== void 0 && (g.format = f.format),
                                f.internalFormat !== void 0 && (g.internalFormat = f.internalFormat),
                                f.type !== void 0 && (g.type = f.type),
                                f.colorSpace !== void 0 && (g.colorSpace = f.colorSpace),
                                f.minFilter !== void 0 && (g.minFilter = n(f.minFilter, WT)),
                                f.magFilter !== void 0 && (g.magFilter = n(f.magFilter, WT)),
                                f.anisotropy !== void 0 && (g.anisotropy = f.anisotropy),
                                f.flipY !== void 0 && (g.flipY = f.flipY),
                                f.generateMipmaps !== void 0 && (g.generateMipmaps = f.generateMipmaps),
                                f.premultiplyAlpha !== void 0 && (g.premultiplyAlpha = f.premultiplyAlpha),
                                f.unpackAlignment !== void 0 && (g.unpackAlignment = f.unpackAlignment),
                                f.compareFunction !== void 0 && (g.compareFunction = f.compareFunction),
                                f.userData !== void 0 && (g.userData = f.userData),
                                a[f.uuid] = g
                            }
                        return a
                    }
                    parseObject(e, t, n, a, r) {
                        let c;
                        function f(_) {
                            return t[_] === void 0 && ot("ObjectLoader: Undefined geometry", _),
                            t[_]
                        }
                        function p(_) {
                            if (_ !== void 0) {
                                if (Array.isArray(_)) {
                                    const x = [];
                                    for (let M = 0, C = _.length; M < C; M++) {
                                        const R = _[M];
                                        n[R] === void 0 && ot("ObjectLoader: Undefined material", R),
                                        x.push(n[R])
                                    }
                                    return x
                                }
                                return n[_] === void 0 && ot("ObjectLoader: Undefined material", _),
                                n[_]
                            }
                        }
                        function m(_) {
                            return a[_] === void 0 && ot("ObjectLoader: Undefined texture", _),
                            a[_]
                        }
                        let g, v;
                        switch (e.type) {
                        case "Scene":
                            c = new Z_,
                            e.background !== void 0 && (Number.isInteger(e.background) ? c.background = new dt(e.background) : c.background = m(e.background)),
                            e.environment !== void 0 && (c.environment = m(e.environment)),
                            e.fog !== void 0 && (e.fog.type === "Fog" ? c.fog = new fM(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (c.fog = new uM(e.fog.color,e.fog.density)),
                            e.fog.name !== "" && (c.fog.name = e.fog.name)),
                            e.backgroundBlurriness !== void 0 && (c.backgroundBlurriness = e.backgroundBlurriness),
                            e.backgroundIntensity !== void 0 && (c.backgroundIntensity = e.backgroundIntensity),
                            e.backgroundRotation !== void 0 && c.backgroundRotation.fromArray(e.backgroundRotation),
                            e.environmentIntensity !== void 0 && (c.environmentIntensity = e.environmentIntensity),
                            e.environmentRotation !== void 0 && c.environmentRotation.fromArray(e.environmentRotation);
                            break;
                        case "PerspectiveCamera":
                            c = new ca(e.fov,e.aspect,e.near,e.far),
                            e.focus !== void 0 && (c.focus = e.focus),
                            e.zoom !== void 0 && (c.zoom = e.zoom),
                            e.filmGauge !== void 0 && (c.filmGauge = e.filmGauge),
                            e.filmOffset !== void 0 && (c.filmOffset = e.filmOffset),
                            e.view !== void 0 && (c.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            c = new jh(e.left,e.right,e.top,e.bottom,e.near,e.far),
                            e.zoom !== void 0 && (c.zoom = e.zoom),
                            e.view !== void 0 && (c.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            c = new zT(e.color,e.intensity);
                            break;
                        case "DirectionalLight":
                            c = new PT(e.color,e.intensity),
                            c.target = e.target || "";
                            break;
                        case "PointLight":
                            c = new OT(e.color,e.intensity,e.distance,e.decay);
                            break;
                        case "RectAreaLight":
                            c = new BT(e.color,e.intensity,e.width,e.height);
                            break;
                        case "SpotLight":
                            c = new IT(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
                            c.target = e.target || "";
                            break;
                        case "HemisphereLight":
                            c = new NT(e.color,e.groundColor,e.intensity);
                            break;
                        case "LightProbe":
                            c = new FT(new OS().fromArray(e.sh),e.intensity);
                            break;
                        case "SkinnedMesh":
                            g = f(e.geometry),
                            v = p(e.material),
                            c = new MM(g,v),
                            e.bindMode !== void 0 && (c.bindMode = e.bindMode),
                            e.bindMatrix !== void 0 && c.bindMatrix.fromArray(e.bindMatrix),
                            e.skeleton !== void 0 && (c.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            g = f(e.geometry),
                            v = p(e.material),
                            c = new Hi(g,v);
                            break;
                        case "InstancedMesh":
                            g = f(e.geometry),
                            v = p(e.material);
                            const _ = e.count
                              , x = e.instanceMatrix
                              , M = e.instanceColor;
                            c = new CM(g,v,_),
                            c.instanceMatrix = new kh(new Float32Array(x.array),16),
                            M !== void 0 && (c.instanceColor = new kh(new Float32Array(M.array),M.itemSize));
                            break;
                        case "BatchedMesh":
                            g = f(e.geometry),
                            v = p(e.material),
                            c = new LM(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,v),
                            c.geometry = g,
                            c.perObjectFrustumCulled = e.perObjectFrustumCulled,
                            c.sortObjects = e.sortObjects,
                            c._drawRanges = e.drawRanges,
                            c._reservedRanges = e.reservedRanges,
                            c._geometryInfo = e.geometryInfo.map(C => {
                                let R = null
                                  , A = null;
                                return C.boundingBox !== void 0 && (R = new Ra().fromJSON(C.boundingBox)),
                                C.boundingSphere !== void 0 && (A = new Sa().fromJSON(C.boundingSphere)),
                                {
                                    ...C,
                                    boundingBox: R,
                                    boundingSphere: A
                                }
                            }
                            ),
                            c._instanceInfo = e.instanceInfo,
                            c._availableInstanceIds = e._availableInstanceIds,
                            c._availableGeometryIds = e._availableGeometryIds,
                            c._nextIndexStart = e.nextIndexStart,
                            c._nextVertexStart = e.nextVertexStart,
                            c._geometryCount = e.geometryCount,
                            c._maxInstanceCount = e.maxInstanceCount,
                            c._maxVertexCount = e.maxVertexCount,
                            c._maxIndexCount = e.maxIndexCount,
                            c._geometryInitialized = e.geometryInitialized,
                            c._matricesTexture = m(e.matricesTexture.uuid),
                            c._indirectTexture = m(e.indirectTexture.uuid),
                            e.colorsTexture !== void 0 && (c._colorsTexture = m(e.colorsTexture.uuid)),
                            e.boundingSphere !== void 0 && (c.boundingSphere = new Sa().fromJSON(e.boundingSphere)),
                            e.boundingBox !== void 0 && (c.boundingBox = new Ra().fromJSON(e.boundingBox));
                            break;
                        case "LOD":
                            c = new vM;
                            break;
                        case "Line":
                            c = new Lc(f(e.geometry),p(e.material));
                            break;
                        case "LineLoop":
                            c = new zM(f(e.geometry),p(e.material));
                            break;
                        case "LineSegments":
                            c = new Po(f(e.geometry),p(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            c = new FM(f(e.geometry),p(e.material));
                            break;
                        case "Sprite":
                            c = new mM(p(e.material));
                            break;
                        case "Group":
                            c = new Ph;
                            break;
                        case "Bone":
                            c = new eS;
                            break;
                        default:
                            c = new Fn
                        }
                        if (c.uuid = e.uuid,
                        e.name !== void 0 && (c.name = e.name),
                        e.matrix !== void 0 ? (c.matrix.fromArray(e.matrix),
                        e.matrixAutoUpdate !== void 0 && (c.matrixAutoUpdate = e.matrixAutoUpdate),
                        c.matrixAutoUpdate && c.matrix.decompose(c.position, c.quaternion, c.scale)) : (e.position !== void 0 && c.position.fromArray(e.position),
                        e.rotation !== void 0 && c.rotation.fromArray(e.rotation),
                        e.quaternion !== void 0 && c.quaternion.fromArray(e.quaternion),
                        e.scale !== void 0 && c.scale.fromArray(e.scale)),
                        e.up !== void 0 && c.up.fromArray(e.up),
                        e.castShadow !== void 0 && (c.castShadow = e.castShadow),
                        e.receiveShadow !== void 0 && (c.receiveShadow = e.receiveShadow),
                        e.shadow && (e.shadow.intensity !== void 0 && (c.shadow.intensity = e.shadow.intensity),
                        e.shadow.bias !== void 0 && (c.shadow.bias = e.shadow.bias),
                        e.shadow.normalBias !== void 0 && (c.shadow.normalBias = e.shadow.normalBias),
                        e.shadow.radius !== void 0 && (c.shadow.radius = e.shadow.radius),
                        e.shadow.mapSize !== void 0 && c.shadow.mapSize.fromArray(e.shadow.mapSize),
                        e.shadow.camera !== void 0 && (c.shadow.camera = this.parseObject(e.shadow.camera))),
                        e.visible !== void 0 && (c.visible = e.visible),
                        e.frustumCulled !== void 0 && (c.frustumCulled = e.frustumCulled),
                        e.renderOrder !== void 0 && (c.renderOrder = e.renderOrder),
                        e.userData !== void 0 && (c.userData = e.userData),
                        e.layers !== void 0 && (c.layers.mask = e.layers),
                        e.children !== void 0) {
                            const _ = e.children;
                            for (let x = 0; x < _.length; x++)
                                c.add(this.parseObject(_[x], t, n, a, r))
                        }
                        if (e.animations !== void 0) {
                            const _ = e.animations;
                            for (let x = 0; x < _.length; x++) {
                                const M = _[x];
                                c.animations.push(r[M])
                            }
                        }
                        if (e.type === "LOD") {
                            e.autoUpdate !== void 0 && (c.autoUpdate = e.autoUpdate);
                            const _ = e.levels;
                            for (let x = 0; x < _.length; x++) {
                                const M = _[x]
                                  , C = c.getObjectByProperty("uuid", M.object);
                                C !== void 0 && c.addLevel(C, M.distance, M.hysteresis)
                            }
                        }
                        return c
                    }
                    bindSkeletons(e, t) {
                        Object.keys(t).length !== 0 && e.traverse(function(n) {
                            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                                const a = t[n.skeleton];
                                a === void 0 ? ot("ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(a, n.bindMatrix)
                            }
                        })
                    }
                    bindLightTargets(e) {
                        e.traverse(function(t) {
                            if (t.isDirectionalLight || t.isSpotLight) {
                                const n = t.target
                                  , a = e.getObjectByProperty("uuid", n);
                                a !== void 0 ? t.target = a : t.target = new Fn
                            }
                        })
                    }
                }
                ;
                const Y3 = {
                    UVMapping: gv,
                    CubeReflectionMapping: Ro,
                    CubeRefractionMapping: vc,
                    EquirectangularReflectionMapping: Dp,
                    EquirectangularRefractionMapping: Np,
                    CubeUVReflectionMapping: hh
                }
                  , GT = {
                    RepeatWrapping: Lp,
                    ClampToEdgeWrapping: Ss,
                    MirroredRepeatWrapping: Up
                }
                  , WT = {
                    NearestFilter: Oi,
                    NearestMipmapNearestFilter: p_,
                    NearestMipmapLinearFilter: dh,
                    LinearFilter: ei,
                    LinearMipmapNearestFilter: Ip,
                    LinearMipmapLinearFilter: Do
                }
                  , zS = new WeakMap;
                var j3 = class extends Ts {
                    constructor(e) {
                        super(e),
                        this.isImageBitmapLoader = !0,
                        typeof createImageBitmap > "u" && ot("ImageBitmapLoader: createImageBitmap() not supported."),
                        typeof fetch > "u" && ot("ImageBitmapLoader: fetch() not supported."),
                        this.options = {
                            premultiplyAlpha: "none"
                        },
                        this._abortController = new AbortController
                    }
                    setOptions(e) {
                        return this.options = e,
                        this
                    }
                    load(e, t, n, a) {
                        e === void 0 && (e = ""),
                        this.path !== void 0 && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const r = this
                          , c = zo.get(`image-bitmap:${e}`);
                        if (c !== void 0) {
                            if (r.manager.itemStart(e),
                            c.then) {
                                c.then(m => {
                                    if (zS.has(c) === !0)
                                        a && a(zS.get(c)),
                                        r.manager.itemError(e),
                                        r.manager.itemEnd(e);
                                    else
                                        return t && t(m),
                                        r.manager.itemEnd(e),
                                        m
                                }
                                );
                                return
                            }
                            return setTimeout(function() {
                                t && t(c),
                                r.manager.itemEnd(e)
                            }, 0),
                            c
                        }
                        const f = {};
                        f.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                        f.headers = this.requestHeader,
                        f.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
                        const p = fetch(e, f).then(function(m) {
                            return m.blob()
                        }).then(function(m) {
                            return createImageBitmap(m, Object.assign(r.options, {
                                colorSpaceConversion: "none"
                            }))
                        }).then(function(m) {
                            return zo.add(`image-bitmap:${e}`, m),
                            t && t(m),
                            r.manager.itemEnd(e),
                            m
                        }).catch(function(m) {
                            a && a(m),
                            zS.set(p, m),
                            zo.remove(`image-bitmap:${e}`),
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        });
                        zo.add(`image-bitmap:${e}`, p),
                        r.manager.itemStart(e)
                    }
                    abort() {
                        return this._abortController.abort(),
                        this._abortController = new AbortController,
                        this
                    }
                }
                ;
                let $0;
                var BS = class {
                    static getContext() {
                        return $0 === void 0 && ($0 = new (window.AudioContext || window.webkitAudioContext)),
                        $0
                    }
                    static setContext(e) {
                        $0 = e
                    }
                }
                  , Z3 = class extends Ts {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, a) {
                        const r = this
                          , c = new Cl(this.manager);
                        c.setResponseType("arraybuffer"),
                        c.setPath(this.path),
                        c.setRequestHeader(this.requestHeader),
                        c.setWithCredentials(this.withCredentials),
                        c.load(e, function(p) {
                            try {
                                const m = p.slice(0);
                                BS.getContext().decodeAudioData(m, function(g) {
                                    t(g)
                                }).catch(f)
                            } catch (m) {
                                f(m)
                            }
                        }, n, a);
                        function f(p) {
                            a ? a(p) : Et(p),
                            r.manager.itemError(e)
                        }
                    }
                }
                ;
                const XT = new Wt
                  , qT = new Wt
                  , Ku = new Wt;
                var Q3 = class {
                    constructor() {
                        this.type = "StereoCamera",
                        this.aspect = 1,
                        this.eyeSep = .064,
                        this.cameraL = new ca,
                        this.cameraL.layers.enable(1),
                        this.cameraL.matrixAutoUpdate = !1,
                        this.cameraR = new ca,
                        this.cameraR.layers.enable(2),
                        this.cameraR.matrixAutoUpdate = !1,
                        this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(e) {
                        const t = this._cache;
                        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                            t.focus = e.focus,
                            t.fov = e.fov,
                            t.aspect = e.aspect * this.aspect,
                            t.near = e.near,
                            t.far = e.far,
                            t.zoom = e.zoom,
                            t.eyeSep = this.eyeSep,
                            Ku.copy(e.projectionMatrix);
                            const n = t.eyeSep / 2
                              , a = n * t.near / t.focus
                              , r = t.near * Math.tan(Fu * t.fov * .5) / t.zoom;
                            let c, f;
                            qT.elements[12] = -n,
                            XT.elements[12] = n,
                            c = -r * t.aspect + a,
                            f = r * t.aspect + a,
                            Ku.elements[0] = 2 * t.near / (f - c),
                            Ku.elements[8] = (f + c) / (f - c),
                            this.cameraL.projectionMatrix.copy(Ku),
                            c = -r * t.aspect - a,
                            f = r * t.aspect - a,
                            Ku.elements[0] = 2 * t.near / (f - c),
                            Ku.elements[8] = (f + c) / (f - c),
                            this.cameraR.projectionMatrix.copy(Ku)
                        }
                        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(qT),
                        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(XT)
                    }
                }
                  , YT = class extends ca {
                    constructor(e=[]) {
                        super(),
                        this.isArrayCamera = !0,
                        this.isMultiViewCamera = !1,
                        this.cameras = e
                    }
                }
                  , FS = class {
                    constructor(e=!0) {
                        this.autoStart = e,
                        this.startTime = 0,
                        this.oldTime = 0,
                        this.elapsedTime = 0,
                        this.running = !1
                    }
                    start() {
                        this.startTime = performance.now(),
                        this.oldTime = this.startTime,
                        this.elapsedTime = 0,
                        this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(),
                        this.running = !1,
                        this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(),
                        this.elapsedTime
                    }
                    getDelta() {
                        let e = 0;
                        if (this.autoStart && !this.running)
                            return this.start(),
                            0;
                        if (this.running) {
                            const t = performance.now();
                            e = (t - this.oldTime) / 1e3,
                            this.oldTime = t,
                            this.elapsedTime += e
                        }
                        return e
                    }
                }
                ;
                const Ju = new Y
                  , VS = new xs
                  , K3 = new Y
                  , $u = new Y
                  , ef = new Y;
                var J3 = class extends Fn {
                    constructor() {
                        super(),
                        this.type = "AudioListener",
                        this.context = BS.getContext(),
                        this.gain = this.context.createGain(),
                        this.gain.connect(this.context.destination),
                        this.filter = null,
                        this.timeDelta = 0,
                        this._clock = new FS
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return this.filter !== null && (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination),
                        this.gain.connect(this.context.destination),
                        this.filter = null),
                        this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(e) {
                        return this.filter !== null ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                        this.filter = e,
                        this.gain.connect(this.filter),
                        this.filter.connect(this.context.destination),
                        this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e);
                        const t = this.context.listener;
                        if (this.timeDelta = this._clock.getDelta(),
                        this.matrixWorld.decompose(Ju, VS, K3),
                        $u.set(0, 0, -1).applyQuaternion(VS),
                        ef.set(0, 1, 0).applyQuaternion(VS),
                        t.positionX) {
                            const n = this.context.currentTime + this.timeDelta;
                            t.positionX.linearRampToValueAtTime(Ju.x, n),
                            t.positionY.linearRampToValueAtTime(Ju.y, n),
                            t.positionZ.linearRampToValueAtTime(Ju.z, n),
                            t.forwardX.linearRampToValueAtTime($u.x, n),
                            t.forwardY.linearRampToValueAtTime($u.y, n),
                            t.forwardZ.linearRampToValueAtTime($u.z, n),
                            t.upX.linearRampToValueAtTime(ef.x, n),
                            t.upY.linearRampToValueAtTime(ef.y, n),
                            t.upZ.linearRampToValueAtTime(ef.z, n)
                        } else
                            t.setPosition(Ju.x, Ju.y, Ju.z),
                            t.setOrientation($u.x, $u.y, $u.z, ef.x, ef.y, ef.z)
                    }
                }
                  , jT = class extends Fn {
                    constructor(e) {
                        super(),
                        this.type = "Audio",
                        this.listener = e,
                        this.context = e.context,
                        this.gain = this.context.createGain(),
                        this.gain.connect(e.getInput()),
                        this.autoplay = !1,
                        this.buffer = null,
                        this.detune = 0,
                        this.loop = !1,
                        this.loopStart = 0,
                        this.loopEnd = 0,
                        this.offset = 0,
                        this.duration = void 0,
                        this.playbackRate = 1,
                        this.isPlaying = !1,
                        this.hasPlaybackControl = !0,
                        this.source = null,
                        this.sourceType = "empty",
                        this._startedAt = 0,
                        this._progress = 0,
                        this._connected = !1,
                        this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "audioNode",
                        this.source = e,
                        this.connect(),
                        this
                    }
                    setMediaElementSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaNode",
                        this.source = this.context.createMediaElementSource(e),
                        this.connect(),
                        this
                    }
                    setMediaStreamSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaStreamNode",
                        this.source = this.context.createMediaStreamSource(e),
                        this.connect(),
                        this
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this.sourceType = "buffer",
                        this.autoplay && this.play(),
                        this
                    }
                    play(e=0) {
                        if (this.isPlaying === !0) {
                            ot("Audio: Audio is already playing.");
                            return
                        }
                        if (this.hasPlaybackControl === !1) {
                            ot("Audio: this Audio has no playback control.");
                            return
                        }
                        this._startedAt = this.context.currentTime + e;
                        const t = this.context.createBufferSource();
                        return t.buffer = this.buffer,
                        t.loop = this.loop,
                        t.loopStart = this.loopStart,
                        t.loopEnd = this.loopEnd,
                        t.onended = this.onEnded.bind(this),
                        t.start(this._startedAt, this._progress + this.offset, this.duration),
                        this.isPlaying = !0,
                        this.source = t,
                        this.setDetune(this.detune),
                        this.setPlaybackRate(this.playbackRate),
                        this.connect()
                    }
                    pause() {
                        if (this.hasPlaybackControl === !1) {
                            ot("Audio: this Audio has no playback control.");
                            return
                        }
                        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                        this.source.stop(),
                        this.source.onended = null,
                        this.isPlaying = !1),
                        this
                    }
                    stop(e=0) {
                        if (this.hasPlaybackControl === !1) {
                            ot("Audio: this Audio has no playback control.");
                            return
                        }
                        return this._progress = 0,
                        this.source !== null && (this.source.stop(this.context.currentTime + e),
                        this.source.onended = null),
                        this.isPlaying = !1,
                        this
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let e = 1, t = this.filters.length; e < t; e++)
                                this.filters[e - 1].connect(this.filters[e]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else
                            this.source.connect(this.getOutput());
                        return this._connected = !0,
                        this
                    }
                    disconnect() {
                        if (this._connected !== !1) {
                            if (this.filters.length > 0) {
                                this.source.disconnect(this.filters[0]);
                                for (let e = 1, t = this.filters.length; e < t; e++)
                                    this.filters[e - 1].disconnect(this.filters[e]);
                                this.filters[this.filters.length - 1].disconnect(this.getOutput())
                            } else
                                this.source.disconnect(this.getOutput());
                            return this._connected = !1,
                            this
                        }
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(e) {
                        return e || (e = []),
                        this._connected === !0 ? (this.disconnect(),
                        this.filters = e.slice(),
                        this.connect()) : this.filters = e.slice(),
                        this
                    }
                    setDetune(e) {
                        return this.detune = e,
                        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                        this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(e) {
                        return this.setFilters(e ? [e] : [])
                    }
                    setPlaybackRate(e) {
                        if (this.hasPlaybackControl === !1) {
                            ot("Audio: this Audio has no playback control.");
                            return
                        }
                        return this.playbackRate = e,
                        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                        this
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1,
                        this._progress = 0
                    }
                    getLoop() {
                        return this.hasPlaybackControl === !1 ? (ot("Audio: this Audio has no playback control."),
                        !1) : this.loop
                    }
                    setLoop(e) {
                        if (this.hasPlaybackControl === !1) {
                            ot("Audio: this Audio has no playback control.");
                            return
                        }
                        return this.loop = e,
                        this.isPlaying === !0 && (this.source.loop = this.loop),
                        this
                    }
                    setLoopStart(e) {
                        return this.loopStart = e,
                        this
                    }
                    setLoopEnd(e) {
                        return this.loopEnd = e,
                        this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        e.sourceType !== "buffer" ? (ot("Audio: Audio source type cannot be copied."),
                        this) : (this.autoplay = e.autoplay,
                        this.buffer = e.buffer,
                        this.detune = e.detune,
                        this.loop = e.loop,
                        this.loopStart = e.loopStart,
                        this.loopEnd = e.loopEnd,
                        this.offset = e.offset,
                        this.duration = e.duration,
                        this.playbackRate = e.playbackRate,
                        this.hasPlaybackControl = e.hasPlaybackControl,
                        this.sourceType = e.sourceType,
                        this.filters = e.filters.slice(),
                        this)
                    }
                    clone(e) {
                        return new this.constructor(this.listener).copy(this, e)
                    }
                }
                ;
                const tf = new Y
                  , ZT = new xs
                  , $3 = new Y
                  , nf = new Y;
                var eR = class extends jT {
                    constructor(e) {
                        super(e),
                        this.panner = this.context.createPanner(),
                        this.panner.panningModel = "HRTF",
                        this.panner.connect(this.gain)
                    }
                    connect() {
                        return super.connect(),
                        this.panner.connect(this.gain),
                        this
                    }
                    disconnect() {
                        return super.disconnect(),
                        this.panner.disconnect(this.gain),
                        this
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(e) {
                        return this.panner.refDistance = e,
                        this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(e) {
                        return this.panner.rolloffFactor = e,
                        this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(e) {
                        return this.panner.distanceModel = e,
                        this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(e) {
                        return this.panner.maxDistance = e,
                        this
                    }
                    setDirectionalCone(e, t, n) {
                        return this.panner.coneInnerAngle = e,
                        this.panner.coneOuterAngle = t,
                        this.panner.coneOuterGain = n,
                        this
                    }
                    updateMatrixWorld(e) {
                        if (super.updateMatrixWorld(e),
                        this.hasPlaybackControl === !0 && this.isPlaying === !1)
                            return;
                        this.matrixWorld.decompose(tf, ZT, $3),
                        nf.set(0, 0, 1).applyQuaternion(ZT);
                        const t = this.panner;
                        if (t.positionX) {
                            const n = this.context.currentTime + this.listener.timeDelta;
                            t.positionX.linearRampToValueAtTime(tf.x, n),
                            t.positionY.linearRampToValueAtTime(tf.y, n),
                            t.positionZ.linearRampToValueAtTime(tf.z, n),
                            t.orientationX.linearRampToValueAtTime(nf.x, n),
                            t.orientationY.linearRampToValueAtTime(nf.y, n),
                            t.orientationZ.linearRampToValueAtTime(nf.z, n)
                        } else
                            t.setPosition(tf.x, tf.y, tf.z),
                            t.setOrientation(nf.x, nf.y, nf.z)
                    }
                }
                  , tR = class {
                    constructor(e, t=2048) {
                        this.analyser = e.context.createAnalyser(),
                        this.analyser.fftSize = t,
                        this.data = new Uint8Array(this.analyser.frequencyBinCount),
                        e.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data),
                        this.data
                    }
                    getAverageFrequency() {
                        let e = 0;
                        const t = this.getFrequencyData();
                        for (let n = 0; n < t.length; n++)
                            e += t[n];
                        return e / t.length
                    }
                }
                  , QT = class {
                    constructor(e, t, n) {
                        this.binding = e,
                        this.valueSize = n;
                        let a, r, c;
                        switch (t) {
                        case "quaternion":
                            a = this._slerp,
                            r = this._slerpAdditive,
                            c = this._setAdditiveIdentityQuaternion,
                            this.buffer = new Float64Array(n * 6),
                            this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            a = this._select,
                            r = this._select,
                            c = this._setAdditiveIdentityOther,
                            this.buffer = new Array(n * 5);
                            break;
                        default:
                            a = this._lerp,
                            r = this._lerpAdditive,
                            c = this._setAdditiveIdentityNumeric,
                            this.buffer = new Float64Array(n * 5)
                        }
                        this._mixBufferRegion = a,
                        this._mixBufferRegionAdditive = r,
                        this._setIdentity = c,
                        this._origIndex = 3,
                        this._addIndex = 4,
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        this.useCount = 0,
                        this.referenceCount = 0
                    }
                    accumulate(e, t) {
                        const n = this.buffer
                          , a = this.valueSize
                          , r = e * a + a;
                        let c = this.cumulativeWeight;
                        if (c === 0) {
                            for (let f = 0; f !== a; ++f)
                                n[r + f] = n[f];
                            c = t
                        } else {
                            c += t;
                            const f = t / c;
                            this._mixBufferRegion(n, r, 0, f, a)
                        }
                        this.cumulativeWeight = c
                    }
                    accumulateAdditive(e) {
                        const t = this.buffer
                          , n = this.valueSize
                          , a = n * this._addIndex;
                        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                        this._mixBufferRegionAdditive(t, a, 0, e, n),
                        this.cumulativeWeightAdditive += e
                    }
                    apply(e) {
                        const t = this.valueSize
                          , n = this.buffer
                          , a = e * t + t
                          , r = this.cumulativeWeight
                          , c = this.cumulativeWeightAdditive
                          , f = this.binding;
                        if (this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        r < 1) {
                            const p = t * this._origIndex;
                            this._mixBufferRegion(n, a, p, 1 - r, t)
                        }
                        c > 0 && this._mixBufferRegionAdditive(n, a, this._addIndex * t, 1, t);
                        for (let p = t, m = t + t; p !== m; ++p)
                            if (n[p] !== n[p + t]) {
                                f.setValue(n, a);
                                break
                            }
                    }
                    saveOriginalState() {
                        const e = this.binding
                          , t = this.buffer
                          , n = this.valueSize
                          , a = n * this._origIndex;
                        e.getValue(t, a);
                        for (let r = n, c = a; r !== c; ++r)
                            t[r] = t[a + r % n];
                        this._setIdentity(),
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const e = this.valueSize * 3;
                        this.binding.setValue(this.buffer, e)
                    }
                    _setAdditiveIdentityNumeric() {
                        const e = this._addIndex * this.valueSize
                          , t = e + this.valueSize;
                        for (let n = e; n < t; n++)
                            this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(),
                        this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const e = this._origIndex * this.valueSize
                          , t = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++)
                            this.buffer[t + n] = this.buffer[e + n]
                    }
                    _select(e, t, n, a, r) {
                        if (a >= .5)
                            for (let c = 0; c !== r; ++c)
                                e[t + c] = e[n + c]
                    }
                    _slerp(e, t, n, a) {
                        xs.slerpFlat(e, t, e, t, e, n, a)
                    }
                    _slerpAdditive(e, t, n, a, r) {
                        const c = this._workIndex * r;
                        xs.multiplyQuaternionsFlat(e, c, e, t, e, n),
                        xs.slerpFlat(e, t, e, t, e, c, a)
                    }
                    _lerp(e, t, n, a, r) {
                        const c = 1 - a;
                        for (let f = 0; f !== r; ++f) {
                            const p = t + f;
                            e[p] = e[p] * c + e[n + f] * a
                        }
                    }
                    _lerpAdditive(e, t, n, a, r) {
                        for (let c = 0; c !== r; ++c) {
                            const f = t + c;
                            e[f] = e[f] + e[n + c] * a
                        }
                    }
                }
                ;
                const kS = "\\[\\]\\.:\\/"
                  , nR = new RegExp("[" + kS + "]","g")
                  , HS = "[^" + kS + "]"
                  , iR = "[^" + kS.replace("\\.", "") + "]"
                  , aR = /((?:WC+[\/:])*)/.source.replace("WC", HS)
                  , sR = /(WCOD+)?/.source.replace("WCOD", iR)
                  , rR = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", HS)
                  , oR = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", HS)
                  , lR = new RegExp("^" + aR + sR + rR + oR + "$")
                  , cR = ["material", "materials", "bones", "map"];
                var uR = class {
                    constructor(e, t, n) {
                        const a = n || Yn.parseTrackName(t);
                        this._targetGroup = e,
                        this._bindings = e.subscribe_(t, a)
                    }
                    getValue(e, t) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_
                          , a = this._bindings[n];
                        a !== void 0 && a.getValue(e, t)
                    }
                    setValue(e, t) {
                        const n = this._bindings;
                        for (let a = this._targetGroup.nCachedObjects_, r = n.length; a !== r; ++a)
                            n[a].setValue(e, t)
                    }
                    bind() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].bind()
                    }
                    unbind() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].unbind()
                    }
                }
                  , Yn = class sd {
                    constructor(t, n, a) {
                        this.path = n,
                        this.parsedPath = a || sd.parseTrackName(n),
                        this.node = sd.findNode(t, this.parsedPath.nodeName),
                        this.rootNode = t,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                    static create(t, n, a) {
                        return t && t.isAnimationObjectGroup ? new sd.Composite(t,n,a) : new sd(t,n,a)
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(nR, "")
                    }
                    static parseTrackName(t) {
                        const n = lR.exec(t);
                        if (n === null)
                            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const a = {
                            nodeName: n[2],
                            objectName: n[3],
                            objectIndex: n[4],
                            propertyName: n[5],
                            propertyIndex: n[6]
                        }
                          , r = a.nodeName && a.nodeName.lastIndexOf(".");
                        if (r !== void 0 && r !== -1) {
                            const c = a.nodeName.substring(r + 1);
                            cR.indexOf(c) !== -1 && (a.nodeName = a.nodeName.substring(0, r),
                            a.objectName = c)
                        }
                        if (a.propertyName === null || a.propertyName.length === 0)
                            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return a
                    }
                    static findNode(t, n) {
                        if (n === void 0 || n === "" || n === "." || n === -1 || n === t.name || n === t.uuid)
                            return t;
                        if (t.skeleton) {
                            const a = t.skeleton.getBoneByName(n);
                            if (a !== void 0)
                                return a
                        }
                        if (t.children) {
                            const a = function(c) {
                                for (let f = 0; f < c.length; f++) {
                                    const p = c[f];
                                    if (p.name === n || p.uuid === n)
                                        return p;
                                    const m = a(p.children);
                                    if (m)
                                        return m
                                }
                                return null
                            }
                              , r = a(t.children);
                            if (r)
                                return r
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, n) {
                        t[n] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(t, n) {
                        const a = this.resolvedProperty;
                        for (let r = 0, c = a.length; r !== c; ++r)
                            t[n++] = a[r]
                    }
                    _getValue_arrayElement(t, n) {
                        t[n] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(t, n) {
                        this.resolvedProperty.toArray(t, n)
                    }
                    _setValue_direct(t, n) {
                        this.targetObject[this.propertyName] = t[n]
                    }
                    _setValue_direct_setNeedsUpdate(t, n) {
                        this.targetObject[this.propertyName] = t[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, n) {
                        this.targetObject[this.propertyName] = t[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(t, n) {
                        const a = this.resolvedProperty;
                        for (let r = 0, c = a.length; r !== c; ++r)
                            a[r] = t[n++]
                    }
                    _setValue_array_setNeedsUpdate(t, n) {
                        const a = this.resolvedProperty;
                        for (let r = 0, c = a.length; r !== c; ++r)
                            a[r] = t[n++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, n) {
                        const a = this.resolvedProperty;
                        for (let r = 0, c = a.length; r !== c; ++r)
                            a[r] = t[n++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n]
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n],
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, n) {
                        this.resolvedProperty[this.propertyIndex] = t[n],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(t, n) {
                        this.resolvedProperty.fromArray(t, n)
                    }
                    _setValue_fromArray_setNeedsUpdate(t, n) {
                        this.resolvedProperty.fromArray(t, n),
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, n) {
                        this.resolvedProperty.fromArray(t, n),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(t, n) {
                        this.bind(),
                        this.getValue(t, n)
                    }
                    _setValue_unbound(t, n) {
                        this.bind(),
                        this.setValue(t, n)
                    }
                    bind() {
                        let t = this.node;
                        const n = this.parsedPath
                          , a = n.objectName
                          , r = n.propertyName;
                        let c = n.propertyIndex;
                        if (t || (t = sd.findNode(this.rootNode, n.nodeName),
                        this.node = t),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !t) {
                            ot("PropertyBinding: No target node found for track: " + this.path + ".");
                            return
                        }
                        if (a) {
                            let g = n.objectIndex;
                            switch (a) {
                            case "materials":
                                if (!t.material) {
                                    Et("PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.materials) {
                                    Et("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) {
                                    Et("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                t = t.skeleton.bones;
                                for (let v = 0; v < t.length; v++)
                                    if (t[v].name === g) {
                                        g = v;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map"in t) {
                                    t = t.map;
                                    break
                                }
                                if (!t.material) {
                                    Et("PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.map) {
                                    Et("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                t = t.material.map;
                                break;
                            default:
                                if (t[a] === void 0) {
                                    Et("PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                t = t[a]
                            }
                            if (g !== void 0) {
                                if (t[g] === void 0) {
                                    Et("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    return
                                }
                                t = t[g]
                            }
                        }
                        const f = t[r];
                        if (f === void 0) {
                            const g = n.nodeName;
                            Et("PropertyBinding: Trying to update property for track: " + g + "." + r + " but it wasn't found.", t);
                            return
                        }
                        let p = this.Versioning.None;
                        this.targetObject = t,
                        t.isMaterial === !0 ? p = this.Versioning.NeedsUpdate : t.isObject3D === !0 && (p = this.Versioning.MatrixWorldNeedsUpdate);
                        let m = this.BindingType.Direct;
                        if (c !== void 0) {
                            if (r === "morphTargetInfluences") {
                                if (!t.geometry) {
                                    Et("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    return
                                }
                                if (!t.geometry.morphAttributes) {
                                    Et("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    return
                                }
                                t.morphTargetDictionary[c] !== void 0 && (c = t.morphTargetDictionary[c])
                            }
                            m = this.BindingType.ArrayElement,
                            this.resolvedProperty = f,
                            this.propertyIndex = c
                        } else
                            f.fromArray !== void 0 && f.toArray !== void 0 ? (m = this.BindingType.HasFromToArray,
                            this.resolvedProperty = f) : Array.isArray(f) ? (m = this.BindingType.EntireArray,
                            this.resolvedProperty = f) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[m],
                        this.setValue = this.SetterByBindingTypeAndVersioning[m][p]
                    }
                    unbind() {
                        this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                }
                ;
                Yn.Composite = uR,
                Yn.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Yn.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                Yn.prototype.GetterByBindingType = [Yn.prototype._getValue_direct, Yn.prototype._getValue_array, Yn.prototype._getValue_arrayElement, Yn.prototype._getValue_toArray],
                Yn.prototype.SetterByBindingTypeAndVersioning = [[Yn.prototype._setValue_direct, Yn.prototype._setValue_direct_setNeedsUpdate, Yn.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Yn.prototype._setValue_array, Yn.prototype._setValue_array_setNeedsUpdate, Yn.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Yn.prototype._setValue_arrayElement, Yn.prototype._setValue_arrayElement_setNeedsUpdate, Yn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Yn.prototype._setValue_fromArray, Yn.prototype._setValue_fromArray_setNeedsUpdate, Yn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
                var fR = class {
                    constructor() {
                        this.isAnimationObjectGroup = !0,
                        this.uuid = Fs(),
                        this._objects = Array.prototype.slice.call(arguments),
                        this.nCachedObjects_ = 0;
                        const e = {};
                        this._indicesByUUID = e;
                        for (let n = 0, a = arguments.length; n !== a; ++n)
                            e[arguments[n].uuid] = n;
                        this._paths = [],
                        this._parsedPaths = [],
                        this._bindings = [],
                        this._bindingsIndicesByPath = {};
                        const t = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return t._objects.length
                                },
                                get inUse() {
                                    return this.total - t.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return t._bindings.length
                            }
                        }
                    }
                    add() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._paths
                          , a = this._parsedPaths
                          , r = this._bindings
                          , c = r.length;
                        let f, p = e.length, m = this.nCachedObjects_;
                        for (let g = 0, v = arguments.length; g !== v; ++g) {
                            const _ = arguments[g]
                              , x = _.uuid;
                            let M = t[x];
                            if (M === void 0) {
                                M = p++,
                                t[x] = M,
                                e.push(_);
                                for (let C = 0, R = c; C !== R; ++C)
                                    r[C].push(new Yn(_,n[C],a[C]))
                            } else if (M < m) {
                                f = e[M];
                                const C = --m
                                  , R = e[C];
                                t[R.uuid] = M,
                                e[M] = R,
                                t[x] = C,
                                e[C] = _;
                                for (let A = 0, E = c; A !== E; ++A) {
                                    const N = r[A]
                                      , I = N[C];
                                    let L = N[M];
                                    N[M] = I,
                                    L === void 0 && (L = new Yn(_,n[A],a[A])),
                                    N[C] = L
                                }
                            } else
                                e[M] !== f && Et("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = m
                    }
                    remove() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , a = n.length;
                        let r = this.nCachedObjects_;
                        for (let c = 0, f = arguments.length; c !== f; ++c) {
                            const p = arguments[c]
                              , m = p.uuid
                              , g = t[m];
                            if (g !== void 0 && g >= r) {
                                const v = r++
                                  , _ = e[v];
                                t[_.uuid] = g,
                                e[g] = _,
                                t[m] = v,
                                e[v] = p;
                                for (let x = 0, M = a; x !== M; ++x) {
                                    const C = n[x]
                                      , R = C[v]
                                      , A = C[g];
                                    C[g] = R,
                                    C[v] = A
                                }
                            }
                        }
                        this.nCachedObjects_ = r
                    }
                    uncache() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , a = n.length;
                        let r = this.nCachedObjects_
                          , c = e.length;
                        for (let f = 0, p = arguments.length; f !== p; ++f) {
                            const m = arguments[f].uuid
                              , g = t[m];
                            if (g !== void 0)
                                if (delete t[m],
                                g < r) {
                                    const v = --r
                                      , _ = e[v]
                                      , x = --c
                                      , M = e[x];
                                    t[_.uuid] = g,
                                    e[g] = _,
                                    t[M.uuid] = v,
                                    e[v] = M,
                                    e.pop();
                                    for (let C = 0, R = a; C !== R; ++C) {
                                        const A = n[C]
                                          , E = A[v]
                                          , N = A[x];
                                        A[g] = E,
                                        A[v] = N,
                                        A.pop()
                                    }
                                } else {
                                    const v = --c
                                      , _ = e[v];
                                    v > 0 && (t[_.uuid] = g),
                                    e[g] = _,
                                    e.pop();
                                    for (let x = 0, M = a; x !== M; ++x) {
                                        const C = n[x];
                                        C[g] = C[v],
                                        C.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = r
                    }
                    subscribe_(e, t) {
                        const n = this._bindingsIndicesByPath;
                        let a = n[e];
                        const r = this._bindings;
                        if (a !== void 0)
                            return r[a];
                        const c = this._paths
                          , f = this._parsedPaths
                          , p = this._objects
                          , m = p.length
                          , g = this.nCachedObjects_
                          , v = new Array(m);
                        a = r.length,
                        n[e] = a,
                        c.push(e),
                        f.push(t),
                        r.push(v);
                        for (let _ = g, x = p.length; _ !== x; ++_) {
                            const M = p[_];
                            v[_] = new Yn(M,e,t)
                        }
                        return v
                    }
                    unsubscribe_(e) {
                        const t = this._bindingsIndicesByPath
                          , n = t[e];
                        if (n !== void 0) {
                            const a = this._paths
                              , r = this._parsedPaths
                              , c = this._bindings
                              , f = c.length - 1
                              , p = c[f]
                              , m = e[f];
                            t[m] = n,
                            c[n] = p,
                            c.pop(),
                            r[n] = r[f],
                            r.pop(),
                            a[n] = a[f],
                            a.pop()
                        }
                    }
                }
                  , KT = class {
                    constructor(e, t, n=null, a=t.blendMode) {
                        this._mixer = e,
                        this._clip = t,
                        this._localRoot = n,
                        this.blendMode = a;
                        const r = t.tracks
                          , c = r.length
                          , f = new Array(c)
                          , p = {
                            endingStart: Pu,
                            endingEnd: Pu
                        };
                        for (let m = 0; m !== c; ++m) {
                            const g = r[m].createInterpolant(null);
                            f[m] = g,
                            g.settings = p
                        }
                        this._interpolantSettings = p,
                        this._interpolants = f,
                        this._propertyBindings = new Array(c),
                        this._cacheIndex = null,
                        this._byClipCacheIndex = null,
                        this._timeScaleInterpolant = null,
                        this._weightInterpolant = null,
                        this.loop = Cb,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.time = 0,
                        this.timeScale = 1,
                        this._effectiveTimeScale = 1,
                        this.weight = 1,
                        this._effectiveWeight = 1,
                        this.repetitions = 1 / 0,
                        this.paused = !1,
                        this.enabled = !0,
                        this.clampWhenFinished = !1,
                        this.zeroSlopeAtStart = !0,
                        this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this),
                        this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this),
                        this.reset()
                    }
                    reset() {
                        return this.paused = !1,
                        this.enabled = !0,
                        this.time = 0,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(e) {
                        return this._startTime = e,
                        this
                    }
                    setLoop(e, t) {
                        return this.loop = e,
                        this.repetitions = t,
                        this
                    }
                    setEffectiveWeight(e) {
                        return this.weight = e,
                        this._effectiveWeight = this.enabled ? e : 0,
                        this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(e) {
                        return this._scheduleFading(e, 0, 1)
                    }
                    fadeOut(e) {
                        return this._scheduleFading(e, 1, 0)
                    }
                    crossFadeFrom(e, t, n=!1) {
                        if (e.fadeOut(t),
                        this.fadeIn(t),
                        n === !0) {
                            const a = this._clip.duration
                              , r = e._clip.duration
                              , c = r / a
                              , f = a / r;
                            e.warp(1, c, t),
                            this.warp(f, 1, t)
                        }
                        return this
                    }
                    crossFadeTo(e, t, n=!1) {
                        return e.crossFadeFrom(this, t, n)
                    }
                    stopFading() {
                        const e = this._weightInterpolant;
                        return e !== null && (this._weightInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    setEffectiveTimeScale(e) {
                        return this.timeScale = e,
                        this._effectiveTimeScale = this.paused ? 0 : e,
                        this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(e) {
                        return this.timeScale = this._clip.duration / e,
                        this.stopWarping()
                    }
                    syncWith(e) {
                        return this.time = e.time,
                        this.timeScale = e.timeScale,
                        this.stopWarping()
                    }
                    halt(e) {
                        return this.warp(this._effectiveTimeScale, 0, e)
                    }
                    warp(e, t, n) {
                        const a = this._mixer
                          , r = a.time
                          , c = this.timeScale;
                        let f = this._timeScaleInterpolant;
                        f === null && (f = a._lendControlInterpolant(),
                        this._timeScaleInterpolant = f);
                        const p = f.parameterPositions
                          , m = f.sampleValues;
                        return p[0] = r,
                        p[1] = r + n,
                        m[0] = e / c,
                        m[1] = t / c,
                        this
                    }
                    stopWarping() {
                        const e = this._timeScaleInterpolant;
                        return e !== null && (this._timeScaleInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(e, t, n, a) {
                        if (!this.enabled) {
                            this._updateWeight(e);
                            return
                        }
                        const r = this._startTime;
                        if (r !== null) {
                            const p = (e - r) * n;
                            p < 0 || n === 0 ? t = 0 : (this._startTime = null,
                            t = n * p)
                        }
                        t *= this._updateTimeScale(e);
                        const c = this._updateTime(t)
                          , f = this._updateWeight(e);
                        if (f > 0) {
                            const p = this._interpolants
                              , m = this._propertyBindings;
                            switch (this.blendMode) {
                            case x_:
                                for (let g = 0, v = p.length; g !== v; ++g)
                                    p[g].evaluate(c),
                                    m[g].accumulateAdditive(f);
                                break;
                            case i0:
                            default:
                                for (let g = 0, v = p.length; g !== v; ++g)
                                    p[g].evaluate(c),
                                    m[g].accumulate(a, f)
                            }
                        }
                    }
                    _updateWeight(e) {
                        let t = 0;
                        if (this.enabled) {
                            t = this.weight;
                            const n = this._weightInterpolant;
                            if (n !== null) {
                                const a = n.evaluate(e)[0];
                                t *= a,
                                e > n.parameterPositions[1] && (this.stopFading(),
                                a === 0 && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = t,
                        t
                    }
                    _updateTimeScale(e) {
                        let t = 0;
                        if (!this.paused) {
                            t = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            if (n !== null) {
                                const a = n.evaluate(e)[0];
                                t *= a,
                                e > n.parameterPositions[1] && (this.stopWarping(),
                                t === 0 ? this.paused = !0 : this.timeScale = t)
                            }
                        }
                        return this._effectiveTimeScale = t,
                        t
                    }
                    _updateTime(e) {
                        const t = this._clip.duration
                          , n = this.loop;
                        let a = this.time + e
                          , r = this._loopCount;
                        const c = n === Rb;
                        if (e === 0)
                            return r === -1 ? a : c && (r & 1) === 1 ? t - a : a;
                        if (n === wb) {
                            r === -1 && (this._loopCount = 0,
                            this._setEndings(!0, !0, !1));
                            e: {
                                if (a >= t)
                                    a = t;
                                else if (a < 0)
                                    a = 0;
                                else {
                                    this.time = a;
                                    break e
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = a,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: e < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (r === -1 && (e >= 0 ? (r = 0,
                            this._setEndings(!0, this.repetitions === 0, c)) : this._setEndings(this.repetitions === 0, !0, c)),
                            a >= t || a < 0) {
                                const f = Math.floor(a / t);
                                a -= t * f,
                                r += Math.abs(f);
                                const p = this.repetitions - r;
                                if (p <= 0)
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    a = e > 0 ? t : 0,
                                    this.time = a,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    });
                                else {
                                    if (p === 1) {
                                        const m = e < 0;
                                        this._setEndings(m, !m, c)
                                    } else
                                        this._setEndings(!1, !1, c);
                                    this._loopCount = r,
                                    this.time = a,
                                    this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: f
                                    })
                                }
                            } else
                                this.time = a;
                            if (c && (r & 1) === 1)
                                return t - a
                        }
                        return a
                    }
                    _setEndings(e, t, n) {
                        const a = this._interpolantSettings;
                        n ? (a.endingStart = zu,
                        a.endingEnd = zu) : (e ? a.endingStart = this.zeroSlopeAtStart ? zu : Pu : a.endingStart = kp,
                        t ? a.endingEnd = this.zeroSlopeAtEnd ? zu : Pu : a.endingEnd = kp)
                    }
                    _scheduleFading(e, t, n) {
                        const a = this._mixer
                          , r = a.time;
                        let c = this._weightInterpolant;
                        c === null && (c = a._lendControlInterpolant(),
                        this._weightInterpolant = c);
                        const f = c.parameterPositions
                          , p = c.sampleValues;
                        return f[0] = r,
                        p[0] = t,
                        f[1] = r + e,
                        p[1] = n,
                        this
                    }
                }
                ;
                const hR = new Float32Array(1);
                var dR = class extends Uo {
                    constructor(e) {
                        super(),
                        this._root = e,
                        this._initMemoryManager(),
                        this._accuIndex = 0,
                        this.time = 0,
                        this.timeScale = 1
                    }
                    _bindAction(e, t) {
                        const n = e._localRoot || this._root
                          , a = e._clip.tracks
                          , r = a.length
                          , c = e._propertyBindings
                          , f = e._interpolants
                          , p = n.uuid
                          , m = this._bindingsByRootAndName;
                        let g = m[p];
                        g === void 0 && (g = {},
                        m[p] = g);
                        for (let v = 0; v !== r; ++v) {
                            const _ = a[v]
                              , x = _.name;
                            let M = g[x];
                            if (M !== void 0)
                                ++M.referenceCount,
                                c[v] = M;
                            else {
                                if (M = c[v],
                                M !== void 0) {
                                    M._cacheIndex === null && (++M.referenceCount,
                                    this._addInactiveBinding(M, p, x));
                                    continue
                                }
                                const C = t && t._propertyBindings[v].binding.parsedPath;
                                M = new QT(Yn.create(n, x, C),_.ValueTypeName,_.getValueSize()),
                                ++M.referenceCount,
                                this._addInactiveBinding(M, p, x),
                                c[v] = M
                            }
                            f[v].resultBuffer = M.buffer
                        }
                    }
                    _activateAction(e) {
                        if (!this._isActiveAction(e)) {
                            if (e._cacheIndex === null) {
                                const n = (e._localRoot || this._root).uuid
                                  , a = e._clip.uuid
                                  , r = this._actionsByClip[a];
                                this._bindAction(e, r && r.knownActions[0]),
                                this._addInactiveAction(e, a, n)
                            }
                            const t = e._propertyBindings;
                            for (let n = 0, a = t.length; n !== a; ++n) {
                                const r = t[n];
                                r.useCount++ === 0 && (this._lendBinding(r),
                                r.saveOriginalState())
                            }
                            this._lendAction(e)
                        }
                    }
                    _deactivateAction(e) {
                        if (this._isActiveAction(e)) {
                            const t = e._propertyBindings;
                            for (let n = 0, a = t.length; n !== a; ++n) {
                                const r = t[n];
                                --r.useCount === 0 && (r.restoreOriginalState(),
                                this._takeBackBinding(r))
                            }
                            this._takeBackAction(e)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [],
                        this._nActiveActions = 0,
                        this._actionsByClip = {},
                        this._bindings = [],
                        this._nActiveBindings = 0,
                        this._bindingsByRootAndName = {},
                        this._controlInterpolants = [],
                        this._nActiveControlInterpolants = 0;
                        const e = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return e._actions.length
                                },
                                get inUse() {
                                    return e._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return e._bindings.length
                                },
                                get inUse() {
                                    return e._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return e._controlInterpolants.length
                                },
                                get inUse() {
                                    return e._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(e) {
                        const t = e._cacheIndex;
                        return t !== null && t < this._nActiveActions
                    }
                    _addInactiveAction(e, t, n) {
                        const a = this._actions
                          , r = this._actionsByClip;
                        let c = r[t];
                        if (c === void 0)
                            c = {
                                knownActions: [e],
                                actionByRoot: {}
                            },
                            e._byClipCacheIndex = 0,
                            r[t] = c;
                        else {
                            const f = c.knownActions;
                            e._byClipCacheIndex = f.length,
                            f.push(e)
                        }
                        e._cacheIndex = a.length,
                        a.push(e),
                        c.actionByRoot[n] = e
                    }
                    _removeInactiveAction(e) {
                        const t = this._actions
                          , n = t[t.length - 1]
                          , a = e._cacheIndex;
                        n._cacheIndex = a,
                        t[a] = n,
                        t.pop(),
                        e._cacheIndex = null;
                        const r = e._clip.uuid
                          , c = this._actionsByClip
                          , f = c[r]
                          , p = f.knownActions
                          , m = p[p.length - 1]
                          , g = e._byClipCacheIndex;
                        m._byClipCacheIndex = g,
                        p[g] = m,
                        p.pop(),
                        e._byClipCacheIndex = null;
                        const v = f.actionByRoot
                          , _ = (e._localRoot || this._root).uuid;
                        delete v[_],
                        p.length === 0 && delete c[r],
                        this._removeInactiveBindingsForAction(e)
                    }
                    _removeInactiveBindingsForAction(e) {
                        const t = e._propertyBindings;
                        for (let n = 0, a = t.length; n !== a; ++n) {
                            const r = t[n];
                            --r.referenceCount === 0 && this._removeInactiveBinding(r)
                        }
                    }
                    _lendAction(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , a = this._nActiveActions++
                          , r = t[a];
                        e._cacheIndex = a,
                        t[a] = e,
                        r._cacheIndex = n,
                        t[n] = r
                    }
                    _takeBackAction(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , a = --this._nActiveActions
                          , r = t[a];
                        e._cacheIndex = a,
                        t[a] = e,
                        r._cacheIndex = n,
                        t[n] = r
                    }
                    _addInactiveBinding(e, t, n) {
                        const a = this._bindingsByRootAndName
                          , r = this._bindings;
                        let c = a[t];
                        c === void 0 && (c = {},
                        a[t] = c),
                        c[n] = e,
                        e._cacheIndex = r.length,
                        r.push(e)
                    }
                    _removeInactiveBinding(e) {
                        const t = this._bindings
                          , n = e.binding
                          , a = n.rootNode.uuid
                          , r = n.path
                          , c = this._bindingsByRootAndName
                          , f = c[a]
                          , p = t[t.length - 1]
                          , m = e._cacheIndex;
                        p._cacheIndex = m,
                        t[m] = p,
                        t.pop(),
                        delete f[r],
                        Object.keys(f).length === 0 && delete c[a]
                    }
                    _lendBinding(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , a = this._nActiveBindings++
                          , r = t[a];
                        e._cacheIndex = a,
                        t[a] = e,
                        r._cacheIndex = n,
                        t[n] = r
                    }
                    _takeBackBinding(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , a = --this._nActiveBindings
                          , r = t[a];
                        e._cacheIndex = a,
                        t[a] = e,
                        r._cacheIndex = n,
                        t[n] = r
                    }
                    _lendControlInterpolant() {
                        const e = this._controlInterpolants
                          , t = this._nActiveControlInterpolants++;
                        let n = e[t];
                        return n === void 0 && (n = new DS(new Float32Array(2),new Float32Array(2),1,hR),
                        n.__cacheIndex = t,
                        e[t] = n),
                        n
                    }
                    _takeBackControlInterpolant(e) {
                        const t = this._controlInterpolants
                          , n = e.__cacheIndex
                          , a = --this._nActiveControlInterpolants
                          , r = t[a];
                        e.__cacheIndex = a,
                        t[a] = e,
                        r.__cacheIndex = n,
                        t[n] = r
                    }
                    clipAction(e, t, n) {
                        const a = t || this._root
                          , r = a.uuid;
                        let c = typeof e == "string" ? ym.findByName(a, e) : e;
                        const f = c !== null ? c.uuid : e
                          , p = this._actionsByClip[f];
                        let m = null;
                        if (n === void 0 && (c !== null ? n = c.blendMode : n = i0),
                        p !== void 0) {
                            const v = p.actionByRoot[r];
                            if (v !== void 0 && v.blendMode === n)
                                return v;
                            m = p.knownActions[0],
                            c === null && (c = m._clip)
                        }
                        if (c === null)
                            return null;
                        const g = new KT(this,c,t,n);
                        return this._bindAction(g, m),
                        this._addInactiveAction(g, f, r),
                        g
                    }
                    existingAction(e, t) {
                        const n = t || this._root
                          , a = n.uuid
                          , r = typeof e == "string" ? ym.findByName(n, e) : e
                          , c = r ? r.uuid : e
                          , f = this._actionsByClip[c];
                        return f !== void 0 && f.actionByRoot[a] || null
                    }
                    stopAllAction() {
                        const e = this._actions
                          , t = this._nActiveActions;
                        for (let n = t - 1; n >= 0; --n)
                            e[n].stop();
                        return this
                    }
                    update(e) {
                        e *= this.timeScale;
                        const t = this._actions
                          , n = this._nActiveActions
                          , a = this.time += e
                          , r = Math.sign(e)
                          , c = this._accuIndex ^= 1;
                        for (let m = 0; m !== n; ++m)
                            t[m]._update(a, e, r, c);
                        const f = this._bindings
                          , p = this._nActiveBindings;
                        for (let m = 0; m !== p; ++m)
                            f[m].apply(c);
                        return this
                    }
                    setTime(e) {
                        this.time = 0;
                        for (let t = 0; t < this._actions.length; t++)
                            this._actions[t].time = 0;
                        return this.update(e)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(e) {
                        const t = this._actions
                          , n = e.uuid
                          , a = this._actionsByClip
                          , r = a[n];
                        if (r !== void 0) {
                            const c = r.knownActions;
                            for (let f = 0, p = c.length; f !== p; ++f) {
                                const m = c[f];
                                this._deactivateAction(m);
                                const g = m._cacheIndex
                                  , v = t[t.length - 1];
                                m._cacheIndex = null,
                                m._byClipCacheIndex = null,
                                v._cacheIndex = g,
                                t[g] = v,
                                t.pop(),
                                this._removeInactiveBindingsForAction(m)
                            }
                            delete a[n]
                        }
                    }
                    uncacheRoot(e) {
                        const t = e.uuid
                          , n = this._actionsByClip;
                        for (const r in n) {
                            const c = n[r].actionByRoot[t];
                            c !== void 0 && (this._deactivateAction(c),
                            this._removeInactiveAction(c))
                        }
                        const a = this._bindingsByRootAndName[t];
                        if (a !== void 0)
                            for (const r in a) {
                                const c = a[r];
                                c.restoreOriginalState(),
                                this._removeInactiveBinding(c)
                            }
                    }
                    uncacheAction(e, t) {
                        const n = this.existingAction(e, t);
                        n !== null && (this._deactivateAction(n),
                        this._removeInactiveAction(n))
                    }
                }
                  , pR = class extends R_ {
                    constructor(e=1, t=1, n=1, a={}) {
                        super(e, t, a),
                        this.isRenderTarget3D = !0,
                        this.depth = n,
                        this.texture = new o0(null,e,t,n),
                        this._setTextureOptions(a),
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                  , mR = class t2 {
                    constructor(t) {
                        this.value = t
                    }
                    clone() {
                        return new t2(this.value.clone === void 0 ? this.value : this.value.clone())
                    }
                }
                ;
                let gR = 0;
                var vR = class extends Uo {
                    constructor() {
                        super(),
                        this.isUniformsGroup = !0,
                        Object.defineProperty(this, "id", {
                            value: gR++
                        }),
                        this.name = "",
                        this.usage = Gp,
                        this.uniforms = []
                    }
                    add(e) {
                        return this.uniforms.push(e),
                        this
                    }
                    remove(e) {
                        const t = this.uniforms.indexOf(e);
                        return t !== -1 && this.uniforms.splice(t, 1),
                        this
                    }
                    setName(e) {
                        return this.name = e,
                        this
                    }
                    setUsage(e) {
                        return this.usage = e,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    copy(e) {
                        this.name = e.name,
                        this.usage = e.usage;
                        const t = e.uniforms;
                        this.uniforms.length = 0;
                        for (let n = 0, a = t.length; n < a; n++) {
                            const r = Array.isArray(t[n]) ? t[n] : [t[n]];
                            for (let c = 0; c < r.length; c++)
                                this.uniforms.push(r[c].clone())
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , yR = class extends A0 {
                    constructor(e, t, n=1) {
                        super(e, t),
                        this.isInstancedInterleavedBuffer = !0,
                        this.meshPerAttribute = n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    }
                    clone(e) {
                        const t = super.clone(e);
                        return t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return t.isInstancedInterleavedBuffer = !0,
                        t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                }
                  , _R = class {
                    constructor(e, t, n, a, r, c=!1) {
                        this.isGLBufferAttribute = !0,
                        this.name = "",
                        this.buffer = e,
                        this.type = t,
                        this.itemSize = n,
                        this.elementSize = a,
                        this.count = r,
                        this.normalized = c,
                        this.version = 0
                    }
                    set needsUpdate(e) {
                        e === !0 && this.version++
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this
                    }
                    setType(e, t) {
                        return this.type = e,
                        this.elementSize = t,
                        this
                    }
                    setItemSize(e) {
                        return this.itemSize = e,
                        this
                    }
                    setCount(e) {
                        return this.count = e,
                        this
                    }
                }
                ;
                const JT = new Wt;
                var $T = class {
                    constructor(e, t, n=0, a=1 / 0) {
                        this.ray = new Eh(e,t),
                        this.near = n,
                        this.far = a,
                        this.camera = null,
                        this.layers = new wh,
                        this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(e, t) {
                        this.ray.set(e, t)
                    }
                    setFromCamera(e, t) {
                        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                        this.camera = t) : Et("Raycaster: Unsupported camera type: " + t.type)
                    }
                    setFromXRController(e) {
                        return JT.identity().extractRotation(e.matrixWorld),
                        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction.set(0, 0, -1).applyMatrix4(JT),
                        this
                    }
                    intersectObject(e, t=!0, n=[]) {
                        return GS(e, this, n, t),
                        n.sort(eE),
                        n
                    }
                    intersectObjects(e, t=!0, n=[]) {
                        for (let a = 0, r = e.length; a < r; a++)
                            GS(e[a], this, n, t);
                        return n.sort(eE),
                        n
                    }
                }
                ;
                function eE(e, t) {
                    return e.distance - t.distance
                }
                function GS(e, t, n, a) {
                    let r = !0;
                    if (e.layers.test(t.layers) && e.raycast(t, n) === !1 && (r = !1),
                    r === !0 && a === !0) {
                        const c = e.children;
                        for (let f = 0, p = c.length; f < p; f++)
                            GS(c[f], t, n, !0)
                    }
                }
                var SR = class {
                    constructor() {
                        this._previousTime = 0,
                        this._currentTime = 0,
                        this._startTime = performance.now(),
                        this._delta = 0,
                        this._elapsed = 0,
                        this._timescale = 1,
                        this._document = null,
                        this._pageVisibilityHandler = null
                    }
                    connect(e) {
                        this._document = e,
                        e.hidden !== void 0 && (this._pageVisibilityHandler = xR.bind(this),
                        e.addEventListener("visibilitychange", this._pageVisibilityHandler, !1))
                    }
                    disconnect() {
                        this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler),
                        this._pageVisibilityHandler = null),
                        this._document = null
                    }
                    getDelta() {
                        return this._delta / 1e3
                    }
                    getElapsed() {
                        return this._elapsed / 1e3
                    }
                    getTimescale() {
                        return this._timescale
                    }
                    setTimescale(e) {
                        return this._timescale = e,
                        this
                    }
                    reset() {
                        return this._currentTime = performance.now() - this._startTime,
                        this
                    }
                    dispose() {
                        this.disconnect()
                    }
                    update(e) {
                        return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime,
                        this._currentTime = (e !== void 0 ? e : performance.now()) - this._startTime,
                        this._delta = (this._currentTime - this._previousTime) * this._timescale,
                        this._elapsed += this._delta),
                        this
                    }
                }
                ;
                function xR() {
                    this._document.hidden === !1 && this.reset()
                }
                var bR = class {
                    constructor(e=1, t=0, n=0) {
                        this.radius = e,
                        this.phi = t,
                        this.theta = n
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.phi = t,
                        this.theta = n,
                        this
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.phi = e.phi,
                        this.theta = e.theta,
                        this
                    }
                    makeSafe() {
                        return this.phi = Bt(this.phi, 1e-6, Math.PI - 1e-6),
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + t * t + n * n),
                        this.radius === 0 ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(e, n),
                        this.phi = Math.acos(Bt(t / this.radius, -1, 1))),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , MR = class {
                    constructor(e=1, t=0, n=0) {
                        this.radius = e,
                        this.theta = t,
                        this.y = n
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.theta = t,
                        this.y = n,
                        this
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.theta = e.theta,
                        this.y = e.y,
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + n * n),
                        this.theta = Math.atan2(e, n),
                        this.y = t,
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                  , TR = class n2 {
                    constructor(t, n, a, r) {
                        n2.prototype.isMatrix2 = !0,
                        this.elements = [1, 0, 0, 1],
                        t !== void 0 && this.set(t, n, a, r)
                    }
                    identity() {
                        return this.set(1, 0, 0, 1),
                        this
                    }
                    fromArray(t, n=0) {
                        for (let a = 0; a < 4; a++)
                            this.elements[a] = t[a + n];
                        return this
                    }
                    set(t, n, a, r) {
                        const c = this.elements;
                        return c[0] = t,
                        c[2] = n,
                        c[1] = a,
                        c[3] = r,
                        this
                    }
                }
                ;
                const tE = new Pe;
                var ER = class {
                    constructor(e=new Pe(1 / 0,1 / 0), t=new Pe(-1 / 0,-1 / 0)) {
                        this.isBox2 = !0,
                        this.min = e,
                        this.max = t
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = tE.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0,
                        this.max.x = this.max.y = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(e) {
                        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    containsPoint(e) {
                        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                    }
                    getParameter(e, t) {
                        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(e) {
                        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
                    }
                    clampPoint(e, t) {
                        return t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return this.clampPoint(e, tE).distanceTo(e)
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                }
                ;
                const nE = new Y
                  , ey = new Y
                  , Zh = new Y
                  , Qh = new Y
                  , WS = new Y
                  , AR = new Y
                  , wR = new Y;
                var CR = class {
                    constructor(e=new Y, t=new Y) {
                        this.start = e,
                        this.end = t
                    }
                    set(e, t) {
                        return this.start.copy(e),
                        this.end.copy(t),
                        this
                    }
                    copy(e) {
                        return this.start.copy(e.start),
                        this.end.copy(e.end),
                        this
                    }
                    getCenter(e) {
                        return e.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(e) {
                        return e.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(e, t) {
                        return this.delta(t).multiplyScalar(e).add(this.start)
                    }
                    closestPointToPointParameter(e, t) {
                        nE.subVectors(e, this.start),
                        ey.subVectors(this.end, this.start);
                        const n = ey.dot(ey);
                        let a = ey.dot(nE) / n;
                        return t && (a = Bt(a, 0, 1)),
                        a
                    }
                    closestPointToPoint(e, t, n) {
                        const a = this.closestPointToPointParameter(e, t);
                        return this.delta(n).multiplyScalar(a).add(this.start)
                    }
                    distanceSqToLine3(e, t=AR, n=wR) {
                        const a = 10000000000000001e-32;
                        let r, c;
                        const f = this.start
                          , p = e.start
                          , m = this.end
                          , g = e.end;
                        Zh.subVectors(m, f),
                        Qh.subVectors(g, p),
                        WS.subVectors(f, p);
                        const v = Zh.dot(Zh)
                          , _ = Qh.dot(Qh)
                          , x = Qh.dot(WS);
                        if (v <= a && _ <= a)
                            return t.copy(f),
                            n.copy(p),
                            t.sub(n),
                            t.dot(t);
                        if (v <= a)
                            r = 0,
                            c = x / _,
                            c = Bt(c, 0, 1);
                        else {
                            const M = Zh.dot(WS);
                            if (_ <= a)
                                c = 0,
                                r = Bt(-M / v, 0, 1);
                            else {
                                const C = Zh.dot(Qh)
                                  , R = v * _ - C * C;
                                R !== 0 ? r = Bt((C * x - M * _) / R, 0, 1) : r = 0,
                                c = (C * r + x) / _,
                                c < 0 ? (c = 0,
                                r = Bt(-M / v, 0, 1)) : c > 1 && (c = 1,
                                r = Bt((C - M) / v, 0, 1))
                            }
                        }
                        return t.copy(f).add(Zh.multiplyScalar(r)),
                        n.copy(p).add(Qh.multiplyScalar(c)),
                        t.sub(n),
                        t.dot(t)
                    }
                    applyMatrix4(e) {
                        return this.start.applyMatrix4(e),
                        this.end.applyMatrix4(e),
                        this
                    }
                    equals(e) {
                        return e.start.equals(this.start) && e.end.equals(this.end)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                ;
                const iE = new Y;
                var RR = class extends Fn {
                    constructor(e, t) {
                        super(),
                        this.light = e,
                        this.matrixAutoUpdate = !1,
                        this.color = t,
                        this.type = "SpotLightHelper";
                        const n = new Xt
                          , a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let r = 0, c = 1, f = 32; r < f; r++,
                        c++) {
                            const p = r / f * Math.PI * 2
                              , m = c / f * Math.PI * 2;
                            a.push(Math.cos(p), Math.sin(p), 1, Math.cos(m), Math.sin(m), 1)
                        }
                        n.setAttribute("position", new vt(a,3)),
                        this.cone = new Po(n,new is({
                            fog: !1,
                            toneMapped: !1
                        })),
                        this.add(this.cone),
                        this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        this.parent ? (this.parent.updateWorldMatrix(!0),
                        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
                        this.matrixWorld.copy(this.light.matrixWorld);
                        const e = this.light.distance ? this.light.distance : 1e3
                          , t = e * Math.tan(this.light.angle);
                        this.cone.scale.set(t, t, e),
                        iE.setFromMatrixPosition(this.light.target.matrixWorld),
                        this.cone.lookAt(iE),
                        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                ;
                const Ic = new Y
                  , ty = new Wt
                  , XS = new Wt;
                var DR = class extends Po {
                    constructor(e) {
                        const t = aE(e)
                          , n = new Xt
                          , a = []
                          , r = [];
                        for (let m = 0; m < t.length; m++) {
                            const g = t[m];
                            g.parent && g.parent.isBone && (a.push(0, 0, 0),
                            a.push(0, 0, 0),
                            r.push(0, 0, 0),
                            r.push(0, 0, 0))
                        }
                        n.setAttribute("position", new vt(a,3)),
                        n.setAttribute("color", new vt(r,3));
                        const c = new is({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        });
                        super(n, c),
                        this.isSkeletonHelper = !0,
                        this.type = "SkeletonHelper",
                        this.root = e,
                        this.bones = t,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1;
                        const f = new dt(255)
                          , p = new dt(65280);
                        this.setColors(f, p)
                    }
                    updateMatrixWorld(e) {
                        const t = this.bones
                          , n = this.geometry
                          , a = n.getAttribute("position");
                        XS.copy(this.root.matrixWorld).invert();
                        for (let r = 0, c = 0; r < t.length; r++) {
                            const f = t[r];
                            f.parent && f.parent.isBone && (ty.multiplyMatrices(XS, f.matrixWorld),
                            Ic.setFromMatrixPosition(ty),
                            a.setXYZ(c, Ic.x, Ic.y, Ic.z),
                            ty.multiplyMatrices(XS, f.parent.matrixWorld),
                            Ic.setFromMatrixPosition(ty),
                            a.setXYZ(c + 1, Ic.x, Ic.y, Ic.z),
                            c += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0,
                        super.updateMatrixWorld(e)
                    }
                    setColors(e, t) {
                        const n = this.geometry.getAttribute("color");
                        for (let a = 0; a < n.count; a += 2)
                            n.setXYZ(a, e.r, e.g, e.b),
                            n.setXYZ(a + 1, t.r, t.g, t.b);
                        return n.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function aE(e) {
                    const t = [];
                    e.isBone === !0 && t.push(e);
                    for (let n = 0; n < e.children.length; n++)
                        t.push(...aE(e.children[n]));
                    return t
                }
                var NR = class extends Hi {
                    constructor(e, t, n) {
                        const a = new MS(t,4,2)
                          , r = new Rc({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                        super(a, r),
                        this.light = e,
                        this.color = n,
                        this.type = "PointLightHelper",
                        this.matrix = this.light.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                ;
                const LR = new Y
                  , sE = new dt
                  , rE = new dt;
                var UR = class extends Fn {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "HemisphereLightHelper";
                        const a = new bS(t);
                        a.rotateY(Math.PI * .5),
                        this.material = new Rc({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }),
                        this.color === void 0 && (this.material.vertexColors = !0);
                        const r = a.getAttribute("position")
                          , c = new Float32Array(r.count * 3);
                        a.setAttribute("color", new Vn(c,3)),
                        this.add(new Hi(a,this.material)),
                        this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                    update() {
                        const e = this.children[0];
                        if (this.color !== void 0)
                            this.material.color.set(this.color);
                        else {
                            const t = e.geometry.getAttribute("color");
                            sE.copy(this.light.color),
                            rE.copy(this.light.groundColor);
                            for (let n = 0, a = t.count; n < a; n++) {
                                const r = n < a / 2 ? sE : rE;
                                t.setXYZ(n, r.r, r.g, r.b)
                            }
                            t.needsUpdate = !0
                        }
                        this.light.updateWorldMatrix(!0, !1),
                        e.lookAt(LR.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                  , IR = class extends Po {
                    constructor(e=10, t=10, n=4473924, a=8947848) {
                        n = new dt(n),
                        a = new dt(a);
                        const r = t / 2
                          , c = e / t
                          , f = e / 2
                          , p = []
                          , m = [];
                        for (let _ = 0, x = 0, M = -f; _ <= t; _++,
                        M += c) {
                            p.push(-f, 0, M, f, 0, M),
                            p.push(M, 0, -f, M, 0, f);
                            const C = _ === r ? n : a;
                            C.toArray(m, x),
                            x += 3,
                            C.toArray(m, x),
                            x += 3,
                            C.toArray(m, x),
                            x += 3,
                            C.toArray(m, x),
                            x += 3
                        }
                        const g = new Xt;
                        g.setAttribute("position", new vt(p,3)),
                        g.setAttribute("color", new vt(m,3));
                        const v = new is({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(g, v),
                        this.type = "GridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , OR = class extends Po {
                    constructor(e=10, t=16, n=8, a=64, r=4473924, c=8947848) {
                        r = new dt(r),
                        c = new dt(c);
                        const f = []
                          , p = [];
                        if (t > 1)
                            for (let v = 0; v < t; v++) {
                                const _ = v / t * (Math.PI * 2)
                                  , x = Math.sin(_) * e
                                  , M = Math.cos(_) * e;
                                f.push(0, 0, 0),
                                f.push(x, 0, M);
                                const C = v & 1 ? r : c;
                                p.push(C.r, C.g, C.b),
                                p.push(C.r, C.g, C.b)
                            }
                        for (let v = 0; v < n; v++) {
                            const _ = v & 1 ? r : c
                              , x = e - e / n * v;
                            for (let M = 0; M < a; M++) {
                                let C = M / a * (Math.PI * 2)
                                  , R = Math.sin(C) * x
                                  , A = Math.cos(C) * x;
                                f.push(R, 0, A),
                                p.push(_.r, _.g, _.b),
                                C = (M + 1) / a * (Math.PI * 2),
                                R = Math.sin(C) * x,
                                A = Math.cos(C) * x,
                                f.push(R, 0, A),
                                p.push(_.r, _.g, _.b)
                            }
                        }
                        const m = new Xt;
                        m.setAttribute("position", new vt(f,3)),
                        m.setAttribute("color", new vt(p,3));
                        const g = new is({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(m, g),
                        this.type = "PolarGridHelper"
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                const oE = new Y
                  , ny = new Y
                  , lE = new Y;
                var PR = class extends Fn {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        this.type = "DirectionalLightHelper",
                        t === void 0 && (t = 1);
                        let a = new Xt;
                        a.setAttribute("position", new vt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
                        const r = new is({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new Lc(a,r),
                        this.add(this.lightPlane),
                        a = new Xt,
                        a.setAttribute("position", new vt([0, 0, 0, 0, 0, 1],3)),
                        this.targetLine = new Lc(a,r),
                        this.add(this.targetLine),
                        this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(),
                        this.lightPlane.material.dispose(),
                        this.targetLine.geometry.dispose(),
                        this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1),
                        this.light.target.updateWorldMatrix(!0, !1),
                        oE.setFromMatrixPosition(this.light.matrixWorld),
                        ny.setFromMatrixPosition(this.light.target.matrixWorld),
                        lE.subVectors(ny, oE),
                        this.lightPlane.lookAt(ny),
                        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                        this.targetLine.lookAt(ny),
                        this.targetLine.scale.z = lE.length()
                    }
                }
                ;
                const iy = new Y
                  , wi = new T0;
                var zR = class extends Po {
                    constructor(e) {
                        const t = new Xt
                          , n = new is({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        })
                          , a = []
                          , r = []
                          , c = {};
                        f("n1", "n2"),
                        f("n2", "n4"),
                        f("n4", "n3"),
                        f("n3", "n1"),
                        f("f1", "f2"),
                        f("f2", "f4"),
                        f("f4", "f3"),
                        f("f3", "f1"),
                        f("n1", "f1"),
                        f("n2", "f2"),
                        f("n3", "f3"),
                        f("n4", "f4"),
                        f("p", "n1"),
                        f("p", "n2"),
                        f("p", "n3"),
                        f("p", "n4"),
                        f("u1", "u2"),
                        f("u2", "u3"),
                        f("u3", "u1"),
                        f("c", "t"),
                        f("p", "c"),
                        f("cn1", "cn2"),
                        f("cn3", "cn4"),
                        f("cf1", "cf2"),
                        f("cf3", "cf4");
                        function f(M, C) {
                            p(M),
                            p(C)
                        }
                        function p(M) {
                            a.push(0, 0, 0),
                            r.push(0, 0, 0),
                            c[M] === void 0 && (c[M] = []),
                            c[M].push(a.length / 3 - 1)
                        }
                        t.setAttribute("position", new vt(a,3)),
                        t.setAttribute("color", new vt(r,3)),
                        super(t, n),
                        this.type = "CameraHelper",
                        this.camera = e,
                        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.pointMap = c,
                        this.update();
                        const m = new dt(16755200)
                          , g = new dt(16711680)
                          , v = new dt(43775)
                          , _ = new dt(16777215)
                          , x = new dt(3355443);
                        this.setColors(m, g, v, _, x)
                    }
                    setColors(e, t, n, a, r) {
                        const c = this.geometry.getAttribute("color");
                        return c.setXYZ(0, e.r, e.g, e.b),
                        c.setXYZ(1, e.r, e.g, e.b),
                        c.setXYZ(2, e.r, e.g, e.b),
                        c.setXYZ(3, e.r, e.g, e.b),
                        c.setXYZ(4, e.r, e.g, e.b),
                        c.setXYZ(5, e.r, e.g, e.b),
                        c.setXYZ(6, e.r, e.g, e.b),
                        c.setXYZ(7, e.r, e.g, e.b),
                        c.setXYZ(8, e.r, e.g, e.b),
                        c.setXYZ(9, e.r, e.g, e.b),
                        c.setXYZ(10, e.r, e.g, e.b),
                        c.setXYZ(11, e.r, e.g, e.b),
                        c.setXYZ(12, e.r, e.g, e.b),
                        c.setXYZ(13, e.r, e.g, e.b),
                        c.setXYZ(14, e.r, e.g, e.b),
                        c.setXYZ(15, e.r, e.g, e.b),
                        c.setXYZ(16, e.r, e.g, e.b),
                        c.setXYZ(17, e.r, e.g, e.b),
                        c.setXYZ(18, e.r, e.g, e.b),
                        c.setXYZ(19, e.r, e.g, e.b),
                        c.setXYZ(20, e.r, e.g, e.b),
                        c.setXYZ(21, e.r, e.g, e.b),
                        c.setXYZ(22, e.r, e.g, e.b),
                        c.setXYZ(23, e.r, e.g, e.b),
                        c.setXYZ(24, t.r, t.g, t.b),
                        c.setXYZ(25, t.r, t.g, t.b),
                        c.setXYZ(26, t.r, t.g, t.b),
                        c.setXYZ(27, t.r, t.g, t.b),
                        c.setXYZ(28, t.r, t.g, t.b),
                        c.setXYZ(29, t.r, t.g, t.b),
                        c.setXYZ(30, t.r, t.g, t.b),
                        c.setXYZ(31, t.r, t.g, t.b),
                        c.setXYZ(32, n.r, n.g, n.b),
                        c.setXYZ(33, n.r, n.g, n.b),
                        c.setXYZ(34, n.r, n.g, n.b),
                        c.setXYZ(35, n.r, n.g, n.b),
                        c.setXYZ(36, n.r, n.g, n.b),
                        c.setXYZ(37, n.r, n.g, n.b),
                        c.setXYZ(38, a.r, a.g, a.b),
                        c.setXYZ(39, a.r, a.g, a.b),
                        c.setXYZ(40, r.r, r.g, r.b),
                        c.setXYZ(41, r.r, r.g, r.b),
                        c.setXYZ(42, r.r, r.g, r.b),
                        c.setXYZ(43, r.r, r.g, r.b),
                        c.setXYZ(44, r.r, r.g, r.b),
                        c.setXYZ(45, r.r, r.g, r.b),
                        c.setXYZ(46, r.r, r.g, r.b),
                        c.setXYZ(47, r.r, r.g, r.b),
                        c.setXYZ(48, r.r, r.g, r.b),
                        c.setXYZ(49, r.r, r.g, r.b),
                        c.needsUpdate = !0,
                        this
                    }
                    update() {
                        const e = this.geometry
                          , t = this.pointMap
                          , n = 1
                          , a = 1;
                        let r, c;
                        if (wi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                        this.camera.reversedDepth === !0)
                            r = 1,
                            c = 0;
                        else if (this.camera.coordinateSystem === Bs)
                            r = -1,
                            c = 1;
                        else if (this.camera.coordinateSystem === gh)
                            r = 0,
                            c = 1;
                        else
                            throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem);
                        Pi("c", t, e, wi, 0, 0, r),
                        Pi("t", t, e, wi, 0, 0, c),
                        Pi("n1", t, e, wi, -n, -a, r),
                        Pi("n2", t, e, wi, n, -a, r),
                        Pi("n3", t, e, wi, -n, a, r),
                        Pi("n4", t, e, wi, n, a, r),
                        Pi("f1", t, e, wi, -n, -a, c),
                        Pi("f2", t, e, wi, n, -a, c),
                        Pi("f3", t, e, wi, -n, a, c),
                        Pi("f4", t, e, wi, n, a, c),
                        Pi("u1", t, e, wi, n * .7, a * 1.1, r),
                        Pi("u2", t, e, wi, -n * .7, a * 1.1, r),
                        Pi("u3", t, e, wi, 0, a * 2, r),
                        Pi("cf1", t, e, wi, -n, 0, c),
                        Pi("cf2", t, e, wi, n, 0, c),
                        Pi("cf3", t, e, wi, 0, -a, c),
                        Pi("cf4", t, e, wi, 0, a, c),
                        Pi("cn1", t, e, wi, -n, 0, r),
                        Pi("cn2", t, e, wi, n, 0, r),
                        Pi("cn3", t, e, wi, 0, -a, r),
                        Pi("cn4", t, e, wi, 0, a, r),
                        e.getAttribute("position").needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                ;
                function Pi(e, t, n, a, r, c, f) {
                    iy.set(r, c, f).unproject(a);
                    const p = t[e];
                    if (p !== void 0) {
                        const m = n.getAttribute("position");
                        for (let g = 0, v = p.length; g < v; g++)
                            m.setXYZ(p[g], iy.x, iy.y, iy.z)
                    }
                }
                const ay = new Ra;
                var BR = class extends Po {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , a = new Float32Array(24)
                          , r = new Xt;
                        r.setIndex(new Vn(n,1)),
                        r.setAttribute("position", new Vn(a,3)),
                        super(r, new is({
                            color: t,
                            toneMapped: !1
                        })),
                        this.object = e,
                        this.type = "BoxHelper",
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    update() {
                        if (this.object !== void 0 && ay.setFromObject(this.object),
                        ay.isEmpty())
                            return;
                        const e = ay.min
                          , t = ay.max
                          , n = this.geometry.attributes.position
                          , a = n.array;
                        a[0] = t.x,
                        a[1] = t.y,
                        a[2] = t.z,
                        a[3] = e.x,
                        a[4] = t.y,
                        a[5] = t.z,
                        a[6] = e.x,
                        a[7] = e.y,
                        a[8] = t.z,
                        a[9] = t.x,
                        a[10] = e.y,
                        a[11] = t.z,
                        a[12] = t.x,
                        a[13] = t.y,
                        a[14] = e.z,
                        a[15] = e.x,
                        a[16] = t.y,
                        a[17] = e.z,
                        a[18] = e.x,
                        a[19] = e.y,
                        a[20] = e.z,
                        a[21] = t.x,
                        a[22] = e.y,
                        a[23] = e.z,
                        n.needsUpdate = !0,
                        this.geometry.computeBoundingSphere()
                    }
                    setFromObject(e) {
                        return this.object = e,
                        this.update(),
                        this
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        this.object = e.object,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , FR = class extends Po {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
                          , r = new Xt;
                        r.setIndex(new Vn(n,1)),
                        r.setAttribute("position", new vt(a,3)),
                        super(r, new is({
                            color: t,
                            toneMapped: !1
                        })),
                        this.box = e,
                        this.type = "Box3Helper",
                        this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(e) {
                        const t = this.box;
                        t.isEmpty() || (t.getCenter(this.position),
                        t.getSize(this.scale),
                        this.scale.multiplyScalar(.5),
                        super.updateMatrixWorld(e))
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , VR = class extends Lc {
                    constructor(e, t=1, n=16776960) {
                        const a = n
                          , r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
                          , c = new Xt;
                        c.setAttribute("position", new vt(r,3)),
                        c.computeBoundingSphere(),
                        super(c, new is({
                            color: a,
                            toneMapped: !1
                        })),
                        this.type = "PlaneHelper",
                        this.plane = e,
                        this.size = t;
                        const f = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
                          , p = new Xt;
                        p.setAttribute("position", new vt(f,3)),
                        p.computeBoundingSphere(),
                        this.add(new Hi(p,new Rc({
                            color: a,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(e) {
                        this.position.set(0, 0, 0),
                        this.scale.set(.5 * this.size, .5 * this.size, 1),
                        this.lookAt(this.plane.normal),
                        this.translateZ(-this.plane.constant),
                        super.updateMatrixWorld(e)
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose(),
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                }
                ;
                const cE = new Y;
                let sy, qS;
                var kR = class extends Fn {
                    constructor(e=new Y(0,0,1), t=new Y(0,0,0), n=1, a=16776960, r=n * .2, c=r * .2) {
                        super(),
                        this.type = "ArrowHelper",
                        sy === void 0 && (sy = new Xt,
                        sy.setAttribute("position", new vt([0, 0, 0, 0, 1, 0],3)),
                        qS = new cS(.5,1,5,1),
                        qS.translate(0, -.5, 0)),
                        this.position.copy(t),
                        this.line = new Lc(sy,new is({
                            color: a,
                            toneMapped: !1
                        })),
                        this.line.matrixAutoUpdate = !1,
                        this.add(this.line),
                        this.cone = new Hi(qS,new Rc({
                            color: a,
                            toneMapped: !1
                        })),
                        this.cone.matrixAutoUpdate = !1,
                        this.add(this.cone),
                        this.setDirection(e),
                        this.setLength(n, r, c)
                    }
                    setDirection(e) {
                        if (e.y > .99999)
                            this.quaternion.set(0, 0, 0, 1);
                        else if (e.y < -.99999)
                            this.quaternion.set(1, 0, 0, 0);
                        else {
                            cE.set(e.z, 0, -e.x).normalize();
                            const t = Math.acos(e.y);
                            this.quaternion.setFromAxisAngle(cE, t)
                        }
                    }
                    setLength(e, t=e * .2, n=t * .2) {
                        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                        this.line.updateMatrix(),
                        this.cone.scale.set(n, t, n),
                        this.cone.position.y = e,
                        this.cone.updateMatrix()
                    }
                    setColor(e) {
                        this.line.material.color.set(e),
                        this.cone.material.color.set(e)
                    }
                    copy(e) {
                        return super.copy(e, !1),
                        this.line.copy(e.line),
                        this.cone.copy(e.cone),
                        this
                    }
                    dispose() {
                        this.line.geometry.dispose(),
                        this.line.material.dispose(),
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                }
                  , HR = class extends Po {
                    constructor(e=1) {
                        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
                          , n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
                          , a = new Xt;
                        a.setAttribute("position", new vt(t,3)),
                        a.setAttribute("color", new vt(n,3));
                        const r = new is({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(a, r),
                        this.type = "AxesHelper"
                    }
                    setColors(e, t, n) {
                        const a = new dt
                          , r = this.geometry.attributes.color.array;
                        return a.set(e),
                        a.toArray(r, 0),
                        a.toArray(r, 3),
                        a.set(t),
                        a.toArray(r, 6),
                        a.toArray(r, 9),
                        a.set(n),
                        a.toArray(r, 12),
                        a.toArray(r, 15),
                        this.geometry.attributes.color.needsUpdate = !0,
                        this
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                }
                  , GR = class {
                    constructor() {
                        this.type = "ShapePath",
                        this.color = new dt,
                        this.subPaths = [],
                        this.currentPath = null
                    }
                    moveTo(e, t) {
                        return this.currentPath = new Z0,
                        this.subPaths.push(this.currentPath),
                        this.currentPath.moveTo(e, t),
                        this
                    }
                    lineTo(e, t) {
                        return this.currentPath.lineTo(e, t),
                        this
                    }
                    quadraticCurveTo(e, t, n, a) {
                        return this.currentPath.quadraticCurveTo(e, t, n, a),
                        this
                    }
                    bezierCurveTo(e, t, n, a, r, c) {
                        return this.currentPath.bezierCurveTo(e, t, n, a, r, c),
                        this
                    }
                    splineThru(e) {
                        return this.currentPath.splineThru(e),
                        this
                    }
                    toShapes(e) {
                        function t(A) {
                            const E = [];
                            for (let N = 0, I = A.length; N < I; N++) {
                                const L = A[N]
                                  , k = new qu;
                                k.curves = L.curves,
                                E.push(k)
                            }
                            return E
                        }
                        function n(A, E) {
                            const N = E.length;
                            let I = !1;
                            for (let L = N - 1, k = 0; k < N; L = k++) {
                                let B = E[L]
                                  , X = E[k]
                                  , G = X.x - B.x
                                  , P = X.y - B.y;
                                if (Math.abs(P) > Number.EPSILON) {
                                    if (P < 0 && (B = E[k],
                                    G = -G,
                                    X = E[L],
                                    P = -P),
                                    A.y < B.y || A.y > X.y)
                                        continue;
                                    if (A.y === B.y) {
                                        if (A.x === B.x)
                                            return !0
                                    } else {
                                        const U = P * (A.x - B.x) - G * (A.y - B.y);
                                        if (U === 0)
                                            return !0;
                                        if (U < 0)
                                            continue;
                                        I = !I
                                    }
                                } else {
                                    if (A.y !== B.y)
                                        continue;
                                    if (X.x <= A.x && A.x <= B.x || B.x <= A.x && A.x <= X.x)
                                        return !0
                                }
                            }
                            return I
                        }
                        const a = Al.isClockWise
                          , r = this.subPaths;
                        if (r.length === 0)
                            return [];
                        let c, f, p;
                        const m = [];
                        if (r.length === 1)
                            return f = r[0],
                            p = new qu,
                            p.curves = f.curves,
                            m.push(p),
                            m;
                        let g = !a(r[0].getPoints());
                        g = e ? !g : g;
                        const v = []
                          , _ = [];
                        let x = [], M = 0, C;
                        _[M] = void 0,
                        x[M] = [];
                        for (let A = 0, E = r.length; A < E; A++)
                            f = r[A],
                            C = f.getPoints(),
                            c = a(C),
                            c = e ? !c : c,
                            c ? (!g && _[M] && M++,
                            _[M] = {
                                s: new qu,
                                p: C
                            },
                            _[M].s.curves = f.curves,
                            g && M++,
                            x[M] = []) : x[M].push({
                                h: f,
                                p: C[0]
                            });
                        if (!_[0])
                            return t(r);
                        if (_.length > 1) {
                            let A = !1
                              , E = 0;
                            for (let N = 0, I = _.length; N < I; N++)
                                v[N] = [];
                            for (let N = 0, I = _.length; N < I; N++) {
                                const L = x[N];
                                for (let k = 0; k < L.length; k++) {
                                    const B = L[k];
                                    let X = !0;
                                    for (let G = 0; G < _.length; G++)
                                        n(B.p, _[G].p) && (N !== G && E++,
                                        X ? (X = !1,
                                        v[G].push(B)) : A = !0);
                                    X && v[N].push(B)
                                }
                            }
                            E > 0 && A === !1 && (x = v)
                        }
                        let R;
                        for (let A = 0, E = _.length; A < E; A++) {
                            p = _[A].s,
                            m.push(p),
                            R = x[A];
                            for (let N = 0, I = R.length; N < I; N++)
                                p.holes.push(R[N].h)
                        }
                        return m
                    }
                }
                  , WR = class extends Uo {
                    constructor(e, t=null) {
                        super(),
                        this.object = e,
                        this.domElement = t,
                        this.enabled = !0,
                        this.state = -1,
                        this.keys = {},
                        this.mouseButtons = {
                            LEFT: null,
                            MIDDLE: null,
                            RIGHT: null
                        },
                        this.touches = {
                            ONE: null,
                            TWO: null
                        }
                    }
                    connect(e) {
                        if (e === void 0) {
                            ot("Controls: connect() now requires an element.");
                            return
                        }
                        this.domElement !== null && this.disconnect(),
                        this.domElement = e
                    }
                    disconnect() {}
                    dispose() {}
                    update() {}
                }
                ;
                function XR(e, t) {
                    const n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = 1,
                    e.repeat.y = n / t,
                    e.offset.x = 0,
                    e.offset.y = (1 - e.repeat.y) / 2) : (e.repeat.x = t / n,
                    e.repeat.y = 1,
                    e.offset.x = (1 - e.repeat.x) / 2,
                    e.offset.y = 0),
                    e
                }
                function qR(e, t) {
                    const n = e.image && e.image.width ? e.image.width / e.image.height : 1;
                    return n > t ? (e.repeat.x = t / n,
                    e.repeat.y = 1,
                    e.offset.x = (1 - e.repeat.x) / 2,
                    e.offset.y = 0) : (e.repeat.x = 1,
                    e.repeat.y = n / t,
                    e.offset.x = 0,
                    e.offset.y = (1 - e.repeat.y) / 2),
                    e
                }
                function YR(e) {
                    return e.repeat.x = 1,
                    e.repeat.y = 1,
                    e.offset.x = 0,
                    e.offset.y = 0,
                    e
                }
                function YS(e, t, n, a) {
                    const r = jR(a);
                    switch (n) {
                    case __:
                        return e * t;
                    case Sv:
                        return e * t / r.components * r.byteLength;
                    case Op:
                        return e * t / r.components * r.byteLength;
                    case Ou:
                        return e * t * 2 / r.components * r.byteLength;
                    case xv:
                        return e * t * 2 / r.components * r.byteLength;
                    case S_:
                        return e * t * 3 / r.components * r.byteLength;
                    case Aa:
                        return e * t * 4 / r.components * r.byteLength;
                    case bv:
                        return e * t * 4 / r.components * r.byteLength;
                    case Pp:
                    case zp:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case Bp:
                    case Fp:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case Tv:
                    case Av:
                        return Math.max(e, 16) * Math.max(t, 8) / 4;
                    case Mv:
                    case Ev:
                        return Math.max(e, 8) * Math.max(t, 8) / 2;
                    case wv:
                    case Cv:
                    case Dv:
                    case Nv:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                    case Rv:
                    case Lv:
                    case Uv:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case Iv:
                        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                    case Ov:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                    case Pv:
                        return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                    case zv:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                    case Bv:
                        return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                    case Fv:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                    case Vv:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                    case kv:
                        return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                    case Hv:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                    case Gv:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                    case Wv:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                    case Xv:
                        return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                    case qv:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                    case Yv:
                        return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                    case jv:
                    case Zv:
                    case Qv:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                    case Kv:
                    case Jv:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                    case $v:
                    case e0:
                        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                    }
                    throw new Error(`Unable to determine texture byte length for ${n} format.`)
                }
                function jR(e) {
                    switch (e) {
                    case Ka:
                    case m_:
                        return {
                            byteLength: 1,
                            components: 1
                        };
                    case ph:
                    case g_:
                    case No:
                        return {
                            byteLength: 2,
                            components: 1
                        };
                    case yv:
                    case _v:
                        return {
                            byteLength: 2,
                            components: 4
                        };
                    case fr:
                    case vv:
                    case Ja:
                        return {
                            byteLength: 4,
                            components: 1
                        };
                    case v_:
                    case y_:
                        return {
                            byteLength: 4,
                            components: 3
                        }
                    }
                    throw new Error(`Unknown texture type ${e}.`)
                }
                var ZR = class {
                    static contain(e, t) {
                        return XR(e, t)
                    }
                    static cover(e, t) {
                        return qR(e, t)
                    }
                    static fill(e) {
                        return YR(e)
                    }
                    static getByteLength(e, t, n, a) {
                        return YS(e, t, n, a)
                    }
                }
                ;
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                    detail: {
                        revision: sv
                    }
                })),
                typeof window < "u" && (window.__THREE__ ? ot("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = sv);
                var QR = G2({
                    ACESFilmicToneMapping: () => mv,
                    AddEquation: () => gc,
                    AddOperation: () => Eb,
                    AdditiveAnimationBlendMode: () => x_,
                    AdditiveBlending: () => a_,
                    AgXToneMapping: () => f_,
                    AlphaFormat: () => __,
                    AlwaysCompare: () => zb,
                    AlwaysDepth: () => cv,
                    AlwaysStencilFunc: () => b_,
                    AmbientLight: () => zT,
                    AnimationAction: () => KT,
                    AnimationClip: () => ym,
                    AnimationLoader: () => B3,
                    AnimationMixer: () => dR,
                    AnimationObjectGroup: () => fR,
                    AnimationUtils: () => I3,
                    ArcCurve: () => YM,
                    ArrayCamera: () => YT,
                    ArrowHelper: () => kR,
                    AttachedBindMode: () => d_,
                    Audio: () => jT,
                    AudioAnalyser: () => tR,
                    AudioContext: () => BS,
                    AudioListener: () => J3,
                    AudioLoader: () => Z3,
                    AxesHelper: () => HR,
                    BackSide: () => Qa,
                    BasicDepthPacking: () => Db,
                    BasicShadowMap: () => sb,
                    BatchedMesh: () => LM,
                    Bone: () => eS,
                    BooleanKeyframeTrack: () => Zu,
                    Box2: () => ER,
                    Box3: () => Ra,
                    Box3Helper: () => FR,
                    BoxGeometry: () => Jp,
                    BoxHelper: () => BR,
                    BufferAttribute: () => Vn,
                    BufferGeometry: () => Xt,
                    BufferGeometryLoader: () => HT,
                    ByteType: () => m_,
                    Cache: () => zo,
                    Camera: () => T0,
                    CameraHelper: () => zR,
                    CanvasTexture: () => i3,
                    CapsuleGeometry: () => GM,
                    CatmullRomCurve3: () => jM,
                    CineonToneMapping: () => c_,
                    CircleGeometry: () => WM,
                    ClampToEdgeWrapping: () => Ss,
                    Clock: () => FS,
                    Color: () => dt,
                    ColorKeyframeTrack: () => NS,
                    ColorManagement: () => Sn,
                    CompressedArrayTexture: () => t3,
                    CompressedCubeTexture: () => n3,
                    CompressedTexture: () => H0,
                    CompressedTextureLoader: () => F3,
                    ConeGeometry: () => cS,
                    ConstantAlphaFactor: () => bb,
                    ConstantColorFactor: () => Sb,
                    Controls: () => WR,
                    CubeCamera: () => cM,
                    CubeDepthTexture: () => HM,
                    CubeReflectionMapping: () => Ro,
                    CubeRefractionMapping: () => vc,
                    CubeTexture: () => $p,
                    CubeTextureLoader: () => V3,
                    CubeUVReflectionMapping: () => hh,
                    CubicBezierCurve: () => mS,
                    CubicBezierCurve3: () => QM,
                    CubicInterpolant: () => wT,
                    CullFaceBack: () => i_,
                    CullFaceFront: () => ab,
                    CullFaceFrontBack: () => aw,
                    CullFaceNone: () => ib,
                    Curve: () => Wr,
                    CurvePath: () => JM,
                    CustomBlending: () => rb,
                    CustomToneMapping: () => u_,
                    CylinderGeometry: () => lS,
                    Cylindrical: () => MR,
                    Data3DTexture: () => o0,
                    DataArrayTexture: () => r0,
                    DataTexture: () => Gr,
                    DataTextureLoader: () => k3,
                    DataUtils: () => AC,
                    DecrementStencilOp: () => bw,
                    DecrementWrapStencilOp: () => Tw,
                    DefaultLoadingManager: () => DT,
                    DepthFormat: () => Lo,
                    DepthStencilFormat: () => yc,
                    DepthTexture: () => Wh,
                    DetachedBindMode: () => Ab,
                    DirectionalLight: () => PT,
                    DirectionalLightHelper: () => PR,
                    DiscreteInterpolant: () => CT,
                    DodecahedronGeometry: () => XM,
                    DoubleSide: () => wo,
                    DstAlphaFactor: () => mb,
                    DstColorFactor: () => vb,
                    DynamicCopyUsage: () => Fw,
                    DynamicDrawUsage: () => Uw,
                    DynamicReadUsage: () => Pw,
                    EdgesGeometry: () => qM,
                    EllipseCurve: () => q0,
                    EqualCompare: () => Ib,
                    EqualDepth: () => fv,
                    EqualStencilFunc: () => Cw,
                    EquirectangularReflectionMapping: () => Dp,
                    EquirectangularRefractionMapping: () => Np,
                    Euler: () => es,
                    EventDispatcher: () => Uo,
                    ExternalTexture: () => oS,
                    ExtrudeGeometry: () => rT,
                    FileLoader: () => Cl,
                    Float16BufferAttribute: () => UC,
                    Float32BufferAttribute: () => vt,
                    FloatType: () => Ja,
                    Fog: () => fM,
                    FogExp2: () => uM,
                    FramebufferTexture: () => e3,
                    FrontSide: () => vl,
                    Frustum: () => Gh,
                    FrustumArray: () => RM,
                    GLBufferAttribute: () => _R,
                    GLSL1: () => kw,
                    GLSL3: () => M_,
                    GreaterCompare: () => Ob,
                    GreaterDepth: () => dv,
                    GreaterEqualCompare: () => s0,
                    GreaterEqualDepth: () => hv,
                    GreaterEqualStencilFunc: () => Lw,
                    GreaterStencilFunc: () => Dw,
                    GridHelper: () => IR,
                    Group: () => Ph,
                    HalfFloatType: () => No,
                    HemisphereLight: () => NT,
                    HemisphereLightHelper: () => UR,
                    IcosahedronGeometry: () => oT,
                    ImageBitmapLoader: () => j3,
                    ImageLoader: () => _m,
                    ImageUtils: () => qb,
                    IncrementStencilOp: () => xw,
                    IncrementWrapStencilOp: () => Mw,
                    InstancedBufferAttribute: () => kh,
                    InstancedBufferGeometry: () => kT,
                    InstancedInterleavedBuffer: () => yR,
                    InstancedMesh: () => CM,
                    Int16BufferAttribute: () => NC,
                    Int32BufferAttribute: () => LC,
                    Int8BufferAttribute: () => CC,
                    IntType: () => vv,
                    InterleavedBuffer: () => A0,
                    InterleavedBufferAttribute: () => em,
                    Interpolant: () => pm,
                    InterpolateDiscrete: () => Vp,
                    InterpolateLinear: () => t0,
                    InterpolateSmooth: () => n0,
                    InterpolationSamplingMode: () => Ww,
                    InterpolationSamplingType: () => Gw,
                    InvertStencilOp: () => Ew,
                    KeepStencilOp: () => Bu,
                    KeyframeTrack: () => pr,
                    LOD: () => vM,
                    LatheGeometry: () => lT,
                    Layers: () => wh,
                    LessCompare: () => Ub,
                    LessDepth: () => uv,
                    LessEqualCompare: () => a0,
                    LessEqualDepth: () => Iu,
                    LessEqualStencilFunc: () => Rw,
                    LessStencilFunc: () => ww,
                    Light: () => Uc,
                    LightProbe: () => FT,
                    Line: () => Lc,
                    Line3: () => CR,
                    LineBasicMaterial: () => is,
                    LineCurve: () => gS,
                    LineCurve3: () => KM,
                    LineDashedMaterial: () => ET,
                    LineLoop: () => zM,
                    LineSegments: () => Po,
                    LinearFilter: () => ei,
                    LinearInterpolant: () => DS,
                    LinearMipMapLinearFilter: () => lw,
                    LinearMipMapNearestFilter: () => ow,
                    LinearMipmapLinearFilter: () => Do,
                    LinearMipmapNearestFilter: () => Ip,
                    LinearSRGBColorSpace: () => Sc,
                    LinearToneMapping: () => o_,
                    LinearTransfer: () => Hp,
                    Loader: () => Ts,
                    LoaderUtils: () => PS,
                    LoadingManager: () => LS,
                    LoopOnce: () => wb,
                    LoopPingPong: () => Rb,
                    LoopRepeat: () => Cb,
                    MOUSE: () => nw,
                    Material: () => Na,
                    MaterialLoader: () => VT,
                    MathUtils: () => fC,
                    Matrix2: () => TR,
                    Matrix3: () => en,
                    Matrix4: () => Wt,
                    MaxEquation: () => ub,
                    Mesh: () => Hi,
                    MeshBasicMaterial: () => Rc,
                    MeshDepthMaterial: () => AS,
                    MeshDistanceMaterial: () => wS,
                    MeshLambertMaterial: () => MT,
                    MeshMatcapMaterial: () => TT,
                    MeshNormalMaterial: () => bT,
                    MeshPhongMaterial: () => ST,
                    MeshPhysicalMaterial: () => _T,
                    MeshStandardMaterial: () => ES,
                    MeshToonMaterial: () => xT,
                    MinEquation: () => cb,
                    MirroredRepeatWrapping: () => Up,
                    MixOperation: () => Tb,
                    MultiplyBlending: () => r_,
                    MultiplyOperation: () => Rp,
                    NearestFilter: () => Oi,
                    NearestMipMapLinearFilter: () => rw,
                    NearestMipMapNearestFilter: () => sw,
                    NearestMipmapLinearFilter: () => dh,
                    NearestMipmapNearestFilter: () => p_,
                    NeutralToneMapping: () => h_,
                    NeverCompare: () => Lb,
                    NeverDepth: () => lv,
                    NeverStencilFunc: () => Aw,
                    NoBlending: () => Co,
                    NoColorSpace: () => yl,
                    NoNormalPacking: () => gw,
                    NoToneMapping: () => ur,
                    NormalAnimationBlendMode: () => i0,
                    NormalBlending: () => Uu,
                    NormalGAPacking: () => yw,
                    NormalRGPacking: () => vw,
                    NotEqualCompare: () => Pb,
                    NotEqualDepth: () => pv,
                    NotEqualStencilFunc: () => Nw,
                    NumberKeyframeTrack: () => mm,
                    Object3D: () => Fn,
                    ObjectLoader: () => q3,
                    ObjectSpaceNormalMap: () => Nb,
                    OctahedronGeometry: () => bS,
                    OneFactor: () => hb,
                    OneMinusConstantAlphaFactor: () => Mb,
                    OneMinusConstantColorFactor: () => xb,
                    OneMinusDstAlphaFactor: () => gb,
                    OneMinusDstColorFactor: () => yb,
                    OneMinusSrcAlphaFactor: () => ov,
                    OneMinusSrcColorFactor: () => pb,
                    OrthographicCamera: () => jh,
                    PCFShadowMap: () => fh,
                    PCFSoftShadowMap: () => Cp,
                    PMREMGenerator: () => JS,
                    Path: () => Z0,
                    PerspectiveCamera: () => ca,
                    Plane: () => Nc,
                    PlaneGeometry: () => J0,
                    PlaneHelper: () => VR,
                    PointLight: () => OT,
                    PointLightHelper: () => NR,
                    Points: () => FM,
                    PointsMaterial: () => sS,
                    PolarGridHelper: () => OR,
                    PolyhedronGeometry: () => Xh,
                    PositionalAudio: () => eR,
                    PropertyBinding: () => Yn,
                    PropertyMixer: () => QT,
                    QuadraticBezierCurve: () => vS,
                    QuadraticBezierCurve3: () => yS,
                    Quaternion: () => xs,
                    QuaternionKeyframeTrack: () => gm,
                    QuaternionLinearInterpolant: () => RT,
                    R11_EAC_Format: () => Dv,
                    RED_GREEN_RGTC2_Format: () => $v,
                    RED_RGTC1_Format: () => Kv,
                    REVISION: () => sv,
                    RG11_EAC_Format: () => Lv,
                    RGBADepthPacking: () => dw,
                    RGBAFormat: () => Aa,
                    RGBAIntegerFormat: () => bv,
                    RGBA_ASTC_10x10_Format: () => Xv,
                    RGBA_ASTC_10x5_Format: () => Hv,
                    RGBA_ASTC_10x6_Format: () => Gv,
                    RGBA_ASTC_10x8_Format: () => Wv,
                    RGBA_ASTC_12x10_Format: () => qv,
                    RGBA_ASTC_12x12_Format: () => Yv,
                    RGBA_ASTC_4x4_Format: () => Iv,
                    RGBA_ASTC_5x4_Format: () => Ov,
                    RGBA_ASTC_5x5_Format: () => Pv,
                    RGBA_ASTC_6x5_Format: () => zv,
                    RGBA_ASTC_6x6_Format: () => Bv,
                    RGBA_ASTC_8x5_Format: () => Fv,
                    RGBA_ASTC_8x6_Format: () => Vv,
                    RGBA_ASTC_8x8_Format: () => kv,
                    RGBA_BPTC_Format: () => jv,
                    RGBA_ETC2_EAC_Format: () => Rv,
                    RGBA_PVRTC_2BPPV1_Format: () => Av,
                    RGBA_PVRTC_4BPPV1_Format: () => Ev,
                    RGBA_S3TC_DXT1_Format: () => zp,
                    RGBA_S3TC_DXT3_Format: () => Bp,
                    RGBA_S3TC_DXT5_Format: () => Fp,
                    RGBDepthPacking: () => pw,
                    RGBFormat: () => S_,
                    RGBIntegerFormat: () => cw,
                    RGB_BPTC_SIGNED_Format: () => Zv,
                    RGB_BPTC_UNSIGNED_Format: () => Qv,
                    RGB_ETC1_Format: () => wv,
                    RGB_ETC2_Format: () => Cv,
                    RGB_PVRTC_2BPPV1_Format: () => Tv,
                    RGB_PVRTC_4BPPV1_Format: () => Mv,
                    RGB_S3TC_DXT1_Format: () => Pp,
                    RGDepthPacking: () => mw,
                    RGFormat: () => Ou,
                    RGIntegerFormat: () => xv,
                    RawShaderMaterial: () => TS,
                    Ray: () => Eh,
                    Raycaster: () => $T,
                    RectAreaLight: () => BT,
                    RedFormat: () => Sv,
                    RedIntegerFormat: () => Op,
                    ReinhardToneMapping: () => l_,
                    RenderTarget: () => R_,
                    RenderTarget3D: () => pR,
                    RepeatWrapping: () => Lp,
                    ReplaceStencilOp: () => Sw,
                    ReverseSubtractEquation: () => lb,
                    RingGeometry: () => cT,
                    SIGNED_R11_EAC_Format: () => Nv,
                    SIGNED_RED_GREEN_RGTC2_Format: () => e0,
                    SIGNED_RED_RGTC1_Format: () => Jv,
                    SIGNED_RG11_EAC_Format: () => Uv,
                    SRGBColorSpace: () => wa,
                    SRGBTransfer: () => Un,
                    Scene: () => Z_,
                    ShaderChunk: () => tn,
                    ShaderLib: () => Xr,
                    ShaderMaterial: () => dr,
                    ShadowMaterial: () => yT,
                    Shape: () => qu,
                    ShapeGeometry: () => uT,
                    ShapePath: () => GR,
                    ShapeUtils: () => Al,
                    ShortType: () => g_,
                    Skeleton: () => EM,
                    SkeletonHelper: () => DR,
                    SkinnedMesh: () => MM,
                    Source: () => bc,
                    Sphere: () => Sa,
                    SphereGeometry: () => MS,
                    Spherical: () => bR,
                    SphericalHarmonics3: () => OS,
                    SplineCurve: () => _S,
                    SpotLight: () => IT,
                    SpotLightHelper: () => RR,
                    Sprite: () => mM,
                    SpriteMaterial: () => Q_,
                    SrcAlphaFactor: () => rv,
                    SrcAlphaSaturateFactor: () => _b,
                    SrcColorFactor: () => db,
                    StaticCopyUsage: () => Bw,
                    StaticDrawUsage: () => Gp,
                    StaticReadUsage: () => Ow,
                    StereoCamera: () => Q3,
                    StreamCopyUsage: () => Vw,
                    StreamDrawUsage: () => Iw,
                    StreamReadUsage: () => zw,
                    StringKeyframeTrack: () => Qu,
                    SubtractEquation: () => ob,
                    SubtractiveBlending: () => s_,
                    TOUCH: () => iw,
                    TangentSpaceNormalMap: () => _c,
                    TetrahedronGeometry: () => fT,
                    Texture: () => oa,
                    TextureLoader: () => H3,
                    TextureUtils: () => ZR,
                    Timer: () => SR,
                    TimestampQuery: () => Hw,
                    TorusGeometry: () => hT,
                    TorusKnotGeometry: () => dT,
                    Triangle: () => wc,
                    TriangleFanDrawMode: () => hw,
                    TriangleStripDrawMode: () => fw,
                    TrianglesDrawMode: () => uw,
                    TubeGeometry: () => pT,
                    UVMapping: () => gv,
                    Uint16BufferAttribute: () => W_,
                    Uint32BufferAttribute: () => X_,
                    Uint8BufferAttribute: () => RC,
                    Uint8ClampedBufferAttribute: () => DC,
                    Uniform: () => mR,
                    UniformsGroup: () => vR,
                    UniformsLib: () => ct,
                    UniformsUtils: () => rM,
                    UnsignedByteType: () => Ka,
                    UnsignedInt101111Type: () => y_,
                    UnsignedInt248Type: () => mh,
                    UnsignedInt5999Type: () => v_,
                    UnsignedIntType: () => fr,
                    UnsignedShort4444Type: () => yv,
                    UnsignedShort5551Type: () => _v,
                    UnsignedShortType: () => ph,
                    VSMShadowMap: () => Lu,
                    Vector2: () => Pe,
                    Vector3: () => Y,
                    Vector4: () => ti,
                    VectorKeyframeTrack: () => vm,
                    VideoFrameTexture: () => $C,
                    VideoTexture: () => kM,
                    WebGL3DRenderTarget: () => gC,
                    WebGLArrayRenderTarget: () => mC,
                    WebGLCoordinateSystem: () => Bs,
                    WebGLCubeRenderTarget: () => j_,
                    WebGLRenderTarget: () => Vs,
                    WebGLRenderer: () => BE,
                    WebGLUtils: () => zE,
                    WebGPUCoordinateSystem: () => gh,
                    WebXRController: () => E0,
                    WireframeGeometry: () => mT,
                    WrapAroundEnding: () => kp,
                    ZeroCurvatureEnding: () => Pu,
                    ZeroFactor: () => fb,
                    ZeroSlopeEnding: () => zu,
                    ZeroStencilOp: () => _w,
                    createCanvasElement: () => Vb,
                    error: () => Et,
                    getConsoleFunction: () => Yw,
                    log: () => Xp,
                    setConsoleFunction: () => qw,
                    warn: () => ot,
                    warnOnce: () => yh
                });
                function uE() {
                    let e = null
                      , t = !1
                      , n = null
                      , a = null;
                    function r(c, f) {
                        n(c, f),
                        a = e.requestAnimationFrame(r)
                    }
                    return {
                        start: function() {
                            t !== !0 && n !== null && (a = e.requestAnimationFrame(r),
                            t = !0)
                        },
                        stop: function() {
                            e.cancelAnimationFrame(a),
                            t = !1
                        },
                        setAnimationLoop: function(c) {
                            n = c
                        },
                        setContext: function(c) {
                            e = c
                        }
                    }
                }
                function KR(e) {
                    const t = new WeakMap;
                    function n(p, m) {
                        const g = p.array
                          , v = p.usage
                          , _ = g.byteLength
                          , x = e.createBuffer();
                        e.bindBuffer(m, x),
                        e.bufferData(m, g, v),
                        p.onUploadCallback();
                        let M;
                        if (g instanceof Float32Array)
                            M = e.FLOAT;
                        else if (typeof Float16Array < "u" && g instanceof Float16Array)
                            M = e.HALF_FLOAT;
                        else if (g instanceof Uint16Array)
                            p.isFloat16BufferAttribute ? M = e.HALF_FLOAT : M = e.UNSIGNED_SHORT;
                        else if (g instanceof Int16Array)
                            M = e.SHORT;
                        else if (g instanceof Uint32Array)
                            M = e.UNSIGNED_INT;
                        else if (g instanceof Int32Array)
                            M = e.INT;
                        else if (g instanceof Int8Array)
                            M = e.BYTE;
                        else if (g instanceof Uint8Array)
                            M = e.UNSIGNED_BYTE;
                        else if (g instanceof Uint8ClampedArray)
                            M = e.UNSIGNED_BYTE;
                        else
                            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + g);
                        return {
                            buffer: x,
                            type: M,
                            bytesPerElement: g.BYTES_PER_ELEMENT,
                            version: p.version,
                            size: _
                        }
                    }
                    function a(p, m, g) {
                        const v = m.array
                          , _ = m.updateRanges;
                        if (e.bindBuffer(g, p),
                        _.length === 0)
                            e.bufferSubData(g, 0, v);
                        else {
                            _.sort( (M, C) => M.start - C.start);
                            let x = 0;
                            for (let M = 1; M < _.length; M++) {
                                const C = _[x]
                                  , R = _[M];
                                R.start <= C.start + C.count + 1 ? C.count = Math.max(C.count, R.start + R.count - C.start) : (++x,
                                _[x] = R)
                            }
                            _.length = x + 1;
                            for (let M = 0, C = _.length; M < C; M++) {
                                const R = _[M];
                                e.bufferSubData(g, R.start * v.BYTES_PER_ELEMENT, v, R.start, R.count)
                            }
                            m.clearUpdateRanges()
                        }
                        m.onUploadCallback()
                    }
                    function r(p) {
                        return p.isInterleavedBufferAttribute && (p = p.data),
                        t.get(p)
                    }
                    function c(p) {
                        p.isInterleavedBufferAttribute && (p = p.data);
                        const m = t.get(p);
                        m && (e.deleteBuffer(m.buffer),
                        t.delete(p))
                    }
                    function f(p, m) {
                        if (p.isInterleavedBufferAttribute && (p = p.data),
                        p.isGLBufferAttribute) {
                            const v = t.get(p);
                            (!v || v.version < p.version) && t.set(p, {
                                buffer: p.buffer,
                                type: p.type,
                                bytesPerElement: p.elementSize,
                                version: p.version
                            });
                            return
                        }
                        const g = t.get(p);
                        if (g === void 0)
                            t.set(p, n(p, m));
                        else if (g.version < p.version) {
                            if (g.size !== p.array.byteLength)
                                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            a(g.buffer, p, m),
                            g.version = p.version
                        }
                    }
                    return {
                        get: r,
                        remove: c,
                        update: f
                    }
                }
                const tn = {
                    alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
                    alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
                    alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
                    alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    alphatest_fragment: `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
                    alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
                    aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
                    aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
                    batching_pars_vertex: `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
                    batching_vertex: `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
                    begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
                    beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
                    bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
                    iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
                    bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
                    clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
                    clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
                    clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
                    clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
                    color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
                    color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
                    color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
                    color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
                    common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
                    cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
                    defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
                    displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
                    displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
                    emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
                    emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
                    envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
                    envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,
                    envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
                    envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
                    envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
                    envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
                    fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
                    fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
                    fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
                    fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
                    gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
                    lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
                    lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
                    lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
                    lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
                    lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
                    lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
                    lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
                    lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
                    lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.metalness = metalnessFactor;
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = vec3( 0.04 );
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
                    lights_physical_pars_fragment: `uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	vec3 diffuseContribution;
	vec3 specularColor;
	vec3 specularColorBlended;
	float roughness;
	float metalness;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
		vec3 iridescenceFresnelDielectric;
		vec3 iridescenceFresnelMetallic;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return v;
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColorBlended;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float rInv = 1.0 / ( roughness + 0.1 );
	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;
	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;
	float DG = exp( a * dotNV + b );
	return saturate( DG );
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;
	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;
	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
 
 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
 
 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );
 
 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );
 
 		irradiance *= sheenEnergyComp;
 
 	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		diffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectDiffuse += diffuse;
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;
 	#endif
	vec3 singleScatteringDielectric = vec3( 0.0 );
	vec3 multiScatteringDielectric = vec3( 0.0 );
	vec3 singleScatteringMetallic = vec3( 0.0 );
	vec3 multiScatteringMetallic = vec3( 0.0 );
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#endif
	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );
	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );
	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;
	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	vec3 indirectSpecular = radiance * singleScattering;
	indirectSpecular += multiScattering * cosineWeightedIrradiance;
	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		indirectSpecular *= sheenEnergyComp;
		indirectDiffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectSpecular += indirectSpecular;
	reflectedLight.indirectDiffuse += indirectDiffuse;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
                    lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );
		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
                    lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
                    lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
                    logdepthbuf_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
                    logdepthbuf_pars_fragment: `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_pars_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
                    logdepthbuf_vertex: `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
                    map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
                    map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
                    map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
                    map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
                    metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
                    metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
                    morphinstance_vertex: `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
                    morphcolor_vertex: `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
                    morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
                    morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
                    normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
                    normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
                    normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
                    normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
                    normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
                    clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
                    clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
                    clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
                    iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
                    opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
                    packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
                    premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
                    project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
                    dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
                    dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
                    roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
                    roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
                    shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#else
			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#endif
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#else
			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#endif
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#elif defined( SHADOWMAP_TYPE_BASIC )
			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#endif
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float interleavedGradientNoise( vec2 position ) {
			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );
		}
		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {
			const float goldenAngle = 2.399963229728653;
			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );
			float theta = float( sampleIndex ) * goldenAngle + phi;
			return vec2( cos( theta ), sin( theta ) ) * r;
		}
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
				float radius = shadowRadius * texelSize.x;
				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
				shadow = (
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )
				) * 0.2;
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#elif defined( SHADOWMAP_TYPE_VSM )
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;
				float mean = distribution.x;
				float variance = distribution.y * distribution.y;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					float hard_shadow = step( mean, shadowCoord.z );
				#else
					float hard_shadow = step( shadowCoord.z, mean );
				#endif
				if ( hard_shadow == 1.0 ) {
					shadow = 1.0;
				} else {
					variance = max( variance, 0.0000001 );
					float d = shadowCoord.z - mean;
					float p_max = variance / ( variance + d * d );
					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );
					shadow = max( hard_shadow, p_max );
				}
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#else
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				float depth = texture2D( shadowMap, shadowCoord.xy ).r;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					shadow = step( depth, shadowCoord.z );
				#else
					shadow = step( shadowCoord.z, depth );
				#endif
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#if defined( SHADOWMAP_TYPE_PCF )
	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float texelSize = shadowRadius / shadowMapSize.x;
			vec3 absDir = abs( bd3D );
			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );
			tangent = normalize( cross( bd3D, tangent ) );
			vec3 bitangent = cross( bd3D, tangent );
			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
			shadow = (
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )
			) * 0.2;
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#elif defined( SHADOWMAP_TYPE_BASIC )
	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float depth = textureCube( shadowMap, bd3D ).r;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadow = step( depth, dp );
			#else
				shadow = step( dp, depth );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#endif
	#endif
#endif`,
                    shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
                    shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
                    shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
                    skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
                    skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
                    skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
                    skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
                    specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
                    specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
                    tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
                    tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
                    transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
                    transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
                    uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
                    uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
                    worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
                    background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                    background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                    cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                    depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
                    distance_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                    distance_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );
}`,
                    equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                    equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                    linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                    meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                    meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                    meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
                    meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                    meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
 
		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;
 
 	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                    points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                    points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                    shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                    shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
                    sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                    sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
                }
                  , ct = {
                    common: {
                        diffuse: {
                            value: new dt(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new en
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new en
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new en
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new en
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        },
                        dfgLUT: {
                            value: null
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new en
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new en
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new en
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new en
                        },
                        normalScale: {
                            value: new Pe(1,1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new en
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new en
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new en
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new en
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new dt(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new dt(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new en
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new en
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new dt(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Pe(.5,.5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new en
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new en
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                }
                  , Xr = {
                    basic: {
                        uniforms: ts([ct.common, ct.specularmap, ct.envmap, ct.aomap, ct.lightmap, ct.fog]),
                        vertexShader: tn.meshbasic_vert,
                        fragmentShader: tn.meshbasic_frag
                    },
                    lambert: {
                        uniforms: ts([ct.common, ct.specularmap, ct.envmap, ct.aomap, ct.lightmap, ct.emissivemap, ct.bumpmap, ct.normalmap, ct.displacementmap, ct.fog, ct.lights, {
                            emissive: {
                                value: new dt(0)
                            }
                        }]),
                        vertexShader: tn.meshlambert_vert,
                        fragmentShader: tn.meshlambert_frag
                    },
                    phong: {
                        uniforms: ts([ct.common, ct.specularmap, ct.envmap, ct.aomap, ct.lightmap, ct.emissivemap, ct.bumpmap, ct.normalmap, ct.displacementmap, ct.fog, ct.lights, {
                            emissive: {
                                value: new dt(0)
                            },
                            specular: {
                                value: new dt(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: tn.meshphong_vert,
                        fragmentShader: tn.meshphong_frag
                    },
                    standard: {
                        uniforms: ts([ct.common, ct.envmap, ct.aomap, ct.lightmap, ct.emissivemap, ct.bumpmap, ct.normalmap, ct.displacementmap, ct.roughnessmap, ct.metalnessmap, ct.fog, ct.lights, {
                            emissive: {
                                value: new dt(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: tn.meshphysical_vert,
                        fragmentShader: tn.meshphysical_frag
                    },
                    toon: {
                        uniforms: ts([ct.common, ct.aomap, ct.lightmap, ct.emissivemap, ct.bumpmap, ct.normalmap, ct.displacementmap, ct.gradientmap, ct.fog, ct.lights, {
                            emissive: {
                                value: new dt(0)
                            }
                        }]),
                        vertexShader: tn.meshtoon_vert,
                        fragmentShader: tn.meshtoon_frag
                    },
                    matcap: {
                        uniforms: ts([ct.common, ct.bumpmap, ct.normalmap, ct.displacementmap, ct.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: tn.meshmatcap_vert,
                        fragmentShader: tn.meshmatcap_frag
                    },
                    points: {
                        uniforms: ts([ct.points, ct.fog]),
                        vertexShader: tn.points_vert,
                        fragmentShader: tn.points_frag
                    },
                    dashed: {
                        uniforms: ts([ct.common, ct.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: tn.linedashed_vert,
                        fragmentShader: tn.linedashed_frag
                    },
                    depth: {
                        uniforms: ts([ct.common, ct.displacementmap]),
                        vertexShader: tn.depth_vert,
                        fragmentShader: tn.depth_frag
                    },
                    normal: {
                        uniforms: ts([ct.common, ct.bumpmap, ct.normalmap, ct.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: tn.meshnormal_vert,
                        fragmentShader: tn.meshnormal_frag
                    },
                    sprite: {
                        uniforms: ts([ct.sprite, ct.fog]),
                        vertexShader: tn.sprite_vert,
                        fragmentShader: tn.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new en
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: tn.background_vert,
                        fragmentShader: tn.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new en
                            }
                        },
                        vertexShader: tn.backgroundCube_vert,
                        fragmentShader: tn.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: tn.cube_vert,
                        fragmentShader: tn.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: tn.equirect_vert,
                        fragmentShader: tn.equirect_frag
                    },
                    distance: {
                        uniforms: ts([ct.common, ct.displacementmap, {
                            referencePosition: {
                                value: new Y
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: tn.distance_vert,
                        fragmentShader: tn.distance_frag
                    },
                    shadow: {
                        uniforms: ts([ct.lights, ct.fog, {
                            color: {
                                value: new dt(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: tn.shadow_vert,
                        fragmentShader: tn.shadow_frag
                    }
                };
                Xr.physical = {
                    uniforms: ts([Xr.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatMapTransform: {
                            value: new en
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        clearcoatNormalMapTransform: {
                            value: new en
                        },
                        clearcoatNormalScale: {
                            value: new Pe(1,1)
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatRoughnessMapTransform: {
                            value: new en
                        },
                        dispersion: {
                            value: 0
                        },
                        iridescence: {
                            value: 0
                        },
                        iridescenceMap: {
                            value: null
                        },
                        iridescenceMapTransform: {
                            value: new en
                        },
                        iridescenceIOR: {
                            value: 1.3
                        },
                        iridescenceThicknessMinimum: {
                            value: 100
                        },
                        iridescenceThicknessMaximum: {
                            value: 400
                        },
                        iridescenceThicknessMap: {
                            value: null
                        },
                        iridescenceThicknessMapTransform: {
                            value: new en
                        },
                        sheen: {
                            value: 0
                        },
                        sheenColor: {
                            value: new dt(0)
                        },
                        sheenColorMap: {
                            value: null
                        },
                        sheenColorMapTransform: {
                            value: new en
                        },
                        sheenRoughness: {
                            value: 1
                        },
                        sheenRoughnessMap: {
                            value: null
                        },
                        sheenRoughnessMapTransform: {
                            value: new en
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionMapTransform: {
                            value: new en
                        },
                        transmissionSamplerSize: {
                            value: new Pe
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        thicknessMapTransform: {
                            value: new en
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new dt(0)
                        },
                        specularColor: {
                            value: new dt(1,1,1)
                        },
                        specularColorMap: {
                            value: null
                        },
                        specularColorMapTransform: {
                            value: new en
                        },
                        specularIntensity: {
                            value: 1
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularIntensityMapTransform: {
                            value: new en
                        },
                        anisotropyVector: {
                            value: new Pe
                        },
                        anisotropyMap: {
                            value: null
                        },
                        anisotropyMapTransform: {
                            value: new en
                        }
                    }]),
                    vertexShader: tn.meshphysical_vert,
                    fragmentShader: tn.meshphysical_frag
                };
                const ry = {
                    r: 0,
                    b: 0,
                    g: 0
                }
                  , af = new es
                  , JR = new Wt;
                function $R(e, t, n, a, r, c, f) {
                    const p = new dt(0);
                    let m = c === !0 ? 0 : 1, g, v, _ = null, x = 0, M = null;
                    function C(I) {
                        let L = I.isScene === !0 ? I.background : null;
                        return L && L.isTexture && (L = (I.backgroundBlurriness > 0 ? n : t).get(L)),
                        L
                    }
                    function R(I) {
                        let L = !1;
                        const k = C(I);
                        k === null ? E(p, m) : k && k.isColor && (E(k, 1),
                        L = !0);
                        const B = e.xr.getEnvironmentBlendMode();
                        B === "additive" ? a.buffers.color.setClear(0, 0, 0, 1, f) : B === "alpha-blend" && a.buffers.color.setClear(0, 0, 0, 0, f),
                        (e.autoClear || L) && (a.buffers.depth.setTest(!0),
                        a.buffers.depth.setMask(!0),
                        a.buffers.color.setMask(!0),
                        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                    }
                    function A(I, L) {
                        const k = C(L);
                        k && (k.isCubeTexture || k.mapping === hh) ? (v === void 0 && (v = new Hi(new Jp(1,1,1),new dr({
                            name: "BackgroundCubeMaterial",
                            uniforms: Uh(Xr.backgroundCube.uniforms),
                            vertexShader: Xr.backgroundCube.vertexShader,
                            fragmentShader: Xr.backgroundCube.fragmentShader,
                            side: Qa,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        v.geometry.deleteAttribute("normal"),
                        v.geometry.deleteAttribute("uv"),
                        v.onBeforeRender = function(B, X, G) {
                            this.matrixWorld.copyPosition(G.matrixWorld)
                        }
                        ,
                        Object.defineProperty(v.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        r.update(v)),
                        af.copy(L.backgroundRotation),
                        af.x *= -1,
                        af.y *= -1,
                        af.z *= -1,
                        k.isCubeTexture && k.isRenderTargetTexture === !1 && (af.y *= -1,
                        af.z *= -1),
                        v.material.uniforms.envMap.value = k,
                        v.material.uniforms.flipEnvMap.value = k.isCubeTexture && k.isRenderTargetTexture === !1 ? -1 : 1,
                        v.material.uniforms.backgroundBlurriness.value = L.backgroundBlurriness,
                        v.material.uniforms.backgroundIntensity.value = L.backgroundIntensity,
                        v.material.uniforms.backgroundRotation.value.setFromMatrix4(JR.makeRotationFromEuler(af)),
                        v.material.toneMapped = Sn.getTransfer(k.colorSpace) !== Un,
                        (_ !== k || x !== k.version || M !== e.toneMapping) && (v.material.needsUpdate = !0,
                        _ = k,
                        x = k.version,
                        M = e.toneMapping),
                        v.layers.enableAll(),
                        I.unshift(v, v.geometry, v.material, 0, 0, null)) : k && k.isTexture && (g === void 0 && (g = new Hi(new J0(2,2),new dr({
                            name: "BackgroundMaterial",
                            uniforms: Uh(Xr.background.uniforms),
                            vertexShader: Xr.background.vertexShader,
                            fragmentShader: Xr.background.fragmentShader,
                            side: vl,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        g.geometry.deleteAttribute("normal"),
                        Object.defineProperty(g.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        r.update(g)),
                        g.material.uniforms.t2D.value = k,
                        g.material.uniforms.backgroundIntensity.value = L.backgroundIntensity,
                        g.material.toneMapped = Sn.getTransfer(k.colorSpace) !== Un,
                        k.matrixAutoUpdate === !0 && k.updateMatrix(),
                        g.material.uniforms.uvTransform.value.copy(k.matrix),
                        (_ !== k || x !== k.version || M !== e.toneMapping) && (g.material.needsUpdate = !0,
                        _ = k,
                        x = k.version,
                        M = e.toneMapping),
                        g.layers.enableAll(),
                        I.unshift(g, g.geometry, g.material, 0, 0, null))
                    }
                    function E(I, L) {
                        I.getRGB(ry, sM(e)),
                        a.buffers.color.setClear(ry.r, ry.g, ry.b, L, f)
                    }
                    function N() {
                        v !== void 0 && (v.geometry.dispose(),
                        v.material.dispose(),
                        v = void 0),
                        g !== void 0 && (g.geometry.dispose(),
                        g.material.dispose(),
                        g = void 0)
                    }
                    return {
                        getClearColor: function() {
                            return p
                        },
                        setClearColor: function(I, L=1) {
                            p.set(I),
                            m = L,
                            E(p, m)
                        },
                        getClearAlpha: function() {
                            return m
                        },
                        setClearAlpha: function(I) {
                            m = I,
                            E(p, m)
                        },
                        render: R,
                        addToRenderList: A,
                        dispose: N
                    }
                }
                function eD(e, t) {
                    const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                      , a = {}
                      , r = x(null);
                    let c = r
                      , f = !1;
                    function p(U, W, K, q, te) {
                        let ce = !1;
                        const J = _(q, K, W);
                        c !== J && (c = J,
                        g(c.object)),
                        ce = M(U, q, K, te),
                        ce && C(U, q, K, te),
                        te !== null && t.update(te, e.ELEMENT_ARRAY_BUFFER),
                        (ce || f) && (f = !1,
                        L(U, W, K, q),
                        te !== null && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(te).buffer))
                    }
                    function m() {
                        return e.createVertexArray()
                    }
                    function g(U) {
                        return e.bindVertexArray(U)
                    }
                    function v(U) {
                        return e.deleteVertexArray(U)
                    }
                    function _(U, W, K) {
                        const q = K.wireframe === !0;
                        let te = a[U.id];
                        te === void 0 && (te = {},
                        a[U.id] = te);
                        let ce = te[W.id];
                        ce === void 0 && (ce = {},
                        te[W.id] = ce);
                        let J = ce[q];
                        return J === void 0 && (J = x(m()),
                        ce[q] = J),
                        J
                    }
                    function x(U) {
                        const W = []
                          , K = []
                          , q = [];
                        for (let te = 0; te < n; te++)
                            W[te] = 0,
                            K[te] = 0,
                            q[te] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: W,
                            enabledAttributes: K,
                            attributeDivisors: q,
                            object: U,
                            attributes: {},
                            index: null
                        }
                    }
                    function M(U, W, K, q) {
                        const te = c.attributes
                          , ce = W.attributes;
                        let J = 0;
                        const Q = K.getAttributes();
                        for (const se in Q)
                            if (Q[se].location >= 0) {
                                const Te = te[se];
                                let Ee = ce[se];
                                if (Ee === void 0 && (se === "instanceMatrix" && U.instanceMatrix && (Ee = U.instanceMatrix),
                                se === "instanceColor" && U.instanceColor && (Ee = U.instanceColor)),
                                Te === void 0 || Te.attribute !== Ee || Ee && Te.data !== Ee.data)
                                    return !0;
                                J++
                            }
                        return c.attributesNum !== J || c.index !== q
                    }
                    function C(U, W, K, q) {
                        const te = {}
                          , ce = W.attributes;
                        let J = 0;
                        const Q = K.getAttributes();
                        for (const se in Q)
                            if (Q[se].location >= 0) {
                                let Te = ce[se];
                                Te === void 0 && (se === "instanceMatrix" && U.instanceMatrix && (Te = U.instanceMatrix),
                                se === "instanceColor" && U.instanceColor && (Te = U.instanceColor));
                                const Ee = {};
                                Ee.attribute = Te,
                                Te && Te.data && (Ee.data = Te.data),
                                te[se] = Ee,
                                J++
                            }
                        c.attributes = te,
                        c.attributesNum = J,
                        c.index = q
                    }
                    function R() {
                        const U = c.newAttributes;
                        for (let W = 0, K = U.length; W < K; W++)
                            U[W] = 0
                    }
                    function A(U) {
                        E(U, 0)
                    }
                    function E(U, W) {
                        const K = c.newAttributes
                          , q = c.enabledAttributes
                          , te = c.attributeDivisors;
                        K[U] = 1,
                        q[U] === 0 && (e.enableVertexAttribArray(U),
                        q[U] = 1),
                        te[U] !== W && (e.vertexAttribDivisor(U, W),
                        te[U] = W)
                    }
                    function N() {
                        const U = c.newAttributes
                          , W = c.enabledAttributes;
                        for (let K = 0, q = W.length; K < q; K++)
                            W[K] !== U[K] && (e.disableVertexAttribArray(K),
                            W[K] = 0)
                    }
                    function I(U, W, K, q, te, ce, J) {
                        J === !0 ? e.vertexAttribIPointer(U, W, K, te, ce) : e.vertexAttribPointer(U, W, K, q, te, ce)
                    }
                    function L(U, W, K, q) {
                        R();
                        const te = q.attributes
                          , ce = K.getAttributes()
                          , J = W.defaultAttributeValues;
                        for (const Q in ce) {
                            const se = ce[Q];
                            if (se.location >= 0) {
                                let Te = te[Q];
                                if (Te === void 0 && (Q === "instanceMatrix" && U.instanceMatrix && (Te = U.instanceMatrix),
                                Q === "instanceColor" && U.instanceColor && (Te = U.instanceColor)),
                                Te !== void 0) {
                                    const Ee = Te.normalized
                                      , Be = Te.itemSize
                                      , j = t.get(Te);
                                    if (j === void 0)
                                        continue;
                                    const ve = j.buffer
                                      , Re = j.type
                                      , le = j.bytesPerElement
                                      , Ae = Re === e.INT || Re === e.UNSIGNED_INT || Te.gpuType === vv;
                                    if (Te.isInterleavedBufferAttribute) {
                                        const Ne = Te.data
                                          , ke = Ne.stride
                                          , at = Te.offset;
                                        if (Ne.isInstancedInterleavedBuffer) {
                                            for (let Je = 0; Je < se.locationSize; Je++)
                                                E(se.location + Je, Ne.meshPerAttribute);
                                            U.isInstancedMesh !== !0 && q._maxInstanceCount === void 0 && (q._maxInstanceCount = Ne.meshPerAttribute * Ne.count)
                                        } else
                                            for (let Je = 0; Je < se.locationSize; Je++)
                                                A(se.location + Je);
                                        e.bindBuffer(e.ARRAY_BUFFER, ve);
                                        for (let Je = 0; Je < se.locationSize; Je++)
                                            I(se.location + Je, Be / se.locationSize, Re, Ee, ke * le, (at + Be / se.locationSize * Je) * le, Ae)
                                    } else {
                                        if (Te.isInstancedBufferAttribute) {
                                            for (let Ne = 0; Ne < se.locationSize; Ne++)
                                                E(se.location + Ne, Te.meshPerAttribute);
                                            U.isInstancedMesh !== !0 && q._maxInstanceCount === void 0 && (q._maxInstanceCount = Te.meshPerAttribute * Te.count)
                                        } else
                                            for (let Ne = 0; Ne < se.locationSize; Ne++)
                                                A(se.location + Ne);
                                        e.bindBuffer(e.ARRAY_BUFFER, ve);
                                        for (let Ne = 0; Ne < se.locationSize; Ne++)
                                            I(se.location + Ne, Be / se.locationSize, Re, Ee, Be * le, Be / se.locationSize * Ne * le, Ae)
                                    }
                                } else if (J !== void 0) {
                                    const Ee = J[Q];
                                    if (Ee !== void 0)
                                        switch (Ee.length) {
                                        case 2:
                                            e.vertexAttrib2fv(se.location, Ee);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(se.location, Ee);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(se.location, Ee);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(se.location, Ee)
                                        }
                                }
                            }
                        }
                        N()
                    }
                    function k() {
                        G();
                        for (const U in a) {
                            const W = a[U];
                            for (const K in W) {
                                const q = W[K];
                                for (const te in q)
                                    v(q[te].object),
                                    delete q[te];
                                delete W[K]
                            }
                            delete a[U]
                        }
                    }
                    function B(U) {
                        if (a[U.id] === void 0)
                            return;
                        const W = a[U.id];
                        for (const K in W) {
                            const q = W[K];
                            for (const te in q)
                                v(q[te].object),
                                delete q[te];
                            delete W[K]
                        }
                        delete a[U.id]
                    }
                    function X(U) {
                        for (const W in a) {
                            const K = a[W];
                            if (K[U.id] === void 0)
                                continue;
                            const q = K[U.id];
                            for (const te in q)
                                v(q[te].object),
                                delete q[te];
                            delete K[U.id]
                        }
                    }
                    function G() {
                        P(),
                        f = !0,
                        c !== r && (c = r,
                        g(c.object))
                    }
                    function P() {
                        r.geometry = null,
                        r.program = null,
                        r.wireframe = !1
                    }
                    return {
                        setup: p,
                        reset: G,
                        resetDefaultState: P,
                        dispose: k,
                        releaseStatesOfGeometry: B,
                        releaseStatesOfProgram: X,
                        initAttributes: R,
                        enableAttribute: A,
                        disableUnusedAttributes: N
                    }
                }
                function tD(e, t, n) {
                    let a;
                    function r(g) {
                        a = g
                    }
                    function c(g, v) {
                        e.drawArrays(a, g, v),
                        n.update(v, a, 1)
                    }
                    function f(g, v, _) {
                        _ !== 0 && (e.drawArraysInstanced(a, g, v, _),
                        n.update(v, a, _))
                    }
                    function p(g, v, _) {
                        if (_ === 0)
                            return;
                        t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(a, g, 0, v, 0, _);
                        let x = 0;
                        for (let M = 0; M < _; M++)
                            x += v[M];
                        n.update(x, a, 1)
                    }
                    function m(g, v, _, x) {
                        if (_ === 0)
                            return;
                        const M = t.get("WEBGL_multi_draw");
                        if (M === null)
                            for (let C = 0; C < g.length; C++)
                                f(g[C], v[C], x[C]);
                        else {
                            M.multiDrawArraysInstancedWEBGL(a, g, 0, v, 0, x, 0, _);
                            let C = 0;
                            for (let R = 0; R < _; R++)
                                C += v[R] * x[R];
                            n.update(C, a, 1)
                        }
                    }
                    this.setMode = r,
                    this.render = c,
                    this.renderInstances = f,
                    this.renderMultiDraw = p,
                    this.renderMultiDrawInstances = m
                }
                function nD(e, t, n, a) {
                    let r;
                    function c() {
                        if (r !== void 0)
                            return r;
                        if (t.has("EXT_texture_filter_anisotropic") === !0) {
                            const X = t.get("EXT_texture_filter_anisotropic");
                            r = e.getParameter(X.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else
                            r = 0;
                        return r
                    }
                    function f(X) {
                        return !(X !== Aa && a.convert(X) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT))
                    }
                    function p(X) {
                        const G = X === No && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                        return !(X !== Ka && a.convert(X) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && X !== Ja && !G)
                    }
                    function m(X) {
                        if (X === "highp") {
                            if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                                return "highp";
                            X = "mediump"
                        }
                        return X === "mediump" && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                    }
                    let g = n.precision !== void 0 ? n.precision : "highp";
                    const v = m(g);
                    v !== g && (ot("WebGLRenderer:", g, "not supported, using", v, "instead."),
                    g = v);
                    const _ = n.logarithmicDepthBuffer === !0
                      , x = n.reversedDepthBuffer === !0 && t.has("EXT_clip_control")
                      , M = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
                      , C = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                      , R = e.getParameter(e.MAX_TEXTURE_SIZE)
                      , A = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
                      , E = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                      , N = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
                      , I = e.getParameter(e.MAX_VARYING_VECTORS)
                      , L = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
                      , k = e.getParameter(e.MAX_SAMPLES)
                      , B = e.getParameter(e.SAMPLES);
                    return {
                        isWebGL2: !0,
                        getMaxAnisotropy: c,
                        getMaxPrecision: m,
                        textureFormatReadable: f,
                        textureTypeReadable: p,
                        precision: g,
                        logarithmicDepthBuffer: _,
                        reversedDepthBuffer: x,
                        maxTextures: M,
                        maxVertexTextures: C,
                        maxTextureSize: R,
                        maxCubemapSize: A,
                        maxAttributes: E,
                        maxVertexUniforms: N,
                        maxVaryings: I,
                        maxFragmentUniforms: L,
                        maxSamples: k,
                        samples: B
                    }
                }
                function iD(e) {
                    const t = this;
                    let n = null
                      , a = 0
                      , r = !1
                      , c = !1;
                    const f = new Nc
                      , p = new en
                      , m = {
                        value: null,
                        needsUpdate: !1
                    };
                    this.uniform = m,
                    this.numPlanes = 0,
                    this.numIntersection = 0,
                    this.init = function(_, x) {
                        const M = _.length !== 0 || x || a !== 0 || r;
                        return r = x,
                        a = _.length,
                        M
                    }
                    ,
                    this.beginShadows = function() {
                        c = !0,
                        v(null)
                    }
                    ,
                    this.endShadows = function() {
                        c = !1
                    }
                    ,
                    this.setGlobalState = function(_, x) {
                        n = v(_, x, 0)
                    }
                    ,
                    this.setState = function(_, x, M) {
                        const C = _.clippingPlanes
                          , R = _.clipIntersection
                          , A = _.clipShadows
                          , E = e.get(_);
                        if (!r || C === null || C.length === 0 || c && !A)
                            c ? v(null) : g();
                        else {
                            const N = c ? 0 : a
                              , I = N * 4;
                            let L = E.clippingState || null;
                            m.value = L,
                            L = v(C, x, I, M);
                            for (let k = 0; k !== I; ++k)
                                L[k] = n[k];
                            E.clippingState = L,
                            this.numIntersection = R ? this.numPlanes : 0,
                            this.numPlanes += N
                        }
                    }
                    ;
                    function g() {
                        m.value !== n && (m.value = n,
                        m.needsUpdate = a > 0),
                        t.numPlanes = a,
                        t.numIntersection = 0
                    }
                    function v(_, x, M, C) {
                        const R = _ !== null ? _.length : 0;
                        let A = null;
                        if (R !== 0) {
                            if (A = m.value,
                            C !== !0 || A === null) {
                                const E = M + R * 4
                                  , N = x.matrixWorldInverse;
                                p.getNormalMatrix(N),
                                (A === null || A.length < E) && (A = new Float32Array(E));
                                for (let I = 0, L = M; I !== R; ++I,
                                L += 4)
                                    f.copy(_[I]).applyMatrix4(N, p),
                                    f.normal.toArray(A, L),
                                    A[L + 3] = f.constant
                            }
                            m.value = A,
                            m.needsUpdate = !0
                        }
                        return t.numPlanes = R,
                        t.numIntersection = 0,
                        A
                    }
                }
                function aD(e) {
                    let t = new WeakMap;
                    function n(f, p) {
                        return p === Dp ? f.mapping = Ro : p === Np && (f.mapping = vc),
                        f
                    }
                    function a(f) {
                        if (f && f.isTexture) {
                            const p = f.mapping;
                            if (p === Dp || p === Np)
                                if (t.has(f)) {
                                    const m = t.get(f).texture;
                                    return n(m, f.mapping)
                                } else {
                                    const m = f.image;
                                    if (m && m.height > 0) {
                                        const g = new j_(m.height);
                                        return g.fromEquirectangularTexture(e, f),
                                        t.set(f, g),
                                        f.addEventListener("dispose", r),
                                        n(g.texture, f.mapping)
                                    } else
                                        return null
                                }
                        }
                        return f
                    }
                    function r(f) {
                        const p = f.target;
                        p.removeEventListener("dispose", r);
                        const m = t.get(p);
                        m !== void 0 && (t.delete(p),
                        m.dispose())
                    }
                    function c() {
                        t = new WeakMap
                    }
                    return {
                        get: a,
                        dispose: c
                    }
                }
                const Oc = 4
                  , fE = [.125, .215, .35, .446, .526, .582]
                  , sf = 20
                  , sD = 256
                  , Sm = new jh
                  , hE = new dt;
                let jS = null
                  , ZS = 0
                  , QS = 0
                  , KS = !1;
                const rD = new Y;
                var JS = class {
                    constructor(e) {
                        this._renderer = e,
                        this._pingPongRenderTarget = null,
                        this._lodMax = 0,
                        this._cubeSize = 0,
                        this._sizeLods = [],
                        this._sigmas = [],
                        this._lodMeshes = [],
                        this._backgroundBox = null,
                        this._cubemapMaterial = null,
                        this._equirectMaterial = null,
                        this._blurMaterial = null,
                        this._ggxMaterial = null
                    }
                    fromScene(e, t=0, n=.1, a=100, r={}) {
                        const {size: c=256, position: f=rD} = r;
                        jS = this._renderer.getRenderTarget(),
                        ZS = this._renderer.getActiveCubeFace(),
                        QS = this._renderer.getActiveMipmapLevel(),
                        KS = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1,
                        this._setSize(c);
                        const p = this._allocateTargets();
                        return p.depthBuffer = !0,
                        this._sceneToCubeUV(e, n, a, p, f),
                        t > 0 && this._blur(p, 0, 0, t),
                        this._applyPMREM(p),
                        this._cleanup(p),
                        p
                    }
                    fromEquirectangular(e, t=null) {
                        return this._fromTexture(e, t)
                    }
                    fromCubemap(e, t=null) {
                        return this._fromTexture(e, t)
                    }
                    compileCubemapShader() {
                        this._cubemapMaterial === null && (this._cubemapMaterial = mE(),
                        this._compileMaterial(this._cubemapMaterial))
                    }
                    compileEquirectangularShader() {
                        this._equirectMaterial === null && (this._equirectMaterial = pE(),
                        this._compileMaterial(this._equirectMaterial))
                    }
                    dispose() {
                        this._dispose(),
                        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                        this._equirectMaterial !== null && this._equirectMaterial.dispose(),
                        this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(),
                        this._backgroundBox.material.dispose())
                    }
                    _setSize(e) {
                        this._lodMax = Math.floor(Math.log2(e)),
                        this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        this._blurMaterial !== null && this._blurMaterial.dispose(),
                        this._ggxMaterial !== null && this._ggxMaterial.dispose(),
                        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                        for (let e = 0; e < this._lodMeshes.length; e++)
                            this._lodMeshes[e].geometry.dispose()
                    }
                    _cleanup(e) {
                        this._renderer.setRenderTarget(jS, ZS, QS),
                        this._renderer.xr.enabled = KS,
                        e.scissorTest = !1,
                        Kh(e, 0, 0, e.width, e.height)
                    }
                    _fromTexture(e, t) {
                        e.mapping === Ro || e.mapping === vc ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                        jS = this._renderer.getRenderTarget(),
                        ZS = this._renderer.getActiveCubeFace(),
                        QS = this._renderer.getActiveMipmapLevel(),
                        KS = this._renderer.xr.enabled,
                        this._renderer.xr.enabled = !1;
                        const n = t || this._allocateTargets();
                        return this._textureToCubeUV(e, n),
                        this._applyPMREM(n),
                        this._cleanup(n),
                        n
                    }
                    _allocateTargets() {
                        const e = 3 * Math.max(this._cubeSize, 112)
                          , t = 4 * this._cubeSize
                          , n = {
                            magFilter: ei,
                            minFilter: ei,
                            generateMipmaps: !1,
                            type: No,
                            format: Aa,
                            colorSpace: Sc,
                            depthBuffer: !1
                        }
                          , a = dE(e, t, n);
                        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                            this._pingPongRenderTarget !== null && this._dispose(),
                            this._pingPongRenderTarget = dE(e, t, n);
                            const {_lodMax: r} = this;
                            ({lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas} = oD(r)),
                            this._blurMaterial = cD(r, e, t),
                            this._ggxMaterial = lD(r, e, t)
                        }
                        return a
                    }
                    _compileMaterial(e) {
                        const t = new Hi(new Xt,e);
                        this._renderer.compile(t, Sm)
                    }
                    _sceneToCubeUV(e, t, n, a, r) {
                        const c = new ca(90,1,t,n)
                          , f = [1, -1, 1, 1, 1, 1]
                          , p = [1, 1, 1, -1, -1, -1]
                          , m = this._renderer
                          , g = m.autoClear
                          , v = m.toneMapping;
                        m.getClearColor(hE),
                        m.toneMapping = ur,
                        m.autoClear = !1,
                        m.state.buffers.depth.getReversed() && (m.setRenderTarget(a),
                        m.clearDepth(),
                        m.setRenderTarget(null)),
                        this._backgroundBox === null && (this._backgroundBox = new Hi(new Jp,new Rc({
                            name: "PMREM.Background",
                            side: Qa,
                            depthWrite: !1,
                            depthTest: !1
                        })));
                        const _ = this._backgroundBox
                          , x = _.material;
                        let M = !1;
                        const C = e.background;
                        C ? C.isColor && (x.color.copy(C),
                        e.background = null,
                        M = !0) : (x.color.copy(hE),
                        M = !0);
                        for (let R = 0; R < 6; R++) {
                            const A = R % 3;
                            A === 0 ? (c.up.set(0, f[R], 0),
                            c.position.set(r.x, r.y, r.z),
                            c.lookAt(r.x + p[R], r.y, r.z)) : A === 1 ? (c.up.set(0, 0, f[R]),
                            c.position.set(r.x, r.y, r.z),
                            c.lookAt(r.x, r.y + p[R], r.z)) : (c.up.set(0, f[R], 0),
                            c.position.set(r.x, r.y, r.z),
                            c.lookAt(r.x, r.y, r.z + p[R]));
                            const E = this._cubeSize;
                            Kh(a, A * E, R > 2 ? E : 0, E, E),
                            m.setRenderTarget(a),
                            M && m.render(_, c),
                            m.render(e, c)
                        }
                        m.toneMapping = v,
                        m.autoClear = g,
                        e.background = C
                    }
                    _textureToCubeUV(e, t) {
                        const n = this._renderer
                          , a = e.mapping === Ro || e.mapping === vc;
                        a ? (this._cubemapMaterial === null && (this._cubemapMaterial = mE()),
                        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = pE());
                        const r = a ? this._cubemapMaterial : this._equirectMaterial
                          , c = this._lodMeshes[0];
                        c.material = r;
                        const f = r.uniforms;
                        f.envMap.value = e;
                        const p = this._cubeSize;
                        Kh(t, 0, 0, 3 * p, 2 * p),
                        n.setRenderTarget(t),
                        n.render(c, Sm)
                    }
                    _applyPMREM(e) {
                        const t = this._renderer
                          , n = t.autoClear;
                        t.autoClear = !1;
                        const a = this._lodMeshes.length;
                        for (let r = 1; r < a; r++)
                            this._applyGGXFilter(e, r - 1, r);
                        t.autoClear = n
                    }
                    _applyGGXFilter(e, t, n) {
                        const a = this._renderer
                          , r = this._pingPongRenderTarget
                          , c = this._ggxMaterial
                          , f = this._lodMeshes[n];
                        f.material = c;
                        const p = c.uniforms
                          , m = n / (this._lodMeshes.length - 1)
                          , g = t / (this._lodMeshes.length - 1)
                          , v = Math.sqrt(m * m - g * g) * (0 + m * 1.25)
                          , {_lodMax: _} = this
                          , x = this._sizeLods[n]
                          , M = 3 * x * (n > _ - Oc ? n - _ + Oc : 0)
                          , C = 4 * (this._cubeSize - x);
                        p.envMap.value = e.texture,
                        p.roughness.value = v,
                        p.mipInt.value = _ - t,
                        Kh(r, M, C, 3 * x, 2 * x),
                        a.setRenderTarget(r),
                        a.render(f, Sm),
                        p.envMap.value = r.texture,
                        p.roughness.value = 0,
                        p.mipInt.value = _ - n,
                        Kh(e, M, C, 3 * x, 2 * x),
                        a.setRenderTarget(e),
                        a.render(f, Sm)
                    }
                    _blur(e, t, n, a, r) {
                        const c = this._pingPongRenderTarget;
                        this._halfBlur(e, c, t, n, a, "latitudinal", r),
                        this._halfBlur(c, e, n, n, a, "longitudinal", r)
                    }
                    _halfBlur(e, t, n, a, r, c, f) {
                        const p = this._renderer
                          , m = this._blurMaterial;
                        c !== "latitudinal" && c !== "longitudinal" && Et("blur direction must be either latitudinal or longitudinal!");
                        const g = 3
                          , v = this._lodMeshes[a];
                        v.material = m;
                        const _ = m.uniforms
                          , x = this._sizeLods[n] - 1
                          , M = isFinite(r) ? Math.PI / (2 * x) : 2 * Math.PI / (2 * sf - 1)
                          , C = r / M
                          , R = isFinite(r) ? 1 + Math.floor(g * C) : sf;
                        R > sf && ot(`sigmaRadians, ${r}, is too large and will clip, as it requested ${R} samples when the maximum is set to ${sf}`);
                        const A = [];
                        let E = 0;
                        for (let L = 0; L < sf; ++L) {
                            const k = L / C
                              , B = Math.exp(-k * k / 2);
                            A.push(B),
                            L === 0 ? E += B : L < R && (E += 2 * B)
                        }
                        for (let L = 0; L < A.length; L++)
                            A[L] = A[L] / E;
                        _.envMap.value = e.texture,
                        _.samples.value = R,
                        _.weights.value = A,
                        _.latitudinal.value = c === "latitudinal",
                        f && (_.poleAxis.value = f);
                        const {_lodMax: N} = this;
                        _.dTheta.value = M,
                        _.mipInt.value = N - n;
                        const I = this._sizeLods[a];
                        Kh(t, 3 * I * (a > N - Oc ? a - N + Oc : 0), 4 * (this._cubeSize - I), 3 * I, 2 * I),
                        p.setRenderTarget(t),
                        p.render(v, Sm)
                    }
                }
                ;
                function oD(e) {
                    const t = []
                      , n = []
                      , a = [];
                    let r = e;
                    const c = e - Oc + 1 + fE.length;
                    for (let f = 0; f < c; f++) {
                        const p = Math.pow(2, r);
                        t.push(p);
                        let m = 1 / p;
                        f > e - Oc ? m = fE[f - e + Oc - 1] : f === 0 && (m = 0),
                        n.push(m);
                        const g = 1 / (p - 2)
                          , v = -g
                          , _ = 1 + g
                          , x = [v, v, _, v, _, _, v, v, _, _, v, _]
                          , M = 6
                          , C = 6
                          , R = 3
                          , A = 2
                          , E = 1
                          , N = new Float32Array(R * C * M)
                          , I = new Float32Array(A * C * M)
                          , L = new Float32Array(E * C * M);
                        for (let B = 0; B < M; B++) {
                            const X = B % 3 * 2 / 3 - 1
                              , G = B > 2 ? 0 : -1
                              , P = [X, G, 0, X + 2 / 3, G, 0, X + 2 / 3, G + 1, 0, X, G, 0, X + 2 / 3, G + 1, 0, X, G + 1, 0];
                            N.set(P, R * C * B),
                            I.set(x, A * C * B);
                            const U = [B, B, B, B, B, B];
                            L.set(U, E * C * B)
                        }
                        const k = new Xt;
                        k.setAttribute("position", new Vn(N,R)),
                        k.setAttribute("uv", new Vn(I,A)),
                        k.setAttribute("faceIndex", new Vn(L,E)),
                        a.push(new Hi(k,null)),
                        r > Oc && r--
                    }
                    return {
                        lodMeshes: a,
                        sizeLods: t,
                        sigmas: n
                    }
                }
                function dE(e, t, n) {
                    const a = new Vs(e,t,n);
                    return a.texture.mapping = hh,
                    a.texture.name = "PMREM.cubeUv",
                    a.scissorTest = !0,
                    a
                }
                function Kh(e, t, n, a, r) {
                    e.viewport.set(t, n, a, r),
                    e.scissor.set(t, n, a, r)
                }
                function lD(e, t, n) {
                    return new dr({
                        name: "PMREMGGXConvolution",
                        defines: {
                            GGX_SAMPLES: sD,
                            CUBEUV_TEXEL_WIDTH: 1 / t,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${e}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            roughness: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            }
                        },
                        vertexShader: oy(),
                        fragmentShader: `

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,
                        blending: Co,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function cD(e, t, n) {
                    const a = new Float32Array(sf)
                      , r = new Y(0,1,0);
                    return new dr({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: sf,
                            CUBEUV_TEXEL_WIDTH: 1 / t,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: `${e}.0`
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: a
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: r
                            }
                        },
                        vertexShader: oy(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                        blending: Co,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function pE() {
                    return new dr({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            }
                        },
                        vertexShader: oy(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                        blending: Co,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function mE() {
                    return new dr({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            }
                        },
                        vertexShader: oy(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                        blending: Co,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function oy() {
                    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                }
                function uD(e) {
                    let t = new WeakMap
                      , n = null;
                    function a(p) {
                        if (p && p.isTexture) {
                            const m = p.mapping
                              , g = m === Dp || m === Np
                              , v = m === Ro || m === vc;
                            if (g || v) {
                                let _ = t.get(p);
                                const x = _ !== void 0 ? _.texture.pmremVersion : 0;
                                if (p.isRenderTargetTexture && p.pmremVersion !== x)
                                    return n === null && (n = new JS(e)),
                                    _ = g ? n.fromEquirectangular(p, _) : n.fromCubemap(p, _),
                                    _.texture.pmremVersion = p.pmremVersion,
                                    t.set(p, _),
                                    _.texture;
                                if (_ !== void 0)
                                    return _.texture;
                                {
                                    const M = p.image;
                                    return g && M && M.height > 0 || v && M && r(M) ? (n === null && (n = new JS(e)),
                                    _ = g ? n.fromEquirectangular(p) : n.fromCubemap(p),
                                    _.texture.pmremVersion = p.pmremVersion,
                                    t.set(p, _),
                                    p.addEventListener("dispose", c),
                                    _.texture) : null
                                }
                            }
                        }
                        return p
                    }
                    function r(p) {
                        let m = 0;
                        const g = 6;
                        for (let v = 0; v < g; v++)
                            p[v] !== void 0 && m++;
                        return m === g
                    }
                    function c(p) {
                        const m = p.target;
                        m.removeEventListener("dispose", c);
                        const g = t.get(m);
                        g !== void 0 && (t.delete(m),
                        g.dispose())
                    }
                    function f() {
                        t = new WeakMap,
                        n !== null && (n.dispose(),
                        n = null)
                    }
                    return {
                        get: a,
                        dispose: f
                    }
                }
                function fD(e) {
                    const t = {};
                    function n(a) {
                        if (t[a] !== void 0)
                            return t[a];
                        const r = e.getExtension(a);
                        return t[a] = r,
                        r
                    }
                    return {
                        has: function(a) {
                            return n(a) !== null
                        },
                        init: function() {
                            n("EXT_color_buffer_float"),
                            n("WEBGL_clip_cull_distance"),
                            n("OES_texture_float_linear"),
                            n("EXT_color_buffer_half_float"),
                            n("WEBGL_multisampled_render_to_texture"),
                            n("WEBGL_render_shared_exponent")
                        },
                        get: function(a) {
                            const r = n(a);
                            return r === null && yh("WebGLRenderer: " + a + " extension not supported."),
                            r
                        }
                    }
                }
                function hD(e, t, n, a) {
                    const r = {}
                      , c = new WeakMap;
                    function f(_) {
                        const x = _.target;
                        x.index !== null && t.remove(x.index);
                        for (const C in x.attributes)
                            t.remove(x.attributes[C]);
                        x.removeEventListener("dispose", f),
                        delete r[x.id];
                        const M = c.get(x);
                        M && (t.remove(M),
                        c.delete(x)),
                        a.releaseStatesOfGeometry(x),
                        x.isInstancedBufferGeometry === !0 && delete x._maxInstanceCount,
                        n.memory.geometries--
                    }
                    function p(_, x) {
                        return r[x.id] === !0 || (x.addEventListener("dispose", f),
                        r[x.id] = !0,
                        n.memory.geometries++),
                        x
                    }
                    function m(_) {
                        const x = _.attributes;
                        for (const M in x)
                            t.update(x[M], e.ARRAY_BUFFER)
                    }
                    function g(_) {
                        const x = []
                          , M = _.index
                          , C = _.attributes.position;
                        let R = 0;
                        if (M !== null) {
                            const N = M.array;
                            R = M.version;
                            for (let I = 0, L = N.length; I < L; I += 3) {
                                const k = N[I + 0]
                                  , B = N[I + 1]
                                  , X = N[I + 2];
                                x.push(k, B, B, X, X, k)
                            }
                        } else if (C !== void 0) {
                            const N = C.array;
                            R = C.version;
                            for (let I = 0, L = N.length / 3 - 1; I < L; I += 3) {
                                const k = I + 0
                                  , B = I + 1
                                  , X = I + 2;
                                x.push(k, B, B, X, X, k)
                            }
                        } else
                            return;
                        const A = new (Bb(x) ? X_ : W_)(x,1);
                        A.version = R;
                        const E = c.get(_);
                        E && t.remove(E),
                        c.set(_, A)
                    }
                    function v(_) {
                        const x = c.get(_);
                        if (x) {
                            const M = _.index;
                            M !== null && x.version < M.version && g(_)
                        } else
                            g(_);
                        return c.get(_)
                    }
                    return {
                        get: p,
                        update: m,
                        getWireframeAttribute: v
                    }
                }
                function dD(e, t, n) {
                    let a;
                    function r(x) {
                        a = x
                    }
                    let c, f;
                    function p(x) {
                        c = x.type,
                        f = x.bytesPerElement
                    }
                    function m(x, M) {
                        e.drawElements(a, M, c, x * f),
                        n.update(M, a, 1)
                    }
                    function g(x, M, C) {
                        C !== 0 && (e.drawElementsInstanced(a, M, c, x * f, C),
                        n.update(M, a, C))
                    }
                    function v(x, M, C) {
                        if (C === 0)
                            return;
                        t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(a, M, 0, c, x, 0, C);
                        let R = 0;
                        for (let A = 0; A < C; A++)
                            R += M[A];
                        n.update(R, a, 1)
                    }
                    function _(x, M, C, R) {
                        if (C === 0)
                            return;
                        const A = t.get("WEBGL_multi_draw");
                        if (A === null)
                            for (let E = 0; E < x.length; E++)
                                g(x[E] / f, M[E], R[E]);
                        else {
                            A.multiDrawElementsInstancedWEBGL(a, M, 0, c, x, 0, R, 0, C);
                            let E = 0;
                            for (let N = 0; N < C; N++)
                                E += M[N] * R[N];
                            n.update(E, a, 1)
                        }
                    }
                    this.setMode = r,
                    this.setIndex = p,
                    this.render = m,
                    this.renderInstances = g,
                    this.renderMultiDraw = v,
                    this.renderMultiDrawInstances = _
                }
                function pD(e) {
                    const t = {
                        geometries: 0,
                        textures: 0
                    }
                      , n = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    function a(c, f, p) {
                        switch (n.calls++,
                        f) {
                        case e.TRIANGLES:
                            n.triangles += p * (c / 3);
                            break;
                        case e.LINES:
                            n.lines += p * (c / 2);
                            break;
                        case e.LINE_STRIP:
                            n.lines += p * (c - 1);
                            break;
                        case e.LINE_LOOP:
                            n.lines += p * c;
                            break;
                        case e.POINTS:
                            n.points += p * c;
                            break;
                        default:
                            Et("WebGLInfo: Unknown draw mode:", f);
                            break
                        }
                    }
                    function r() {
                        n.calls = 0,
                        n.triangles = 0,
                        n.points = 0,
                        n.lines = 0
                    }
                    return {
                        memory: t,
                        render: n,
                        programs: null,
                        autoReset: !0,
                        reset: r,
                        update: a
                    }
                }
                function mD(e, t, n) {
                    const a = new WeakMap
                      , r = new ti;
                    function c(f, p, m) {
                        const g = f.morphTargetInfluences
                          , v = p.morphAttributes.position || p.morphAttributes.normal || p.morphAttributes.color
                          , _ = v !== void 0 ? v.length : 0;
                        let x = a.get(p);
                        if (x === void 0 || x.count !== _) {
                            let U = function() {
                                G.dispose(),
                                a.delete(p),
                                p.removeEventListener("dispose", U)
                            };
                            var M = U;
                            x !== void 0 && x.texture.dispose();
                            const C = p.morphAttributes.position !== void 0
                              , R = p.morphAttributes.normal !== void 0
                              , A = p.morphAttributes.color !== void 0
                              , E = p.morphAttributes.position || []
                              , N = p.morphAttributes.normal || []
                              , I = p.morphAttributes.color || [];
                            let L = 0;
                            C === !0 && (L = 1),
                            R === !0 && (L = 2),
                            A === !0 && (L = 3);
                            let k = p.attributes.position.count * L
                              , B = 1;
                            k > t.maxTextureSize && (B = Math.ceil(k / t.maxTextureSize),
                            k = t.maxTextureSize);
                            const X = new Float32Array(k * B * 4 * _)
                              , G = new r0(X,k,B,_);
                            G.type = Ja,
                            G.needsUpdate = !0;
                            const P = L * 4;
                            for (let W = 0; W < _; W++) {
                                const K = E[W]
                                  , q = N[W]
                                  , te = I[W]
                                  , ce = k * B * 4 * W;
                                for (let J = 0; J < K.count; J++) {
                                    const Q = J * P;
                                    C === !0 && (r.fromBufferAttribute(K, J),
                                    X[ce + Q + 0] = r.x,
                                    X[ce + Q + 1] = r.y,
                                    X[ce + Q + 2] = r.z,
                                    X[ce + Q + 3] = 0),
                                    R === !0 && (r.fromBufferAttribute(q, J),
                                    X[ce + Q + 4] = r.x,
                                    X[ce + Q + 5] = r.y,
                                    X[ce + Q + 6] = r.z,
                                    X[ce + Q + 7] = 0),
                                    A === !0 && (r.fromBufferAttribute(te, J),
                                    X[ce + Q + 8] = r.x,
                                    X[ce + Q + 9] = r.y,
                                    X[ce + Q + 10] = r.z,
                                    X[ce + Q + 11] = te.itemSize === 4 ? r.w : 1)
                                }
                            }
                            x = {
                                count: _,
                                texture: G,
                                size: new Pe(k,B)
                            },
                            a.set(p, x),
                            p.addEventListener("dispose", U)
                        }
                        if (f.isInstancedMesh === !0 && f.morphTexture !== null)
                            m.getUniforms().setValue(e, "morphTexture", f.morphTexture, n);
                        else {
                            let C = 0;
                            for (let A = 0; A < g.length; A++)
                                C += g[A];
                            const R = p.morphTargetsRelative ? 1 : 1 - C;
                            m.getUniforms().setValue(e, "morphTargetBaseInfluence", R),
                            m.getUniforms().setValue(e, "morphTargetInfluences", g)
                        }
                        m.getUniforms().setValue(e, "morphTargetsTexture", x.texture, n),
                        m.getUniforms().setValue(e, "morphTargetsTextureSize", x.size)
                    }
                    return {
                        update: c
                    }
                }
                function gD(e, t, n, a) {
                    let r = new WeakMap;
                    function c(m) {
                        const g = a.render.frame
                          , v = m.geometry
                          , _ = t.get(m, v);
                        if (r.get(_) !== g && (t.update(_),
                        r.set(_, g)),
                        m.isInstancedMesh && (m.hasEventListener("dispose", p) === !1 && m.addEventListener("dispose", p),
                        r.get(m) !== g && (n.update(m.instanceMatrix, e.ARRAY_BUFFER),
                        m.instanceColor !== null && n.update(m.instanceColor, e.ARRAY_BUFFER),
                        r.set(m, g))),
                        m.isSkinnedMesh) {
                            const x = m.skeleton;
                            r.get(x) !== g && (x.update(),
                            r.set(x, g))
                        }
                        return _
                    }
                    function f() {
                        r = new WeakMap
                    }
                    function p(m) {
                        const g = m.target;
                        g.removeEventListener("dispose", p),
                        n.remove(g.instanceMatrix),
                        g.instanceColor !== null && n.remove(g.instanceColor)
                    }
                    return {
                        update: c,
                        dispose: f
                    }
                }
                const vD = {
                    [o_]: "LINEAR_TONE_MAPPING",
                    [l_]: "REINHARD_TONE_MAPPING",
                    [c_]: "CINEON_TONE_MAPPING",
                    [mv]: "ACES_FILMIC_TONE_MAPPING",
                    [f_]: "AGX_TONE_MAPPING",
                    [h_]: "NEUTRAL_TONE_MAPPING",
                    [u_]: "CUSTOM_TONE_MAPPING"
                };
                function yD(e, t, n, a, r) {
                    const c = new Vs(t,n,{
                        type: e,
                        depthBuffer: a,
                        stencilBuffer: r
                    })
                      , f = new Vs(t,n,{
                        type: No,
                        depthBuffer: !1,
                        stencilBuffer: !1
                    })
                      , p = new Xt;
                    p.setAttribute("position", new vt([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
                    p.setAttribute("uv", new vt([0, 2, 0, 0, 2, 0],2));
                    const m = new TS({
                        uniforms: {
                            tDiffuse: {
                                value: null
                            }
                        },
                        vertexShader: `
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`,
                        fragmentShader: `
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`,
                        depthTest: !1,
                        depthWrite: !1
                    })
                      , g = new Hi(p,m)
                      , v = new jh(-1,1,1,-1,0,1);
                    let _ = null, x = null, M = !1, C, R = null, A = [], E = !1;
                    this.setSize = function(N, I) {
                        c.setSize(N, I),
                        f.setSize(N, I);
                        for (let L = 0; L < A.length; L++) {
                            const k = A[L];
                            k.setSize && k.setSize(N, I)
                        }
                    }
                    ,
                    this.setEffects = function(N) {
                        A = N,
                        E = A.length > 0 && A[0].isRenderPass === !0;
                        const I = c.width
                          , L = c.height;
                        for (let k = 0; k < A.length; k++) {
                            const B = A[k];
                            B.setSize && B.setSize(I, L)
                        }
                    }
                    ,
                    this.begin = function(N, I) {
                        if (M || N.toneMapping === ur && A.length === 0)
                            return !1;
                        if (R = I,
                        I !== null) {
                            const L = I.width
                              , k = I.height;
                            (c.width !== L || c.height !== k) && this.setSize(L, k)
                        }
                        return E === !1 && N.setRenderTarget(c),
                        C = N.toneMapping,
                        N.toneMapping = ur,
                        !0
                    }
                    ,
                    this.hasRenderPass = function() {
                        return E
                    }
                    ,
                    this.end = function(N, I) {
                        N.toneMapping = C,
                        M = !0;
                        let L = c
                          , k = f;
                        for (let B = 0; B < A.length; B++) {
                            const X = A[B];
                            if (X.enabled !== !1 && (X.render(N, k, L, I),
                            X.needsSwap !== !1)) {
                                const G = L;
                                L = k,
                                k = G
                            }
                        }
                        if (_ !== N.outputColorSpace || x !== N.toneMapping) {
                            _ = N.outputColorSpace,
                            x = N.toneMapping,
                            m.defines = {},
                            Sn.getTransfer(_) === Un && (m.defines.SRGB_TRANSFER = "");
                            const B = vD[x];
                            B && (m.defines[B] = ""),
                            m.needsUpdate = !0
                        }
                        m.uniforms.tDiffuse.value = L.texture,
                        N.setRenderTarget(R),
                        N.render(g, v),
                        R = null,
                        M = !1
                    }
                    ,
                    this.isCompositing = function() {
                        return M
                    }
                    ,
                    this.dispose = function() {
                        c.dispose(),
                        f.dispose(),
                        p.dispose(),
                        m.dispose()
                    }
                }
                const gE = new oa
                  , $S = new Wh(1,1)
                  , vE = new r0
                  , yE = new o0
                  , _E = new $p
                  , SE = []
                  , xE = []
                  , bE = new Float32Array(16)
                  , ME = new Float32Array(9)
                  , TE = new Float32Array(4);
                function Jh(e, t, n) {
                    const a = e[0];
                    if (a <= 0 || a > 0)
                        return e;
                    const r = t * n;
                    let c = SE[r];
                    if (c === void 0 && (c = new Float32Array(r),
                    SE[r] = c),
                    t !== 0) {
                        a.toArray(c, 0);
                        for (let f = 1, p = 0; f !== t; ++f)
                            p += n,
                            e[f].toArray(c, p)
                    }
                    return c
                }
                function Qi(e, t) {
                    if (e.length !== t.length)
                        return !1;
                    for (let n = 0, a = e.length; n < a; n++)
                        if (e[n] !== t[n])
                            return !1;
                    return !0
                }
                function Ki(e, t) {
                    for (let n = 0, a = t.length; n < a; n++)
                        e[n] = t[n]
                }
                function ly(e, t) {
                    let n = xE[t];
                    n === void 0 && (n = new Int32Array(t),
                    xE[t] = n);
                    for (let a = 0; a !== t; ++a)
                        n[a] = e.allocateTextureUnit();
                    return n
                }
                function _D(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1f(this.addr, t),
                    n[0] = t)
                }
                function SD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform2fv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function xD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else if (t.r !== void 0)
                        (n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b),
                        n[0] = t.r,
                        n[1] = t.g,
                        n[2] = t.b);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform3fv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function bD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform4fv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function MD(e, t) {
                    const n = this.cache
                      , a = t.elements;
                    if (a === void 0) {
                        if (Qi(n, t))
                            return;
                        e.uniformMatrix2fv(this.addr, !1, t),
                        Ki(n, t)
                    } else {
                        if (Qi(n, a))
                            return;
                        TE.set(a),
                        e.uniformMatrix2fv(this.addr, !1, TE),
                        Ki(n, a)
                    }
                }
                function TD(e, t) {
                    const n = this.cache
                      , a = t.elements;
                    if (a === void 0) {
                        if (Qi(n, t))
                            return;
                        e.uniformMatrix3fv(this.addr, !1, t),
                        Ki(n, t)
                    } else {
                        if (Qi(n, a))
                            return;
                        ME.set(a),
                        e.uniformMatrix3fv(this.addr, !1, ME),
                        Ki(n, a)
                    }
                }
                function ED(e, t) {
                    const n = this.cache
                      , a = t.elements;
                    if (a === void 0) {
                        if (Qi(n, t))
                            return;
                        e.uniformMatrix4fv(this.addr, !1, t),
                        Ki(n, t)
                    } else {
                        if (Qi(n, a))
                            return;
                        bE.set(a),
                        e.uniformMatrix4fv(this.addr, !1, bE),
                        Ki(n, a)
                    }
                }
                function AD(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1i(this.addr, t),
                    n[0] = t)
                }
                function wD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform2iv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function CD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform3iv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function RD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform4iv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function DD(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1ui(this.addr, t),
                    n[0] = t)
                }
                function ND(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform2uiv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function LD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform3uiv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function UD(e, t) {
                    const n = this.cache;
                    if (t.x !== void 0)
                        (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (Qi(n, t))
                            return;
                        e.uniform4uiv(this.addr, t),
                        Ki(n, t)
                    }
                }
                function ID(e, t, n) {
                    const a = this.cache
                      , r = n.allocateTextureUnit();
                    a[0] !== r && (e.uniform1i(this.addr, r),
                    a[0] = r);
                    let c;
                    this.type === e.SAMPLER_2D_SHADOW ? ($S.compareFunction = n.isReversedDepthBuffer() ? s0 : a0,
                    c = $S) : c = gE,
                    n.setTexture2D(t || c, r)
                }
                function OD(e, t, n) {
                    const a = this.cache
                      , r = n.allocateTextureUnit();
                    a[0] !== r && (e.uniform1i(this.addr, r),
                    a[0] = r),
                    n.setTexture3D(t || yE, r)
                }
                function PD(e, t, n) {
                    const a = this.cache
                      , r = n.allocateTextureUnit();
                    a[0] !== r && (e.uniform1i(this.addr, r),
                    a[0] = r),
                    n.setTextureCube(t || _E, r)
                }
                function zD(e, t, n) {
                    const a = this.cache
                      , r = n.allocateTextureUnit();
                    a[0] !== r && (e.uniform1i(this.addr, r),
                    a[0] = r),
                    n.setTexture2DArray(t || vE, r)
                }
                function BD(e) {
                    switch (e) {
                    case 5126:
                        return _D;
                    case 35664:
                        return SD;
                    case 35665:
                        return xD;
                    case 35666:
                        return bD;
                    case 35674:
                        return MD;
                    case 35675:
                        return TD;
                    case 35676:
                        return ED;
                    case 5124:
                    case 35670:
                        return AD;
                    case 35667:
                    case 35671:
                        return wD;
                    case 35668:
                    case 35672:
                        return CD;
                    case 35669:
                    case 35673:
                        return RD;
                    case 5125:
                        return DD;
                    case 36294:
                        return ND;
                    case 36295:
                        return LD;
                    case 36296:
                        return UD;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return ID;
                    case 35679:
                    case 36299:
                    case 36307:
                        return OD;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return PD;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return zD
                    }
                }
                function FD(e, t) {
                    e.uniform1fv(this.addr, t)
                }
                function VD(e, t) {
                    const n = Jh(t, this.size, 2);
                    e.uniform2fv(this.addr, n)
                }
                function kD(e, t) {
                    const n = Jh(t, this.size, 3);
                    e.uniform3fv(this.addr, n)
                }
                function HD(e, t) {
                    const n = Jh(t, this.size, 4);
                    e.uniform4fv(this.addr, n)
                }
                function GD(e, t) {
                    const n = Jh(t, this.size, 4);
                    e.uniformMatrix2fv(this.addr, !1, n)
                }
                function WD(e, t) {
                    const n = Jh(t, this.size, 9);
                    e.uniformMatrix3fv(this.addr, !1, n)
                }
                function XD(e, t) {
                    const n = Jh(t, this.size, 16);
                    e.uniformMatrix4fv(this.addr, !1, n)
                }
                function qD(e, t) {
                    e.uniform1iv(this.addr, t)
                }
                function YD(e, t) {
                    e.uniform2iv(this.addr, t)
                }
                function jD(e, t) {
                    e.uniform3iv(this.addr, t)
                }
                function ZD(e, t) {
                    e.uniform4iv(this.addr, t)
                }
                function QD(e, t) {
                    e.uniform1uiv(this.addr, t)
                }
                function KD(e, t) {
                    e.uniform2uiv(this.addr, t)
                }
                function JD(e, t) {
                    e.uniform3uiv(this.addr, t)
                }
                function $D(e, t) {
                    e.uniform4uiv(this.addr, t)
                }
                function eN(e, t, n) {
                    const a = this.cache
                      , r = t.length
                      , c = ly(n, r);
                    Qi(a, c) || (e.uniform1iv(this.addr, c),
                    Ki(a, c));
                    let f;
                    this.type === e.SAMPLER_2D_SHADOW ? f = $S : f = gE;
                    for (let p = 0; p !== r; ++p)
                        n.setTexture2D(t[p] || f, c[p])
                }
                function tN(e, t, n) {
                    const a = this.cache
                      , r = t.length
                      , c = ly(n, r);
                    Qi(a, c) || (e.uniform1iv(this.addr, c),
                    Ki(a, c));
                    for (let f = 0; f !== r; ++f)
                        n.setTexture3D(t[f] || yE, c[f])
                }
                function nN(e, t, n) {
                    const a = this.cache
                      , r = t.length
                      , c = ly(n, r);
                    Qi(a, c) || (e.uniform1iv(this.addr, c),
                    Ki(a, c));
                    for (let f = 0; f !== r; ++f)
                        n.setTextureCube(t[f] || _E, c[f])
                }
                function iN(e, t, n) {
                    const a = this.cache
                      , r = t.length
                      , c = ly(n, r);
                    Qi(a, c) || (e.uniform1iv(this.addr, c),
                    Ki(a, c));
                    for (let f = 0; f !== r; ++f)
                        n.setTexture2DArray(t[f] || vE, c[f])
                }
                function aN(e) {
                    switch (e) {
                    case 5126:
                        return FD;
                    case 35664:
                        return VD;
                    case 35665:
                        return kD;
                    case 35666:
                        return HD;
                    case 35674:
                        return GD;
                    case 35675:
                        return WD;
                    case 35676:
                        return XD;
                    case 5124:
                    case 35670:
                        return qD;
                    case 35667:
                    case 35671:
                        return YD;
                    case 35668:
                    case 35672:
                        return jD;
                    case 35669:
                    case 35673:
                        return ZD;
                    case 5125:
                        return QD;
                    case 36294:
                        return KD;
                    case 36295:
                        return JD;
                    case 36296:
                        return $D;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return eN;
                    case 35679:
                    case 36299:
                    case 36307:
                        return tN;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return nN;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return iN
                    }
                }
                var sN = class {
                    constructor(e, t, n) {
                        this.id = e,
                        this.addr = n,
                        this.cache = [],
                        this.type = t.type,
                        this.setValue = BD(t.type)
                    }
                }
                  , rN = class {
                    constructor(e, t, n) {
                        this.id = e,
                        this.addr = n,
                        this.cache = [],
                        this.type = t.type,
                        this.size = t.size,
                        this.setValue = aN(t.type)
                    }
                }
                  , oN = class {
                    constructor(e) {
                        this.id = e,
                        this.seq = [],
                        this.map = {}
                    }
                    setValue(e, t, n) {
                        const a = this.seq;
                        for (let r = 0, c = a.length; r !== c; ++r) {
                            const f = a[r];
                            f.setValue(e, t[f.id], n)
                        }
                    }
                }
                ;
                const ex = /(\w+)(\])?(\[|\.)?/g;
                function EE(e, t) {
                    e.seq.push(t),
                    e.map[t.id] = t
                }
                function lN(e, t, n) {
                    const a = e.name
                      , r = a.length;
                    for (ex.lastIndex = 0; ; ) {
                        const c = ex.exec(a)
                          , f = ex.lastIndex;
                        let p = c[1];
                        const m = c[2] === "]"
                          , g = c[3];
                        if (m && (p = p | 0),
                        g === void 0 || g === "[" && f + 2 === r) {
                            EE(n, g === void 0 ? new sN(p,e,t) : new rN(p,e,t));
                            break
                        } else {
                            let v = n.map[p];
                            v === void 0 && (v = new oN(p),
                            EE(n, v)),
                            n = v
                        }
                    }
                }
                var cy = class {
                    constructor(e, t) {
                        this.seq = [],
                        this.map = {};
                        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                        for (let c = 0; c < n; ++c) {
                            const f = e.getActiveUniform(t, c);
                            lN(f, e.getUniformLocation(t, f.name), this)
                        }
                        const a = []
                          , r = [];
                        for (const c of this.seq)
                            c.type === e.SAMPLER_2D_SHADOW || c.type === e.SAMPLER_CUBE_SHADOW || c.type === e.SAMPLER_2D_ARRAY_SHADOW ? a.push(c) : r.push(c);
                        a.length > 0 && (this.seq = a.concat(r))
                    }
                    setValue(e, t, n, a) {
                        const r = this.map[t];
                        r !== void 0 && r.setValue(e, n, a)
                    }
                    setOptional(e, t, n) {
                        const a = t[n];
                        a !== void 0 && this.setValue(e, n, a)
                    }
                    static upload(e, t, n, a) {
                        for (let r = 0, c = t.length; r !== c; ++r) {
                            const f = t[r]
                              , p = n[f.id];
                            p.needsUpdate !== !1 && f.setValue(e, p.value, a)
                        }
                    }
                    static seqWithValue(e, t) {
                        const n = [];
                        for (let a = 0, r = e.length; a !== r; ++a) {
                            const c = e[a];
                            c.id in t && n.push(c)
                        }
                        return n
                    }
                }
                ;
                function AE(e, t, n) {
                    const a = e.createShader(t);
                    return e.shaderSource(a, n),
                    e.compileShader(a),
                    a
                }
                const cN = 37297;
                let uN = 0;
                function fN(e, t) {
                    const n = e.split(`
`)
                      , a = []
                      , r = Math.max(t - 6, 0)
                      , c = Math.min(t + 6, n.length);
                    for (let f = r; f < c; f++) {
                        const p = f + 1;
                        a.push(`${p === t ? ">" : " "} ${p}: ${n[f]}`)
                    }
                    return a.join(`
`)
                }
                const wE = new en;
                function hN(e) {
                    Sn._getMatrix(wE, Sn.workingColorSpace, e);
                    const t = `mat3( ${wE.elements.map(n => n.toFixed(4))} )`;
                    switch (Sn.getTransfer(e)) {
                    case Hp:
                        return [t, "LinearTransferOETF"];
                    case Un:
                        return [t, "sRGBTransferOETF"];
                    default:
                        return ot("WebGLProgram: Unsupported color space: ", e),
                        [t, "LinearTransferOETF"]
                    }
                }
                function CE(e, t, n) {
                    const a = e.getShaderParameter(t, e.COMPILE_STATUS)
                      , r = (e.getShaderInfoLog(t) || "").trim();
                    if (a && r === "")
                        return "";
                    const c = /ERROR: 0:(\d+)/.exec(r);
                    if (c) {
                        const f = parseInt(c[1]);
                        return n.toUpperCase() + `

` + r + `

` + fN(e.getShaderSource(t), f)
                    } else
                        return r
                }
                function dN(e, t) {
                    const n = hN(t);
                    return [`vec4 ${e}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
                }
                const pN = {
                    [o_]: "Linear",
                    [l_]: "Reinhard",
                    [c_]: "Cineon",
                    [mv]: "ACESFilmic",
                    [f_]: "AgX",
                    [h_]: "Neutral",
                    [u_]: "Custom"
                };
                function mN(e, t) {
                    const n = pN[t];
                    return n === void 0 ? (ot("WebGLProgram: Unsupported toneMapping:", t),
                    "vec3 " + e + "( vec3 color ) { return LinearToneMapping( color ); }") : "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }
                const uy = new Y;
                function gN() {
                    return Sn.getLuminanceCoefficients(uy),
                    ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${uy.x.toFixed(4)}, ${uy.y.toFixed(4)}, ${uy.z.toFixed(4)} );`, "	return dot( weights, rgb );", "}"].join(`
`)
                }
                function vN(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(xm).join(`
`)
                }
                function yN(e) {
                    const t = [];
                    for (const n in e) {
                        const a = e[n];
                        a !== !1 && t.push("#define " + n + " " + a)
                    }
                    return t.join(`
`)
                }
                function _N(e, t) {
                    const n = {}
                      , a = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < a; r++) {
                        const c = e.getActiveAttrib(t, r)
                          , f = c.name;
                        let p = 1;
                        c.type === e.FLOAT_MAT2 && (p = 2),
                        c.type === e.FLOAT_MAT3 && (p = 3),
                        c.type === e.FLOAT_MAT4 && (p = 4),
                        n[f] = {
                            type: c.type,
                            location: e.getAttribLocation(t, f),
                            locationSize: p
                        }
                    }
                    return n
                }
                function xm(e) {
                    return e !== ""
                }
                function RE(e, t) {
                    const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
                }
                function DE(e, t) {
                    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
                }
                const SN = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function tx(e) {
                    return e.replace(SN, bN)
                }
                const xN = new Map;
                function bN(e, t) {
                    let n = tn[t];
                    if (n === void 0) {
                        const a = xN.get(t);
                        if (a !== void 0)
                            n = tn[a],
                            ot('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, a);
                        else
                            throw new Error("Can not resolve #include <" + t + ">")
                    }
                    return tx(n)
                }
                const MN = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function NE(e) {
                    return e.replace(MN, TN)
                }
                function TN(e, t, n, a) {
                    let r = "";
                    for (let c = parseInt(t); c < parseInt(n); c++)
                        r += a.replace(/\[\s*i\s*\]/g, "[ " + c + " ]").replace(/UNROLLED_LOOP_INDEX/g, c);
                    return r
                }
                function LE(e) {
                    let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`;
                    return e.precision === "highp" ? t += `
#define HIGH_PRECISION` : e.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : e.precision === "lowp" && (t += `
#define LOW_PRECISION`),
                    t
                }
                const EN = {
                    [fh]: "SHADOWMAP_TYPE_PCF",
                    [Lu]: "SHADOWMAP_TYPE_VSM"
                };
                function AN(e) {
                    return EN[e.shadowMapType] || "SHADOWMAP_TYPE_BASIC"
                }
                const wN = {
                    [Ro]: "ENVMAP_TYPE_CUBE",
                    [vc]: "ENVMAP_TYPE_CUBE",
                    [hh]: "ENVMAP_TYPE_CUBE_UV"
                };
                function CN(e) {
                    return e.envMap === !1 ? "ENVMAP_TYPE_CUBE" : wN[e.envMapMode] || "ENVMAP_TYPE_CUBE"
                }
                const RN = {
                    [vc]: "ENVMAP_MODE_REFRACTION"
                };
                function DN(e) {
                    return e.envMap === !1 ? "ENVMAP_MODE_REFLECTION" : RN[e.envMapMode] || "ENVMAP_MODE_REFLECTION"
                }
                const NN = {
                    [Rp]: "ENVMAP_BLENDING_MULTIPLY",
                    [Tb]: "ENVMAP_BLENDING_MIX",
                    [Eb]: "ENVMAP_BLENDING_ADD"
                };
                function LN(e) {
                    return e.envMap === !1 ? "ENVMAP_BLENDING_NONE" : NN[e.combine] || "ENVMAP_BLENDING_NONE"
                }
                function UN(e) {
                    const t = e.envMapCubeUVHeight;
                    if (t === null)
                        return null;
                    const n = Math.log2(t) - 2
                      , a = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: a,
                        maxMip: n
                    }
                }
                function IN(e, t, n, a) {
                    const r = e.getContext()
                      , c = n.defines;
                    let f = n.vertexShader
                      , p = n.fragmentShader;
                    const m = AN(n)
                      , g = CN(n)
                      , v = DN(n)
                      , _ = LN(n)
                      , x = UN(n)
                      , M = vN(n)
                      , C = yN(c)
                      , R = r.createProgram();
                    let A, E, N = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
                    n.isRawShaderMaterial ? (A = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, C].filter(xm).join(`
`),
                    A.length > 0 && (A += `
`),
                    E = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, C].filter(xm).join(`
`),
                    E.length > 0 && (E += `
`)) : (A = [LE(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, C, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + v : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(xm).join(`
`),
                    E = [LE(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, C, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + g : "", n.envMap ? "#define " + v : "", n.envMap ? "#define " + _ : "", x ? "#define CUBEUV_TEXEL_WIDTH " + x.texelWidth : "", x ? "#define CUBEUV_TEXEL_HEIGHT " + x.texelHeight : "", x ? "#define CUBEUV_MAX_MIP " + x.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== ur ? "#define TONE_MAPPING" : "", n.toneMapping !== ur ? tn.tonemapping_pars_fragment : "", n.toneMapping !== ur ? mN("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", tn.colorspace_pars_fragment, dN("linearToOutputTexel", n.outputColorSpace), gN(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(xm).join(`
`)),
                    f = tx(f),
                    f = RE(f, n),
                    f = DE(f, n),
                    p = tx(p),
                    p = RE(p, n),
                    p = DE(p, n),
                    f = NE(f),
                    p = NE(p),
                    n.isRawShaderMaterial !== !0 && (N = `#version 300 es
`,
                    A = [M, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + A,
                    E = ["#define varying in", n.glslVersion === M_ ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === M_ ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + E);
                    const I = N + A + f
                      , L = N + E + p
                      , k = AE(r, r.VERTEX_SHADER, I)
                      , B = AE(r, r.FRAGMENT_SHADER, L);
                    r.attachShader(R, k),
                    r.attachShader(R, B),
                    n.index0AttributeName !== void 0 ? r.bindAttribLocation(R, 0, n.index0AttributeName) : n.morphTargets === !0 && r.bindAttribLocation(R, 0, "position"),
                    r.linkProgram(R);
                    function X(W) {
                        if (e.debug.checkShaderErrors) {
                            const K = r.getProgramInfoLog(R) || ""
                              , q = r.getShaderInfoLog(k) || ""
                              , te = r.getShaderInfoLog(B) || ""
                              , ce = K.trim()
                              , J = q.trim()
                              , Q = te.trim();
                            let se = !0
                              , Te = !0;
                            if (r.getProgramParameter(R, r.LINK_STATUS) === !1)
                                if (se = !1,
                                typeof e.debug.onShaderError == "function")
                                    e.debug.onShaderError(r, R, k, B);
                                else {
                                    const Ee = CE(r, k, "vertex")
                                      , Be = CE(r, B, "fragment");
                                    Et("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(R, r.VALIDATE_STATUS) + `

Material Name: ` + W.name + `
Material Type: ` + W.type + `

Program Info Log: ` + ce + `
` + Ee + `
` + Be)
                                }
                            else
                                ce !== "" ? ot("WebGLProgram: Program Info Log:", ce) : (J === "" || Q === "") && (Te = !1);
                            Te && (W.diagnostics = {
                                runnable: se,
                                programLog: ce,
                                vertexShader: {
                                    log: J,
                                    prefix: A
                                },
                                fragmentShader: {
                                    log: Q,
                                    prefix: E
                                }
                            })
                        }
                        r.deleteShader(k),
                        r.deleteShader(B),
                        G = new cy(r,R),
                        P = _N(r, R)
                    }
                    let G;
                    this.getUniforms = function() {
                        return G === void 0 && X(this),
                        G
                    }
                    ;
                    let P;
                    this.getAttributes = function() {
                        return P === void 0 && X(this),
                        P
                    }
                    ;
                    let U = n.rendererExtensionParallelShaderCompile === !1;
                    return this.isReady = function() {
                        return U === !1 && (U = r.getProgramParameter(R, cN)),
                        U
                    }
                    ,
                    this.destroy = function() {
                        a.releaseStatesOfProgram(this),
                        r.deleteProgram(R),
                        this.program = void 0
                    }
                    ,
                    this.type = n.shaderType,
                    this.name = n.shaderName,
                    this.id = uN++,
                    this.cacheKey = t,
                    this.usedTimes = 1,
                    this.program = R,
                    this.vertexShader = k,
                    this.fragmentShader = B,
                    this
                }
                let ON = 0;
                var PN = class {
                    constructor() {
                        this.shaderCache = new Map,
                        this.materialCache = new Map
                    }
                    update(e) {
                        const t = e.vertexShader
                          , n = e.fragmentShader
                          , a = this._getShaderStage(t)
                          , r = this._getShaderStage(n)
                          , c = this._getShaderCacheForMaterial(e);
                        return c.has(a) === !1 && (c.add(a),
                        a.usedTimes++),
                        c.has(r) === !1 && (c.add(r),
                        r.usedTimes++),
                        this
                    }
                    remove(e) {
                        const t = this.materialCache.get(e);
                        for (const n of t)
                            n.usedTimes--,
                            n.usedTimes === 0 && this.shaderCache.delete(n.code);
                        return this.materialCache.delete(e),
                        this
                    }
                    getVertexShaderID(e) {
                        return this._getShaderStage(e.vertexShader).id
                    }
                    getFragmentShaderID(e) {
                        return this._getShaderStage(e.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear(),
                        this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(e) {
                        const t = this.materialCache;
                        let n = t.get(e);
                        return n === void 0 && (n = new Set,
                        t.set(e, n)),
                        n
                    }
                    _getShaderStage(e) {
                        const t = this.shaderCache;
                        let n = t.get(e);
                        return n === void 0 && (n = new zN(e),
                        t.set(e, n)),
                        n
                    }
                }
                  , zN = class {
                    constructor(e) {
                        this.id = ON++,
                        this.code = e,
                        this.usedTimes = 0
                    }
                }
                ;
                function BN(e, t, n, a, r, c, f) {
                    const p = new wh
                      , m = new PN
                      , g = new Set
                      , v = []
                      , _ = new Map
                      , x = r.logarithmicDepthBuffer;
                    let M = r.precision;
                    const C = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distance",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                    function R(P) {
                        return g.add(P),
                        P === 0 ? "uv" : `uv${P}`
                    }
                    function A(P, U, W, K, q) {
                        const te = K.fog
                          , ce = q.geometry
                          , J = P.isMeshStandardMaterial ? K.environment : null
                          , Q = (P.isMeshStandardMaterial ? n : t).get(P.envMap || J)
                          , se = Q && Q.mapping === hh ? Q.image.height : null
                          , Te = C[P.type];
                        P.precision !== null && (M = r.getMaxPrecision(P.precision),
                        M !== P.precision && ot("WebGLProgram.getParameters:", P.precision, "not supported, using", M, "instead."));
                        const Ee = ce.morphAttributes.position || ce.morphAttributes.normal || ce.morphAttributes.color
                          , Be = Ee !== void 0 ? Ee.length : 0;
                        let j = 0;
                        ce.morphAttributes.position !== void 0 && (j = 1),
                        ce.morphAttributes.normal !== void 0 && (j = 2),
                        ce.morphAttributes.color !== void 0 && (j = 3);
                        let ve, Re, le, Ae;
                        if (Te) {
                            const xn = Xr[Te];
                            ve = xn.vertexShader,
                            Re = xn.fragmentShader
                        } else
                            ve = P.vertexShader,
                            Re = P.fragmentShader,
                            m.update(P),
                            le = m.getVertexShaderID(P),
                            Ae = m.getFragmentShaderID(P);
                        const Ne = e.getRenderTarget()
                          , ke = e.state.buffers.depth.getReversed()
                          , at = q.isInstancedMesh === !0
                          , Je = q.isBatchedMesh === !0
                          , Ft = !!P.map
                          , Vt = !!P.matcap
                          , we = !!Q
                          , Ye = !!P.aoMap
                          , Ve = !!P.lightMap
                          , tt = !!P.bumpMap
                          , Z = !!P.normalMap
                          , At = !!P.displacementMap
                          , $e = !!P.emissiveMap
                          , xt = !!P.metalnessMap
                          , Ke = !!P.roughnessMap
                          , wt = P.anisotropy > 0
                          , H = P.clearcoat > 0
                          , O = P.dispersion > 0
                          , oe = P.iridescence > 0
                          , Ce = P.sheen > 0
                          , Ue = P.transmission > 0
                          , Me = wt && !!P.anisotropyMap
                          , st = H && !!P.clearcoatMap
                          , je = H && !!P.clearcoatNormalMap
                          , St = H && !!P.clearcoatRoughnessMap
                          , Ct = oe && !!P.iridescenceMap
                          , He = oe && !!P.iridescenceThicknessMap
                          , We = Ce && !!P.sheenColorMap
                          , rt = Ce && !!P.sheenRoughnessMap
                          , ft = !!P.specularMap
                          , et = !!P.specularColorMap
                          , qt = !!P.specularIntensityMap
                          , ae = Ue && !!P.transmissionMap
                          , nt = Ue && !!P.thicknessMap
                          , Ge = !!P.gradientMap
                          , ht = !!P.alphaMap
                          , Fe = P.alphaTest > 0
                          , xe = !!P.alphaHash
                          , pt = !!P.extensions;
                        let Mt = ur;
                        P.toneMapped && (Ne === null || Ne.isXRRenderTarget === !0) && (Mt = e.toneMapping);
                        const In = {
                            shaderID: Te,
                            shaderType: P.type,
                            shaderName: P.name,
                            vertexShader: ve,
                            fragmentShader: Re,
                            defines: P.defines,
                            customVertexShaderID: le,
                            customFragmentShaderID: Ae,
                            isRawShaderMaterial: P.isRawShaderMaterial === !0,
                            glslVersion: P.glslVersion,
                            precision: M,
                            batching: Je,
                            batchingColor: Je && q._colorsTexture !== null,
                            instancing: at,
                            instancingColor: at && q.instanceColor !== null,
                            instancingMorph: at && q.morphTexture !== null,
                            outputColorSpace: Ne === null ? e.outputColorSpace : Ne.isXRRenderTarget === !0 ? Ne.texture.colorSpace : Sc,
                            alphaToCoverage: !!P.alphaToCoverage,
                            map: Ft,
                            matcap: Vt,
                            envMap: we,
                            envMapMode: we && Q.mapping,
                            envMapCubeUVHeight: se,
                            aoMap: Ye,
                            lightMap: Ve,
                            bumpMap: tt,
                            normalMap: Z,
                            displacementMap: At,
                            emissiveMap: $e,
                            normalMapObjectSpace: Z && P.normalMapType === Nb,
                            normalMapTangentSpace: Z && P.normalMapType === _c,
                            metalnessMap: xt,
                            roughnessMap: Ke,
                            anisotropy: wt,
                            anisotropyMap: Me,
                            clearcoat: H,
                            clearcoatMap: st,
                            clearcoatNormalMap: je,
                            clearcoatRoughnessMap: St,
                            dispersion: O,
                            iridescence: oe,
                            iridescenceMap: Ct,
                            iridescenceThicknessMap: He,
                            sheen: Ce,
                            sheenColorMap: We,
                            sheenRoughnessMap: rt,
                            specularMap: ft,
                            specularColorMap: et,
                            specularIntensityMap: qt,
                            transmission: Ue,
                            transmissionMap: ae,
                            thicknessMap: nt,
                            gradientMap: Ge,
                            opaque: P.transparent === !1 && P.blending === Uu && P.alphaToCoverage === !1,
                            alphaMap: ht,
                            alphaTest: Fe,
                            alphaHash: xe,
                            combine: P.combine,
                            mapUv: Ft && R(P.map.channel),
                            aoMapUv: Ye && R(P.aoMap.channel),
                            lightMapUv: Ve && R(P.lightMap.channel),
                            bumpMapUv: tt && R(P.bumpMap.channel),
                            normalMapUv: Z && R(P.normalMap.channel),
                            displacementMapUv: At && R(P.displacementMap.channel),
                            emissiveMapUv: $e && R(P.emissiveMap.channel),
                            metalnessMapUv: xt && R(P.metalnessMap.channel),
                            roughnessMapUv: Ke && R(P.roughnessMap.channel),
                            anisotropyMapUv: Me && R(P.anisotropyMap.channel),
                            clearcoatMapUv: st && R(P.clearcoatMap.channel),
                            clearcoatNormalMapUv: je && R(P.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: St && R(P.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: Ct && R(P.iridescenceMap.channel),
                            iridescenceThicknessMapUv: He && R(P.iridescenceThicknessMap.channel),
                            sheenColorMapUv: We && R(P.sheenColorMap.channel),
                            sheenRoughnessMapUv: rt && R(P.sheenRoughnessMap.channel),
                            specularMapUv: ft && R(P.specularMap.channel),
                            specularColorMapUv: et && R(P.specularColorMap.channel),
                            specularIntensityMapUv: qt && R(P.specularIntensityMap.channel),
                            transmissionMapUv: ae && R(P.transmissionMap.channel),
                            thicknessMapUv: nt && R(P.thicknessMap.channel),
                            alphaMapUv: ht && R(P.alphaMap.channel),
                            vertexTangents: !!ce.attributes.tangent && (Z || wt),
                            vertexColors: P.vertexColors,
                            vertexAlphas: P.vertexColors === !0 && !!ce.attributes.color && ce.attributes.color.itemSize === 4,
                            pointsUvs: q.isPoints === !0 && !!ce.attributes.uv && (Ft || ht),
                            fog: !!te,
                            useFog: P.fog === !0,
                            fogExp2: !!te && te.isFogExp2,
                            flatShading: P.flatShading === !0 && P.wireframe === !1,
                            sizeAttenuation: P.sizeAttenuation === !0,
                            logarithmicDepthBuffer: x,
                            reversedDepthBuffer: ke,
                            skinning: q.isSkinnedMesh === !0,
                            morphTargets: ce.morphAttributes.position !== void 0,
                            morphNormals: ce.morphAttributes.normal !== void 0,
                            morphColors: ce.morphAttributes.color !== void 0,
                            morphTargetsCount: Be,
                            morphTextureStride: j,
                            numDirLights: U.directional.length,
                            numPointLights: U.point.length,
                            numSpotLights: U.spot.length,
                            numSpotLightMaps: U.spotLightMap.length,
                            numRectAreaLights: U.rectArea.length,
                            numHemiLights: U.hemi.length,
                            numDirLightShadows: U.directionalShadowMap.length,
                            numPointLightShadows: U.pointShadowMap.length,
                            numSpotLightShadows: U.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: U.numSpotLightShadowsWithMaps,
                            numLightProbes: U.numLightProbes,
                            numClippingPlanes: f.numPlanes,
                            numClipIntersection: f.numIntersection,
                            dithering: P.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && W.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: Mt,
                            decodeVideoTexture: Ft && P.map.isVideoTexture === !0 && Sn.getTransfer(P.map.colorSpace) === Un,
                            decodeVideoTextureEmissive: $e && P.emissiveMap.isVideoTexture === !0 && Sn.getTransfer(P.emissiveMap.colorSpace) === Un,
                            premultipliedAlpha: P.premultipliedAlpha,
                            doubleSided: P.side === wo,
                            flipSided: P.side === Qa,
                            useDepthPacking: P.depthPacking >= 0,
                            depthPacking: P.depthPacking || 0,
                            index0AttributeName: P.index0AttributeName,
                            extensionClipCullDistance: pt && P.extensions.clipCullDistance === !0 && a.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (pt && P.extensions.multiDraw === !0 || Je) && a.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: a.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: P.customProgramCacheKey()
                        };
                        return In.vertexUv1s = g.has(1),
                        In.vertexUv2s = g.has(2),
                        In.vertexUv3s = g.has(3),
                        g.clear(),
                        In
                    }
                    function E(P) {
                        const U = [];
                        if (P.shaderID ? U.push(P.shaderID) : (U.push(P.customVertexShaderID),
                        U.push(P.customFragmentShaderID)),
                        P.defines !== void 0)
                            for (const W in P.defines)
                                U.push(W),
                                U.push(P.defines[W]);
                        return P.isRawShaderMaterial === !1 && (N(U, P),
                        I(U, P),
                        U.push(e.outputColorSpace)),
                        U.push(P.customProgramCacheKey),
                        U.join()
                    }
                    function N(P, U) {
                        P.push(U.precision),
                        P.push(U.outputColorSpace),
                        P.push(U.envMapMode),
                        P.push(U.envMapCubeUVHeight),
                        P.push(U.mapUv),
                        P.push(U.alphaMapUv),
                        P.push(U.lightMapUv),
                        P.push(U.aoMapUv),
                        P.push(U.bumpMapUv),
                        P.push(U.normalMapUv),
                        P.push(U.displacementMapUv),
                        P.push(U.emissiveMapUv),
                        P.push(U.metalnessMapUv),
                        P.push(U.roughnessMapUv),
                        P.push(U.anisotropyMapUv),
                        P.push(U.clearcoatMapUv),
                        P.push(U.clearcoatNormalMapUv),
                        P.push(U.clearcoatRoughnessMapUv),
                        P.push(U.iridescenceMapUv),
                        P.push(U.iridescenceThicknessMapUv),
                        P.push(U.sheenColorMapUv),
                        P.push(U.sheenRoughnessMapUv),
                        P.push(U.specularMapUv),
                        P.push(U.specularColorMapUv),
                        P.push(U.specularIntensityMapUv),
                        P.push(U.transmissionMapUv),
                        P.push(U.thicknessMapUv),
                        P.push(U.combine),
                        P.push(U.fogExp2),
                        P.push(U.sizeAttenuation),
                        P.push(U.morphTargetsCount),
                        P.push(U.morphAttributeCount),
                        P.push(U.numDirLights),
                        P.push(U.numPointLights),
                        P.push(U.numSpotLights),
                        P.push(U.numSpotLightMaps),
                        P.push(U.numHemiLights),
                        P.push(U.numRectAreaLights),
                        P.push(U.numDirLightShadows),
                        P.push(U.numPointLightShadows),
                        P.push(U.numSpotLightShadows),
                        P.push(U.numSpotLightShadowsWithMaps),
                        P.push(U.numLightProbes),
                        P.push(U.shadowMapType),
                        P.push(U.toneMapping),
                        P.push(U.numClippingPlanes),
                        P.push(U.numClipIntersection),
                        P.push(U.depthPacking)
                    }
                    function I(P, U) {
                        p.disableAll(),
                        U.instancing && p.enable(0),
                        U.instancingColor && p.enable(1),
                        U.instancingMorph && p.enable(2),
                        U.matcap && p.enable(3),
                        U.envMap && p.enable(4),
                        U.normalMapObjectSpace && p.enable(5),
                        U.normalMapTangentSpace && p.enable(6),
                        U.clearcoat && p.enable(7),
                        U.iridescence && p.enable(8),
                        U.alphaTest && p.enable(9),
                        U.vertexColors && p.enable(10),
                        U.vertexAlphas && p.enable(11),
                        U.vertexUv1s && p.enable(12),
                        U.vertexUv2s && p.enable(13),
                        U.vertexUv3s && p.enable(14),
                        U.vertexTangents && p.enable(15),
                        U.anisotropy && p.enable(16),
                        U.alphaHash && p.enable(17),
                        U.batching && p.enable(18),
                        U.dispersion && p.enable(19),
                        U.batchingColor && p.enable(20),
                        U.gradientMap && p.enable(21),
                        P.push(p.mask),
                        p.disableAll(),
                        U.fog && p.enable(0),
                        U.useFog && p.enable(1),
                        U.flatShading && p.enable(2),
                        U.logarithmicDepthBuffer && p.enable(3),
                        U.reversedDepthBuffer && p.enable(4),
                        U.skinning && p.enable(5),
                        U.morphTargets && p.enable(6),
                        U.morphNormals && p.enable(7),
                        U.morphColors && p.enable(8),
                        U.premultipliedAlpha && p.enable(9),
                        U.shadowMapEnabled && p.enable(10),
                        U.doubleSided && p.enable(11),
                        U.flipSided && p.enable(12),
                        U.useDepthPacking && p.enable(13),
                        U.dithering && p.enable(14),
                        U.transmission && p.enable(15),
                        U.sheen && p.enable(16),
                        U.opaque && p.enable(17),
                        U.pointsUvs && p.enable(18),
                        U.decodeVideoTexture && p.enable(19),
                        U.decodeVideoTextureEmissive && p.enable(20),
                        U.alphaToCoverage && p.enable(21),
                        P.push(p.mask)
                    }
                    function L(P) {
                        const U = C[P.type];
                        let W;
                        if (U) {
                            const K = Xr[U];
                            W = rM.clone(K.uniforms)
                        } else
                            W = P.uniforms;
                        return W
                    }
                    function k(P, U) {
                        let W = _.get(U);
                        return W !== void 0 ? ++W.usedTimes : (W = new IN(e,U,P,c),
                        v.push(W),
                        _.set(U, W)),
                        W
                    }
                    function B(P) {
                        if (--P.usedTimes === 0) {
                            const U = v.indexOf(P);
                            v[U] = v[v.length - 1],
                            v.pop(),
                            _.delete(P.cacheKey),
                            P.destroy()
                        }
                    }
                    function X(P) {
                        m.remove(P)
                    }
                    function G() {
                        m.dispose()
                    }
                    return {
                        getParameters: A,
                        getProgramCacheKey: E,
                        getUniforms: L,
                        acquireProgram: k,
                        releaseProgram: B,
                        releaseShaderCache: X,
                        programs: v,
                        dispose: G
                    }
                }
                function FN() {
                    let e = new WeakMap;
                    function t(f) {
                        return e.has(f)
                    }
                    function n(f) {
                        let p = e.get(f);
                        return p === void 0 && (p = {},
                        e.set(f, p)),
                        p
                    }
                    function a(f) {
                        e.delete(f)
                    }
                    function r(f, p, m) {
                        e.get(f)[p] = m
                    }
                    function c() {
                        e = new WeakMap
                    }
                    return {
                        has: t,
                        get: n,
                        remove: a,
                        update: r,
                        dispose: c
                    }
                }
                function VN(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                }
                function UE(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                }
                function IE() {
                    const e = [];
                    let t = 0;
                    const n = []
                      , a = []
                      , r = [];
                    function c() {
                        t = 0,
                        n.length = 0,
                        a.length = 0,
                        r.length = 0
                    }
                    function f(_, x, M, C, R, A) {
                        let E = e[t];
                        return E === void 0 ? (E = {
                            id: _.id,
                            object: _,
                            geometry: x,
                            material: M,
                            groupOrder: C,
                            renderOrder: _.renderOrder,
                            z: R,
                            group: A
                        },
                        e[t] = E) : (E.id = _.id,
                        E.object = _,
                        E.geometry = x,
                        E.material = M,
                        E.groupOrder = C,
                        E.renderOrder = _.renderOrder,
                        E.z = R,
                        E.group = A),
                        t++,
                        E
                    }
                    function p(_, x, M, C, R, A) {
                        const E = f(_, x, M, C, R, A);
                        M.transmission > 0 ? a.push(E) : M.transparent === !0 ? r.push(E) : n.push(E)
                    }
                    function m(_, x, M, C, R, A) {
                        const E = f(_, x, M, C, R, A);
                        M.transmission > 0 ? a.unshift(E) : M.transparent === !0 ? r.unshift(E) : n.unshift(E)
                    }
                    function g(_, x) {
                        n.length > 1 && n.sort(_ || VN),
                        a.length > 1 && a.sort(x || UE),
                        r.length > 1 && r.sort(x || UE)
                    }
                    function v() {
                        for (let _ = t, x = e.length; _ < x; _++) {
                            const M = e[_];
                            if (M.id === null)
                                break;
                            M.id = null,
                            M.object = null,
                            M.geometry = null,
                            M.material = null,
                            M.group = null
                        }
                    }
                    return {
                        opaque: n,
                        transmissive: a,
                        transparent: r,
                        init: c,
                        push: p,
                        unshift: m,
                        finish: v,
                        sort: g
                    }
                }
                function kN() {
                    let e = new WeakMap;
                    function t(a, r) {
                        const c = e.get(a);
                        let f;
                        return c === void 0 ? (f = new IE,
                        e.set(a, [f])) : r >= c.length ? (f = new IE,
                        c.push(f)) : f = c[r],
                        f
                    }
                    function n() {
                        e = new WeakMap
                    }
                    return {
                        get: t,
                        dispose: n
                    }
                }
                function HN() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (e[t.id] !== void 0)
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Y,
                                    color: new dt
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Y,
                                    direction: new Y,
                                    color: new dt,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Y,
                                    color: new dt,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Y,
                                    skyColor: new dt,
                                    groundColor: new dt
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new dt,
                                    position: new Y,
                                    halfWidth: new Y,
                                    halfHeight: new Y
                                };
                                break
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                function GN() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (e[t.id] !== void 0)
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Pe
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Pe
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Pe,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                let WN = 0;
                function XN(e, t) {
                    return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
                }
                function qN(e) {
                    const t = new HN
                      , n = GN()
                      , a = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                    for (let g = 0; g < 9; g++)
                        a.probe.push(new Y);
                    const r = new Y
                      , c = new Wt
                      , f = new Wt;
                    function p(g) {
                        let v = 0
                          , _ = 0
                          , x = 0;
                        for (let P = 0; P < 9; P++)
                            a.probe[P].set(0, 0, 0);
                        let M = 0
                          , C = 0
                          , R = 0
                          , A = 0
                          , E = 0
                          , N = 0
                          , I = 0
                          , L = 0
                          , k = 0
                          , B = 0
                          , X = 0;
                        g.sort(XN);
                        for (let P = 0, U = g.length; P < U; P++) {
                            const W = g[P]
                              , K = W.color
                              , q = W.intensity
                              , te = W.distance;
                            let ce = null;
                            if (W.shadow && W.shadow.map && (W.shadow.map.texture.format === Ou ? ce = W.shadow.map.texture : ce = W.shadow.map.depthTexture || W.shadow.map.texture),
                            W.isAmbientLight)
                                v += K.r * q,
                                _ += K.g * q,
                                x += K.b * q;
                            else if (W.isLightProbe) {
                                for (let J = 0; J < 9; J++)
                                    a.probe[J].addScaledVector(W.sh.coefficients[J], q);
                                X++
                            } else if (W.isDirectionalLight) {
                                const J = t.get(W);
                                if (J.color.copy(W.color).multiplyScalar(W.intensity),
                                W.castShadow) {
                                    const Q = W.shadow
                                      , se = n.get(W);
                                    se.shadowIntensity = Q.intensity,
                                    se.shadowBias = Q.bias,
                                    se.shadowNormalBias = Q.normalBias,
                                    se.shadowRadius = Q.radius,
                                    se.shadowMapSize = Q.mapSize,
                                    a.directionalShadow[M] = se,
                                    a.directionalShadowMap[M] = ce,
                                    a.directionalShadowMatrix[M] = W.shadow.matrix,
                                    N++
                                }
                                a.directional[M] = J,
                                M++
                            } else if (W.isSpotLight) {
                                const J = t.get(W);
                                J.position.setFromMatrixPosition(W.matrixWorld),
                                J.color.copy(K).multiplyScalar(q),
                                J.distance = te,
                                J.coneCos = Math.cos(W.angle),
                                J.penumbraCos = Math.cos(W.angle * (1 - W.penumbra)),
                                J.decay = W.decay,
                                a.spot[R] = J;
                                const Q = W.shadow;
                                if (W.map && (a.spotLightMap[k] = W.map,
                                k++,
                                Q.updateMatrices(W),
                                W.castShadow && B++),
                                a.spotLightMatrix[R] = Q.matrix,
                                W.castShadow) {
                                    const se = n.get(W);
                                    se.shadowIntensity = Q.intensity,
                                    se.shadowBias = Q.bias,
                                    se.shadowNormalBias = Q.normalBias,
                                    se.shadowRadius = Q.radius,
                                    se.shadowMapSize = Q.mapSize,
                                    a.spotShadow[R] = se,
                                    a.spotShadowMap[R] = ce,
                                    L++
                                }
                                R++
                            } else if (W.isRectAreaLight) {
                                const J = t.get(W);
                                J.color.copy(K).multiplyScalar(q),
                                J.halfWidth.set(W.width * .5, 0, 0),
                                J.halfHeight.set(0, W.height * .5, 0),
                                a.rectArea[A] = J,
                                A++
                            } else if (W.isPointLight) {
                                const J = t.get(W);
                                if (J.color.copy(W.color).multiplyScalar(W.intensity),
                                J.distance = W.distance,
                                J.decay = W.decay,
                                W.castShadow) {
                                    const Q = W.shadow
                                      , se = n.get(W);
                                    se.shadowIntensity = Q.intensity,
                                    se.shadowBias = Q.bias,
                                    se.shadowNormalBias = Q.normalBias,
                                    se.shadowRadius = Q.radius,
                                    se.shadowMapSize = Q.mapSize,
                                    se.shadowCameraNear = Q.camera.near,
                                    se.shadowCameraFar = Q.camera.far,
                                    a.pointShadow[C] = se,
                                    a.pointShadowMap[C] = ce,
                                    a.pointShadowMatrix[C] = W.shadow.matrix,
                                    I++
                                }
                                a.point[C] = J,
                                C++
                            } else if (W.isHemisphereLight) {
                                const J = t.get(W);
                                J.skyColor.copy(W.color).multiplyScalar(q),
                                J.groundColor.copy(W.groundColor).multiplyScalar(q),
                                a.hemi[E] = J,
                                E++
                            }
                        }
                        A > 0 && (e.has("OES_texture_float_linear") === !0 ? (a.rectAreaLTC1 = ct.LTC_FLOAT_1,
                        a.rectAreaLTC2 = ct.LTC_FLOAT_2) : (a.rectAreaLTC1 = ct.LTC_HALF_1,
                        a.rectAreaLTC2 = ct.LTC_HALF_2)),
                        a.ambient[0] = v,
                        a.ambient[1] = _,
                        a.ambient[2] = x;
                        const G = a.hash;
                        (G.directionalLength !== M || G.pointLength !== C || G.spotLength !== R || G.rectAreaLength !== A || G.hemiLength !== E || G.numDirectionalShadows !== N || G.numPointShadows !== I || G.numSpotShadows !== L || G.numSpotMaps !== k || G.numLightProbes !== X) && (a.directional.length = M,
                        a.spot.length = R,
                        a.rectArea.length = A,
                        a.point.length = C,
                        a.hemi.length = E,
                        a.directionalShadow.length = N,
                        a.directionalShadowMap.length = N,
                        a.pointShadow.length = I,
                        a.pointShadowMap.length = I,
                        a.spotShadow.length = L,
                        a.spotShadowMap.length = L,
                        a.directionalShadowMatrix.length = N,
                        a.pointShadowMatrix.length = I,
                        a.spotLightMatrix.length = L + k - B,
                        a.spotLightMap.length = k,
                        a.numSpotLightShadowsWithMaps = B,
                        a.numLightProbes = X,
                        G.directionalLength = M,
                        G.pointLength = C,
                        G.spotLength = R,
                        G.rectAreaLength = A,
                        G.hemiLength = E,
                        G.numDirectionalShadows = N,
                        G.numPointShadows = I,
                        G.numSpotShadows = L,
                        G.numSpotMaps = k,
                        G.numLightProbes = X,
                        a.version = WN++)
                    }
                    function m(g, v) {
                        let _ = 0
                          , x = 0
                          , M = 0
                          , C = 0
                          , R = 0;
                        const A = v.matrixWorldInverse;
                        for (let E = 0, N = g.length; E < N; E++) {
                            const I = g[E];
                            if (I.isDirectionalLight) {
                                const L = a.directional[_];
                                L.direction.setFromMatrixPosition(I.matrixWorld),
                                r.setFromMatrixPosition(I.target.matrixWorld),
                                L.direction.sub(r),
                                L.direction.transformDirection(A),
                                _++
                            } else if (I.isSpotLight) {
                                const L = a.spot[M];
                                L.position.setFromMatrixPosition(I.matrixWorld),
                                L.position.applyMatrix4(A),
                                L.direction.setFromMatrixPosition(I.matrixWorld),
                                r.setFromMatrixPosition(I.target.matrixWorld),
                                L.direction.sub(r),
                                L.direction.transformDirection(A),
                                M++
                            } else if (I.isRectAreaLight) {
                                const L = a.rectArea[C];
                                L.position.setFromMatrixPosition(I.matrixWorld),
                                L.position.applyMatrix4(A),
                                f.identity(),
                                c.copy(I.matrixWorld),
                                c.premultiply(A),
                                f.extractRotation(c),
                                L.halfWidth.set(I.width * .5, 0, 0),
                                L.halfHeight.set(0, I.height * .5, 0),
                                L.halfWidth.applyMatrix4(f),
                                L.halfHeight.applyMatrix4(f),
                                C++
                            } else if (I.isPointLight) {
                                const L = a.point[x];
                                L.position.setFromMatrixPosition(I.matrixWorld),
                                L.position.applyMatrix4(A),
                                x++
                            } else if (I.isHemisphereLight) {
                                const L = a.hemi[R];
                                L.direction.setFromMatrixPosition(I.matrixWorld),
                                L.direction.transformDirection(A),
                                R++
                            }
                        }
                    }
                    return {
                        setup: p,
                        setupView: m,
                        state: a
                    }
                }
                function OE(e) {
                    const t = new qN(e)
                      , n = []
                      , a = [];
                    function r(v) {
                        g.camera = v,
                        n.length = 0,
                        a.length = 0
                    }
                    function c(v) {
                        n.push(v)
                    }
                    function f(v) {
                        a.push(v)
                    }
                    function p() {
                        t.setup(n)
                    }
                    function m(v) {
                        t.setupView(n, v)
                    }
                    const g = {
                        lightsArray: n,
                        shadowsArray: a,
                        camera: null,
                        lights: t,
                        transmissionRenderTarget: {}
                    };
                    return {
                        init: r,
                        state: g,
                        setupLights: p,
                        setupLightsView: m,
                        pushLight: c,
                        pushShadow: f
                    }
                }
                function YN(e) {
                    let t = new WeakMap;
                    function n(r, c=0) {
                        const f = t.get(r);
                        let p;
                        return f === void 0 ? (p = new OE(e),
                        t.set(r, [p])) : c >= f.length ? (p = new OE(e),
                        f.push(p)) : p = f[c],
                        p
                    }
                    function a() {
                        t = new WeakMap
                    }
                    return {
                        get: n,
                        dispose: a
                    }
                }
                const jN = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
                  , ZN = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );
	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );
}`
                  , QN = [new Y(1,0,0), new Y(-1,0,0), new Y(0,1,0), new Y(0,-1,0), new Y(0,0,1), new Y(0,0,-1)]
                  , KN = [new Y(0,-1,0), new Y(0,-1,0), new Y(0,0,1), new Y(0,0,-1), new Y(0,-1,0), new Y(0,-1,0)]
                  , PE = new Wt
                  , bm = new Y
                  , nx = new Y;
                function JN(e, t, n) {
                    let a = new Gh;
                    const r = new Pe
                      , c = new Pe
                      , f = new ti
                      , p = new AS
                      , m = new wS
                      , g = {}
                      , v = n.maxTextureSize
                      , _ = {
                        [vl]: Qa,
                        [Qa]: vl,
                        [wo]: wo
                    }
                      , x = new dr({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Pe
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: jN,
                        fragmentShader: ZN
                    })
                      , M = x.clone();
                    M.defines.HORIZONTAL_PASS = 1;
                    const C = new Xt;
                    C.setAttribute("position", new Vn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                    const R = new Hi(C,x)
                      , A = this;
                    this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = fh;
                    let E = this.type;
                    this.render = function(B, X, G) {
                        if (A.enabled === !1 || A.autoUpdate === !1 && A.needsUpdate === !1 || B.length === 0)
                            return;
                        B.type === Cp && (ot("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead."),
                        B.type = fh);
                        const P = e.getRenderTarget()
                          , U = e.getActiveCubeFace()
                          , W = e.getActiveMipmapLevel()
                          , K = e.state;
                        K.setBlending(Co),
                        K.buffers.depth.getReversed() === !0 ? K.buffers.color.setClear(0, 0, 0, 0) : K.buffers.color.setClear(1, 1, 1, 1),
                        K.buffers.depth.setTest(!0),
                        K.setScissorTest(!1);
                        const q = E !== this.type;
                        q && X.traverse(function(te) {
                            te.material && (Array.isArray(te.material) ? te.material.forEach(ce => ce.needsUpdate = !0) : te.material.needsUpdate = !0)
                        });
                        for (let te = 0, ce = B.length; te < ce; te++) {
                            const J = B[te]
                              , Q = J.shadow;
                            if (Q === void 0) {
                                ot("WebGLShadowMap:", J, "has no shadow.");
                                continue
                            }
                            if (Q.autoUpdate === !1 && Q.needsUpdate === !1)
                                continue;
                            r.copy(Q.mapSize);
                            const se = Q.getFrameExtents();
                            if (r.multiply(se),
                            c.copy(Q.mapSize),
                            (r.x > v || r.y > v) && (r.x > v && (c.x = Math.floor(v / se.x),
                            r.x = c.x * se.x,
                            Q.mapSize.x = c.x),
                            r.y > v && (c.y = Math.floor(v / se.y),
                            r.y = c.y * se.y,
                            Q.mapSize.y = c.y)),
                            Q.map === null || q === !0) {
                                if (Q.map !== null && (Q.map.depthTexture !== null && (Q.map.depthTexture.dispose(),
                                Q.map.depthTexture = null),
                                Q.map.dispose()),
                                this.type === Lu) {
                                    if (J.isPointLight) {
                                        ot("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");
                                        continue
                                    }
                                    Q.map = new Vs(r.x,r.y,{
                                        format: Ou,
                                        type: No,
                                        minFilter: ei,
                                        magFilter: ei,
                                        generateMipmaps: !1
                                    }),
                                    Q.map.texture.name = J.name + ".shadowMap",
                                    Q.map.depthTexture = new Wh(r.x,r.y,Ja),
                                    Q.map.depthTexture.name = J.name + ".shadowMapDepth",
                                    Q.map.depthTexture.format = Lo,
                                    Q.map.depthTexture.compareFunction = null,
                                    Q.map.depthTexture.minFilter = Oi,
                                    Q.map.depthTexture.magFilter = Oi
                                } else {
                                    J.isPointLight ? (Q.map = new j_(r.x),
                                    Q.map.depthTexture = new HM(r.x,fr)) : (Q.map = new Vs(r.x,r.y),
                                    Q.map.depthTexture = new Wh(r.x,r.y,fr)),
                                    Q.map.depthTexture.name = J.name + ".shadowMap",
                                    Q.map.depthTexture.format = Lo;
                                    const Ee = e.state.buffers.depth.getReversed();
                                    this.type === fh ? (Q.map.depthTexture.compareFunction = Ee ? s0 : a0,
                                    Q.map.depthTexture.minFilter = ei,
                                    Q.map.depthTexture.magFilter = ei) : (Q.map.depthTexture.compareFunction = null,
                                    Q.map.depthTexture.minFilter = Oi,
                                    Q.map.depthTexture.magFilter = Oi)
                                }
                                Q.camera.updateProjectionMatrix()
                            }
                            const Te = Q.map.isWebGLCubeRenderTarget ? 6 : 1;
                            for (let Ee = 0; Ee < Te; Ee++) {
                                if (Q.map.isWebGLCubeRenderTarget)
                                    e.setRenderTarget(Q.map, Ee),
                                    e.clear();
                                else {
                                    Ee === 0 && (e.setRenderTarget(Q.map),
                                    e.clear());
                                    const Be = Q.getViewport(Ee);
                                    f.set(c.x * Be.x, c.y * Be.y, c.x * Be.z, c.y * Be.w),
                                    K.viewport(f)
                                }
                                if (J.isPointLight) {
                                    const Be = Q.camera
                                      , j = Q.matrix
                                      , ve = J.distance || Be.far;
                                    ve !== Be.far && (Be.far = ve,
                                    Be.updateProjectionMatrix()),
                                    bm.setFromMatrixPosition(J.matrixWorld),
                                    Be.position.copy(bm),
                                    nx.copy(Be.position),
                                    nx.add(QN[Ee]),
                                    Be.up.copy(KN[Ee]),
                                    Be.lookAt(nx),
                                    Be.updateMatrixWorld(),
                                    j.makeTranslation(-bm.x, -bm.y, -bm.z),
                                    PE.multiplyMatrices(Be.projectionMatrix, Be.matrixWorldInverse),
                                    Q._frustum.setFromProjectionMatrix(PE, Be.coordinateSystem, Be.reversedDepth)
                                } else
                                    Q.updateMatrices(J);
                                a = Q.getFrustum(),
                                L(X, G, Q.camera, J, this.type)
                            }
                            Q.isPointLightShadow !== !0 && this.type === Lu && N(Q, G),
                            Q.needsUpdate = !1
                        }
                        E = this.type,
                        A.needsUpdate = !1,
                        e.setRenderTarget(P, U, W)
                    }
                    ;
                    function N(B, X) {
                        const G = t.update(R);
                        x.defines.VSM_SAMPLES !== B.blurSamples && (x.defines.VSM_SAMPLES = B.blurSamples,
                        M.defines.VSM_SAMPLES = B.blurSamples,
                        x.needsUpdate = !0,
                        M.needsUpdate = !0),
                        B.mapPass === null && (B.mapPass = new Vs(r.x,r.y,{
                            format: Ou,
                            type: No
                        })),
                        x.uniforms.shadow_pass.value = B.map.depthTexture,
                        x.uniforms.resolution.value = B.mapSize,
                        x.uniforms.radius.value = B.radius,
                        e.setRenderTarget(B.mapPass),
                        e.clear(),
                        e.renderBufferDirect(X, null, G, x, R, null),
                        M.uniforms.shadow_pass.value = B.mapPass.texture,
                        M.uniforms.resolution.value = B.mapSize,
                        M.uniforms.radius.value = B.radius,
                        e.setRenderTarget(B.map),
                        e.clear(),
                        e.renderBufferDirect(X, null, G, M, R, null)
                    }
                    function I(B, X, G, P) {
                        let U = null;
                        const W = G.isPointLight === !0 ? B.customDistanceMaterial : B.customDepthMaterial;
                        if (W !== void 0)
                            U = W;
                        else if (U = G.isPointLight === !0 ? m : p,
                        e.localClippingEnabled && X.clipShadows === !0 && Array.isArray(X.clippingPlanes) && X.clippingPlanes.length !== 0 || X.displacementMap && X.displacementScale !== 0 || X.alphaMap && X.alphaTest > 0 || X.map && X.alphaTest > 0 || X.alphaToCoverage === !0) {
                            const K = U.uuid
                              , q = X.uuid;
                            let te = g[K];
                            te === void 0 && (te = {},
                            g[K] = te);
                            let ce = te[q];
                            ce === void 0 && (ce = U.clone(),
                            te[q] = ce,
                            X.addEventListener("dispose", k)),
                            U = ce
                        }
                        if (U.visible = X.visible,
                        U.wireframe = X.wireframe,
                        P === Lu ? U.side = X.shadowSide !== null ? X.shadowSide : X.side : U.side = X.shadowSide !== null ? X.shadowSide : _[X.side],
                        U.alphaMap = X.alphaMap,
                        U.alphaTest = X.alphaToCoverage === !0 ? .5 : X.alphaTest,
                        U.map = X.map,
                        U.clipShadows = X.clipShadows,
                        U.clippingPlanes = X.clippingPlanes,
                        U.clipIntersection = X.clipIntersection,
                        U.displacementMap = X.displacementMap,
                        U.displacementScale = X.displacementScale,
                        U.displacementBias = X.displacementBias,
                        U.wireframeLinewidth = X.wireframeLinewidth,
                        U.linewidth = X.linewidth,
                        G.isPointLight === !0 && U.isMeshDistanceMaterial === !0) {
                            const K = e.properties.get(U);
                            K.light = G
                        }
                        return U
                    }
                    function L(B, X, G, P, U) {
                        if (B.visible === !1)
                            return;
                        if (B.layers.test(X.layers) && (B.isMesh || B.isLine || B.isPoints) && (B.castShadow || B.receiveShadow && U === Lu) && (!B.frustumCulled || a.intersectsObject(B))) {
                            B.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, B.matrixWorld);
                            const K = t.update(B)
                              , q = B.material;
                            if (Array.isArray(q)) {
                                const te = K.groups;
                                for (let ce = 0, J = te.length; ce < J; ce++) {
                                    const Q = te[ce]
                                      , se = q[Q.materialIndex];
                                    if (se && se.visible) {
                                        const Te = I(B, se, P, U);
                                        B.onBeforeShadow(e, B, X, G, K, Te, Q),
                                        e.renderBufferDirect(G, null, K, Te, B, Q),
                                        B.onAfterShadow(e, B, X, G, K, Te, Q)
                                    }
                                }
                            } else if (q.visible) {
                                const te = I(B, q, P, U);
                                B.onBeforeShadow(e, B, X, G, K, te, null),
                                e.renderBufferDirect(G, null, K, te, B, null),
                                B.onAfterShadow(e, B, X, G, K, te, null)
                            }
                        }
                        const W = B.children;
                        for (let K = 0, q = W.length; K < q; K++)
                            L(W[K], X, G, P, U)
                    }
                    function k(B) {
                        B.target.removeEventListener("dispose", k);
                        for (const X in g) {
                            const G = g[X]
                              , P = B.target.uuid;
                            P in G && (G[P].dispose(),
                            delete G[P])
                        }
                    }
                }
                const $N = {
                    [lv]: cv,
                    [uv]: dv,
                    [fv]: pv,
                    [Iu]: hv,
                    [cv]: lv,
                    [dv]: uv,
                    [pv]: fv,
                    [hv]: Iu
                };
                function eL(e, t) {
                    function n() {
                        let ae = !1;
                        const nt = new ti;
                        let Ge = null;
                        const ht = new ti(0,0,0,0);
                        return {
                            setMask: function(Fe) {
                                Ge !== Fe && !ae && (e.colorMask(Fe, Fe, Fe, Fe),
                                Ge = Fe)
                            },
                            setLocked: function(Fe) {
                                ae = Fe
                            },
                            setClear: function(Fe, xe, pt, Mt, In) {
                                In === !0 && (Fe *= Mt,
                                xe *= Mt,
                                pt *= Mt),
                                nt.set(Fe, xe, pt, Mt),
                                ht.equals(nt) === !1 && (e.clearColor(Fe, xe, pt, Mt),
                                ht.copy(nt))
                            },
                            reset: function() {
                                ae = !1,
                                Ge = null,
                                ht.set(-1, 0, 0, 0)
                            }
                        }
                    }
                    function a() {
                        let ae = !1
                          , nt = !1
                          , Ge = null
                          , ht = null
                          , Fe = null;
                        return {
                            setReversed: function(xe) {
                                if (nt !== xe) {
                                    const pt = t.get("EXT_clip_control");
                                    xe ? pt.clipControlEXT(pt.LOWER_LEFT_EXT, pt.ZERO_TO_ONE_EXT) : pt.clipControlEXT(pt.LOWER_LEFT_EXT, pt.NEGATIVE_ONE_TO_ONE_EXT),
                                    nt = xe;
                                    const Mt = Fe;
                                    Fe = null,
                                    this.setClear(Mt)
                                }
                            },
                            getReversed: function() {
                                return nt
                            },
                            setTest: function(xe) {
                                xe ? Ne(e.DEPTH_TEST) : ke(e.DEPTH_TEST)
                            },
                            setMask: function(xe) {
                                Ge !== xe && !ae && (e.depthMask(xe),
                                Ge = xe)
                            },
                            setFunc: function(xe) {
                                if (nt && (xe = $N[xe]),
                                ht !== xe) {
                                    switch (xe) {
                                    case lv:
                                        e.depthFunc(e.NEVER);
                                        break;
                                    case cv:
                                        e.depthFunc(e.ALWAYS);
                                        break;
                                    case uv:
                                        e.depthFunc(e.LESS);
                                        break;
                                    case Iu:
                                        e.depthFunc(e.LEQUAL);
                                        break;
                                    case fv:
                                        e.depthFunc(e.EQUAL);
                                        break;
                                    case hv:
                                        e.depthFunc(e.GEQUAL);
                                        break;
                                    case dv:
                                        e.depthFunc(e.GREATER);
                                        break;
                                    case pv:
                                        e.depthFunc(e.NOTEQUAL);
                                        break;
                                    default:
                                        e.depthFunc(e.LEQUAL)
                                    }
                                    ht = xe
                                }
                            },
                            setLocked: function(xe) {
                                ae = xe
                            },
                            setClear: function(xe) {
                                Fe !== xe && (nt && (xe = 1 - xe),
                                e.clearDepth(xe),
                                Fe = xe)
                            },
                            reset: function() {
                                ae = !1,
                                Ge = null,
                                ht = null,
                                Fe = null,
                                nt = !1
                            }
                        }
                    }
                    function r() {
                        let ae = !1
                          , nt = null
                          , Ge = null
                          , ht = null
                          , Fe = null
                          , xe = null
                          , pt = null
                          , Mt = null
                          , In = null;
                        return {
                            setTest: function(xn) {
                                ae || (xn ? Ne(e.STENCIL_TEST) : ke(e.STENCIL_TEST))
                            },
                            setMask: function(xn) {
                                nt !== xn && !ae && (e.stencilMask(xn),
                                nt = xn)
                            },
                            setFunc: function(xn, xa, Gi) {
                                (Ge !== xn || ht !== xa || Fe !== Gi) && (e.stencilFunc(xn, xa, Gi),
                                Ge = xn,
                                ht = xa,
                                Fe = Gi)
                            },
                            setOp: function(xn, xa, Gi) {
                                (xe !== xn || pt !== xa || Mt !== Gi) && (e.stencilOp(xn, xa, Gi),
                                xe = xn,
                                pt = xa,
                                Mt = Gi)
                            },
                            setLocked: function(xn) {
                                ae = xn
                            },
                            setClear: function(xn) {
                                In !== xn && (e.clearStencil(xn),
                                In = xn)
                            },
                            reset: function() {
                                ae = !1,
                                nt = null,
                                Ge = null,
                                ht = null,
                                Fe = null,
                                xe = null,
                                pt = null,
                                Mt = null,
                                In = null
                            }
                        }
                    }
                    const c = new n
                      , f = new a
                      , p = new r
                      , m = new WeakMap
                      , g = new WeakMap;
                    let v = {}
                      , _ = {}
                      , x = new WeakMap
                      , M = []
                      , C = null
                      , R = !1
                      , A = null
                      , E = null
                      , N = null
                      , I = null
                      , L = null
                      , k = null
                      , B = null
                      , X = new dt(0,0,0)
                      , G = 0
                      , P = !1
                      , U = null
                      , W = null
                      , K = null
                      , q = null
                      , te = null;
                    const ce = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    let J = !1
                      , Q = 0;
                    const se = e.getParameter(e.VERSION);
                    se.indexOf("WebGL") !== -1 ? (Q = parseFloat(/^WebGL (\d)/.exec(se)[1]),
                    J = Q >= 1) : se.indexOf("OpenGL ES") !== -1 && (Q = parseFloat(/^OpenGL ES (\d)/.exec(se)[1]),
                    J = Q >= 2);
                    let Te = null
                      , Ee = {};
                    const Be = e.getParameter(e.SCISSOR_BOX)
                      , j = e.getParameter(e.VIEWPORT)
                      , ve = new ti().fromArray(Be)
                      , Re = new ti().fromArray(j);
                    function le(ae, nt, Ge, ht) {
                        const Fe = new Uint8Array(4)
                          , xe = e.createTexture();
                        e.bindTexture(ae, xe),
                        e.texParameteri(ae, e.TEXTURE_MIN_FILTER, e.NEAREST),
                        e.texParameteri(ae, e.TEXTURE_MAG_FILTER, e.NEAREST);
                        for (let pt = 0; pt < Ge; pt++)
                            ae === e.TEXTURE_3D || ae === e.TEXTURE_2D_ARRAY ? e.texImage3D(nt, 0, e.RGBA, 1, 1, ht, 0, e.RGBA, e.UNSIGNED_BYTE, Fe) : e.texImage2D(nt + pt, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, Fe);
                        return xe
                    }
                    const Ae = {};
                    Ae[e.TEXTURE_2D] = le(e.TEXTURE_2D, e.TEXTURE_2D, 1),
                    Ae[e.TEXTURE_CUBE_MAP] = le(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                    Ae[e.TEXTURE_2D_ARRAY] = le(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
                    Ae[e.TEXTURE_3D] = le(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
                    c.setClear(0, 0, 0, 1),
                    f.setClear(1),
                    p.setClear(0),
                    Ne(e.DEPTH_TEST),
                    f.setFunc(Iu),
                    tt(!1),
                    Z(i_),
                    Ne(e.CULL_FACE),
                    Ye(Co);
                    function Ne(ae) {
                        v[ae] !== !0 && (e.enable(ae),
                        v[ae] = !0)
                    }
                    function ke(ae) {
                        v[ae] !== !1 && (e.disable(ae),
                        v[ae] = !1)
                    }
                    function at(ae, nt) {
                        return _[ae] !== nt ? (e.bindFramebuffer(ae, nt),
                        _[ae] = nt,
                        ae === e.DRAW_FRAMEBUFFER && (_[e.FRAMEBUFFER] = nt),
                        ae === e.FRAMEBUFFER && (_[e.DRAW_FRAMEBUFFER] = nt),
                        !0) : !1
                    }
                    function Je(ae, nt) {
                        let Ge = M
                          , ht = !1;
                        if (ae) {
                            Ge = x.get(nt),
                            Ge === void 0 && (Ge = [],
                            x.set(nt, Ge));
                            const Fe = ae.textures;
                            if (Ge.length !== Fe.length || Ge[0] !== e.COLOR_ATTACHMENT0) {
                                for (let xe = 0, pt = Fe.length; xe < pt; xe++)
                                    Ge[xe] = e.COLOR_ATTACHMENT0 + xe;
                                Ge.length = Fe.length,
                                ht = !0
                            }
                        } else
                            Ge[0] !== e.BACK && (Ge[0] = e.BACK,
                            ht = !0);
                        ht && e.drawBuffers(Ge)
                    }
                    function Ft(ae) {
                        return C !== ae ? (e.useProgram(ae),
                        C = ae,
                        !0) : !1
                    }
                    const Vt = {
                        [gc]: e.FUNC_ADD,
                        [ob]: e.FUNC_SUBTRACT,
                        [lb]: e.FUNC_REVERSE_SUBTRACT
                    };
                    Vt[cb] = e.MIN,
                    Vt[ub] = e.MAX;
                    const we = {
                        [fb]: e.ZERO,
                        [hb]: e.ONE,
                        [db]: e.SRC_COLOR,
                        [rv]: e.SRC_ALPHA,
                        [_b]: e.SRC_ALPHA_SATURATE,
                        [vb]: e.DST_COLOR,
                        [mb]: e.DST_ALPHA,
                        [pb]: e.ONE_MINUS_SRC_COLOR,
                        [ov]: e.ONE_MINUS_SRC_ALPHA,
                        [yb]: e.ONE_MINUS_DST_COLOR,
                        [gb]: e.ONE_MINUS_DST_ALPHA,
                        [Sb]: e.CONSTANT_COLOR,
                        [xb]: e.ONE_MINUS_CONSTANT_COLOR,
                        [bb]: e.CONSTANT_ALPHA,
                        [Mb]: e.ONE_MINUS_CONSTANT_ALPHA
                    };
                    function Ye(ae, nt, Ge, ht, Fe, xe, pt, Mt, In, xn) {
                        if (ae === Co) {
                            R === !0 && (ke(e.BLEND),
                            R = !1);
                            return
                        }
                        if (R === !1 && (Ne(e.BLEND),
                        R = !0),
                        ae !== rb) {
                            if (ae !== A || xn !== P) {
                                if ((E !== gc || L !== gc) && (e.blendEquation(e.FUNC_ADD),
                                E = gc,
                                L = gc),
                                xn)
                                    switch (ae) {
                                    case Uu:
                                        e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case a_:
                                        e.blendFunc(e.ONE, e.ONE);
                                        break;
                                    case s_:
                                        e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                        break;
                                    case r_:
                                        e.blendFuncSeparate(e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ZERO, e.ONE);
                                        break;
                                    default:
                                        Et("WebGLState: Invalid blending: ", ae);
                                        break
                                    }
                                else
                                    switch (ae) {
                                    case Uu:
                                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                        break;
                                    case a_:
                                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE);
                                        break;
                                    case s_:
                                        Et("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                                        break;
                                    case r_:
                                        Et("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                                        break;
                                    default:
                                        Et("WebGLState: Invalid blending: ", ae);
                                        break
                                    }
                                N = null,
                                I = null,
                                k = null,
                                B = null,
                                X.set(0, 0, 0),
                                G = 0,
                                A = ae,
                                P = xn
                            }
                            return
                        }
                        Fe = Fe || nt,
                        xe = xe || Ge,
                        pt = pt || ht,
                        (nt !== E || Fe !== L) && (e.blendEquationSeparate(Vt[nt], Vt[Fe]),
                        E = nt,
                        L = Fe),
                        (Ge !== N || ht !== I || xe !== k || pt !== B) && (e.blendFuncSeparate(we[Ge], we[ht], we[xe], we[pt]),
                        N = Ge,
                        I = ht,
                        k = xe,
                        B = pt),
                        (Mt.equals(X) === !1 || In !== G) && (e.blendColor(Mt.r, Mt.g, Mt.b, In),
                        X.copy(Mt),
                        G = In),
                        A = ae,
                        P = !1
                    }
                    function Ve(ae, nt) {
                        ae.side === wo ? ke(e.CULL_FACE) : Ne(e.CULL_FACE);
                        let Ge = ae.side === Qa;
                        nt && (Ge = !Ge),
                        tt(Ge),
                        ae.blending === Uu && ae.transparent === !1 ? Ye(Co) : Ye(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.blendColor, ae.blendAlpha, ae.premultipliedAlpha),
                        f.setFunc(ae.depthFunc),
                        f.setTest(ae.depthTest),
                        f.setMask(ae.depthWrite),
                        c.setMask(ae.colorWrite);
                        const ht = ae.stencilWrite;
                        p.setTest(ht),
                        ht && (p.setMask(ae.stencilWriteMask),
                        p.setFunc(ae.stencilFunc, ae.stencilRef, ae.stencilFuncMask),
                        p.setOp(ae.stencilFail, ae.stencilZFail, ae.stencilZPass)),
                        $e(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits),
                        ae.alphaToCoverage === !0 ? Ne(e.SAMPLE_ALPHA_TO_COVERAGE) : ke(e.SAMPLE_ALPHA_TO_COVERAGE)
                    }
                    function tt(ae) {
                        U !== ae && (ae ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                        U = ae)
                    }
                    function Z(ae) {
                        ae !== ib ? (Ne(e.CULL_FACE),
                        ae !== W && (ae === i_ ? e.cullFace(e.BACK) : ae === ab ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : ke(e.CULL_FACE),
                        W = ae
                    }
                    function At(ae) {
                        ae !== K && (J && e.lineWidth(ae),
                        K = ae)
                    }
                    function $e(ae, nt, Ge) {
                        ae ? (Ne(e.POLYGON_OFFSET_FILL),
                        (q !== nt || te !== Ge) && (e.polygonOffset(nt, Ge),
                        q = nt,
                        te = Ge)) : ke(e.POLYGON_OFFSET_FILL)
                    }
                    function xt(ae) {
                        ae ? Ne(e.SCISSOR_TEST) : ke(e.SCISSOR_TEST)
                    }
                    function Ke(ae) {
                        ae === void 0 && (ae = e.TEXTURE0 + ce - 1),
                        Te !== ae && (e.activeTexture(ae),
                        Te = ae)
                    }
                    function wt(ae, nt, Ge) {
                        Ge === void 0 && (Te === null ? Ge = e.TEXTURE0 + ce - 1 : Ge = Te);
                        let ht = Ee[Ge];
                        ht === void 0 && (ht = {
                            type: void 0,
                            texture: void 0
                        },
                        Ee[Ge] = ht),
                        (ht.type !== ae || ht.texture !== nt) && (Te !== Ge && (e.activeTexture(Ge),
                        Te = Ge),
                        e.bindTexture(ae, nt || Ae[ae]),
                        ht.type = ae,
                        ht.texture = nt)
                    }
                    function H() {
                        const ae = Ee[Te];
                        ae !== void 0 && ae.type !== void 0 && (e.bindTexture(ae.type, null),
                        ae.type = void 0,
                        ae.texture = void 0)
                    }
                    function O() {
                        try {
                            e.compressedTexImage2D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function oe() {
                        try {
                            e.compressedTexImage3D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function Ce() {
                        try {
                            e.texSubImage2D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function Ue() {
                        try {
                            e.texSubImage3D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function Me() {
                        try {
                            e.compressedTexSubImage2D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function st() {
                        try {
                            e.compressedTexSubImage3D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function je() {
                        try {
                            e.texStorage2D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function St() {
                        try {
                            e.texStorage3D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function Ct() {
                        try {
                            e.texImage2D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function He() {
                        try {
                            e.texImage3D(...arguments)
                        } catch (ae) {
                            Et("WebGLState:", ae)
                        }
                    }
                    function We(ae) {
                        ve.equals(ae) === !1 && (e.scissor(ae.x, ae.y, ae.z, ae.w),
                        ve.copy(ae))
                    }
                    function rt(ae) {
                        Re.equals(ae) === !1 && (e.viewport(ae.x, ae.y, ae.z, ae.w),
                        Re.copy(ae))
                    }
                    function ft(ae, nt) {
                        let Ge = g.get(nt);
                        Ge === void 0 && (Ge = new WeakMap,
                        g.set(nt, Ge));
                        let ht = Ge.get(ae);
                        ht === void 0 && (ht = e.getUniformBlockIndex(nt, ae.name),
                        Ge.set(ae, ht))
                    }
                    function et(ae, nt) {
                        const Ge = g.get(nt).get(ae);
                        m.get(nt) !== Ge && (e.uniformBlockBinding(nt, Ge, ae.__bindingPointIndex),
                        m.set(nt, Ge))
                    }
                    function qt() {
                        e.disable(e.BLEND),
                        e.disable(e.CULL_FACE),
                        e.disable(e.DEPTH_TEST),
                        e.disable(e.POLYGON_OFFSET_FILL),
                        e.disable(e.SCISSOR_TEST),
                        e.disable(e.STENCIL_TEST),
                        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                        e.blendEquation(e.FUNC_ADD),
                        e.blendFunc(e.ONE, e.ZERO),
                        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                        e.blendColor(0, 0, 0, 0),
                        e.colorMask(!0, !0, !0, !0),
                        e.clearColor(0, 0, 0, 0),
                        e.depthMask(!0),
                        e.depthFunc(e.LESS),
                        f.setReversed(!1),
                        e.clearDepth(1),
                        e.stencilMask(4294967295),
                        e.stencilFunc(e.ALWAYS, 0, 4294967295),
                        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                        e.clearStencil(0),
                        e.cullFace(e.BACK),
                        e.frontFace(e.CCW),
                        e.polygonOffset(0, 0),
                        e.activeTexture(e.TEXTURE0),
                        e.bindFramebuffer(e.FRAMEBUFFER, null),
                        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        e.useProgram(null),
                        e.lineWidth(1),
                        e.scissor(0, 0, e.canvas.width, e.canvas.height),
                        e.viewport(0, 0, e.canvas.width, e.canvas.height),
                        v = {},
                        Te = null,
                        Ee = {},
                        _ = {},
                        x = new WeakMap,
                        M = [],
                        C = null,
                        R = !1,
                        A = null,
                        E = null,
                        N = null,
                        I = null,
                        L = null,
                        k = null,
                        B = null,
                        X = new dt(0,0,0),
                        G = 0,
                        P = !1,
                        U = null,
                        W = null,
                        K = null,
                        q = null,
                        te = null,
                        ve.set(0, 0, e.canvas.width, e.canvas.height),
                        Re.set(0, 0, e.canvas.width, e.canvas.height),
                        c.reset(),
                        f.reset(),
                        p.reset()
                    }
                    return {
                        buffers: {
                            color: c,
                            depth: f,
                            stencil: p
                        },
                        enable: Ne,
                        disable: ke,
                        bindFramebuffer: at,
                        drawBuffers: Je,
                        useProgram: Ft,
                        setBlending: Ye,
                        setMaterial: Ve,
                        setFlipSided: tt,
                        setCullFace: Z,
                        setLineWidth: At,
                        setPolygonOffset: $e,
                        setScissorTest: xt,
                        activeTexture: Ke,
                        bindTexture: wt,
                        unbindTexture: H,
                        compressedTexImage2D: O,
                        compressedTexImage3D: oe,
                        texImage2D: Ct,
                        texImage3D: He,
                        updateUBOMapping: ft,
                        uniformBlockBinding: et,
                        texStorage2D: je,
                        texStorage3D: St,
                        texSubImage2D: Ce,
                        texSubImage3D: Ue,
                        compressedTexSubImage2D: Me,
                        compressedTexSubImage3D: st,
                        scissor: We,
                        viewport: rt,
                        reset: qt
                    }
                }
                function tL(e, t, n, a, r, c, f) {
                    const p = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
                      , m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
                      , g = new Pe
                      , v = new WeakMap;
                    let _;
                    const x = new WeakMap;
                    let M = !1;
                    try {
                        M = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
                    } catch {}
                    function C(H, O) {
                        return M ? new OffscreenCanvas(H,O) : Wp("canvas")
                    }
                    function R(H, O, oe) {
                        let Ce = 1;
                        const Ue = wt(H);
                        if ((Ue.width > oe || Ue.height > oe) && (Ce = oe / Math.max(Ue.width, Ue.height)),
                        Ce < 1)
                            if (typeof HTMLImageElement < "u" && H instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && H instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && H instanceof ImageBitmap || typeof VideoFrame < "u" && H instanceof VideoFrame) {
                                const Me = Math.floor(Ce * Ue.width)
                                  , st = Math.floor(Ce * Ue.height);
                                _ === void 0 && (_ = C(Me, st));
                                const je = O ? C(Me, st) : _;
                                return je.width = Me,
                                je.height = st,
                                je.getContext("2d").drawImage(H, 0, 0, Me, st),
                                ot("WebGLRenderer: Texture has been resized from (" + Ue.width + "x" + Ue.height + ") to (" + Me + "x" + st + ")."),
                                je
                            } else
                                return "data"in H && ot("WebGLRenderer: Image in DataTexture is too big (" + Ue.width + "x" + Ue.height + ")."),
                                H;
                        return H
                    }
                    function A(H) {
                        return H.generateMipmaps
                    }
                    function E(H) {
                        e.generateMipmap(H)
                    }
                    function N(H) {
                        return H.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : H.isWebGL3DRenderTarget ? e.TEXTURE_3D : H.isWebGLArrayRenderTarget || H.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
                    }
                    function I(H, O, oe, Ce, Ue=!1) {
                        if (H !== null) {
                            if (e[H] !== void 0)
                                return e[H];
                            ot("WebGLRenderer: Attempt to use non-existing WebGL internal format '" + H + "'")
                        }
                        let Me = O;
                        if (O === e.RED && (oe === e.FLOAT && (Me = e.R32F),
                        oe === e.HALF_FLOAT && (Me = e.R16F),
                        oe === e.UNSIGNED_BYTE && (Me = e.R8)),
                        O === e.RED_INTEGER && (oe === e.UNSIGNED_BYTE && (Me = e.R8UI),
                        oe === e.UNSIGNED_SHORT && (Me = e.R16UI),
                        oe === e.UNSIGNED_INT && (Me = e.R32UI),
                        oe === e.BYTE && (Me = e.R8I),
                        oe === e.SHORT && (Me = e.R16I),
                        oe === e.INT && (Me = e.R32I)),
                        O === e.RG && (oe === e.FLOAT && (Me = e.RG32F),
                        oe === e.HALF_FLOAT && (Me = e.RG16F),
                        oe === e.UNSIGNED_BYTE && (Me = e.RG8)),
                        O === e.RG_INTEGER && (oe === e.UNSIGNED_BYTE && (Me = e.RG8UI),
                        oe === e.UNSIGNED_SHORT && (Me = e.RG16UI),
                        oe === e.UNSIGNED_INT && (Me = e.RG32UI),
                        oe === e.BYTE && (Me = e.RG8I),
                        oe === e.SHORT && (Me = e.RG16I),
                        oe === e.INT && (Me = e.RG32I)),
                        O === e.RGB_INTEGER && (oe === e.UNSIGNED_BYTE && (Me = e.RGB8UI),
                        oe === e.UNSIGNED_SHORT && (Me = e.RGB16UI),
                        oe === e.UNSIGNED_INT && (Me = e.RGB32UI),
                        oe === e.BYTE && (Me = e.RGB8I),
                        oe === e.SHORT && (Me = e.RGB16I),
                        oe === e.INT && (Me = e.RGB32I)),
                        O === e.RGBA_INTEGER && (oe === e.UNSIGNED_BYTE && (Me = e.RGBA8UI),
                        oe === e.UNSIGNED_SHORT && (Me = e.RGBA16UI),
                        oe === e.UNSIGNED_INT && (Me = e.RGBA32UI),
                        oe === e.BYTE && (Me = e.RGBA8I),
                        oe === e.SHORT && (Me = e.RGBA16I),
                        oe === e.INT && (Me = e.RGBA32I)),
                        O === e.RGB && (oe === e.UNSIGNED_INT_5_9_9_9_REV && (Me = e.RGB9_E5),
                        oe === e.UNSIGNED_INT_10F_11F_11F_REV && (Me = e.R11F_G11F_B10F)),
                        O === e.RGBA) {
                            const st = Ue ? Hp : Sn.getTransfer(Ce);
                            oe === e.FLOAT && (Me = e.RGBA32F),
                            oe === e.HALF_FLOAT && (Me = e.RGBA16F),
                            oe === e.UNSIGNED_BYTE && (Me = st === Un ? e.SRGB8_ALPHA8 : e.RGBA8),
                            oe === e.UNSIGNED_SHORT_4_4_4_4 && (Me = e.RGBA4),
                            oe === e.UNSIGNED_SHORT_5_5_5_1 && (Me = e.RGB5_A1)
                        }
                        return (Me === e.R16F || Me === e.R32F || Me === e.RG16F || Me === e.RG32F || Me === e.RGBA16F || Me === e.RGBA32F) && t.get("EXT_color_buffer_float"),
                        Me
                    }
                    function L(H, O) {
                        let oe;
                        return H ? O === null || O === fr || O === mh ? oe = e.DEPTH24_STENCIL8 : O === Ja ? oe = e.DEPTH32F_STENCIL8 : O === ph && (oe = e.DEPTH24_STENCIL8,
                        ot("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : O === null || O === fr || O === mh ? oe = e.DEPTH_COMPONENT24 : O === Ja ? oe = e.DEPTH_COMPONENT32F : O === ph && (oe = e.DEPTH_COMPONENT16),
                        oe
                    }
                    function k(H, O) {
                        return A(H) === !0 || H.isFramebufferTexture && H.minFilter !== Oi && H.minFilter !== ei ? Math.log2(Math.max(O.width, O.height)) + 1 : H.mipmaps !== void 0 && H.mipmaps.length > 0 ? H.mipmaps.length : H.isCompressedTexture && Array.isArray(H.image) ? O.mipmaps.length : 1
                    }
                    function B(H) {
                        const O = H.target;
                        O.removeEventListener("dispose", B),
                        G(O),
                        O.isVideoTexture && v.delete(O)
                    }
                    function X(H) {
                        const O = H.target;
                        O.removeEventListener("dispose", X),
                        U(O)
                    }
                    function G(H) {
                        const O = a.get(H);
                        if (O.__webglInit === void 0)
                            return;
                        const oe = H.source
                          , Ce = x.get(oe);
                        if (Ce) {
                            const Ue = Ce[O.__cacheKey];
                            Ue.usedTimes--,
                            Ue.usedTimes === 0 && P(H),
                            Object.keys(Ce).length === 0 && x.delete(oe)
                        }
                        a.remove(H)
                    }
                    function P(H) {
                        const O = a.get(H);
                        e.deleteTexture(O.__webglTexture);
                        const oe = H.source
                          , Ce = x.get(oe);
                        delete Ce[O.__cacheKey],
                        f.memory.textures--
                    }
                    function U(H) {
                        const O = a.get(H);
                        if (H.depthTexture && (H.depthTexture.dispose(),
                        a.remove(H.depthTexture)),
                        H.isWebGLCubeRenderTarget)
                            for (let Ce = 0; Ce < 6; Ce++) {
                                if (Array.isArray(O.__webglFramebuffer[Ce]))
                                    for (let Ue = 0; Ue < O.__webglFramebuffer[Ce].length; Ue++)
                                        e.deleteFramebuffer(O.__webglFramebuffer[Ce][Ue]);
                                else
                                    e.deleteFramebuffer(O.__webglFramebuffer[Ce]);
                                O.__webglDepthbuffer && e.deleteRenderbuffer(O.__webglDepthbuffer[Ce])
                            }
                        else {
                            if (Array.isArray(O.__webglFramebuffer))
                                for (let Ce = 0; Ce < O.__webglFramebuffer.length; Ce++)
                                    e.deleteFramebuffer(O.__webglFramebuffer[Ce]);
                            else
                                e.deleteFramebuffer(O.__webglFramebuffer);
                            if (O.__webglDepthbuffer && e.deleteRenderbuffer(O.__webglDepthbuffer),
                            O.__webglMultisampledFramebuffer && e.deleteFramebuffer(O.__webglMultisampledFramebuffer),
                            O.__webglColorRenderbuffer)
                                for (let Ce = 0; Ce < O.__webglColorRenderbuffer.length; Ce++)
                                    O.__webglColorRenderbuffer[Ce] && e.deleteRenderbuffer(O.__webglColorRenderbuffer[Ce]);
                            O.__webglDepthRenderbuffer && e.deleteRenderbuffer(O.__webglDepthRenderbuffer)
                        }
                        const oe = H.textures;
                        for (let Ce = 0, Ue = oe.length; Ce < Ue; Ce++) {
                            const Me = a.get(oe[Ce]);
                            Me.__webglTexture && (e.deleteTexture(Me.__webglTexture),
                            f.memory.textures--),
                            a.remove(oe[Ce])
                        }
                        a.remove(H)
                    }
                    let W = 0;
                    function K() {
                        W = 0
                    }
                    function q() {
                        const H = W;
                        return H >= r.maxTextures && ot("WebGLTextures: Trying to use " + H + " texture units while this GPU supports only " + r.maxTextures),
                        W += 1,
                        H
                    }
                    function te(H) {
                        const O = [];
                        return O.push(H.wrapS),
                        O.push(H.wrapT),
                        O.push(H.wrapR || 0),
                        O.push(H.magFilter),
                        O.push(H.minFilter),
                        O.push(H.anisotropy),
                        O.push(H.internalFormat),
                        O.push(H.format),
                        O.push(H.type),
                        O.push(H.generateMipmaps),
                        O.push(H.premultiplyAlpha),
                        O.push(H.flipY),
                        O.push(H.unpackAlignment),
                        O.push(H.colorSpace),
                        O.join()
                    }
                    function ce(H, O) {
                        const oe = a.get(H);
                        if (H.isVideoTexture && xt(H),
                        H.isRenderTargetTexture === !1 && H.isExternalTexture !== !0 && H.version > 0 && oe.__version !== H.version) {
                            const Ce = H.image;
                            if (Ce === null)
                                ot("WebGLRenderer: Texture marked for update but no image data found.");
                            else if (Ce.complete === !1)
                                ot("WebGLRenderer: Texture marked for update but image is incomplete");
                            else {
                                Ae(oe, H, O);
                                return
                            }
                        } else
                            H.isExternalTexture && (oe.__webglTexture = H.sourceTexture ? H.sourceTexture : null);
                        n.bindTexture(e.TEXTURE_2D, oe.__webglTexture, e.TEXTURE0 + O)
                    }
                    function J(H, O) {
                        const oe = a.get(H);
                        if (H.isRenderTargetTexture === !1 && H.version > 0 && oe.__version !== H.version) {
                            Ae(oe, H, O);
                            return
                        } else
                            H.isExternalTexture && (oe.__webglTexture = H.sourceTexture ? H.sourceTexture : null);
                        n.bindTexture(e.TEXTURE_2D_ARRAY, oe.__webglTexture, e.TEXTURE0 + O)
                    }
                    function Q(H, O) {
                        const oe = a.get(H);
                        if (H.isRenderTargetTexture === !1 && H.version > 0 && oe.__version !== H.version) {
                            Ae(oe, H, O);
                            return
                        }
                        n.bindTexture(e.TEXTURE_3D, oe.__webglTexture, e.TEXTURE0 + O)
                    }
                    function se(H, O) {
                        const oe = a.get(H);
                        if (H.isCubeDepthTexture !== !0 && H.version > 0 && oe.__version !== H.version) {
                            Ne(oe, H, O);
                            return
                        }
                        n.bindTexture(e.TEXTURE_CUBE_MAP, oe.__webglTexture, e.TEXTURE0 + O)
                    }
                    const Te = {
                        [Lp]: e.REPEAT,
                        [Ss]: e.CLAMP_TO_EDGE,
                        [Up]: e.MIRRORED_REPEAT
                    }
                      , Ee = {
                        [Oi]: e.NEAREST,
                        [p_]: e.NEAREST_MIPMAP_NEAREST,
                        [dh]: e.NEAREST_MIPMAP_LINEAR,
                        [ei]: e.LINEAR,
                        [Ip]: e.LINEAR_MIPMAP_NEAREST,
                        [Do]: e.LINEAR_MIPMAP_LINEAR
                    }
                      , Be = {
                        [Lb]: e.NEVER,
                        [zb]: e.ALWAYS,
                        [Ub]: e.LESS,
                        [a0]: e.LEQUAL,
                        [Ib]: e.EQUAL,
                        [s0]: e.GEQUAL,
                        [Ob]: e.GREATER,
                        [Pb]: e.NOTEQUAL
                    };
                    function j(H, O) {
                        if (O.type === Ja && t.has("OES_texture_float_linear") === !1 && (O.magFilter === ei || O.magFilter === Ip || O.magFilter === dh || O.magFilter === Do || O.minFilter === ei || O.minFilter === Ip || O.minFilter === dh || O.minFilter === Do) && ot("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                        e.texParameteri(H, e.TEXTURE_WRAP_S, Te[O.wrapS]),
                        e.texParameteri(H, e.TEXTURE_WRAP_T, Te[O.wrapT]),
                        (H === e.TEXTURE_3D || H === e.TEXTURE_2D_ARRAY) && e.texParameteri(H, e.TEXTURE_WRAP_R, Te[O.wrapR]),
                        e.texParameteri(H, e.TEXTURE_MAG_FILTER, Ee[O.magFilter]),
                        e.texParameteri(H, e.TEXTURE_MIN_FILTER, Ee[O.minFilter]),
                        O.compareFunction && (e.texParameteri(H, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                        e.texParameteri(H, e.TEXTURE_COMPARE_FUNC, Be[O.compareFunction])),
                        t.has("EXT_texture_filter_anisotropic") === !0) {
                            if (O.magFilter === Oi || O.minFilter !== dh && O.minFilter !== Do || O.type === Ja && t.has("OES_texture_float_linear") === !1)
                                return;
                            if (O.anisotropy > 1 || a.get(O).__currentAnisotropy) {
                                const oe = t.get("EXT_texture_filter_anisotropic");
                                e.texParameterf(H, oe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(O.anisotropy, r.getMaxAnisotropy())),
                                a.get(O).__currentAnisotropy = O.anisotropy
                            }
                        }
                    }
                    function ve(H, O) {
                        let oe = !1;
                        H.__webglInit === void 0 && (H.__webglInit = !0,
                        O.addEventListener("dispose", B));
                        const Ce = O.source;
                        let Ue = x.get(Ce);
                        Ue === void 0 && (Ue = {},
                        x.set(Ce, Ue));
                        const Me = te(O);
                        if (Me !== H.__cacheKey) {
                            Ue[Me] === void 0 && (Ue[Me] = {
                                texture: e.createTexture(),
                                usedTimes: 0
                            },
                            f.memory.textures++,
                            oe = !0),
                            Ue[Me].usedTimes++;
                            const st = Ue[H.__cacheKey];
                            st !== void 0 && (Ue[H.__cacheKey].usedTimes--,
                            st.usedTimes === 0 && P(O)),
                            H.__cacheKey = Me,
                            H.__webglTexture = Ue[Me].texture
                        }
                        return oe
                    }
                    function Re(H, O, oe) {
                        return Math.floor(Math.floor(H / oe) / O)
                    }
                    function le(H, O, oe, Ce) {
                        const Me = H.updateRanges;
                        if (Me.length === 0)
                            n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, O.width, O.height, oe, Ce, O.data);
                        else {
                            Me.sort( (He, We) => He.start - We.start);
                            let st = 0;
                            for (let He = 1; He < Me.length; He++) {
                                const We = Me[st]
                                  , rt = Me[He]
                                  , ft = We.start + We.count
                                  , et = Re(rt.start, O.width, 4)
                                  , qt = Re(We.start, O.width, 4);
                                rt.start <= ft + 1 && et === qt && Re(rt.start + rt.count - 1, O.width, 4) === et ? We.count = Math.max(We.count, rt.start + rt.count - We.start) : (++st,
                                Me[st] = rt)
                            }
                            Me.length = st + 1;
                            const je = e.getParameter(e.UNPACK_ROW_LENGTH)
                              , St = e.getParameter(e.UNPACK_SKIP_PIXELS)
                              , Ct = e.getParameter(e.UNPACK_SKIP_ROWS);
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, O.width);
                            for (let He = 0, We = Me.length; He < We; He++) {
                                const rt = Me[He]
                                  , ft = Math.floor(rt.start / 4)
                                  , et = Math.ceil(rt.count / 4)
                                  , qt = ft % O.width
                                  , ae = Math.floor(ft / O.width)
                                  , nt = et
                                  , Ge = 1;
                                e.pixelStorei(e.UNPACK_SKIP_PIXELS, qt),
                                e.pixelStorei(e.UNPACK_SKIP_ROWS, ae),
                                n.texSubImage2D(e.TEXTURE_2D, 0, qt, ae, nt, Ge, oe, Ce, O.data)
                            }
                            H.clearUpdateRanges(),
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, je),
                            e.pixelStorei(e.UNPACK_SKIP_PIXELS, St),
                            e.pixelStorei(e.UNPACK_SKIP_ROWS, Ct)
                        }
                    }
                    function Ae(H, O, oe) {
                        let Ce = e.TEXTURE_2D;
                        (O.isDataArrayTexture || O.isCompressedArrayTexture) && (Ce = e.TEXTURE_2D_ARRAY),
                        O.isData3DTexture && (Ce = e.TEXTURE_3D);
                        const Ue = ve(H, O)
                          , Me = O.source;
                        n.bindTexture(Ce, H.__webglTexture, e.TEXTURE0 + oe);
                        const st = a.get(Me);
                        if (Me.version !== st.__version || Ue === !0) {
                            n.activeTexture(e.TEXTURE0 + oe);
                            const je = Sn.getPrimaries(Sn.workingColorSpace)
                              , St = O.colorSpace === yl ? null : Sn.getPrimaries(O.colorSpace)
                              , Ct = O.colorSpace === yl || je === St ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, O.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, O.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ct);
                            let He = R(O.image, !1, r.maxTextureSize);
                            He = Ke(O, He);
                            const We = c.convert(O.format, O.colorSpace)
                              , rt = c.convert(O.type);
                            let ft = I(O.internalFormat, We, rt, O.colorSpace, O.isVideoTexture);
                            j(Ce, O);
                            let et;
                            const qt = O.mipmaps
                              , ae = O.isVideoTexture !== !0
                              , nt = st.__version === void 0 || Ue === !0
                              , Ge = Me.dataReady
                              , ht = k(O, He);
                            if (O.isDepthTexture)
                                ft = L(O.format === yc, O.type),
                                nt && (ae ? n.texStorage2D(e.TEXTURE_2D, 1, ft, He.width, He.height) : n.texImage2D(e.TEXTURE_2D, 0, ft, He.width, He.height, 0, We, rt, null));
                            else if (O.isDataTexture)
                                if (qt.length > 0) {
                                    ae && nt && n.texStorage2D(e.TEXTURE_2D, ht, ft, qt[0].width, qt[0].height);
                                    for (let Fe = 0, xe = qt.length; Fe < xe; Fe++)
                                        et = qt[Fe],
                                        ae ? Ge && n.texSubImage2D(e.TEXTURE_2D, Fe, 0, 0, et.width, et.height, We, rt, et.data) : n.texImage2D(e.TEXTURE_2D, Fe, ft, et.width, et.height, 0, We, rt, et.data);
                                    O.generateMipmaps = !1
                                } else
                                    ae ? (nt && n.texStorage2D(e.TEXTURE_2D, ht, ft, He.width, He.height),
                                    Ge && le(O, He, We, rt)) : n.texImage2D(e.TEXTURE_2D, 0, ft, He.width, He.height, 0, We, rt, He.data);
                            else if (O.isCompressedTexture)
                                if (O.isCompressedArrayTexture) {
                                    ae && nt && n.texStorage3D(e.TEXTURE_2D_ARRAY, ht, ft, qt[0].width, qt[0].height, He.depth);
                                    for (let Fe = 0, xe = qt.length; Fe < xe; Fe++)
                                        if (et = qt[Fe],
                                        O.format !== Aa)
                                            if (We !== null)
                                                if (ae) {
                                                    if (Ge)
                                                        if (O.layerUpdates.size > 0) {
                                                            const pt = YS(et.width, et.height, O.format, O.type);
                                                            for (const Mt of O.layerUpdates) {
                                                                const In = et.data.subarray(Mt * pt / et.data.BYTES_PER_ELEMENT, (Mt + 1) * pt / et.data.BYTES_PER_ELEMENT);
                                                                n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, Fe, 0, 0, Mt, et.width, et.height, 1, We, In)
                                                            }
                                                            O.clearLayerUpdates()
                                                        } else
                                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, Fe, 0, 0, 0, et.width, et.height, He.depth, We, et.data)
                                                } else
                                                    n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, Fe, ft, et.width, et.height, He.depth, 0, et.data, 0, 0);
                                            else
                                                ot("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                        else
                                            ae ? Ge && n.texSubImage3D(e.TEXTURE_2D_ARRAY, Fe, 0, 0, 0, et.width, et.height, He.depth, We, rt, et.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, Fe, ft, et.width, et.height, He.depth, 0, We, rt, et.data)
                                } else {
                                    ae && nt && n.texStorage2D(e.TEXTURE_2D, ht, ft, qt[0].width, qt[0].height);
                                    for (let Fe = 0, xe = qt.length; Fe < xe; Fe++)
                                        et = qt[Fe],
                                        O.format !== Aa ? We !== null ? ae ? Ge && n.compressedTexSubImage2D(e.TEXTURE_2D, Fe, 0, 0, et.width, et.height, We, et.data) : n.compressedTexImage2D(e.TEXTURE_2D, Fe, ft, et.width, et.height, 0, et.data) : ot("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ae ? Ge && n.texSubImage2D(e.TEXTURE_2D, Fe, 0, 0, et.width, et.height, We, rt, et.data) : n.texImage2D(e.TEXTURE_2D, Fe, ft, et.width, et.height, 0, We, rt, et.data)
                                }
                            else if (O.isDataArrayTexture)
                                if (ae) {
                                    if (nt && n.texStorage3D(e.TEXTURE_2D_ARRAY, ht, ft, He.width, He.height, He.depth),
                                    Ge)
                                        if (O.layerUpdates.size > 0) {
                                            const Fe = YS(He.width, He.height, O.format, O.type);
                                            for (const xe of O.layerUpdates) {
                                                const pt = He.data.subarray(xe * Fe / He.data.BYTES_PER_ELEMENT, (xe + 1) * Fe / He.data.BYTES_PER_ELEMENT);
                                                n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, xe, He.width, He.height, 1, We, rt, pt)
                                            }
                                            O.clearLayerUpdates()
                                        } else
                                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, He.width, He.height, He.depth, We, rt, He.data)
                                } else
                                    n.texImage3D(e.TEXTURE_2D_ARRAY, 0, ft, He.width, He.height, He.depth, 0, We, rt, He.data);
                            else if (O.isData3DTexture)
                                ae ? (nt && n.texStorage3D(e.TEXTURE_3D, ht, ft, He.width, He.height, He.depth),
                                Ge && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, He.width, He.height, He.depth, We, rt, He.data)) : n.texImage3D(e.TEXTURE_3D, 0, ft, He.width, He.height, He.depth, 0, We, rt, He.data);
                            else if (O.isFramebufferTexture) {
                                if (nt)
                                    if (ae)
                                        n.texStorage2D(e.TEXTURE_2D, ht, ft, He.width, He.height);
                                    else {
                                        let Fe = He.width
                                          , xe = He.height;
                                        for (let pt = 0; pt < ht; pt++)
                                            n.texImage2D(e.TEXTURE_2D, pt, ft, Fe, xe, 0, We, rt, null),
                                            Fe >>= 1,
                                            xe >>= 1
                                    }
                            } else if (qt.length > 0) {
                                if (ae && nt) {
                                    const Fe = wt(qt[0]);
                                    n.texStorage2D(e.TEXTURE_2D, ht, ft, Fe.width, Fe.height)
                                }
                                for (let Fe = 0, xe = qt.length; Fe < xe; Fe++)
                                    et = qt[Fe],
                                    ae ? Ge && n.texSubImage2D(e.TEXTURE_2D, Fe, 0, 0, We, rt, et) : n.texImage2D(e.TEXTURE_2D, Fe, ft, We, rt, et);
                                O.generateMipmaps = !1
                            } else if (ae) {
                                if (nt) {
                                    const Fe = wt(He);
                                    n.texStorage2D(e.TEXTURE_2D, ht, ft, Fe.width, Fe.height)
                                }
                                Ge && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, We, rt, He)
                            } else
                                n.texImage2D(e.TEXTURE_2D, 0, ft, We, rt, He);
                            A(O) && E(Ce),
                            st.__version = Me.version,
                            O.onUpdate && O.onUpdate(O)
                        }
                        H.__version = O.version
                    }
                    function Ne(H, O, oe) {
                        if (O.image.length !== 6)
                            return;
                        const Ce = ve(H, O)
                          , Ue = O.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, H.__webglTexture, e.TEXTURE0 + oe);
                        const Me = a.get(Ue);
                        if (Ue.version !== Me.__version || Ce === !0) {
                            n.activeTexture(e.TEXTURE0 + oe);
                            const st = Sn.getPrimaries(Sn.workingColorSpace)
                              , je = O.colorSpace === yl ? null : Sn.getPrimaries(O.colorSpace)
                              , St = O.colorSpace === yl || st === je ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, O.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, O.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, St);
                            const Ct = O.isCompressedTexture || O.image[0].isCompressedTexture
                              , He = O.image[0] && O.image[0].isDataTexture
                              , We = [];
                            for (let xe = 0; xe < 6; xe++)
                                !Ct && !He ? We[xe] = R(O.image[xe], !0, r.maxCubemapSize) : We[xe] = He ? O.image[xe].image : O.image[xe],
                                We[xe] = Ke(O, We[xe]);
                            const rt = We[0]
                              , ft = c.convert(O.format, O.colorSpace)
                              , et = c.convert(O.type)
                              , qt = I(O.internalFormat, ft, et, O.colorSpace)
                              , ae = O.isVideoTexture !== !0
                              , nt = Me.__version === void 0 || Ce === !0
                              , Ge = Ue.dataReady;
                            let ht = k(O, rt);
                            j(e.TEXTURE_CUBE_MAP, O);
                            let Fe;
                            if (Ct) {
                                ae && nt && n.texStorage2D(e.TEXTURE_CUBE_MAP, ht, qt, rt.width, rt.height);
                                for (let xe = 0; xe < 6; xe++) {
                                    Fe = We[xe].mipmaps;
                                    for (let pt = 0; pt < Fe.length; pt++) {
                                        const Mt = Fe[pt];
                                        O.format !== Aa ? ft !== null ? ae ? Ge && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt, 0, 0, Mt.width, Mt.height, ft, Mt.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt, qt, Mt.width, Mt.height, 0, Mt.data) : ot("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ae ? Ge && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt, 0, 0, Mt.width, Mt.height, ft, et, Mt.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt, qt, Mt.width, Mt.height, 0, ft, et, Mt.data)
                                    }
                                }
                            } else {
                                if (Fe = O.mipmaps,
                                ae && nt) {
                                    Fe.length > 0 && ht++;
                                    const xe = wt(We[0]);
                                    n.texStorage2D(e.TEXTURE_CUBE_MAP, ht, qt, xe.width, xe.height)
                                }
                                for (let xe = 0; xe < 6; xe++)
                                    if (He) {
                                        ae ? Ge && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, 0, 0, We[xe].width, We[xe].height, ft, et, We[xe].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, qt, We[xe].width, We[xe].height, 0, ft, et, We[xe].data);
                                        for (let pt = 0; pt < Fe.length; pt++) {
                                            const Mt = Fe[pt].image[xe].image;
                                            ae ? Ge && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt + 1, 0, 0, Mt.width, Mt.height, ft, et, Mt.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt + 1, qt, Mt.width, Mt.height, 0, ft, et, Mt.data)
                                        }
                                    } else {
                                        ae ? Ge && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, 0, 0, ft, et, We[xe]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, 0, qt, ft, et, We[xe]);
                                        for (let pt = 0; pt < Fe.length; pt++) {
                                            const Mt = Fe[pt];
                                            ae ? Ge && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt + 1, 0, 0, ft, et, Mt.image[xe]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + xe, pt + 1, qt, ft, et, Mt.image[xe])
                                        }
                                    }
                            }
                            A(O) && E(e.TEXTURE_CUBE_MAP),
                            Me.__version = Ue.version,
                            O.onUpdate && O.onUpdate(O)
                        }
                        H.__version = O.version
                    }
                    function ke(H, O, oe, Ce, Ue, Me) {
                        const st = c.convert(oe.format, oe.colorSpace)
                          , je = c.convert(oe.type)
                          , St = I(oe.internalFormat, st, je, oe.colorSpace)
                          , Ct = a.get(O)
                          , He = a.get(oe);
                        if (He.__renderTarget = O,
                        !Ct.__hasExternalTextures) {
                            const We = Math.max(1, O.width >> Me)
                              , rt = Math.max(1, O.height >> Me);
                            Ue === e.TEXTURE_3D || Ue === e.TEXTURE_2D_ARRAY ? n.texImage3D(Ue, Me, St, We, rt, O.depth, 0, st, je, null) : n.texImage2D(Ue, Me, St, We, rt, 0, st, je, null)
                        }
                        n.bindFramebuffer(e.FRAMEBUFFER, H),
                        $e(O) ? p.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, Ce, Ue, He.__webglTexture, 0, At(O)) : (Ue === e.TEXTURE_2D || Ue >= e.TEXTURE_CUBE_MAP_POSITIVE_X && Ue <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, Ce, Ue, He.__webglTexture, Me),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                    function at(H, O, oe) {
                        if (e.bindRenderbuffer(e.RENDERBUFFER, H),
                        O.depthBuffer) {
                            const Ce = O.depthTexture
                              , Ue = Ce && Ce.isDepthTexture ? Ce.type : null
                              , Me = L(O.stencilBuffer, Ue)
                              , st = O.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                            $e(O) ? p.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, At(O), Me, O.width, O.height) : oe ? e.renderbufferStorageMultisample(e.RENDERBUFFER, At(O), Me, O.width, O.height) : e.renderbufferStorage(e.RENDERBUFFER, Me, O.width, O.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, st, e.RENDERBUFFER, H)
                        } else {
                            const Ce = O.textures;
                            for (let Ue = 0; Ue < Ce.length; Ue++) {
                                const Me = Ce[Ue]
                                  , st = c.convert(Me.format, Me.colorSpace)
                                  , je = c.convert(Me.type)
                                  , St = I(Me.internalFormat, st, je, Me.colorSpace);
                                $e(O) ? p.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, At(O), St, O.width, O.height) : oe ? e.renderbufferStorageMultisample(e.RENDERBUFFER, At(O), St, O.width, O.height) : e.renderbufferStorage(e.RENDERBUFFER, St, O.width, O.height)
                            }
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null)
                    }
                    function Je(H, O, oe) {
                        const Ce = O.isWebGLCubeRenderTarget === !0;
                        if (n.bindFramebuffer(e.FRAMEBUFFER, H),
                        !(O.depthTexture && O.depthTexture.isDepthTexture))
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        const Ue = a.get(O.depthTexture);
                        if (Ue.__renderTarget = O,
                        (!Ue.__webglTexture || O.depthTexture.image.width !== O.width || O.depthTexture.image.height !== O.height) && (O.depthTexture.image.width = O.width,
                        O.depthTexture.image.height = O.height,
                        O.depthTexture.needsUpdate = !0),
                        Ce) {
                            if (Ue.__webglInit === void 0 && (Ue.__webglInit = !0,
                            O.depthTexture.addEventListener("dispose", B)),
                            Ue.__webglTexture === void 0) {
                                Ue.__webglTexture = e.createTexture(),
                                n.bindTexture(e.TEXTURE_CUBE_MAP, Ue.__webglTexture),
                                j(e.TEXTURE_CUBE_MAP, O.depthTexture);
                                const Ct = c.convert(O.depthTexture.format)
                                  , He = c.convert(O.depthTexture.type);
                                let We;
                                O.depthTexture.format === Lo ? We = e.DEPTH_COMPONENT24 : O.depthTexture.format === yc && (We = e.DEPTH24_STENCIL8);
                                for (let rt = 0; rt < 6; rt++)
                                    e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + rt, 0, We, O.width, O.height, 0, Ct, He, null)
                            }
                        } else
                            ce(O.depthTexture, 0);
                        const Me = Ue.__webglTexture
                          , st = At(O)
                          , je = Ce ? e.TEXTURE_CUBE_MAP_POSITIVE_X + oe : e.TEXTURE_2D
                          , St = O.depthTexture.format === yc ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                        if (O.depthTexture.format === Lo)
                            $e(O) ? p.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, St, je, Me, 0, st) : e.framebufferTexture2D(e.FRAMEBUFFER, St, je, Me, 0);
                        else if (O.depthTexture.format === yc)
                            $e(O) ? p.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, St, je, Me, 0, st) : e.framebufferTexture2D(e.FRAMEBUFFER, St, je, Me, 0);
                        else
                            throw new Error("Unknown depthTexture format")
                    }
                    function Ft(H) {
                        const O = a.get(H)
                          , oe = H.isWebGLCubeRenderTarget === !0;
                        if (O.__boundDepthTexture !== H.depthTexture) {
                            const Ce = H.depthTexture;
                            if (O.__depthDisposeCallback && O.__depthDisposeCallback(),
                            Ce) {
                                const Ue = () => {
                                    delete O.__boundDepthTexture,
                                    delete O.__depthDisposeCallback,
                                    Ce.removeEventListener("dispose", Ue)
                                }
                                ;
                                Ce.addEventListener("dispose", Ue),
                                O.__depthDisposeCallback = Ue
                            }
                            O.__boundDepthTexture = Ce
                        }
                        if (H.depthTexture && !O.__autoAllocateDepthBuffer)
                            if (oe)
                                for (let Ce = 0; Ce < 6; Ce++)
                                    Je(O.__webglFramebuffer[Ce], H, Ce);
                            else {
                                const Ce = H.texture.mipmaps;
                                Ce && Ce.length > 0 ? Je(O.__webglFramebuffer[0], H, 0) : Je(O.__webglFramebuffer, H, 0)
                            }
                        else if (oe) {
                            O.__webglDepthbuffer = [];
                            for (let Ce = 0; Ce < 6; Ce++)
                                if (n.bindFramebuffer(e.FRAMEBUFFER, O.__webglFramebuffer[Ce]),
                                O.__webglDepthbuffer[Ce] === void 0)
                                    O.__webglDepthbuffer[Ce] = e.createRenderbuffer(),
                                    at(O.__webglDepthbuffer[Ce], H, !1);
                                else {
                                    const Ue = H.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                      , Me = O.__webglDepthbuffer[Ce];
                                    e.bindRenderbuffer(e.RENDERBUFFER, Me),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, Ue, e.RENDERBUFFER, Me)
                                }
                        } else {
                            const Ce = H.texture.mipmaps;
                            if (Ce && Ce.length > 0 ? n.bindFramebuffer(e.FRAMEBUFFER, O.__webglFramebuffer[0]) : n.bindFramebuffer(e.FRAMEBUFFER, O.__webglFramebuffer),
                            O.__webglDepthbuffer === void 0)
                                O.__webglDepthbuffer = e.createRenderbuffer(),
                                at(O.__webglDepthbuffer, H, !1);
                            else {
                                const Ue = H.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , Me = O.__webglDepthbuffer;
                                e.bindRenderbuffer(e.RENDERBUFFER, Me),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, Ue, e.RENDERBUFFER, Me)
                            }
                        }
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                    function Vt(H, O, oe) {
                        const Ce = a.get(H);
                        O !== void 0 && ke(Ce.__webglFramebuffer, H, H.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                        oe !== void 0 && Ft(H)
                    }
                    function we(H) {
                        const O = H.texture
                          , oe = a.get(H)
                          , Ce = a.get(O);
                        H.addEventListener("dispose", X);
                        const Ue = H.textures
                          , Me = H.isWebGLCubeRenderTarget === !0
                          , st = Ue.length > 1;
                        if (st || (Ce.__webglTexture === void 0 && (Ce.__webglTexture = e.createTexture()),
                        Ce.__version = O.version,
                        f.memory.textures++),
                        Me) {
                            oe.__webglFramebuffer = [];
                            for (let je = 0; je < 6; je++)
                                if (O.mipmaps && O.mipmaps.length > 0) {
                                    oe.__webglFramebuffer[je] = [];
                                    for (let St = 0; St < O.mipmaps.length; St++)
                                        oe.__webglFramebuffer[je][St] = e.createFramebuffer()
                                } else
                                    oe.__webglFramebuffer[je] = e.createFramebuffer()
                        } else {
                            if (O.mipmaps && O.mipmaps.length > 0) {
                                oe.__webglFramebuffer = [];
                                for (let je = 0; je < O.mipmaps.length; je++)
                                    oe.__webglFramebuffer[je] = e.createFramebuffer()
                            } else
                                oe.__webglFramebuffer = e.createFramebuffer();
                            if (st)
                                for (let je = 0, St = Ue.length; je < St; je++) {
                                    const Ct = a.get(Ue[je]);
                                    Ct.__webglTexture === void 0 && (Ct.__webglTexture = e.createTexture(),
                                    f.memory.textures++)
                                }
                            if (H.samples > 0 && $e(H) === !1) {
                                oe.__webglMultisampledFramebuffer = e.createFramebuffer(),
                                oe.__webglColorRenderbuffer = [],
                                n.bindFramebuffer(e.FRAMEBUFFER, oe.__webglMultisampledFramebuffer);
                                for (let je = 0; je < Ue.length; je++) {
                                    const St = Ue[je];
                                    oe.__webglColorRenderbuffer[je] = e.createRenderbuffer(),
                                    e.bindRenderbuffer(e.RENDERBUFFER, oe.__webglColorRenderbuffer[je]);
                                    const Ct = c.convert(St.format, St.colorSpace)
                                      , He = c.convert(St.type)
                                      , We = I(St.internalFormat, Ct, He, St.colorSpace, H.isXRRenderTarget === !0)
                                      , rt = At(H);
                                    e.renderbufferStorageMultisample(e.RENDERBUFFER, rt, We, H.width, H.height),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + je, e.RENDERBUFFER, oe.__webglColorRenderbuffer[je])
                                }
                                e.bindRenderbuffer(e.RENDERBUFFER, null),
                                H.depthBuffer && (oe.__webglDepthRenderbuffer = e.createRenderbuffer(),
                                at(oe.__webglDepthRenderbuffer, H, !0)),
                                n.bindFramebuffer(e.FRAMEBUFFER, null)
                            }
                        }
                        if (Me) {
                            n.bindTexture(e.TEXTURE_CUBE_MAP, Ce.__webglTexture),
                            j(e.TEXTURE_CUBE_MAP, O);
                            for (let je = 0; je < 6; je++)
                                if (O.mipmaps && O.mipmaps.length > 0)
                                    for (let St = 0; St < O.mipmaps.length; St++)
                                        ke(oe.__webglFramebuffer[je][St], H, O, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + je, St);
                                else
                                    ke(oe.__webglFramebuffer[je], H, O, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + je, 0);
                            A(O) && E(e.TEXTURE_CUBE_MAP),
                            n.unbindTexture()
                        } else if (st) {
                            for (let je = 0, St = Ue.length; je < St; je++) {
                                const Ct = Ue[je]
                                  , He = a.get(Ct);
                                let We = e.TEXTURE_2D;
                                (H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) && (We = H.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                                n.bindTexture(We, He.__webglTexture),
                                j(We, Ct),
                                ke(oe.__webglFramebuffer, H, Ct, e.COLOR_ATTACHMENT0 + je, We, 0),
                                A(Ct) && E(We)
                            }
                            n.unbindTexture()
                        } else {
                            let je = e.TEXTURE_2D;
                            if ((H.isWebGL3DRenderTarget || H.isWebGLArrayRenderTarget) && (je = H.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                            n.bindTexture(je, Ce.__webglTexture),
                            j(je, O),
                            O.mipmaps && O.mipmaps.length > 0)
                                for (let St = 0; St < O.mipmaps.length; St++)
                                    ke(oe.__webglFramebuffer[St], H, O, e.COLOR_ATTACHMENT0, je, St);
                            else
                                ke(oe.__webglFramebuffer, H, O, e.COLOR_ATTACHMENT0, je, 0);
                            A(O) && E(je),
                            n.unbindTexture()
                        }
                        H.depthBuffer && Ft(H)
                    }
                    function Ye(H) {
                        const O = H.textures;
                        for (let oe = 0, Ce = O.length; oe < Ce; oe++) {
                            const Ue = O[oe];
                            if (A(Ue)) {
                                const Me = N(H)
                                  , st = a.get(Ue).__webglTexture;
                                n.bindTexture(Me, st),
                                E(Me),
                                n.unbindTexture()
                            }
                        }
                    }
                    const Ve = []
                      , tt = [];
                    function Z(H) {
                        if (H.samples > 0) {
                            if ($e(H) === !1) {
                                const O = H.textures
                                  , oe = H.width
                                  , Ce = H.height;
                                let Ue = e.COLOR_BUFFER_BIT;
                                const Me = H.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , st = a.get(H)
                                  , je = O.length > 1;
                                if (je)
                                    for (let Ct = 0; Ct < O.length; Ct++)
                                        n.bindFramebuffer(e.FRAMEBUFFER, st.__webglMultisampledFramebuffer),
                                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.RENDERBUFFER, null),
                                        n.bindFramebuffer(e.FRAMEBUFFER, st.__webglFramebuffer),
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.TEXTURE_2D, null, 0);
                                n.bindFramebuffer(e.READ_FRAMEBUFFER, st.__webglMultisampledFramebuffer);
                                const St = H.texture.mipmaps;
                                St && St.length > 0 ? n.bindFramebuffer(e.DRAW_FRAMEBUFFER, st.__webglFramebuffer[0]) : n.bindFramebuffer(e.DRAW_FRAMEBUFFER, st.__webglFramebuffer);
                                for (let Ct = 0; Ct < O.length; Ct++) {
                                    if (H.resolveDepthBuffer && (H.depthBuffer && (Ue |= e.DEPTH_BUFFER_BIT),
                                    H.stencilBuffer && H.resolveStencilBuffer && (Ue |= e.STENCIL_BUFFER_BIT)),
                                    je) {
                                        e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, st.__webglColorRenderbuffer[Ct]);
                                        const He = a.get(O[Ct]).__webglTexture;
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, He, 0)
                                    }
                                    e.blitFramebuffer(0, 0, oe, Ce, 0, 0, oe, Ce, Ue, e.NEAREST),
                                    m === !0 && (Ve.length = 0,
                                    tt.length = 0,
                                    Ve.push(e.COLOR_ATTACHMENT0 + Ct),
                                    H.depthBuffer && H.resolveDepthBuffer === !1 && (Ve.push(Me),
                                    tt.push(Me),
                                    e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, tt)),
                                    e.invalidateFramebuffer(e.READ_FRAMEBUFFER, Ve))
                                }
                                if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                                je)
                                    for (let Ct = 0; Ct < O.length; Ct++) {
                                        n.bindFramebuffer(e.FRAMEBUFFER, st.__webglMultisampledFramebuffer),
                                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.RENDERBUFFER, st.__webglColorRenderbuffer[Ct]);
                                        const He = a.get(O[Ct]).__webglTexture;
                                        n.bindFramebuffer(e.FRAMEBUFFER, st.__webglFramebuffer),
                                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + Ct, e.TEXTURE_2D, He, 0)
                                    }
                                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, st.__webglMultisampledFramebuffer)
                            } else if (H.depthBuffer && H.resolveDepthBuffer === !1 && m) {
                                const O = H.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [O])
                            }
                        }
                    }
                    function At(H) {
                        return Math.min(r.maxSamples, H.samples)
                    }
                    function $e(H) {
                        const O = a.get(H);
                        return H.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && O.__useRenderToTexture !== !1
                    }
                    function xt(H) {
                        const O = f.render.frame;
                        v.get(H) !== O && (v.set(H, O),
                        H.update())
                    }
                    function Ke(H, O) {
                        const oe = H.colorSpace
                          , Ce = H.format
                          , Ue = H.type;
                        return H.isCompressedTexture === !0 || H.isVideoTexture === !0 || oe !== Sc && oe !== yl && (Sn.getTransfer(oe) === Un ? (Ce !== Aa || Ue !== Ka) && ot("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : Et("WebGLTextures: Unsupported texture color space:", oe)),
                        O
                    }
                    function wt(H) {
                        return typeof HTMLImageElement < "u" && H instanceof HTMLImageElement ? (g.width = H.naturalWidth || H.width,
                        g.height = H.naturalHeight || H.height) : typeof VideoFrame < "u" && H instanceof VideoFrame ? (g.width = H.displayWidth,
                        g.height = H.displayHeight) : (g.width = H.width,
                        g.height = H.height),
                        g
                    }
                    this.allocateTextureUnit = q,
                    this.resetTextureUnits = K,
                    this.setTexture2D = ce,
                    this.setTexture2DArray = J,
                    this.setTexture3D = Q,
                    this.setTextureCube = se,
                    this.rebindTextures = Vt,
                    this.setupRenderTarget = we,
                    this.updateRenderTargetMipmap = Ye,
                    this.updateMultisampleRenderTarget = Z,
                    this.setupDepthRenderbuffer = Ft,
                    this.setupFrameBufferTexture = ke,
                    this.useMultisampledRTT = $e,
                    this.isReversedDepthBuffer = function() {
                        return n.buffers.depth.getReversed()
                    }
                }
                function zE(e, t) {
                    function n(a, r=yl) {
                        let c;
                        const f = Sn.getTransfer(r);
                        if (a === Ka)
                            return e.UNSIGNED_BYTE;
                        if (a === yv)
                            return e.UNSIGNED_SHORT_4_4_4_4;
                        if (a === _v)
                            return e.UNSIGNED_SHORT_5_5_5_1;
                        if (a === v_)
                            return e.UNSIGNED_INT_5_9_9_9_REV;
                        if (a === y_)
                            return e.UNSIGNED_INT_10F_11F_11F_REV;
                        if (a === m_)
                            return e.BYTE;
                        if (a === g_)
                            return e.SHORT;
                        if (a === ph)
                            return e.UNSIGNED_SHORT;
                        if (a === vv)
                            return e.INT;
                        if (a === fr)
                            return e.UNSIGNED_INT;
                        if (a === Ja)
                            return e.FLOAT;
                        if (a === No)
                            return e.HALF_FLOAT;
                        if (a === __)
                            return e.ALPHA;
                        if (a === S_)
                            return e.RGB;
                        if (a === Aa)
                            return e.RGBA;
                        if (a === Lo)
                            return e.DEPTH_COMPONENT;
                        if (a === yc)
                            return e.DEPTH_STENCIL;
                        if (a === Sv)
                            return e.RED;
                        if (a === Op)
                            return e.RED_INTEGER;
                        if (a === Ou)
                            return e.RG;
                        if (a === xv)
                            return e.RG_INTEGER;
                        if (a === bv)
                            return e.RGBA_INTEGER;
                        if (a === Pp || a === zp || a === Bp || a === Fp)
                            if (f === Un)
                                if (c = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                                c !== null) {
                                    if (a === Pp)
                                        return c.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (a === zp)
                                        return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (a === Bp)
                                        return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (a === Fp)
                                        return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                } else
                                    return null;
                            else if (c = t.get("WEBGL_compressed_texture_s3tc"),
                            c !== null) {
                                if (a === Pp)
                                    return c.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (a === zp)
                                    return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (a === Bp)
                                    return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (a === Fp)
                                    return c.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } else
                                return null;
                        if (a === Mv || a === Tv || a === Ev || a === Av)
                            if (c = t.get("WEBGL_compressed_texture_pvrtc"),
                            c !== null) {
                                if (a === Mv)
                                    return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (a === Tv)
                                    return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (a === Ev)
                                    return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (a === Av)
                                    return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            } else
                                return null;
                        if (a === wv || a === Cv || a === Rv || a === Dv || a === Nv || a === Lv || a === Uv)
                            if (c = t.get("WEBGL_compressed_texture_etc"),
                            c !== null) {
                                if (a === wv || a === Cv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ETC2 : c.COMPRESSED_RGB8_ETC2;
                                if (a === Rv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : c.COMPRESSED_RGBA8_ETC2_EAC;
                                if (a === Dv)
                                    return c.COMPRESSED_R11_EAC;
                                if (a === Nv)
                                    return c.COMPRESSED_SIGNED_R11_EAC;
                                if (a === Lv)
                                    return c.COMPRESSED_RG11_EAC;
                                if (a === Uv)
                                    return c.COMPRESSED_SIGNED_RG11_EAC
                            } else
                                return null;
                        if (a === Iv || a === Ov || a === Pv || a === zv || a === Bv || a === Fv || a === Vv || a === kv || a === Hv || a === Gv || a === Wv || a === Xv || a === qv || a === Yv)
                            if (c = t.get("WEBGL_compressed_texture_astc"),
                            c !== null) {
                                if (a === Iv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : c.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (a === Ov)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : c.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (a === Pv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : c.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (a === zv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : c.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (a === Bv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : c.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (a === Fv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : c.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (a === Vv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : c.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (a === kv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : c.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (a === Hv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : c.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (a === Gv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : c.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (a === Wv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : c.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (a === Xv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : c.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (a === qv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : c.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (a === Yv)
                                    return f === Un ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : c.COMPRESSED_RGBA_ASTC_12x12_KHR
                            } else
                                return null;
                        if (a === jv || a === Zv || a === Qv)
                            if (c = t.get("EXT_texture_compression_bptc"),
                            c !== null) {
                                if (a === jv)
                                    return f === Un ? c.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : c.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (a === Zv)
                                    return c.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (a === Qv)
                                    return c.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            } else
                                return null;
                        if (a === Kv || a === Jv || a === $v || a === e0)
                            if (c = t.get("EXT_texture_compression_rgtc"),
                            c !== null) {
                                if (a === Kv)
                                    return c.COMPRESSED_RED_RGTC1_EXT;
                                if (a === Jv)
                                    return c.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (a === $v)
                                    return c.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (a === e0)
                                    return c.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            } else
                                return null;
                        return a === mh ? e.UNSIGNED_INT_24_8 : e[a] !== void 0 ? e[a] : null
                    }
                    return {
                        convert: n
                    }
                }
                const nL = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
                  , iL = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
                var aL = class {
                    constructor() {
                        this.texture = null,
                        this.mesh = null,
                        this.depthNear = 0,
                        this.depthFar = 0
                    }
                    init(e, t) {
                        if (this.texture === null) {
                            const n = new oS(e.texture);
                            (e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) && (this.depthNear = e.depthNear,
                            this.depthFar = e.depthFar),
                            this.texture = n
                        }
                    }
                    getMesh(e) {
                        if (this.texture !== null && this.mesh === null) {
                            const t = e.cameras[0].viewport
                              , n = new dr({
                                vertexShader: nL,
                                fragmentShader: iL,
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: t.z
                                    },
                                    depthHeight: {
                                        value: t.w
                                    }
                                }
                            });
                            this.mesh = new Hi(new J0(20,20),n)
                        }
                        return this.mesh
                    }
                    reset() {
                        this.texture = null,
                        this.mesh = null
                    }
                    getDepthTexture() {
                        return this.texture
                    }
                }
                  , sL = class extends Uo {
                    constructor(e, t) {
                        super();
                        const n = this;
                        let a = null
                          , r = 1
                          , c = null
                          , f = "local-floor"
                          , p = 1
                          , m = null
                          , g = null
                          , v = null
                          , _ = null
                          , x = null
                          , M = null;
                        const C = typeof XRWebGLBinding < "u"
                          , R = new aL
                          , A = {}
                          , E = t.getContextAttributes();
                        let N = null
                          , I = null;
                        const L = []
                          , k = []
                          , B = new Pe;
                        let X = null;
                        const G = new ca;
                        G.viewport = new ti;
                        const P = new ca;
                        P.viewport = new ti;
                        const U = [G, P]
                          , W = new YT;
                        let K = null
                          , q = null;
                        this.cameraAutoUpdate = !0,
                        this.enabled = !1,
                        this.isPresenting = !1,
                        this.getController = function(le) {
                            let Ae = L[le];
                            return Ae === void 0 && (Ae = new E0,
                            L[le] = Ae),
                            Ae.getTargetRaySpace()
                        }
                        ,
                        this.getControllerGrip = function(le) {
                            let Ae = L[le];
                            return Ae === void 0 && (Ae = new E0,
                            L[le] = Ae),
                            Ae.getGripSpace()
                        }
                        ,
                        this.getHand = function(le) {
                            let Ae = L[le];
                            return Ae === void 0 && (Ae = new E0,
                            L[le] = Ae),
                            Ae.getHandSpace()
                        }
                        ;
                        function te(le) {
                            const Ae = k.indexOf(le.inputSource);
                            if (Ae === -1)
                                return;
                            const Ne = L[Ae];
                            Ne !== void 0 && (Ne.update(le.inputSource, le.frame, m || c),
                            Ne.dispatchEvent({
                                type: le.type,
                                data: le.inputSource
                            }))
                        }
                        function ce() {
                            a.removeEventListener("select", te),
                            a.removeEventListener("selectstart", te),
                            a.removeEventListener("selectend", te),
                            a.removeEventListener("squeeze", te),
                            a.removeEventListener("squeezestart", te),
                            a.removeEventListener("squeezeend", te),
                            a.removeEventListener("end", ce),
                            a.removeEventListener("inputsourceschange", J);
                            for (let le = 0; le < L.length; le++) {
                                const Ae = k[le];
                                Ae !== null && (k[le] = null,
                                L[le].disconnect(Ae))
                            }
                            K = null,
                            q = null,
                            R.reset();
                            for (const le in A)
                                delete A[le];
                            e.setRenderTarget(N),
                            x = null,
                            _ = null,
                            v = null,
                            a = null,
                            I = null,
                            Re.stop(),
                            n.isPresenting = !1,
                            e.setPixelRatio(X),
                            e.setSize(B.width, B.height, !1),
                            n.dispatchEvent({
                                type: "sessionend"
                            })
                        }
                        this.setFramebufferScaleFactor = function(le) {
                            r = le,
                            n.isPresenting === !0 && ot("WebXRManager: Cannot change framebuffer scale while presenting.")
                        }
                        ,
                        this.setReferenceSpaceType = function(le) {
                            f = le,
                            n.isPresenting === !0 && ot("WebXRManager: Cannot change reference space type while presenting.")
                        }
                        ,
                        this.getReferenceSpace = function() {
                            return m || c
                        }
                        ,
                        this.setReferenceSpace = function(le) {
                            m = le
                        }
                        ,
                        this.getBaseLayer = function() {
                            return _ !== null ? _ : x
                        }
                        ,
                        this.getBinding = function() {
                            return v === null && C && (v = new XRWebGLBinding(a,t)),
                            v
                        }
                        ,
                        this.getFrame = function() {
                            return M
                        }
                        ,
                        this.getSession = function() {
                            return a
                        }
                        ,
                        this.setSession = async function(le) {
                            if (a = le,
                            a !== null) {
                                if (N = e.getRenderTarget(),
                                a.addEventListener("select", te),
                                a.addEventListener("selectstart", te),
                                a.addEventListener("selectend", te),
                                a.addEventListener("squeeze", te),
                                a.addEventListener("squeezestart", te),
                                a.addEventListener("squeezeend", te),
                                a.addEventListener("end", ce),
                                a.addEventListener("inputsourceschange", J),
                                E.xrCompatible !== !0 && await t.makeXRCompatible(),
                                X = e.getPixelRatio(),
                                e.getSize(B),
                                C && "createProjectionLayer"in XRWebGLBinding.prototype) {
                                    let Ae = null
                                      , Ne = null
                                      , ke = null;
                                    E.depth && (ke = E.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                                    Ae = E.stencil ? yc : Lo,
                                    Ne = E.stencil ? mh : fr);
                                    const at = {
                                        colorFormat: t.RGBA8,
                                        depthFormat: ke,
                                        scaleFactor: r
                                    };
                                    v = this.getBinding(),
                                    _ = v.createProjectionLayer(at),
                                    a.updateRenderState({
                                        layers: [_]
                                    }),
                                    e.setPixelRatio(1),
                                    e.setSize(_.textureWidth, _.textureHeight, !1),
                                    I = new Vs(_.textureWidth,_.textureHeight,{
                                        format: Aa,
                                        type: Ka,
                                        depthTexture: new Wh(_.textureWidth,_.textureHeight,Ne,void 0,void 0,void 0,void 0,void 0,void 0,Ae),
                                        stencilBuffer: E.stencil,
                                        colorSpace: e.outputColorSpace,
                                        samples: E.antialias ? 4 : 0,
                                        resolveDepthBuffer: _.ignoreDepthValues === !1,
                                        resolveStencilBuffer: _.ignoreDepthValues === !1
                                    })
                                } else {
                                    const Ae = {
                                        antialias: E.antialias,
                                        alpha: !0,
                                        depth: E.depth,
                                        stencil: E.stencil,
                                        framebufferScaleFactor: r
                                    };
                                    x = new XRWebGLLayer(a,t,Ae),
                                    a.updateRenderState({
                                        baseLayer: x
                                    }),
                                    e.setPixelRatio(1),
                                    e.setSize(x.framebufferWidth, x.framebufferHeight, !1),
                                    I = new Vs(x.framebufferWidth,x.framebufferHeight,{
                                        format: Aa,
                                        type: Ka,
                                        colorSpace: e.outputColorSpace,
                                        stencilBuffer: E.stencil,
                                        resolveDepthBuffer: x.ignoreDepthValues === !1,
                                        resolveStencilBuffer: x.ignoreDepthValues === !1
                                    })
                                }
                                I.isXRRenderTarget = !0,
                                this.setFoveation(p),
                                m = null,
                                c = await a.requestReferenceSpace(f),
                                Re.setContext(a),
                                Re.start(),
                                n.isPresenting = !0,
                                n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        }
                        ,
                        this.getEnvironmentBlendMode = function() {
                            if (a !== null)
                                return a.environmentBlendMode
                        }
                        ,
                        this.getDepthTexture = function() {
                            return R.getDepthTexture()
                        }
                        ;
                        function J(le) {
                            for (let Ae = 0; Ae < le.removed.length; Ae++) {
                                const Ne = le.removed[Ae]
                                  , ke = k.indexOf(Ne);
                                ke >= 0 && (k[ke] = null,
                                L[ke].disconnect(Ne))
                            }
                            for (let Ae = 0; Ae < le.added.length; Ae++) {
                                const Ne = le.added[Ae];
                                let ke = k.indexOf(Ne);
                                if (ke === -1) {
                                    for (let Je = 0; Je < L.length; Je++)
                                        if (Je >= k.length) {
                                            k.push(Ne),
                                            ke = Je;
                                            break
                                        } else if (k[Je] === null) {
                                            k[Je] = Ne,
                                            ke = Je;
                                            break
                                        }
                                    if (ke === -1)
                                        break
                                }
                                const at = L[ke];
                                at && at.connect(Ne)
                            }
                        }
                        const Q = new Y
                          , se = new Y;
                        function Te(le, Ae, Ne) {
                            Q.setFromMatrixPosition(Ae.matrixWorld),
                            se.setFromMatrixPosition(Ne.matrixWorld);
                            const ke = Q.distanceTo(se)
                              , at = Ae.projectionMatrix.elements
                              , Je = Ne.projectionMatrix.elements
                              , Ft = at[14] / (at[10] - 1)
                              , Vt = at[14] / (at[10] + 1)
                              , we = (at[9] + 1) / at[5]
                              , Ye = (at[9] - 1) / at[5]
                              , Ve = (at[8] - 1) / at[0]
                              , tt = (Je[8] + 1) / Je[0]
                              , Z = Ft * Ve
                              , At = Ft * tt
                              , $e = ke / (-Ve + tt)
                              , xt = $e * -Ve;
                            if (Ae.matrixWorld.decompose(le.position, le.quaternion, le.scale),
                            le.translateX(xt),
                            le.translateZ($e),
                            le.matrixWorld.compose(le.position, le.quaternion, le.scale),
                            le.matrixWorldInverse.copy(le.matrixWorld).invert(),
                            at[10] === -1)
                                le.projectionMatrix.copy(Ae.projectionMatrix),
                                le.projectionMatrixInverse.copy(Ae.projectionMatrixInverse);
                            else {
                                const Ke = Ft + $e
                                  , wt = Vt + $e
                                  , H = Z - xt
                                  , O = At + (ke - xt)
                                  , oe = we * Vt / wt * Ke
                                  , Ce = Ye * Vt / wt * Ke;
                                le.projectionMatrix.makePerspective(H, O, oe, Ce, Ke, wt),
                                le.projectionMatrixInverse.copy(le.projectionMatrix).invert()
                            }
                        }
                        function Ee(le, Ae) {
                            Ae === null ? le.matrixWorld.copy(le.matrix) : le.matrixWorld.multiplyMatrices(Ae.matrixWorld, le.matrix),
                            le.matrixWorldInverse.copy(le.matrixWorld).invert()
                        }
                        this.updateCamera = function(le) {
                            if (a === null)
                                return;
                            let Ae = le.near
                              , Ne = le.far;
                            R.texture !== null && (R.depthNear > 0 && (Ae = R.depthNear),
                            R.depthFar > 0 && (Ne = R.depthFar)),
                            W.near = P.near = G.near = Ae,
                            W.far = P.far = G.far = Ne,
                            (K !== W.near || q !== W.far) && (a.updateRenderState({
                                depthNear: W.near,
                                depthFar: W.far
                            }),
                            K = W.near,
                            q = W.far),
                            W.layers.mask = le.layers.mask | 6,
                            G.layers.mask = W.layers.mask & 3,
                            P.layers.mask = W.layers.mask & 5;
                            const ke = le.parent
                              , at = W.cameras;
                            Ee(W, ke);
                            for (let Je = 0; Je < at.length; Je++)
                                Ee(at[Je], ke);
                            at.length === 2 ? Te(W, G, P) : W.projectionMatrix.copy(G.projectionMatrix),
                            Be(le, W, ke)
                        }
                        ;
                        function Be(le, Ae, Ne) {
                            Ne === null ? le.matrix.copy(Ae.matrixWorld) : (le.matrix.copy(Ne.matrixWorld),
                            le.matrix.invert(),
                            le.matrix.multiply(Ae.matrixWorld)),
                            le.matrix.decompose(le.position, le.quaternion, le.scale),
                            le.updateMatrixWorld(!0),
                            le.projectionMatrix.copy(Ae.projectionMatrix),
                            le.projectionMatrixInverse.copy(Ae.projectionMatrixInverse),
                            le.isPerspectiveCamera && (le.fov = _h * 2 * Math.atan(1 / le.projectionMatrix.elements[5]),
                            le.zoom = 1)
                        }
                        this.getCamera = function() {
                            return W
                        }
                        ,
                        this.getFoveation = function() {
                            if (!(_ === null && x === null))
                                return p
                        }
                        ,
                        this.setFoveation = function(le) {
                            p = le,
                            _ !== null && (_.fixedFoveation = le),
                            x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = le)
                        }
                        ,
                        this.hasDepthSensing = function() {
                            return R.texture !== null
                        }
                        ,
                        this.getDepthSensingMesh = function() {
                            return R.getMesh(W)
                        }
                        ,
                        this.getCameraTexture = function(le) {
                            return A[le]
                        }
                        ;
                        let j = null;
                        function ve(le, Ae) {
                            if (g = Ae.getViewerPose(m || c),
                            M = Ae,
                            g !== null) {
                                const Ne = g.views;
                                x !== null && (e.setRenderTargetFramebuffer(I, x.framebuffer),
                                e.setRenderTarget(I));
                                let ke = !1;
                                Ne.length !== W.cameras.length && (W.cameras.length = 0,
                                ke = !0);
                                for (let Je = 0; Je < Ne.length; Je++) {
                                    const Ft = Ne[Je];
                                    let Vt = null;
                                    if (x !== null)
                                        Vt = x.getViewport(Ft);
                                    else {
                                        const Ye = v.getViewSubImage(_, Ft);
                                        Vt = Ye.viewport,
                                        Je === 0 && (e.setRenderTargetTextures(I, Ye.colorTexture, Ye.depthStencilTexture),
                                        e.setRenderTarget(I))
                                    }
                                    let we = U[Je];
                                    we === void 0 && (we = new ca,
                                    we.layers.enable(Je),
                                    we.viewport = new ti,
                                    U[Je] = we),
                                    we.matrix.fromArray(Ft.transform.matrix),
                                    we.matrix.decompose(we.position, we.quaternion, we.scale),
                                    we.projectionMatrix.fromArray(Ft.projectionMatrix),
                                    we.projectionMatrixInverse.copy(we.projectionMatrix).invert(),
                                    we.viewport.set(Vt.x, Vt.y, Vt.width, Vt.height),
                                    Je === 0 && (W.matrix.copy(we.matrix),
                                    W.matrix.decompose(W.position, W.quaternion, W.scale)),
                                    ke === !0 && W.cameras.push(we)
                                }
                                const at = a.enabledFeatures;
                                if (at && at.includes("depth-sensing") && a.depthUsage == "gpu-optimized" && C) {
                                    v = n.getBinding();
                                    const Je = v.getDepthInformation(Ne[0]);
                                    Je && Je.isValid && Je.texture && R.init(Je, a.renderState)
                                }
                                if (at && at.includes("camera-access") && C) {
                                    e.state.unbindTexture(),
                                    v = n.getBinding();
                                    for (let Je = 0; Je < Ne.length; Je++) {
                                        const Ft = Ne[Je].camera;
                                        if (Ft) {
                                            let Vt = A[Ft];
                                            Vt || (Vt = new oS,
                                            A[Ft] = Vt);
                                            const we = v.getCameraImage(Ft);
                                            Vt.sourceTexture = we
                                        }
                                    }
                                }
                            }
                            for (let Ne = 0; Ne < L.length; Ne++) {
                                const ke = k[Ne]
                                  , at = L[Ne];
                                ke !== null && at !== void 0 && at.update(ke, Ae, m || c)
                            }
                            j && j(le, Ae),
                            Ae.detectedPlanes && n.dispatchEvent({
                                type: "planesdetected",
                                data: Ae
                            }),
                            M = null
                        }
                        const Re = new uE;
                        Re.setAnimationLoop(ve),
                        this.setAnimationLoop = function(le) {
                            j = le
                        }
                        ,
                        this.dispose = function() {}
                    }
                }
                ;
                const rf = new es
                  , rL = new Wt;
                function oL(e, t) {
                    function n(A, E) {
                        A.matrixAutoUpdate === !0 && A.updateMatrix(),
                        E.value.copy(A.matrix)
                    }
                    function a(A, E) {
                        E.color.getRGB(A.fogColor.value, sM(e)),
                        E.isFog ? (A.fogNear.value = E.near,
                        A.fogFar.value = E.far) : E.isFogExp2 && (A.fogDensity.value = E.density)
                    }
                    function r(A, E, N, I, L) {
                        E.isMeshBasicMaterial || E.isMeshLambertMaterial ? c(A, E) : E.isMeshToonMaterial ? (c(A, E),
                        _(A, E)) : E.isMeshPhongMaterial ? (c(A, E),
                        v(A, E)) : E.isMeshStandardMaterial ? (c(A, E),
                        x(A, E),
                        E.isMeshPhysicalMaterial && M(A, E, L)) : E.isMeshMatcapMaterial ? (c(A, E),
                        C(A, E)) : E.isMeshDepthMaterial ? c(A, E) : E.isMeshDistanceMaterial ? (c(A, E),
                        R(A, E)) : E.isMeshNormalMaterial ? c(A, E) : E.isLineBasicMaterial ? (f(A, E),
                        E.isLineDashedMaterial && p(A, E)) : E.isPointsMaterial ? m(A, E, N, I) : E.isSpriteMaterial ? g(A, E) : E.isShadowMaterial ? (A.color.value.copy(E.color),
                        A.opacity.value = E.opacity) : E.isShaderMaterial && (E.uniformsNeedUpdate = !1)
                    }
                    function c(A, E) {
                        A.opacity.value = E.opacity,
                        E.color && A.diffuse.value.copy(E.color),
                        E.emissive && A.emissive.value.copy(E.emissive).multiplyScalar(E.emissiveIntensity),
                        E.map && (A.map.value = E.map,
                        n(E.map, A.mapTransform)),
                        E.alphaMap && (A.alphaMap.value = E.alphaMap,
                        n(E.alphaMap, A.alphaMapTransform)),
                        E.bumpMap && (A.bumpMap.value = E.bumpMap,
                        n(E.bumpMap, A.bumpMapTransform),
                        A.bumpScale.value = E.bumpScale,
                        E.side === Qa && (A.bumpScale.value *= -1)),
                        E.normalMap && (A.normalMap.value = E.normalMap,
                        n(E.normalMap, A.normalMapTransform),
                        A.normalScale.value.copy(E.normalScale),
                        E.side === Qa && A.normalScale.value.negate()),
                        E.displacementMap && (A.displacementMap.value = E.displacementMap,
                        n(E.displacementMap, A.displacementMapTransform),
                        A.displacementScale.value = E.displacementScale,
                        A.displacementBias.value = E.displacementBias),
                        E.emissiveMap && (A.emissiveMap.value = E.emissiveMap,
                        n(E.emissiveMap, A.emissiveMapTransform)),
                        E.specularMap && (A.specularMap.value = E.specularMap,
                        n(E.specularMap, A.specularMapTransform)),
                        E.alphaTest > 0 && (A.alphaTest.value = E.alphaTest);
                        const N = t.get(E)
                          , I = N.envMap
                          , L = N.envMapRotation;
                        I && (A.envMap.value = I,
                        rf.copy(L),
                        rf.x *= -1,
                        rf.y *= -1,
                        rf.z *= -1,
                        I.isCubeTexture && I.isRenderTargetTexture === !1 && (rf.y *= -1,
                        rf.z *= -1),
                        A.envMapRotation.value.setFromMatrix4(rL.makeRotationFromEuler(rf)),
                        A.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1,
                        A.reflectivity.value = E.reflectivity,
                        A.ior.value = E.ior,
                        A.refractionRatio.value = E.refractionRatio),
                        E.lightMap && (A.lightMap.value = E.lightMap,
                        A.lightMapIntensity.value = E.lightMapIntensity,
                        n(E.lightMap, A.lightMapTransform)),
                        E.aoMap && (A.aoMap.value = E.aoMap,
                        A.aoMapIntensity.value = E.aoMapIntensity,
                        n(E.aoMap, A.aoMapTransform))
                    }
                    function f(A, E) {
                        A.diffuse.value.copy(E.color),
                        A.opacity.value = E.opacity,
                        E.map && (A.map.value = E.map,
                        n(E.map, A.mapTransform))
                    }
                    function p(A, E) {
                        A.dashSize.value = E.dashSize,
                        A.totalSize.value = E.dashSize + E.gapSize,
                        A.scale.value = E.scale
                    }
                    function m(A, E, N, I) {
                        A.diffuse.value.copy(E.color),
                        A.opacity.value = E.opacity,
                        A.size.value = E.size * N,
                        A.scale.value = I * .5,
                        E.map && (A.map.value = E.map,
                        n(E.map, A.uvTransform)),
                        E.alphaMap && (A.alphaMap.value = E.alphaMap,
                        n(E.alphaMap, A.alphaMapTransform)),
                        E.alphaTest > 0 && (A.alphaTest.value = E.alphaTest)
                    }
                    function g(A, E) {
                        A.diffuse.value.copy(E.color),
                        A.opacity.value = E.opacity,
                        A.rotation.value = E.rotation,
                        E.map && (A.map.value = E.map,
                        n(E.map, A.mapTransform)),
                        E.alphaMap && (A.alphaMap.value = E.alphaMap,
                        n(E.alphaMap, A.alphaMapTransform)),
                        E.alphaTest > 0 && (A.alphaTest.value = E.alphaTest)
                    }
                    function v(A, E) {
                        A.specular.value.copy(E.specular),
                        A.shininess.value = Math.max(E.shininess, 1e-4)
                    }
                    function _(A, E) {
                        E.gradientMap && (A.gradientMap.value = E.gradientMap)
                    }
                    function x(A, E) {
                        A.metalness.value = E.metalness,
                        E.metalnessMap && (A.metalnessMap.value = E.metalnessMap,
                        n(E.metalnessMap, A.metalnessMapTransform)),
                        A.roughness.value = E.roughness,
                        E.roughnessMap && (A.roughnessMap.value = E.roughnessMap,
                        n(E.roughnessMap, A.roughnessMapTransform)),
                        E.envMap && (A.envMapIntensity.value = E.envMapIntensity)
                    }
                    function M(A, E, N) {
                        A.ior.value = E.ior,
                        E.sheen > 0 && (A.sheenColor.value.copy(E.sheenColor).multiplyScalar(E.sheen),
                        A.sheenRoughness.value = E.sheenRoughness,
                        E.sheenColorMap && (A.sheenColorMap.value = E.sheenColorMap,
                        n(E.sheenColorMap, A.sheenColorMapTransform)),
                        E.sheenRoughnessMap && (A.sheenRoughnessMap.value = E.sheenRoughnessMap,
                        n(E.sheenRoughnessMap, A.sheenRoughnessMapTransform))),
                        E.clearcoat > 0 && (A.clearcoat.value = E.clearcoat,
                        A.clearcoatRoughness.value = E.clearcoatRoughness,
                        E.clearcoatMap && (A.clearcoatMap.value = E.clearcoatMap,
                        n(E.clearcoatMap, A.clearcoatMapTransform)),
                        E.clearcoatRoughnessMap && (A.clearcoatRoughnessMap.value = E.clearcoatRoughnessMap,
                        n(E.clearcoatRoughnessMap, A.clearcoatRoughnessMapTransform)),
                        E.clearcoatNormalMap && (A.clearcoatNormalMap.value = E.clearcoatNormalMap,
                        n(E.clearcoatNormalMap, A.clearcoatNormalMapTransform),
                        A.clearcoatNormalScale.value.copy(E.clearcoatNormalScale),
                        E.side === Qa && A.clearcoatNormalScale.value.negate())),
                        E.dispersion > 0 && (A.dispersion.value = E.dispersion),
                        E.iridescence > 0 && (A.iridescence.value = E.iridescence,
                        A.iridescenceIOR.value = E.iridescenceIOR,
                        A.iridescenceThicknessMinimum.value = E.iridescenceThicknessRange[0],
                        A.iridescenceThicknessMaximum.value = E.iridescenceThicknessRange[1],
                        E.iridescenceMap && (A.iridescenceMap.value = E.iridescenceMap,
                        n(E.iridescenceMap, A.iridescenceMapTransform)),
                        E.iridescenceThicknessMap && (A.iridescenceThicknessMap.value = E.iridescenceThicknessMap,
                        n(E.iridescenceThicknessMap, A.iridescenceThicknessMapTransform))),
                        E.transmission > 0 && (A.transmission.value = E.transmission,
                        A.transmissionSamplerMap.value = N.texture,
                        A.transmissionSamplerSize.value.set(N.width, N.height),
                        E.transmissionMap && (A.transmissionMap.value = E.transmissionMap,
                        n(E.transmissionMap, A.transmissionMapTransform)),
                        A.thickness.value = E.thickness,
                        E.thicknessMap && (A.thicknessMap.value = E.thicknessMap,
                        n(E.thicknessMap, A.thicknessMapTransform)),
                        A.attenuationDistance.value = E.attenuationDistance,
                        A.attenuationColor.value.copy(E.attenuationColor)),
                        E.anisotropy > 0 && (A.anisotropyVector.value.set(E.anisotropy * Math.cos(E.anisotropyRotation), E.anisotropy * Math.sin(E.anisotropyRotation)),
                        E.anisotropyMap && (A.anisotropyMap.value = E.anisotropyMap,
                        n(E.anisotropyMap, A.anisotropyMapTransform))),
                        A.specularIntensity.value = E.specularIntensity,
                        A.specularColor.value.copy(E.specularColor),
                        E.specularColorMap && (A.specularColorMap.value = E.specularColorMap,
                        n(E.specularColorMap, A.specularColorMapTransform)),
                        E.specularIntensityMap && (A.specularIntensityMap.value = E.specularIntensityMap,
                        n(E.specularIntensityMap, A.specularIntensityMapTransform))
                    }
                    function C(A, E) {
                        E.matcap && (A.matcap.value = E.matcap)
                    }
                    function R(A, E) {
                        const N = t.get(E).light;
                        A.referencePosition.value.setFromMatrixPosition(N.matrixWorld),
                        A.nearDistance.value = N.shadow.camera.near,
                        A.farDistance.value = N.shadow.camera.far
                    }
                    return {
                        refreshFogUniforms: a,
                        refreshMaterialUniforms: r
                    }
                }
                function lL(e, t, n, a) {
                    let r = {}
                      , c = {}
                      , f = [];
                    const p = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
                    function m(N, I) {
                        const L = I.program;
                        a.uniformBlockBinding(N, L)
                    }
                    function g(N, I) {
                        let L = r[N.id];
                        L === void 0 && (C(N),
                        L = v(N),
                        r[N.id] = L,
                        N.addEventListener("dispose", A));
                        const k = I.program;
                        a.updateUBOMapping(N, k);
                        const B = t.render.frame;
                        c[N.id] !== B && (x(N),
                        c[N.id] = B)
                    }
                    function v(N) {
                        const I = _();
                        N.__bindingPointIndex = I;
                        const L = e.createBuffer()
                          , k = N.__size
                          , B = N.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, L),
                        e.bufferData(e.UNIFORM_BUFFER, k, B),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, I, L),
                        L
                    }
                    function _() {
                        for (let N = 0; N < p; N++)
                            if (f.indexOf(N) === -1)
                                return f.push(N),
                                N;
                        return Et("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                        0
                    }
                    function x(N) {
                        const I = r[N.id]
                          , L = N.uniforms
                          , k = N.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, I);
                        for (let B = 0, X = L.length; B < X; B++) {
                            const G = Array.isArray(L[B]) ? L[B] : [L[B]];
                            for (let P = 0, U = G.length; P < U; P++) {
                                const W = G[P];
                                if (M(W, B, P, k) === !0) {
                                    const K = W.__offset
                                      , q = Array.isArray(W.value) ? W.value : [W.value];
                                    let te = 0;
                                    for (let ce = 0; ce < q.length; ce++) {
                                        const J = q[ce]
                                          , Q = R(J);
                                        typeof J == "number" || typeof J == "boolean" ? (W.__data[0] = J,
                                        e.bufferSubData(e.UNIFORM_BUFFER, K + te, W.__data)) : J.isMatrix3 ? (W.__data[0] = J.elements[0],
                                        W.__data[1] = J.elements[1],
                                        W.__data[2] = J.elements[2],
                                        W.__data[3] = 0,
                                        W.__data[4] = J.elements[3],
                                        W.__data[5] = J.elements[4],
                                        W.__data[6] = J.elements[5],
                                        W.__data[7] = 0,
                                        W.__data[8] = J.elements[6],
                                        W.__data[9] = J.elements[7],
                                        W.__data[10] = J.elements[8],
                                        W.__data[11] = 0) : (J.toArray(W.__data, te),
                                        te += Q.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, K, W.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }
                    function M(N, I, L, k) {
                        const B = N.value
                          , X = I + "_" + L;
                        if (k[X] === void 0)
                            return typeof B == "number" || typeof B == "boolean" ? k[X] = B : k[X] = B.clone(),
                            !0;
                        {
                            const G = k[X];
                            if (typeof B == "number" || typeof B == "boolean") {
                                if (G !== B)
                                    return k[X] = B,
                                    !0
                            } else if (G.equals(B) === !1)
                                return G.copy(B),
                                !0
                        }
                        return !1
                    }
                    function C(N) {
                        const I = N.uniforms;
                        let L = 0;
                        const k = 16;
                        for (let X = 0, G = I.length; X < G; X++) {
                            const P = Array.isArray(I[X]) ? I[X] : [I[X]];
                            for (let U = 0, W = P.length; U < W; U++) {
                                const K = P[U]
                                  , q = Array.isArray(K.value) ? K.value : [K.value];
                                for (let te = 0, ce = q.length; te < ce; te++) {
                                    const J = q[te]
                                      , Q = R(J)
                                      , se = L % k
                                      , Te = se % Q.boundary
                                      , Ee = se + Te;
                                    L += Te,
                                    Ee !== 0 && k - Ee < Q.storage && (L += k - Ee),
                                    K.__data = new Float32Array(Q.storage / Float32Array.BYTES_PER_ELEMENT),
                                    K.__offset = L,
                                    L += Q.storage
                                }
                            }
                        }
                        const B = L % k;
                        return B > 0 && (L += k - B),
                        N.__size = L,
                        N.__cache = {},
                        this
                    }
                    function R(N) {
                        const I = {
                            boundary: 0,
                            storage: 0
                        };
                        return typeof N == "number" || typeof N == "boolean" ? (I.boundary = 4,
                        I.storage = 4) : N.isVector2 ? (I.boundary = 8,
                        I.storage = 8) : N.isVector3 || N.isColor ? (I.boundary = 16,
                        I.storage = 12) : N.isVector4 ? (I.boundary = 16,
                        I.storage = 16) : N.isMatrix3 ? (I.boundary = 48,
                        I.storage = 48) : N.isMatrix4 ? (I.boundary = 64,
                        I.storage = 64) : N.isTexture ? ot("WebGLRenderer: Texture samplers can not be part of an uniforms group.") : ot("WebGLRenderer: Unsupported uniform value type.", N),
                        I
                    }
                    function A(N) {
                        const I = N.target;
                        I.removeEventListener("dispose", A);
                        const L = f.indexOf(I.__bindingPointIndex);
                        f.splice(L, 1),
                        e.deleteBuffer(r[I.id]),
                        delete r[I.id],
                        delete c[I.id]
                    }
                    function E() {
                        for (const N in r)
                            e.deleteBuffer(r[N]);
                        f = [],
                        r = {},
                        c = {}
                    }
                    return {
                        bind: m,
                        update: g,
                        dispose: E
                    }
                }
                const cL = new Uint16Array([12469, 15057, 12620, 14925, 13266, 14620, 13807, 14376, 14323, 13990, 14545, 13625, 14713, 13328, 14840, 12882, 14931, 12528, 14996, 12233, 15039, 11829, 15066, 11525, 15080, 11295, 15085, 10976, 15082, 10705, 15073, 10495, 13880, 14564, 13898, 14542, 13977, 14430, 14158, 14124, 14393, 13732, 14556, 13410, 14702, 12996, 14814, 12596, 14891, 12291, 14937, 11834, 14957, 11489, 14958, 11194, 14943, 10803, 14921, 10506, 14893, 10278, 14858, 9960, 14484, 14039, 14487, 14025, 14499, 13941, 14524, 13740, 14574, 13468, 14654, 13106, 14743, 12678, 14818, 12344, 14867, 11893, 14889, 11509, 14893, 11180, 14881, 10751, 14852, 10428, 14812, 10128, 14765, 9754, 14712, 9466, 14764, 13480, 14764, 13475, 14766, 13440, 14766, 13347, 14769, 13070, 14786, 12713, 14816, 12387, 14844, 11957, 14860, 11549, 14868, 11215, 14855, 10751, 14825, 10403, 14782, 10044, 14729, 9651, 14666, 9352, 14599, 9029, 14967, 12835, 14966, 12831, 14963, 12804, 14954, 12723, 14936, 12564, 14917, 12347, 14900, 11958, 14886, 11569, 14878, 11247, 14859, 10765, 14828, 10401, 14784, 10011, 14727, 9600, 14660, 9289, 14586, 8893, 14508, 8533, 15111, 12234, 15110, 12234, 15104, 12216, 15092, 12156, 15067, 12010, 15028, 11776, 14981, 11500, 14942, 11205, 14902, 10752, 14861, 10393, 14812, 9991, 14752, 9570, 14682, 9252, 14603, 8808, 14519, 8445, 14431, 8145, 15209, 11449, 15208, 11451, 15202, 11451, 15190, 11438, 15163, 11384, 15117, 11274, 15055, 10979, 14994, 10648, 14932, 10343, 14871, 9936, 14803, 9532, 14729, 9218, 14645, 8742, 14556, 8381, 14461, 8020, 14365, 7603, 15273, 10603, 15272, 10607, 15267, 10619, 15256, 10631, 15231, 10614, 15182, 10535, 15118, 10389, 15042, 10167, 14963, 9787, 14883, 9447, 14800, 9115, 14710, 8665, 14615, 8318, 14514, 7911, 14411, 7507, 14279, 7198, 15314, 9675, 15313, 9683, 15309, 9712, 15298, 9759, 15277, 9797, 15229, 9773, 15166, 9668, 15084, 9487, 14995, 9274, 14898, 8910, 14800, 8539, 14697, 8234, 14590, 7790, 14479, 7409, 14367, 7067, 14178, 6621, 15337, 8619, 15337, 8631, 15333, 8677, 15325, 8769, 15305, 8871, 15264, 8940, 15202, 8909, 15119, 8775, 15022, 8565, 14916, 8328, 14804, 8009, 14688, 7614, 14569, 7287, 14448, 6888, 14321, 6483, 14088, 6171, 15350, 7402, 15350, 7419, 15347, 7480, 15340, 7613, 15322, 7804, 15287, 7973, 15229, 8057, 15148, 8012, 15046, 7846, 14933, 7611, 14810, 7357, 14682, 7069, 14552, 6656, 14421, 6316, 14251, 5948, 14007, 5528, 15356, 5942, 15356, 5977, 15353, 6119, 15348, 6294, 15332, 6551, 15302, 6824, 15249, 7044, 15171, 7122, 15070, 7050, 14949, 6861, 14818, 6611, 14679, 6349, 14538, 6067, 14398, 5651, 14189, 5311, 13935, 4958, 15359, 4123, 15359, 4153, 15356, 4296, 15353, 4646, 15338, 5160, 15311, 5508, 15263, 5829, 15188, 6042, 15088, 6094, 14966, 6001, 14826, 5796, 14678, 5543, 14527, 5287, 14377, 4985, 14133, 4586, 13869, 4257, 15360, 1563, 15360, 1642, 15358, 2076, 15354, 2636, 15341, 3350, 15317, 4019, 15273, 4429, 15203, 4732, 15105, 4911, 14981, 4932, 14836, 4818, 14679, 4621, 14517, 4386, 14359, 4156, 14083, 3795, 13808, 3437, 15360, 122, 15360, 137, 15358, 285, 15355, 636, 15344, 1274, 15322, 2177, 15281, 2765, 15215, 3223, 15120, 3451, 14995, 3569, 14846, 3567, 14681, 3466, 14511, 3305, 14344, 3121, 14037, 2800, 13753, 2467, 15360, 0, 15360, 1, 15359, 21, 15355, 89, 15346, 253, 15325, 479, 15287, 796, 15225, 1148, 15133, 1492, 15008, 1749, 14856, 1882, 14685, 1886, 14506, 1783, 14324, 1608, 13996, 1398, 13702, 1183]);
                let Bo = null;
                function uL() {
                    return Bo === null && (Bo = new Gr(cL,16,16,Ou,No),
                    Bo.name = "DFG_LUT",
                    Bo.minFilter = ei,
                    Bo.magFilter = ei,
                    Bo.wrapS = Ss,
                    Bo.wrapT = Ss,
                    Bo.generateMipmaps = !1,
                    Bo.needsUpdate = !0),
                    Bo
                }
                var BE = class {
                    constructor(e={}) {
                        const {canvas: t=Vb(), context: n=null, depth: a=!0, stencil: r=!1, alpha: c=!1, antialias: f=!1, premultipliedAlpha: p=!0, preserveDrawingBuffer: m=!1, powerPreference: g="default", failIfMajorPerformanceCaveat: v=!1, reversedDepthBuffer: _=!1, outputBufferType: x=Ka} = e;
                        this.isWebGLRenderer = !0;
                        let M;
                        if (n !== null) {
                            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                            M = n.getContextAttributes().alpha
                        } else
                            M = c;
                        const C = x
                          , R = new Set([bv, xv, Op])
                          , A = new Set([Ka, fr, ph, mh, yv, _v])
                          , E = new Uint32Array(4)
                          , N = new Int32Array(4);
                        let I = null
                          , L = null;
                        const k = []
                          , B = [];
                        let X = null;
                        this.domElement = t,
                        this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        },
                        this.autoClear = !0,
                        this.autoClearColor = !0,
                        this.autoClearDepth = !0,
                        this.autoClearStencil = !0,
                        this.sortObjects = !0,
                        this.clippingPlanes = [],
                        this.localClippingEnabled = !1,
                        this.toneMapping = ur,
                        this.toneMappingExposure = 1,
                        this.transmissionResolutionScale = 1;
                        const G = this;
                        let P = !1;
                        this._outputColorSpace = wa;
                        let U = 0
                          , W = 0
                          , K = null
                          , q = -1
                          , te = null;
                        const ce = new ti
                          , J = new ti;
                        let Q = null;
                        const se = new dt(0);
                        let Te = 0
                          , Ee = t.width
                          , Be = t.height
                          , j = 1
                          , ve = null
                          , Re = null;
                        const le = new ti(0,0,Ee,Be)
                          , Ae = new ti(0,0,Ee,Be);
                        let Ne = !1;
                        const ke = new Gh;
                        let at = !1
                          , Je = !1;
                        const Ft = new Wt
                          , Vt = new Y
                          , we = new ti
                          , Ye = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };
                        let Ve = !1;
                        function tt() {
                            return K === null ? j : 1
                        }
                        let Z = n;
                        function At(V, re) {
                            return t.getContext(V, re)
                        }
                        try {
                            const V = {
                                alpha: !0,
                                depth: a,
                                stencil: r,
                                antialias: f,
                                premultipliedAlpha: p,
                                preserveDrawingBuffer: m,
                                powerPreference: g,
                                failIfMajorPerformanceCaveat: v
                            };
                            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${sv}`),
                            t.addEventListener("webglcontextlost", pt, !1),
                            t.addEventListener("webglcontextrestored", Mt, !1),
                            t.addEventListener("webglcontextcreationerror", In, !1),
                            Z === null) {
                                const re = "webgl2";
                                if (Z = At(re, V),
                                Z === null)
                                    throw At(re) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                            }
                        } catch (V) {
                            throw Et("WebGLRenderer: " + V.message),
                            V
                        }
                        let $e, xt, Ke, wt, H, O, oe, Ce, Ue, Me, st, je, St, Ct, He, We, rt, ft, et, qt, ae, nt, Ge, ht;
                        function Fe() {
                            $e = new fD(Z),
                            $e.init(),
                            nt = new zE(Z,$e),
                            xt = new nD(Z,$e,e,nt),
                            Ke = new eL(Z,$e),
                            xt.reversedDepthBuffer && _ && Ke.buffers.depth.setReversed(!0),
                            wt = new pD(Z),
                            H = new FN,
                            O = new tL(Z,$e,Ke,H,xt,nt,wt),
                            oe = new aD(G),
                            Ce = new uD(G),
                            Ue = new KR(Z),
                            Ge = new eD(Z,Ue),
                            Me = new hD(Z,Ue,wt,Ge),
                            st = new gD(Z,Me,Ue,wt),
                            et = new mD(Z,xt,O),
                            We = new iD(H),
                            je = new BN(G,oe,Ce,$e,xt,Ge,We),
                            St = new oL(G,H),
                            Ct = new kN,
                            He = new YN($e),
                            ft = new $R(G,oe,Ce,Ke,st,M,p),
                            rt = new JN(G,st,xt),
                            ht = new lL(Z,wt,xt,Ke),
                            qt = new tD(Z,$e,wt),
                            ae = new dD(Z,$e,wt),
                            wt.programs = je.programs,
                            G.capabilities = xt,
                            G.extensions = $e,
                            G.properties = H,
                            G.renderLists = Ct,
                            G.shadowMap = rt,
                            G.state = Ke,
                            G.info = wt
                        }
                        Fe(),
                        C !== Ka && (X = new yD(C,t.width,t.height,a,r));
                        const xe = new sL(G,Z);
                        this.xr = xe,
                        this.getContext = function() {
                            return Z
                        }
                        ,
                        this.getContextAttributes = function() {
                            return Z.getContextAttributes()
                        }
                        ,
                        this.forceContextLoss = function() {
                            const V = $e.get("WEBGL_lose_context");
                            V && V.loseContext()
                        }
                        ,
                        this.forceContextRestore = function() {
                            const V = $e.get("WEBGL_lose_context");
                            V && V.restoreContext()
                        }
                        ,
                        this.getPixelRatio = function() {
                            return j
                        }
                        ,
                        this.setPixelRatio = function(V) {
                            V !== void 0 && (j = V,
                            this.setSize(Ee, Be, !1))
                        }
                        ,
                        this.getSize = function(V) {
                            return V.set(Ee, Be)
                        }
                        ,
                        this.setSize = function(V, re, he=!0) {
                            if (xe.isPresenting) {
                                ot("WebGLRenderer: Can't change size while VR device is presenting.");
                                return
                            }
                            Ee = V,
                            Be = re,
                            t.width = Math.floor(V * j),
                            t.height = Math.floor(re * j),
                            he === !0 && (t.style.width = V + "px",
                            t.style.height = re + "px"),
                            X !== null && X.setSize(t.width, t.height),
                            this.setViewport(0, 0, V, re)
                        }
                        ,
                        this.getDrawingBufferSize = function(V) {
                            return V.set(Ee * j, Be * j).floor()
                        }
                        ,
                        this.setDrawingBufferSize = function(V, re, he) {
                            Ee = V,
                            Be = re,
                            j = he,
                            t.width = Math.floor(V * he),
                            t.height = Math.floor(re * he),
                            this.setViewport(0, 0, V, re)
                        }
                        ,
                        this.setEffects = function(V) {
                            if (C === Ka) {
                                console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.");
                                return
                            }
                            if (V) {
                                for (let re = 0; re < V.length; re++)
                                    if (V[re].isOutputPass === !0) {
                                        console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");
                                        break
                                    }
                            }
                            X.setEffects(V || [])
                        }
                        ,
                        this.getCurrentViewport = function(V) {
                            return V.copy(ce)
                        }
                        ,
                        this.getViewport = function(V) {
                            return V.copy(le)
                        }
                        ,
                        this.setViewport = function(V, re, he, ye) {
                            V.isVector4 ? le.set(V.x, V.y, V.z, V.w) : le.set(V, re, he, ye),
                            Ke.viewport(ce.copy(le).multiplyScalar(j).round())
                        }
                        ,
                        this.getScissor = function(V) {
                            return V.copy(Ae)
                        }
                        ,
                        this.setScissor = function(V, re, he, ye) {
                            V.isVector4 ? Ae.set(V.x, V.y, V.z, V.w) : Ae.set(V, re, he, ye),
                            Ke.scissor(J.copy(Ae).multiplyScalar(j).round())
                        }
                        ,
                        this.getScissorTest = function() {
                            return Ne
                        }
                        ,
                        this.setScissorTest = function(V) {
                            Ke.setScissorTest(Ne = V)
                        }
                        ,
                        this.setOpaqueSort = function(V) {
                            ve = V
                        }
                        ,
                        this.setTransparentSort = function(V) {
                            Re = V
                        }
                        ,
                        this.getClearColor = function(V) {
                            return V.copy(ft.getClearColor())
                        }
                        ,
                        this.setClearColor = function() {
                            ft.setClearColor(...arguments)
                        }
                        ,
                        this.getClearAlpha = function() {
                            return ft.getClearAlpha()
                        }
                        ,
                        this.setClearAlpha = function() {
                            ft.setClearAlpha(...arguments)
                        }
                        ,
                        this.clear = function(V=!0, re=!0, he=!0) {
                            let ye = 0;
                            if (V) {
                                let fe = !1;
                                if (K !== null) {
                                    const ze = K.texture.format;
                                    fe = R.has(ze)
                                }
                                if (fe) {
                                    const ze = K.texture.type
                                      , qe = A.has(ze)
                                      , mt = ft.getClearColor()
                                      , Ze = ft.getClearAlpha()
                                      , Rt = mt.r
                                      , Ot = mt.g
                                      , Tt = mt.b;
                                    qe ? (E[0] = Rt,
                                    E[1] = Ot,
                                    E[2] = Tt,
                                    E[3] = Ze,
                                    Z.clearBufferuiv(Z.COLOR, 0, E)) : (N[0] = Rt,
                                    N[1] = Ot,
                                    N[2] = Tt,
                                    N[3] = Ze,
                                    Z.clearBufferiv(Z.COLOR, 0, N))
                                } else
                                    ye |= Z.COLOR_BUFFER_BIT
                            }
                            re && (ye |= Z.DEPTH_BUFFER_BIT),
                            he && (ye |= Z.STENCIL_BUFFER_BIT,
                            this.state.buffers.stencil.setMask(4294967295)),
                            Z.clear(ye)
                        }
                        ,
                        this.clearColor = function() {
                            this.clear(!0, !1, !1)
                        }
                        ,
                        this.clearDepth = function() {
                            this.clear(!1, !0, !1)
                        }
                        ,
                        this.clearStencil = function() {
                            this.clear(!1, !1, !0)
                        }
                        ,
                        this.dispose = function() {
                            t.removeEventListener("webglcontextlost", pt, !1),
                            t.removeEventListener("webglcontextrestored", Mt, !1),
                            t.removeEventListener("webglcontextcreationerror", In, !1),
                            ft.dispose(),
                            Ct.dispose(),
                            He.dispose(),
                            H.dispose(),
                            oe.dispose(),
                            Ce.dispose(),
                            st.dispose(),
                            Ge.dispose(),
                            ht.dispose(),
                            je.dispose(),
                            xe.dispose(),
                            xe.removeEventListener("sessionstart", Yr),
                            xe.removeEventListener("sessionend", jr),
                            Ua.stop()
                        }
                        ;
                        function pt(V) {
                            V.preventDefault(),
                            Xp("WebGLRenderer: Context Lost."),
                            P = !0
                        }
                        function Mt() {
                            Xp("WebGLRenderer: Context Restored."),
                            P = !1;
                            const V = wt.autoReset
                              , re = rt.enabled
                              , he = rt.autoUpdate
                              , ye = rt.needsUpdate
                              , fe = rt.type;
                            Fe(),
                            wt.autoReset = V,
                            rt.enabled = re,
                            rt.autoUpdate = he,
                            rt.needsUpdate = ye,
                            rt.type = fe
                        }
                        function In(V) {
                            Et("WebGLRenderer: A WebGL context could not be created. Reason: ", V.statusMessage)
                        }
                        function xn(V) {
                            const re = V.target;
                            re.removeEventListener("dispose", xn),
                            xa(re)
                        }
                        function xa(V) {
                            Gi(V),
                            H.remove(V)
                        }
                        function Gi(V) {
                            const re = H.get(V).programs;
                            re !== void 0 && (re.forEach(function(he) {
                                je.releaseProgram(he)
                            }),
                            V.isShaderMaterial && je.releaseShaderCache(V))
                        }
                        this.renderBufferDirect = function(V, re, he, ye, fe, ze) {
                            re === null && (re = Ye);
                            const qe = fe.isMesh && fe.matrixWorld.determinant() < 0
                              , mt = Bc(V, re, he, ye, fe);
                            Ke.setMaterial(ye, qe);
                            let Ze = he.index
                              , Rt = 1;
                            if (ye.wireframe === !0) {
                                if (Ze = Me.getWireframeAttribute(he),
                                Ze === void 0)
                                    return;
                                Rt = 2
                            }
                            const Ot = he.drawRange
                              , Tt = he.attributes.position;
                            let Qt = Ot.start * Rt
                              , cn = (Ot.start + Ot.count) * Rt;
                            ze !== null && (Qt = Math.max(Qt, ze.start * Rt),
                            cn = Math.min(cn, (ze.start + ze.count) * Rt)),
                            Ze !== null ? (Qt = Math.max(Qt, 0),
                            cn = Math.min(cn, Ze.count)) : Tt != null && (Qt = Math.max(Qt, 0),
                            cn = Math.min(cn, Tt.count));
                            const nn = cn - Qt;
                            if (nn < 0 || nn === 1 / 0)
                                return;
                            Ge.setup(fe, ye, mt, he, Ze);
                            let On, un = qt;
                            if (Ze !== null && (On = Ue.get(Ze),
                            un = ae,
                            un.setIndex(On)),
                            fe.isMesh)
                                ye.wireframe === !0 ? (Ke.setLineWidth(ye.wireframeLinewidth * tt()),
                                un.setMode(Z.LINES)) : un.setMode(Z.TRIANGLES);
                            else if (fe.isLine) {
                                let ut = ye.linewidth;
                                ut === void 0 && (ut = 1),
                                Ke.setLineWidth(ut * tt()),
                                fe.isLineSegments ? un.setMode(Z.LINES) : fe.isLineLoop ? un.setMode(Z.LINE_LOOP) : un.setMode(Z.LINE_STRIP)
                            } else
                                fe.isPoints ? un.setMode(Z.POINTS) : fe.isSprite && un.setMode(Z.TRIANGLES);
                            if (fe.isBatchedMesh)
                                if (fe._multiDrawInstances !== null)
                                    yh("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                                    un.renderMultiDrawInstances(fe._multiDrawStarts, fe._multiDrawCounts, fe._multiDrawCount, fe._multiDrawInstances);
                                else if ($e.get("WEBGL_multi_draw"))
                                    un.renderMultiDraw(fe._multiDrawStarts, fe._multiDrawCounts, fe._multiDrawCount);
                                else {
                                    const ut = fe._multiDrawStarts
                                      , kt = fe._multiDrawCounts
                                      , an = fe._multiDrawCount
                                      , Xi = Ze ? Ue.get(Ze).bytesPerElement : 1
                                      , ni = H.get(ye).currentProgram.getUniforms();
                                    for (let Ri = 0; Ri < an; Ri++)
                                        ni.setValue(Z, "_gl_DrawID", Ri),
                                        un.render(ut[Ri] / Xi, kt[Ri])
                                }
                            else if (fe.isInstancedMesh)
                                un.renderInstances(Qt, nn, fe.count);
                            else if (he.isInstancedBufferGeometry) {
                                const ut = he._maxInstanceCount !== void 0 ? he._maxInstanceCount : 1 / 0
                                  , kt = Math.min(he.instanceCount, ut);
                                un.renderInstances(Qt, nn, kt)
                            } else
                                un.render(Qt, nn)
                        }
                        ;
                        function qr(V, re, he) {
                            V.transparent === !0 && V.side === wo && V.forceSinglePass === !1 ? (V.side = Qa,
                            V.needsUpdate = !0,
                            Wi(V, re, he),
                            V.side = vl,
                            V.needsUpdate = !0,
                            Wi(V, re, he),
                            V.side = wo) : Wi(V, re, he)
                        }
                        this.compile = function(V, re, he=null) {
                            he === null && (he = V),
                            L = He.get(he),
                            L.init(re),
                            B.push(L),
                            he.traverseVisible(function(fe) {
                                fe.isLight && fe.layers.test(re.layers) && (L.pushLight(fe),
                                fe.castShadow && L.pushShadow(fe))
                            }),
                            V !== he && V.traverseVisible(function(fe) {
                                fe.isLight && fe.layers.test(re.layers) && (L.pushLight(fe),
                                fe.castShadow && L.pushShadow(fe))
                            }),
                            L.setupLights();
                            const ye = new Set;
                            return V.traverse(function(fe) {
                                if (!(fe.isMesh || fe.isPoints || fe.isLine || fe.isSprite))
                                    return;
                                const ze = fe.material;
                                if (ze)
                                    if (Array.isArray(ze))
                                        for (let qe = 0; qe < ze.length; qe++) {
                                            const mt = ze[qe];
                                            qr(mt, he, fe),
                                            ye.add(mt)
                                        }
                                    else
                                        qr(ze, he, fe),
                                        ye.add(ze)
                            }),
                            L = B.pop(),
                            ye
                        }
                        ,
                        this.compileAsync = function(V, re, he=null) {
                            const ye = this.compile(V, re, he);
                            return new Promise(fe => {
                                function ze() {
                                    if (ye.forEach(function(qe) {
                                        H.get(qe).currentProgram.isReady() && ye.delete(qe)
                                    }),
                                    ye.size === 0) {
                                        fe(V);
                                        return
                                    }
                                    setTimeout(ze, 10)
                                }
                                $e.get("KHR_parallel_shader_compile") !== null ? ze() : setTimeout(ze, 10)
                            }
                            )
                        }
                        ;
                        let mr = null;
                        function zc(V) {
                            mr && mr(V)
                        }
                        function Yr() {
                            Ua.stop()
                        }
                        function jr() {
                            Ua.start()
                        }
                        const Ua = new uE;
                        Ua.setAnimationLoop(zc),
                        typeof self < "u" && Ua.setContext(self),
                        this.setAnimationLoop = function(V) {
                            mr = V,
                            xe.setAnimationLoop(V),
                            V === null ? Ua.stop() : Ua.start()
                        }
                        ,
                        xe.addEventListener("sessionstart", Yr),
                        xe.addEventListener("sessionend", jr),
                        this.render = function(V, re) {
                            if (re !== void 0 && re.isCamera !== !0) {
                                Et("WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                return
                            }
                            if (P === !0)
                                return;
                            const he = xe.enabled === !0 && xe.isPresenting === !0
                              , ye = X !== null && (K === null || he) && X.begin(G, K);
                            if (V.matrixWorldAutoUpdate === !0 && V.updateMatrixWorld(),
                            re.parent === null && re.matrixWorldAutoUpdate === !0 && re.updateMatrixWorld(),
                            xe.enabled === !0 && xe.isPresenting === !0 && (X === null || X.isCompositing() === !1) && (xe.cameraAutoUpdate === !0 && xe.updateCamera(re),
                            re = xe.getCamera()),
                            V.isScene === !0 && V.onBeforeRender(G, V, re, K),
                            L = He.get(V, B.length),
                            L.init(re),
                            B.push(L),
                            Ft.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse),
                            ke.setFromProjectionMatrix(Ft, Bs, re.reversedDepth),
                            Je = this.localClippingEnabled,
                            at = We.init(this.clippingPlanes, Je),
                            I = Ct.get(V, k.length),
                            I.init(),
                            k.push(I),
                            xe.enabled === !0 && xe.isPresenting === !0) {
                                const ze = G.xr.getDepthSensingMesh();
                                ze !== null && ss(ze, re, -1 / 0, G.sortObjects)
                            }
                            ss(V, re, 0, G.sortObjects),
                            I.finish(),
                            G.sortObjects === !0 && I.sort(ve, Re),
                            Ve = xe.enabled === !1 || xe.isPresenting === !1 || xe.hasDepthSensing() === !1,
                            Ve && ft.addToRenderList(I, V),
                            this.info.render.frame++,
                            at === !0 && We.beginShadows();
                            const fe = L.state.shadowsArray;
                            if (rt.render(fe, V, re),
                            at === !0 && We.endShadows(),
                            this.info.autoReset === !0 && this.info.reset(),
                            (ye && X.hasRenderPass()) === !1) {
                                const ze = I.opaque
                                  , qe = I.transmissive;
                                if (L.setupLights(),
                                re.isArrayCamera) {
                                    const mt = re.cameras;
                                    if (qe.length > 0)
                                        for (let Ze = 0, Rt = mt.length; Ze < Rt; Ze++) {
                                            const Ot = mt[Ze];
                                            ba(ze, qe, V, Ot)
                                        }
                                    Ve && ft.render(V);
                                    for (let Ze = 0, Rt = mt.length; Ze < Rt; Ze++) {
                                        const Ot = mt[Ze];
                                        Rl(I, V, Ot, Ot.viewport)
                                    }
                                } else
                                    qe.length > 0 && ba(ze, qe, V, re),
                                    Ve && ft.render(V),
                                    Rl(I, V, re)
                            }
                            K !== null && W === 0 && (O.updateMultisampleRenderTarget(K),
                            O.updateRenderTargetMipmap(K)),
                            ye && X.end(G),
                            V.isScene === !0 && V.onAfterRender(G, V, re),
                            Ge.resetDefaultState(),
                            q = -1,
                            te = null,
                            B.pop(),
                            B.length > 0 ? (L = B[B.length - 1],
                            at === !0 && We.setGlobalState(G.clippingPlanes, L.state.camera)) : L = null,
                            k.pop(),
                            k.length > 0 ? I = k[k.length - 1] : I = null
                        }
                        ;
                        function ss(V, re, he, ye) {
                            if (V.visible === !1)
                                return;
                            if (V.layers.test(re.layers)) {
                                if (V.isGroup)
                                    he = V.renderOrder;
                                else if (V.isLOD)
                                    V.autoUpdate === !0 && V.update(re);
                                else if (V.isLight)
                                    L.pushLight(V),
                                    V.castShadow && L.pushShadow(V);
                                else if (V.isSprite) {
                                    if (!V.frustumCulled || ke.intersectsSprite(V)) {
                                        ye && we.setFromMatrixPosition(V.matrixWorld).applyMatrix4(Ft);
                                        const ze = st.update(V)
                                          , qe = V.material;
                                        qe.visible && I.push(V, ze, qe, he, we.z, null)
                                    }
                                } else if ((V.isMesh || V.isLine || V.isPoints) && (!V.frustumCulled || ke.intersectsObject(V))) {
                                    const ze = st.update(V)
                                      , qe = V.material;
                                    if (ye && (V.boundingSphere !== void 0 ? (V.boundingSphere === null && V.computeBoundingSphere(),
                                    we.copy(V.boundingSphere.center)) : (ze.boundingSphere === null && ze.computeBoundingSphere(),
                                    we.copy(ze.boundingSphere.center)),
                                    we.applyMatrix4(V.matrixWorld).applyMatrix4(Ft)),
                                    Array.isArray(qe)) {
                                        const mt = ze.groups;
                                        for (let Ze = 0, Rt = mt.length; Ze < Rt; Ze++) {
                                            const Ot = mt[Ze]
                                              , Tt = qe[Ot.materialIndex];
                                            Tt && Tt.visible && I.push(V, ze, Tt, he, we.z, Ot)
                                        }
                                    } else
                                        qe.visible && I.push(V, ze, qe, he, we.z, null)
                                }
                            }
                            const fe = V.children;
                            for (let ze = 0, qe = fe.length; ze < qe; ze++)
                                ss(fe[ze], re, he, ye)
                        }
                        function Rl(V, re, he, ye) {
                            const {opaque: fe, transmissive: ze, transparent: qe} = V;
                            L.setupLightsView(he),
                            at === !0 && We.setGlobalState(G.clippingPlanes, he),
                            ye && Ke.viewport(ce.copy(ye)),
                            fe.length > 0 && Zn(fe, re, he),
                            ze.length > 0 && Zn(ze, re, he),
                            qe.length > 0 && Zn(qe, re, he),
                            Ke.buffers.depth.setTest(!0),
                            Ke.buffers.depth.setMask(!0),
                            Ke.buffers.color.setMask(!0),
                            Ke.setPolygonOffset(!1)
                        }
                        function ba(V, re, he, ye) {
                            if ((he.isScene === !0 ? he.overrideMaterial : null) !== null)
                                return;
                            if (L.state.transmissionRenderTarget[ye.id] === void 0) {
                                const Tt = $e.has("EXT_color_buffer_half_float") || $e.has("EXT_color_buffer_float");
                                L.state.transmissionRenderTarget[ye.id] = new Vs(1,1,{
                                    generateMipmaps: !0,
                                    type: Tt ? No : Ka,
                                    minFilter: Do,
                                    samples: xt.samples,
                                    stencilBuffer: r,
                                    resolveDepthBuffer: !1,
                                    resolveStencilBuffer: !1,
                                    colorSpace: Sn.workingColorSpace
                                })
                            }
                            const fe = L.state.transmissionRenderTarget[ye.id]
                              , ze = ye.viewport || ce;
                            fe.setSize(ze.z * G.transmissionResolutionScale, ze.w * G.transmissionResolutionScale);
                            const qe = G.getRenderTarget()
                              , mt = G.getActiveCubeFace()
                              , Ze = G.getActiveMipmapLevel();
                            G.setRenderTarget(fe),
                            G.getClearColor(se),
                            Te = G.getClearAlpha(),
                            Te < 1 && G.setClearColor(16777215, .5),
                            G.clear(),
                            Ve && ft.render(he);
                            const Rt = G.toneMapping;
                            G.toneMapping = ur;
                            const Ot = ye.viewport;
                            if (ye.viewport !== void 0 && (ye.viewport = void 0),
                            L.setupLightsView(ye),
                            at === !0 && We.setGlobalState(G.clippingPlanes, ye),
                            Zn(V, he, ye),
                            O.updateMultisampleRenderTarget(fe),
                            O.updateRenderTargetMipmap(fe),
                            $e.has("WEBGL_multisampled_render_to_texture") === !1) {
                                let Tt = !1;
                                for (let Qt = 0, cn = re.length; Qt < cn; Qt++) {
                                    const {object: nn, geometry: On, material: un, group: ut} = re[Qt];
                                    if (un.side === wo && nn.layers.test(ye.layers)) {
                                        const kt = un.side;
                                        un.side = Qa,
                                        un.needsUpdate = !0,
                                        Ci(nn, he, ye, On, un, ut),
                                        un.side = kt,
                                        un.needsUpdate = !0,
                                        Tt = !0
                                    }
                                }
                                Tt === !0 && (O.updateMultisampleRenderTarget(fe),
                                O.updateRenderTargetMipmap(fe))
                            }
                            G.setRenderTarget(qe, mt, Ze),
                            G.setClearColor(se, Te),
                            Ot !== void 0 && (ye.viewport = Ot),
                            G.toneMapping = Rt
                        }
                        function Zn(V, re, he) {
                            const ye = re.isScene === !0 ? re.overrideMaterial : null;
                            for (let fe = 0, ze = V.length; fe < ze; fe++) {
                                const qe = V[fe]
                                  , {object: mt, geometry: Ze, group: Rt} = qe;
                                let Ot = qe.material;
                                Ot.allowOverride === !0 && ye !== null && (Ot = ye),
                                mt.layers.test(he.layers) && Ci(mt, re, he, Ze, Ot, Rt)
                            }
                        }
                        function Ci(V, re, he, ye, fe, ze) {
                            V.onBeforeRender(G, re, he, ye, fe, ze),
                            V.modelViewMatrix.multiplyMatrices(he.matrixWorldInverse, V.matrixWorld),
                            V.normalMatrix.getNormalMatrix(V.modelViewMatrix),
                            fe.onBeforeRender(G, re, he, ye, V, ze),
                            fe.transparent === !0 && fe.side === wo && fe.forceSinglePass === !1 ? (fe.side = Qa,
                            fe.needsUpdate = !0,
                            G.renderBufferDirect(he, re, ye, fe, V, ze),
                            fe.side = vl,
                            fe.needsUpdate = !0,
                            G.renderBufferDirect(he, re, ye, fe, V, ze),
                            fe.side = wo) : G.renderBufferDirect(he, re, ye, fe, V, ze),
                            V.onAfterRender(G, re, he, ye, fe, ze)
                        }
                        function Wi(V, re, he) {
                            re.isScene !== !0 && (re = Ye);
                            const ye = H.get(V)
                              , fe = L.state.lights
                              , ze = L.state.shadowsArray
                              , qe = fe.state.version
                              , mt = je.getParameters(V, fe.state, ze, re, he)
                              , Ze = je.getProgramCacheKey(mt);
                            let Rt = ye.programs;
                            ye.environment = V.isMeshStandardMaterial ? re.environment : null,
                            ye.fog = re.fog,
                            ye.envMap = (V.isMeshStandardMaterial ? Ce : oe).get(V.envMap || ye.environment),
                            ye.envMapRotation = ye.environment !== null && V.envMap === null ? re.environmentRotation : V.envMapRotation,
                            Rt === void 0 && (V.addEventListener("dispose", xn),
                            Rt = new Map,
                            ye.programs = Rt);
                            let Ot = Rt.get(Ze);
                            if (Ot !== void 0) {
                                if (ye.currentProgram === Ot && ye.lightsStateVersion === qe)
                                    return Zr(V, mt),
                                    Ot
                            } else
                                mt.uniforms = je.getUniforms(V),
                                V.onBeforeCompile(mt, G),
                                Ot = je.acquireProgram(mt, Ze),
                                Rt.set(Ze, Ot),
                                ye.uniforms = mt.uniforms;
                            const Tt = ye.uniforms;
                            return (!V.isShaderMaterial && !V.isRawShaderMaterial || V.clipping === !0) && (Tt.clippingPlanes = We.uniform),
                            Zr(V, mt),
                            ye.needsLights = Es(V),
                            ye.lightsStateVersion = qe,
                            ye.needsLights && (Tt.ambientLightColor.value = fe.state.ambient,
                            Tt.lightProbe.value = fe.state.probe,
                            Tt.directionalLights.value = fe.state.directional,
                            Tt.directionalLightShadows.value = fe.state.directionalShadow,
                            Tt.spotLights.value = fe.state.spot,
                            Tt.spotLightShadows.value = fe.state.spotShadow,
                            Tt.rectAreaLights.value = fe.state.rectArea,
                            Tt.ltc_1.value = fe.state.rectAreaLTC1,
                            Tt.ltc_2.value = fe.state.rectAreaLTC2,
                            Tt.pointLights.value = fe.state.point,
                            Tt.pointLightShadows.value = fe.state.pointShadow,
                            Tt.hemisphereLights.value = fe.state.hemi,
                            Tt.directionalShadowMap.value = fe.state.directionalShadowMap,
                            Tt.directionalShadowMatrix.value = fe.state.directionalShadowMatrix,
                            Tt.spotShadowMap.value = fe.state.spotShadowMap,
                            Tt.spotLightMatrix.value = fe.state.spotLightMatrix,
                            Tt.spotLightMap.value = fe.state.spotLightMap,
                            Tt.pointShadowMap.value = fe.state.pointShadowMap,
                            Tt.pointShadowMatrix.value = fe.state.pointShadowMatrix),
                            ye.currentProgram = Ot,
                            ye.uniformsList = null,
                            Ot
                        }
                        function Ia(V) {
                            if (V.uniformsList === null) {
                                const re = V.currentProgram.getUniforms();
                                V.uniformsList = cy.seqWithValue(re.seq, V.uniforms)
                            }
                            return V.uniformsList
                        }
                        function Zr(V, re) {
                            const he = H.get(V);
                            he.outputColorSpace = re.outputColorSpace,
                            he.batching = re.batching,
                            he.batchingColor = re.batchingColor,
                            he.instancing = re.instancing,
                            he.instancingColor = re.instancingColor,
                            he.instancingMorph = re.instancingMorph,
                            he.skinning = re.skinning,
                            he.morphTargets = re.morphTargets,
                            he.morphNormals = re.morphNormals,
                            he.morphColors = re.morphColors,
                            he.morphTargetsCount = re.morphTargetsCount,
                            he.numClippingPlanes = re.numClippingPlanes,
                            he.numIntersection = re.numClipIntersection,
                            he.vertexAlphas = re.vertexAlphas,
                            he.vertexTangents = re.vertexTangents,
                            he.toneMapping = re.toneMapping
                        }
                        function Bc(V, re, he, ye, fe) {
                            re.isScene !== !0 && (re = Ye),
                            O.resetTextureUnits();
                            const ze = re.fog
                              , qe = ye.isMeshStandardMaterial ? re.environment : null
                              , mt = K === null ? G.outputColorSpace : K.isXRRenderTarget === !0 ? K.texture.colorSpace : Sc
                              , Ze = (ye.isMeshStandardMaterial ? Ce : oe).get(ye.envMap || qe)
                              , Rt = ye.vertexColors === !0 && !!he.attributes.color && he.attributes.color.itemSize === 4
                              , Ot = !!he.attributes.tangent && (!!ye.normalMap || ye.anisotropy > 0)
                              , Tt = !!he.morphAttributes.position
                              , Qt = !!he.morphAttributes.normal
                              , cn = !!he.morphAttributes.color;
                            let nn = ur;
                            ye.toneMapped && (K === null || K.isXRRenderTarget === !0) && (nn = G.toneMapping);
                            const On = he.morphAttributes.position || he.morphAttributes.normal || he.morphAttributes.color
                              , un = On !== void 0 ? On.length : 0
                              , ut = H.get(ye)
                              , kt = L.state.lights;
                            if (at === !0 && (Je === !0 || V !== te)) {
                                const hi = V === te && ye.id === q;
                                We.setState(ye, V, hi)
                            }
                            let an = !1;
                            ye.version === ut.__version ? (ut.needsLights && ut.lightsStateVersion !== kt.state.version || ut.outputColorSpace !== mt || fe.isBatchedMesh && ut.batching === !1 || !fe.isBatchedMesh && ut.batching === !0 || fe.isBatchedMesh && ut.batchingColor === !0 && fe.colorTexture === null || fe.isBatchedMesh && ut.batchingColor === !1 && fe.colorTexture !== null || fe.isInstancedMesh && ut.instancing === !1 || !fe.isInstancedMesh && ut.instancing === !0 || fe.isSkinnedMesh && ut.skinning === !1 || !fe.isSkinnedMesh && ut.skinning === !0 || fe.isInstancedMesh && ut.instancingColor === !0 && fe.instanceColor === null || fe.isInstancedMesh && ut.instancingColor === !1 && fe.instanceColor !== null || fe.isInstancedMesh && ut.instancingMorph === !0 && fe.morphTexture === null || fe.isInstancedMesh && ut.instancingMorph === !1 && fe.morphTexture !== null || ut.envMap !== Ze || ye.fog === !0 && ut.fog !== ze || ut.numClippingPlanes !== void 0 && (ut.numClippingPlanes !== We.numPlanes || ut.numIntersection !== We.numIntersection) || ut.vertexAlphas !== Rt || ut.vertexTangents !== Ot || ut.morphTargets !== Tt || ut.morphNormals !== Qt || ut.morphColors !== cn || ut.toneMapping !== nn || ut.morphTargetsCount !== un) && (an = !0) : (an = !0,
                            ut.__version = ye.version);
                            let Xi = ut.currentProgram;
                            an === !0 && (Xi = Wi(ye, re, fe));
                            let ni = !1
                              , Ri = !1
                              , Ji = !1;
                            const bn = Xi.getUniforms()
                              , Jn = ut.uniforms;
                            if (Ke.useProgram(Xi.program) && (ni = !0,
                            Ri = !0,
                            Ji = !0),
                            ye.id !== q && (q = ye.id,
                            Ri = !0),
                            ni || te !== V) {
                                Ke.buffers.depth.getReversed() && V.reversedDepth !== !0 && (V._reversedDepth = !0,
                                V.updateProjectionMatrix()),
                                bn.setValue(Z, "projectionMatrix", V.projectionMatrix),
                                bn.setValue(Z, "viewMatrix", V.matrixWorldInverse);
                                const hi = bn.map.cameraPosition;
                                hi !== void 0 && hi.setValue(Z, Vt.setFromMatrixPosition(V.matrixWorld)),
                                xt.logarithmicDepthBuffer && bn.setValue(Z, "logDepthBufFC", 2 / (Math.log(V.far + 1) / Math.LN2)),
                                (ye.isMeshPhongMaterial || ye.isMeshToonMaterial || ye.isMeshLambertMaterial || ye.isMeshBasicMaterial || ye.isMeshStandardMaterial || ye.isShaderMaterial) && bn.setValue(Z, "isOrthographic", V.isOrthographicCamera === !0),
                                te !== V && (te = V,
                                Ri = !0,
                                Ji = !0)
                            }
                            if (ut.needsLights && (kt.state.directionalShadowMap.length > 0 && bn.setValue(Z, "directionalShadowMap", kt.state.directionalShadowMap, O),
                            kt.state.spotShadowMap.length > 0 && bn.setValue(Z, "spotShadowMap", kt.state.spotShadowMap, O),
                            kt.state.pointShadowMap.length > 0 && bn.setValue(Z, "pointShadowMap", kt.state.pointShadowMap, O)),
                            fe.isSkinnedMesh) {
                                bn.setOptional(Z, fe, "bindMatrix"),
                                bn.setOptional(Z, fe, "bindMatrixInverse");
                                const hi = fe.skeleton;
                                hi && (hi.boneTexture === null && hi.computeBoneTexture(),
                                bn.setValue(Z, "boneTexture", hi.boneTexture, O))
                            }
                            fe.isBatchedMesh && (bn.setOptional(Z, fe, "batchingTexture"),
                            bn.setValue(Z, "batchingTexture", fe._matricesTexture, O),
                            bn.setOptional(Z, fe, "batchingIdTexture"),
                            bn.setValue(Z, "batchingIdTexture", fe._indirectTexture, O),
                            bn.setOptional(Z, fe, "batchingColorTexture"),
                            fe._colorsTexture !== null && bn.setValue(Z, "batchingColorTexture", fe._colorsTexture, O));
                            const qi = he.morphAttributes;
                            if ((qi.position !== void 0 || qi.normal !== void 0 || qi.color !== void 0) && et.update(fe, he, Xi),
                            (Ri || ut.receiveShadow !== fe.receiveShadow) && (ut.receiveShadow = fe.receiveShadow,
                            bn.setValue(Z, "receiveShadow", fe.receiveShadow)),
                            ye.isMeshGouraudMaterial && ye.envMap !== null && (Jn.envMap.value = Ze,
                            Jn.flipEnvMap.value = Ze.isCubeTexture && Ze.isRenderTargetTexture === !1 ? -1 : 1),
                            ye.isMeshStandardMaterial && ye.envMap === null && re.environment !== null && (Jn.envMapIntensity.value = re.environmentIntensity),
                            Jn.dfgLUT !== void 0 && (Jn.dfgLUT.value = uL()),
                            Ri && (bn.setValue(Z, "toneMappingExposure", G.toneMappingExposure),
                            ut.needsLights && Qr(Jn, Ji),
                            ze && ye.fog === !0 && St.refreshFogUniforms(Jn, ze),
                            St.refreshMaterialUniforms(Jn, ye, j, Be, L.state.transmissionRenderTarget[V.id]),
                            cy.upload(Z, Ia(ut), Jn, O)),
                            ye.isShaderMaterial && ye.uniformsNeedUpdate === !0 && (cy.upload(Z, Ia(ut), Jn, O),
                            ye.uniformsNeedUpdate = !1),
                            ye.isSpriteMaterial && bn.setValue(Z, "center", fe.center),
                            bn.setValue(Z, "modelViewMatrix", fe.modelViewMatrix),
                            bn.setValue(Z, "normalMatrix", fe.normalMatrix),
                            bn.setValue(Z, "modelMatrix", fe.matrixWorld),
                            ye.isShaderMaterial || ye.isRawShaderMaterial) {
                                const hi = ye.uniformsGroups;
                                for (let Di = 0, Nl = hi.length; Di < Nl; Di++) {
                                    const As = hi[Di];
                                    ht.update(As, Xi),
                                    ht.bind(As, Xi)
                                }
                            }
                            return Xi
                        }
                        function Qr(V, re) {
                            V.ambientLightColor.needsUpdate = re,
                            V.lightProbe.needsUpdate = re,
                            V.directionalLights.needsUpdate = re,
                            V.directionalLightShadows.needsUpdate = re,
                            V.pointLights.needsUpdate = re,
                            V.pointLightShadows.needsUpdate = re,
                            V.spotLights.needsUpdate = re,
                            V.spotLightShadows.needsUpdate = re,
                            V.rectAreaLights.needsUpdate = re,
                            V.hemisphereLights.needsUpdate = re
                        }
                        function Es(V) {
                            return V.isMeshLambertMaterial || V.isMeshToonMaterial || V.isMeshPhongMaterial || V.isMeshStandardMaterial || V.isShadowMaterial || V.isShaderMaterial && V.lights === !0
                        }
                        this.getActiveCubeFace = function() {
                            return U
                        }
                        ,
                        this.getActiveMipmapLevel = function() {
                            return W
                        }
                        ,
                        this.getRenderTarget = function() {
                            return K
                        }
                        ,
                        this.setRenderTargetTextures = function(V, re, he) {
                            const ye = H.get(V);
                            ye.__autoAllocateDepthBuffer = V.resolveDepthBuffer === !1,
                            ye.__autoAllocateDepthBuffer === !1 && (ye.__useRenderToTexture = !1),
                            H.get(V.texture).__webglTexture = re,
                            H.get(V.depthTexture).__webglTexture = ye.__autoAllocateDepthBuffer ? void 0 : he,
                            ye.__hasExternalTextures = !0
                        }
                        ,
                        this.setRenderTargetFramebuffer = function(V, re) {
                            const he = H.get(V);
                            he.__webglFramebuffer = re,
                            he.__useDefaultFramebuffer = re === void 0
                        }
                        ;
                        const Dl = Z.createFramebuffer();
                        this.setRenderTarget = function(V, re=0, he=0) {
                            K = V,
                            U = re,
                            W = he;
                            let ye = null
                              , fe = !1
                              , ze = !1;
                            if (V) {
                                const qe = H.get(V);
                                if (qe.__useDefaultFramebuffer !== void 0) {
                                    Ke.bindFramebuffer(Z.FRAMEBUFFER, qe.__webglFramebuffer),
                                    ce.copy(V.viewport),
                                    J.copy(V.scissor),
                                    Q = V.scissorTest,
                                    Ke.viewport(ce),
                                    Ke.scissor(J),
                                    Ke.setScissorTest(Q),
                                    q = -1;
                                    return
                                } else if (qe.__webglFramebuffer === void 0)
                                    O.setupRenderTarget(V);
                                else if (qe.__hasExternalTextures)
                                    O.rebindTextures(V, H.get(V.texture).__webglTexture, H.get(V.depthTexture).__webglTexture);
                                else if (V.depthBuffer) {
                                    const Rt = V.depthTexture;
                                    if (qe.__boundDepthTexture !== Rt) {
                                        if (Rt !== null && H.has(Rt) && (V.width !== Rt.image.width || V.height !== Rt.image.height))
                                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                        O.setupDepthRenderbuffer(V)
                                    }
                                }
                                const mt = V.texture;
                                (mt.isData3DTexture || mt.isDataArrayTexture || mt.isCompressedArrayTexture) && (ze = !0);
                                const Ze = H.get(V).__webglFramebuffer;
                                V.isWebGLCubeRenderTarget ? (Array.isArray(Ze[re]) ? ye = Ze[re][he] : ye = Ze[re],
                                fe = !0) : V.samples > 0 && O.useMultisampledRTT(V) === !1 ? ye = H.get(V).__webglMultisampledFramebuffer : Array.isArray(Ze) ? ye = Ze[he] : ye = Ze,
                                ce.copy(V.viewport),
                                J.copy(V.scissor),
                                Q = V.scissorTest
                            } else
                                ce.copy(le).multiplyScalar(j).floor(),
                                J.copy(Ae).multiplyScalar(j).floor(),
                                Q = Ne;
                            if (he !== 0 && (ye = Dl),
                            Ke.bindFramebuffer(Z.FRAMEBUFFER, ye) && Ke.drawBuffers(V, ye),
                            Ke.viewport(ce),
                            Ke.scissor(J),
                            Ke.setScissorTest(Q),
                            fe) {
                                const qe = H.get(V.texture);
                                Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + re, qe.__webglTexture, he)
                            } else if (ze) {
                                const qe = re;
                                for (let mt = 0; mt < V.textures.length; mt++) {
                                    const Ze = H.get(V.textures[mt]);
                                    Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0 + mt, Ze.__webglTexture, he, qe)
                                }
                            } else if (V !== null && he !== 0) {
                                const qe = H.get(V.texture);
                                Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_2D, qe.__webglTexture, he)
                            }
                            q = -1
                        }
                        ,
                        this.readRenderTargetPixels = function(V, re, he, ye, fe, ze, qe, mt=0) {
                            if (!(V && V.isWebGLRenderTarget)) {
                                Et("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                return
                            }
                            let Ze = H.get(V).__webglFramebuffer;
                            if (V.isWebGLCubeRenderTarget && qe !== void 0 && (Ze = Ze[qe]),
                            Ze) {
                                Ke.bindFramebuffer(Z.FRAMEBUFFER, Ze);
                                try {
                                    const Rt = V.textures[mt]
                                      , Ot = Rt.format
                                      , Tt = Rt.type;
                                    if (!xt.textureFormatReadable(Ot)) {
                                        Et("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                        return
                                    }
                                    if (!xt.textureTypeReadable(Tt)) {
                                        Et("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        return
                                    }
                                    re >= 0 && re <= V.width - ye && he >= 0 && he <= V.height - fe && (V.textures.length > 1 && Z.readBuffer(Z.COLOR_ATTACHMENT0 + mt),
                                    Z.readPixels(re, he, ye, fe, nt.convert(Ot), nt.convert(Tt), ze))
                                } finally {
                                    const Rt = K !== null ? H.get(K).__webglFramebuffer : null;
                                    Ke.bindFramebuffer(Z.FRAMEBUFFER, Rt)
                                }
                            }
                        }
                        ,
                        this.readRenderTargetPixelsAsync = async function(V, re, he, ye, fe, ze, qe, mt=0) {
                            if (!(V && V.isWebGLRenderTarget))
                                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                            let Ze = H.get(V).__webglFramebuffer;
                            if (V.isWebGLCubeRenderTarget && qe !== void 0 && (Ze = Ze[qe]),
                            Ze)
                                if (re >= 0 && re <= V.width - ye && he >= 0 && he <= V.height - fe) {
                                    Ke.bindFramebuffer(Z.FRAMEBUFFER, Ze);
                                    const Rt = V.textures[mt]
                                      , Ot = Rt.format
                                      , Tt = Rt.type;
                                    if (!xt.textureFormatReadable(Ot))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                    if (!xt.textureTypeReadable(Tt))
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                    const Qt = Z.createBuffer();
                                    Z.bindBuffer(Z.PIXEL_PACK_BUFFER, Qt),
                                    Z.bufferData(Z.PIXEL_PACK_BUFFER, ze.byteLength, Z.STREAM_READ),
                                    V.textures.length > 1 && Z.readBuffer(Z.COLOR_ATTACHMENT0 + mt),
                                    Z.readPixels(re, he, ye, fe, nt.convert(Ot), nt.convert(Tt), 0);
                                    const cn = K !== null ? H.get(K).__webglFramebuffer : null;
                                    Ke.bindFramebuffer(Z.FRAMEBUFFER, cn);
                                    const nn = Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                    return Z.flush(),
                                    await jw(Z, nn, 4),
                                    Z.bindBuffer(Z.PIXEL_PACK_BUFFER, Qt),
                                    Z.getBufferSubData(Z.PIXEL_PACK_BUFFER, 0, ze),
                                    Z.deleteBuffer(Qt),
                                    Z.deleteSync(nn),
                                    ze
                                } else
                                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                        ,
                        this.copyFramebufferToTexture = function(V, re=null, he=0) {
                            const ye = Math.pow(2, -he)
                              , fe = Math.floor(V.image.width * ye)
                              , ze = Math.floor(V.image.height * ye)
                              , qe = re !== null ? re.x : 0
                              , mt = re !== null ? re.y : 0;
                            O.setTexture2D(V, 0),
                            Z.copyTexSubImage2D(Z.TEXTURE_2D, he, 0, 0, qe, mt, fe, ze),
                            Ke.unbindTexture()
                        }
                        ;
                        const gr = Z.createFramebuffer()
                          , vr = Z.createFramebuffer();
                        this.copyTextureToTexture = function(V, re, he=null, ye=null, fe=0, ze=null) {
                            ze === null && (fe !== 0 ? (yh("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                            ze = fe,
                            fe = 0) : ze = 0);
                            let qe, mt, Ze, Rt, Ot, Tt, Qt, cn, nn;
                            const On = V.isCompressedTexture ? V.mipmaps[ze] : V.image;
                            if (he !== null)
                                qe = he.max.x - he.min.x,
                                mt = he.max.y - he.min.y,
                                Ze = he.isBox3 ? he.max.z - he.min.z : 1,
                                Rt = he.min.x,
                                Ot = he.min.y,
                                Tt = he.isBox3 ? he.min.z : 0;
                            else {
                                const qi = Math.pow(2, -fe);
                                qe = Math.floor(On.width * qi),
                                mt = Math.floor(On.height * qi),
                                V.isDataArrayTexture ? Ze = On.depth : V.isData3DTexture ? Ze = Math.floor(On.depth * qi) : Ze = 1,
                                Rt = 0,
                                Ot = 0,
                                Tt = 0
                            }
                            ye !== null ? (Qt = ye.x,
                            cn = ye.y,
                            nn = ye.z) : (Qt = 0,
                            cn = 0,
                            nn = 0);
                            const un = nt.convert(re.format)
                              , ut = nt.convert(re.type);
                            let kt;
                            re.isData3DTexture ? (O.setTexture3D(re, 0),
                            kt = Z.TEXTURE_3D) : re.isDataArrayTexture || re.isCompressedArrayTexture ? (O.setTexture2DArray(re, 0),
                            kt = Z.TEXTURE_2D_ARRAY) : (O.setTexture2D(re, 0),
                            kt = Z.TEXTURE_2D),
                            Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, re.flipY),
                            Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, re.premultiplyAlpha),
                            Z.pixelStorei(Z.UNPACK_ALIGNMENT, re.unpackAlignment);
                            const an = Z.getParameter(Z.UNPACK_ROW_LENGTH)
                              , Xi = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT)
                              , ni = Z.getParameter(Z.UNPACK_SKIP_PIXELS)
                              , Ri = Z.getParameter(Z.UNPACK_SKIP_ROWS)
                              , Ji = Z.getParameter(Z.UNPACK_SKIP_IMAGES);
                            Z.pixelStorei(Z.UNPACK_ROW_LENGTH, On.width),
                            Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, On.height),
                            Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, Rt),
                            Z.pixelStorei(Z.UNPACK_SKIP_ROWS, Ot),
                            Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, Tt);
                            const bn = V.isDataArrayTexture || V.isData3DTexture
                              , Jn = re.isDataArrayTexture || re.isData3DTexture;
                            if (V.isDepthTexture) {
                                const qi = H.get(V)
                                  , hi = H.get(re)
                                  , Di = H.get(qi.__renderTarget)
                                  , Nl = H.get(hi.__renderTarget);
                                Ke.bindFramebuffer(Z.READ_FRAMEBUFFER, Di.__webglFramebuffer),
                                Ke.bindFramebuffer(Z.DRAW_FRAMEBUFFER, Nl.__webglFramebuffer);
                                for (let As = 0; As < Ze; As++)
                                    bn && (Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, H.get(V).__webglTexture, fe, Tt + As),
                                    Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, H.get(re).__webglTexture, ze, nn + As)),
                                    Z.blitFramebuffer(Rt, Ot, qe, mt, Qt, cn, qe, mt, Z.DEPTH_BUFFER_BIT, Z.NEAREST);
                                Ke.bindFramebuffer(Z.READ_FRAMEBUFFER, null),
                                Ke.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null)
                            } else if (fe !== 0 || V.isRenderTargetTexture || H.has(V)) {
                                const qi = H.get(V)
                                  , hi = H.get(re);
                                Ke.bindFramebuffer(Z.READ_FRAMEBUFFER, gr),
                                Ke.bindFramebuffer(Z.DRAW_FRAMEBUFFER, vr);
                                for (let Di = 0; Di < Ze; Di++)
                                    bn ? Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, qi.__webglTexture, fe, Tt + Di) : Z.framebufferTexture2D(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_2D, qi.__webglTexture, fe),
                                    Jn ? Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, hi.__webglTexture, ze, nn + Di) : Z.framebufferTexture2D(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_2D, hi.__webglTexture, ze),
                                    fe !== 0 ? Z.blitFramebuffer(Rt, Ot, qe, mt, Qt, cn, qe, mt, Z.COLOR_BUFFER_BIT, Z.NEAREST) : Jn ? Z.copyTexSubImage3D(kt, ze, Qt, cn, nn + Di, Rt, Ot, qe, mt) : Z.copyTexSubImage2D(kt, ze, Qt, cn, Rt, Ot, qe, mt);
                                Ke.bindFramebuffer(Z.READ_FRAMEBUFFER, null),
                                Ke.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null)
                            } else
                                Jn ? V.isDataTexture || V.isData3DTexture ? Z.texSubImage3D(kt, ze, Qt, cn, nn, qe, mt, Ze, un, ut, On.data) : re.isCompressedArrayTexture ? Z.compressedTexSubImage3D(kt, ze, Qt, cn, nn, qe, mt, Ze, un, On.data) : Z.texSubImage3D(kt, ze, Qt, cn, nn, qe, mt, Ze, un, ut, On) : V.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, ze, Qt, cn, qe, mt, un, ut, On.data) : V.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, ze, Qt, cn, On.width, On.height, un, On.data) : Z.texSubImage2D(Z.TEXTURE_2D, ze, Qt, cn, qe, mt, un, ut, On);
                            Z.pixelStorei(Z.UNPACK_ROW_LENGTH, an),
                            Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Xi),
                            Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, ni),
                            Z.pixelStorei(Z.UNPACK_SKIP_ROWS, Ri),
                            Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, Ji),
                            ze === 0 && re.generateMipmaps && Z.generateMipmap(kt),
                            Ke.unbindTexture()
                        }
                        ,
                        this.initRenderTarget = function(V) {
                            H.get(V).__webglFramebuffer === void 0 && O.setupRenderTarget(V)
                        }
                        ,
                        this.initTexture = function(V) {
                            V.isCubeTexture ? O.setTextureCube(V, 0) : V.isData3DTexture ? O.setTexture3D(V, 0) : V.isDataArrayTexture || V.isCompressedArrayTexture ? O.setTexture2DArray(V, 0) : O.setTexture2D(V, 0),
                            Ke.unbindTexture()
                        }
                        ,
                        this.resetState = function() {
                            U = 0,
                            W = 0,
                            K = null,
                            Ke.reset(),
                            Ge.reset()
                        }
                        ,
                        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    get coordinateSystem() {
                        return Bs
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(e) {
                        this._outputColorSpace = e;
                        const t = this.getContext();
                        t.drawingBufferColorSpace = Sn._getDrawingBufferColorSpace(e),
                        t.unpackColorSpace = Sn._getUnpackColorSpace()
                    }
                }
                ;
                var fL = Ai((e => {
                    var t = wp();
                    function n(x, M) {
                        return x === M && (x !== 0 || 1 / x === 1 / M) || x !== x && M !== M
                    }
                    var a = typeof Object.is == "function" ? Object.is : n
                      , r = t.useState
                      , c = t.useEffect
                      , f = t.useLayoutEffect
                      , p = t.useDebugValue;
                    function m(x, M) {
                        var C = M()
                          , R = r({
                            inst: {
                                value: C,
                                getSnapshot: M
                            }
                        })
                          , A = R[0].inst
                          , E = R[1];
                        return f(function() {
                            A.value = C,
                            A.getSnapshot = M,
                            g(A) && E({
                                inst: A
                            })
                        }, [x, C, M]),
                        c(function() {
                            return g(A) && E({
                                inst: A
                            }),
                            x(function() {
                                g(A) && E({
                                    inst: A
                                })
                            })
                        }, [x]),
                        p(C),
                        C
                    }
                    function g(x) {
                        var M = x.getSnapshot;
                        x = x.value;
                        try {
                            var C = M();
                            return !a(x, C)
                        } catch {
                            return !0
                        }
                    }
                    function v(x, M) {
                        return M()
                    }
                    var _ = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? v : m;
                    e.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : _
                }
                ))
                  , hL = Ai(( (e, t) => {
                    t.exports = fL()
                }
                ));
                var dL = Ai((e => {
                    var t = wp()
                      , n = hL();
                    function a(v, _) {
                        return v === _ && (v !== 0 || 1 / v === 1 / _) || v !== v && _ !== _
                    }
                    var r = typeof Object.is == "function" ? Object.is : a
                      , c = n.useSyncExternalStore
                      , f = t.useRef
                      , p = t.useEffect
                      , m = t.useMemo
                      , g = t.useDebugValue;
                    e.useSyncExternalStoreWithSelector = function(v, _, x, M, C) {
                        var R = f(null);
                        if (R.current === null) {
                            var A = {
                                hasValue: !1,
                                value: null
                            };
                            R.current = A
                        } else
                            A = R.current;
                        R = m(function() {
                            function N(X) {
                                if (!I) {
                                    if (I = !0,
                                    L = X,
                                    X = M(X),
                                    C !== void 0 && A.hasValue) {
                                        var G = A.value;
                                        if (C(G, X))
                                            return k = G
                                    }
                                    return k = X
                                }
                                if (G = k,
                                r(L, X))
                                    return G;
                                var P = M(X);
                                return C !== void 0 && C(G, P) ? (L = X,
                                G) : (L = X,
                                k = P)
                            }
                            var I = !1, L, k, B = x === void 0 ? null : x;
                            return [function() {
                                return N(_())
                            }
                            , B === null ? void 0 : function() {
                                return N(B())
                            }
                            ]
                        }, [_, x, M, C]);
                        var E = c(v, R[0], R[1]);
                        return p(function() {
                            A.hasValue = !0,
                            A.value = E
                        }, [E]),
                        g(E),
                        E
                    }
                }
                ))
                  , pL = Ai(( (e, t) => {
                    t.exports = dL()
                }
                ))
                  , mL = av(pL(), 1);
                const FE = e => {
                    let t;
                    const n = new Set
                      , a = (g, v) => {
                        const _ = typeof g == "function" ? g(t) : g;
                        if (!Object.is(_, t)) {
                            const x = t;
                            t = v ?? (typeof _ != "object" || _ === null) ? _ : Object.assign({}, t, _),
                            n.forEach(M => M(t, x))
                        }
                    }
                      , r = () => t
                      , p = {
                        setState: a,
                        getState: r,
                        getInitialState: () => m,
                        subscribe: g => (n.add(g),
                        () => n.delete(g))
                    }
                      , m = t = e(a, r, p);
                    return p
                }
                  , gL = (e => e ? FE(e) : FE)
                  , {useSyncExternalStoreWithSelector: vL} = mL.default
                  , yL = e => e;
                function _L(e, t=yL, n) {
                    const a = vL(e.subscribe, e.getState, e.getInitialState, t, n);
                    return lt.useDebugValue(a),
                    a
                }
                const VE = (e, t) => {
                    const n = gL(e)
                      , a = (r, c=t) => _L(n, r, c);
                    return Object.assign(a, n),
                    a
                }
                  , SL = ( (e, t) => e ? VE(e, t) : VE)
                  , xL = e => typeof e == "object" && typeof e.then == "function"
                  , of = [];
                function kE(e, t, n= (a, r) => a === r) {
                    if (e === t)
                        return !0;
                    if (!e || !t)
                        return !1;
                    const a = e.length;
                    if (t.length !== a)
                        return !1;
                    for (let r = 0; r < a; r++)
                        if (!n(e[r], t[r]))
                            return !1;
                    return !0
                }
                function HE(e, t=null, n=!1, a={}) {
                    t === null && (t = [e]);
                    for (const c of of)
                        if (kE(t, c.keys, c.equal)) {
                            if (n)
                                return;
                            if (Object.prototype.hasOwnProperty.call(c, "error"))
                                throw c.error;
                            if (Object.prototype.hasOwnProperty.call(c, "response"))
                                return a.lifespan && a.lifespan > 0 && (c.timeout && clearTimeout(c.timeout),
                                c.timeout = setTimeout(c.remove, a.lifespan)),
                                c.response;
                            if (!n)
                                throw c.promise
                        }
                    const r = {
                        keys: t,
                        equal: a.equal,
                        remove: () => {
                            const c = of.indexOf(r);
                            c !== -1 && of.splice(c, 1)
                        }
                        ,
                        promise: (xL(e) ? e : e(...t)).then(c => {
                            r.response = c,
                            a.lifespan && a.lifespan > 0 && (r.timeout = setTimeout(r.remove, a.lifespan))
                        }
                        ).catch(c => r.error = c)
                    };
                    if (of.push(r),
                    !n)
                        throw r.promise
                }
                const bL = (e, t, n) => HE(e, t, !1, n)
                  , ML = (e, t, n) => {
                    HE(e, t, !0, n)
                }
                  , TL = e => {
                    if (e === void 0 || e.length === 0)
                        of.splice(0, of.length);
                    else {
                        const t = of.find(n => kE(e, n.keys, n.equal));
                        t && t.remove()
                    }
                }
                ;
                var EL = Ai((e => {
                    var t = Symbol.for("react.transitional.element")
                      , n = Symbol.for("react.fragment");
                    function a(r, c, f) {
                        var p = null;
                        if (f !== void 0 && (p = "" + f),
                        c.key !== void 0 && (p = "" + c.key),
                        "key"in c) {
                            f = {};
                            for (var m in c)
                                m !== "key" && (f[m] = c[m])
                        } else
                            f = c;
                        return c = f.ref,
                        {
                            $$typeof: t,
                            type: r,
                            key: p,
                            ref: c !== void 0 ? c : null,
                            props: f
                        }
                    }
                    e.jsx = a,
                    e.jsxs = a
                }
                ))
                  , AL = Ai(( (e, t) => {
                    t.exports = EL()
                }
                ))
                  , _t = AL()
                  , ix = av(nb());
                const PU = ( () => {
                    var e, t;
                    return typeof window < "u" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative")
                }
                )() ? lt.useLayoutEffect : lt.useEffect;
                function ax(e, t, n) {
                    if (!e)
                        return;
                    if (n(e) === !0)
                        return e;
                    let a = t ? e.return : e.child;
                    for (; a; ) {
                        const r = ax(a, t, n);
                        if (r)
                            return r;
                        a = t ? null : a.sibling
                    }
                }
                function GE(e) {
                    try {
                        return Object.defineProperties(e, {
                            _currentRenderer: {
                                get() {
                                    return null
                                },
                                set() {}
                            },
                            _currentRenderer2: {
                                get() {
                                    return null
                                },
                                set() {}
                            }
                        })
                    } catch {
                        return e
                    }
                }
                const sx = GE(lt.createContext(null));
                var WE = class extends lt.Component {
                    render() {
                        return lt.createElement(sx.Provider, {
                            value: this._reactInternals
                        }, this.props.children)
                    }
                }
                ;
                function XE() {
                    const e = lt.useContext(sx);
                    if (e === null)
                        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
                    const t = lt.useId();
                    return lt.useMemo( () => {
                        for (const n of [e, e?.alternate]) {
                            if (!n)
                                continue;
                            const a = ax(n, !1, r => {
                                let c = r.memoizedState;
                                for (; c; ) {
                                    if (c.memoizedState === t)
                                        return !0;
                                    c = c.next
                                }
                            }
                            );
                            if (a)
                                return a
                        }
                    }
                    , [e, t])
                }
                const wL = Symbol.for("react.context")
                  , CL = e => e !== null && typeof e == "object" && "$$typeof"in e && e.$$typeof === wL;
                function RL() {
                    const e = XE()
                      , [t] = lt.useState( () => new Map);
                    t.clear();
                    let n = e;
                    for (; n; ) {
                        const a = n.type;
                        CL(a) && a !== sx && !t.has(a) && t.set(a, lt.use(GE(a))),
                        n = n.return
                    }
                    return t
                }
                function DL() {
                    const e = RL();
                    return lt.useMemo( () => Array.from(e.keys()).reduce( (t, n) => a => lt.createElement(t, null, lt.createElement(n.Provider, {
                        ...a,
                        value: e.get(n)
                    })), t => lt.createElement(WE, {
                        ...t
                    })), [e])
                }
                function qE(e) {
                    let t = e.root;
                    for (; t.getState().previousRoot; )
                        t = t.getState().previousRoot;
                    return t
                }
                const zU = lt.act
                  , YE = e => e && e.isOrthographicCamera
                  , NL = e => e && e.hasOwnProperty("current")
                  , LL = e => e != null && (typeof e == "string" || typeof e == "number" || e.isColor)
                  , Mm = ( (e, t) => typeof window < "u" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative"))() ? lt.useLayoutEffect : lt.useEffect;
                function jE(e) {
                    const t = lt.useRef(e);
                    return Mm( () => {
                        t.current = e
                    }
                    , [e]),
                    t
                }
                function UL() {
                    const e = XE()
                      , t = DL();
                    return lt.useMemo( () => ({children: n}) => (0,
                    _t.jsx)(ax(e, !0, a => a.type === lt.StrictMode) ? lt.StrictMode : lt.Fragment, {
                        children: (0,
                        _t.jsx)(t, {
                            children: n
                        })
                    }), [e, t])
                }
                function IL({set: e}) {
                    return Mm( () => (e(new Promise( () => null)),
                    () => e(!1)), [e]),
                    null
                }
                const OL = (e => (e = class extends lt.Component {
                    constructor(...n) {
                        super(...n),
                        this.state = {
                            error: !1
                        }
                    }
                    componentDidCatch(n) {
                        this.props.set(n)
                    }
                    render() {
                        return this.state.error ? null : this.props.children
                    }
                }
                ,
                e.getDerivedStateFromError = () => ({
                    error: !0
                }),
                e))();
                function ZE(e) {
                    var t;
                    const n = typeof window < "u" ? (t = window.devicePixelRatio) != null ? t : 2 : 1;
                    return Array.isArray(e) ? Math.min(Math.max(e[0], n), e[1]) : e
                }
                function $h(e) {
                    var t;
                    return (t = e.__r3f) == null ? void 0 : t.root.getState()
                }
                const fi = {
                    obj: e => e === Object(e) && !fi.arr(e) && typeof e != "function",
                    fun: e => typeof e == "function",
                    str: e => typeof e == "string",
                    num: e => typeof e == "number",
                    boo: e => typeof e == "boolean",
                    und: e => e === void 0,
                    nul: e => e === null,
                    arr: e => Array.isArray(e),
                    equ(e, t, {arrays: n="shallow", objects: a="reference", strict: r=!0}={}) {
                        if (typeof e != typeof t || !!e != !!t)
                            return !1;
                        if (fi.str(e) || fi.num(e) || fi.boo(e))
                            return e === t;
                        const c = fi.obj(e);
                        if (c && a === "reference")
                            return e === t;
                        const f = fi.arr(e);
                        if (f && n === "reference")
                            return e === t;
                        if ((f || c) && e === t)
                            return !0;
                        let p;
                        for (p in e)
                            if (!(p in t))
                                return !1;
                        if (c && n === "shallow" && a === "shallow") {
                            for (p in r ? t : e)
                                if (!fi.equ(e[p], t[p], {
                                    strict: r,
                                    objects: "reference"
                                }))
                                    return !1
                        } else
                            for (p in r ? t : e)
                                if (e[p] !== t[p])
                                    return !1;
                        if (fi.und(p)) {
                            if (f && e.length === 0 && t.length === 0 || c && Object.keys(e).length === 0 && Object.keys(t).length === 0)
                                return !0;
                            if (e !== t)
                                return !1
                        }
                        return !0
                    }
                };
                function PL(e) {
                    const t = {
                        nodes: {},
                        materials: {},
                        meshes: {}
                    };
                    return e && e.traverse(n => {
                        n.name && (t.nodes[n.name] = n),
                        n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material),
                        n.isMesh && !t.meshes[n.name] && (t.meshes[n.name] = n)
                    }
                    ),
                    t
                }
                function zL(e) {
                    e.type !== "Scene" && (e.dispose == null || e.dispose());
                    for (const t in e) {
                        const n = e[t];
                        n?.type !== "Scene" && (n == null || n.dispose == null || n.dispose())
                    }
                }
                const QE = ["children", "key", "ref"];
                function BL(e) {
                    const t = {};
                    for (const n in e)
                        QE.includes(n) || (t[n] = e[n]);
                    return t
                }
                function fy(e, t, n, a) {
                    const r = e;
                    let c = r?.__r3f;
                    return c || (c = {
                        root: t,
                        type: n,
                        parent: null,
                        children: [],
                        props: BL(a),
                        object: r,
                        eventCount: 0,
                        handlers: {},
                        isHidden: !1
                    },
                    r && (r.__r3f = c)),
                    c
                }
                function Tm(e, t) {
                    if (!t.includes("-"))
                        return {
                            root: e,
                            key: t,
                            target: e[t]
                        };
                    if (t in e)
                        return {
                            root: e,
                            key: t,
                            target: e[t]
                        };
                    let n = e;
                    const a = t.split("-");
                    for (const r of a) {
                        if (typeof n != "object" || n === null) {
                            if (n !== void 0) {
                                const c = a.slice(a.indexOf(r)).join("-");
                                return {
                                    root: n,
                                    key: c,
                                    target: void 0
                                }
                            }
                            return {
                                root: e,
                                key: t,
                                target: void 0
                            }
                        }
                        t = r,
                        e = n,
                        n = n[t]
                    }
                    return {
                        root: e,
                        key: t,
                        target: n
                    }
                }
                const KE = /-\d+$/;
                function hy(e, t) {
                    if (fi.str(t.props.attach)) {
                        if (KE.test(t.props.attach)) {
                            const r = t.props.attach.replace(KE, "")
                              , {root: c, key: f} = Tm(e.object, r);
                            Array.isArray(c[f]) || (c[f] = [])
                        }
                        const {root: n, key: a} = Tm(e.object, t.props.attach);
                        t.previousAttach = n[a],
                        n[a] = t.object
                    } else
                        fi.fun(t.props.attach) && (t.previousAttach = t.props.attach(e.object, t.object))
                }
                function dy(e, t) {
                    if (fi.str(t.props.attach)) {
                        const {root: n, key: a} = Tm(e.object, t.props.attach)
                          , r = t.previousAttach;
                        r === void 0 ? delete n[a] : n[a] = r
                    } else
                        t.previousAttach == null || t.previousAttach(e.object, t.object);
                    delete t.previousAttach
                }
                const rx = [...QE, "args", "dispose", "attach", "object", "onUpdate", "dispose"]
                  , JE = new Map;
                function FL(e) {
                    let t = JE.get(e.constructor);
                    try {
                        t || (t = new e.constructor,
                        JE.set(e.constructor, t))
                    } catch {}
                    return t
                }
                function VL(e, t) {
                    const n = {};
                    for (const a in t)
                        if (!rx.includes(a) && !fi.equ(t[a], e.props[a])) {
                            n[a] = t[a];
                            for (const r in t)
                                r.startsWith(`${a}-`) && (n[r] = t[r])
                        }
                    for (const a in e.props) {
                        if (rx.includes(a) || t.hasOwnProperty(a))
                            continue;
                        const {root: r, key: c} = Tm(e.object, a);
                        if (r.constructor && r.constructor.length === 0) {
                            const f = FL(r);
                            fi.und(f) || (n[c] = f[c])
                        } else
                            n[c] = 0
                    }
                    return n
                }
                const kL = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"]
                  , HL = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
                function Pc(e, t) {
                    var n;
                    const a = e.__r3f
                      , r = a && qE(a).getState()
                      , c = a?.eventCount;
                    for (const p in t) {
                        let m = t[p];
                        if (rx.includes(p))
                            continue;
                        if (a && HL.test(p)) {
                            typeof m == "function" ? a.handlers[p] = m : delete a.handlers[p],
                            a.eventCount = Object.keys(a.handlers).length;
                            continue
                        }
                        if (m === void 0)
                            continue;
                        let {root: g, key: v, target: _} = Tm(e, p);
                        if (_ === void 0 && (typeof g != "object" || g === null))
                            throw Error(`R3F: Cannot set "${p}". Ensure it is an object before setting "${v}".`);
                        if (_ instanceof wh && m instanceof wh)
                            _.mask = m.mask;
                        else if (_ instanceof dt && LL(m))
                            _.set(m);
                        else if (_ !== null && typeof _ == "object" && typeof _.set == "function" && typeof _.copy == "function" && m != null && m.constructor && _.constructor === m.constructor)
                            _.copy(m);
                        else if (_ !== null && typeof _ == "object" && typeof _.set == "function" && Array.isArray(m))
                            typeof _.fromArray == "function" ? _.fromArray(m) : _.set(...m);
                        else if (_ !== null && typeof _ == "object" && typeof _.set == "function" && typeof m == "number")
                            typeof _.setScalar == "function" ? _.setScalar(m) : _.set(m);
                        else {
                            var f;
                            g[v] = m,
                            r && !r.linear && kL.includes(v) && (f = g[v]) != null && f.isTexture && g[v].format === Aa && g[v].type === Ka && (g[v].colorSpace = wa)
                        }
                    }
                    if (a != null && a.parent && r != null && r.internal && (n = a.object) != null && n.isObject3D && c !== a.eventCount) {
                        const p = a.object
                          , m = r.internal.interaction.indexOf(p);
                        m > -1 && r.internal.interaction.splice(m, 1),
                        a.eventCount && p.raycast !== null && r.internal.interaction.push(p)
                    }
                    return a && a.props.attach === void 0 && (a.object.isBufferGeometry ? a.props.attach = "geometry" : a.object.isMaterial && (a.props.attach = "material")),
                    a && ed(a),
                    e
                }
                function ed(e) {
                    var t;
                    if (!e.parent)
                        return;
                    e.props.onUpdate == null || e.props.onUpdate(e.object);
                    const n = (t = e.root) == null || t.getState == null ? void 0 : t.getState();
                    n && n.internal.frames === 0 && n.invalidate()
                }
                function GL(e, t) {
                    e.manual || (YE(e) ? (e.left = t.width / -2,
                    e.right = t.width / 2,
                    e.top = t.height / 2,
                    e.bottom = t.height / -2) : e.aspect = t.width / t.height,
                    e.updateProjectionMatrix())
                }
                const as = e => e?.isObject3D;
                function py(e) {
                    return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId
                }
                function $E(e, t, n, a) {
                    const r = n.get(t);
                    r && (n.delete(t),
                    n.size === 0 && (e.delete(a),
                    r.target.releasePointerCapture(a)))
                }
                function WL(e, t) {
                    const {internal: n} = e.getState();
                    n.interaction = n.interaction.filter(a => a !== t),
                    n.initialHits = n.initialHits.filter(a => a !== t),
                    n.hovered.forEach( (a, r) => {
                        (a.eventObject === t || a.object === t) && n.hovered.delete(r)
                    }
                    ),
                    n.capturedMap.forEach( (a, r) => {
                        $E(n.capturedMap, t, a, r)
                    }
                    )
                }
                function XL(e) {
                    function t(m) {
                        const {internal: g} = e.getState()
                          , v = m.offsetX - g.initialClick[0]
                          , _ = m.offsetY - g.initialClick[1];
                        return Math.round(Math.sqrt(v * v + _ * _))
                    }
                    function n(m) {
                        return m.filter(g => ["Move", "Over", "Enter", "Out", "Leave"].some(v => {
                            var _;
                            return (_ = g.__r3f) == null ? void 0 : _.handlers["onPointer" + v]
                        }
                        ))
                    }
                    function a(m, g) {
                        const v = e.getState()
                          , _ = new Set
                          , x = []
                          , M = g ? g(v.internal.interaction) : v.internal.interaction;
                        for (let E = 0; E < M.length; E++) {
                            const N = $h(M[E]);
                            N && (N.raycaster.camera = void 0)
                        }
                        v.previousRoot || v.events.compute == null || v.events.compute(m, v);
                        function C(E) {
                            const N = $h(E);
                            if (!N || !N.events.enabled || N.raycaster.camera === null)
                                return [];
                            if (N.raycaster.camera === void 0) {
                                var I;
                                N.events.compute == null || N.events.compute(m, N, (I = N.previousRoot) == null ? void 0 : I.getState()),
                                N.raycaster.camera === void 0 && (N.raycaster.camera = null)
                            }
                            return N.raycaster.camera ? N.raycaster.intersectObject(E, !0) : []
                        }
                        let R = M.flatMap(C).sort( (E, N) => {
                            const I = $h(E.object)
                              , L = $h(N.object);
                            return !I || !L ? E.distance - N.distance : L.events.priority - I.events.priority || E.distance - N.distance
                        }
                        ).filter(E => {
                            const N = py(E);
                            return _.has(N) ? !1 : (_.add(N),
                            !0)
                        }
                        );
                        v.events.filter && (R = v.events.filter(R, v));
                        for (const E of R) {
                            let N = E.object;
                            for (; N; ) {
                                var A;
                                (A = N.__r3f) != null && A.eventCount && x.push({
                                    ...E,
                                    eventObject: N
                                }),
                                N = N.parent
                            }
                        }
                        if ("pointerId"in m && v.internal.capturedMap.has(m.pointerId))
                            for (let E of v.internal.capturedMap.get(m.pointerId).values())
                                _.has(py(E.intersection)) || x.push(E.intersection);
                        return x
                    }
                    function r(m, g, v, _) {
                        if (m.length) {
                            const x = {
                                stopped: !1
                            };
                            for (const M of m) {
                                let C = $h(M.object);
                                if (C || M.object.traverseAncestors(R => {
                                    const A = $h(R);
                                    if (A)
                                        return C = A,
                                        !1
                                }
                                ),
                                C) {
                                    const {raycaster: R, pointer: A, camera: E, internal: N} = C
                                      , I = new Y(A.x,A.y,0).unproject(E)
                                      , L = P => {
                                        var U, W;
                                        return (U = (W = N.capturedMap.get(P)) == null ? void 0 : W.has(M.eventObject)) != null ? U : !1
                                    }
                                      , k = P => {
                                        const U = {
                                            intersection: M,
                                            target: g.target
                                        };
                                        N.capturedMap.has(P) ? N.capturedMap.get(P).set(M.eventObject, U) : N.capturedMap.set(P, new Map([[M.eventObject, U]])),
                                        g.target.setPointerCapture(P)
                                    }
                                      , B = P => {
                                        const U = N.capturedMap.get(P);
                                        U && $E(N.capturedMap, M.eventObject, U, P)
                                    }
                                    ;
                                    let X = {};
                                    for (let P in g) {
                                        let U = g[P];
                                        typeof U != "function" && (X[P] = U)
                                    }
                                    let G = {
                                        ...M,
                                        ...X,
                                        pointer: A,
                                        intersections: m,
                                        stopped: x.stopped,
                                        delta: v,
                                        unprojectedPoint: I,
                                        ray: R.ray,
                                        camera: E,
                                        stopPropagation() {
                                            const P = "pointerId"in g && N.capturedMap.get(g.pointerId);
                                            (!P || P.has(M.eventObject)) && (G.stopped = x.stopped = !0,
                                            N.hovered.size && Array.from(N.hovered.values()).find(U => U.eventObject === M.eventObject) && c([...m.slice(0, m.indexOf(M)), M]))
                                        },
                                        target: {
                                            hasPointerCapture: L,
                                            setPointerCapture: k,
                                            releasePointerCapture: B
                                        },
                                        currentTarget: {
                                            hasPointerCapture: L,
                                            setPointerCapture: k,
                                            releasePointerCapture: B
                                        },
                                        nativeEvent: g
                                    };
                                    if (_(G),
                                    x.stopped === !0)
                                        break
                                }
                            }
                        }
                        return m
                    }
                    function c(m) {
                        const {internal: g} = e.getState();
                        for (const v of g.hovered.values())
                            if (!m.length || !m.find(_ => _.object === v.object && _.index === v.index && _.instanceId === v.instanceId)) {
                                const _ = v.eventObject.__r3f;
                                if (g.hovered.delete(py(v)),
                                _ != null && _.eventCount) {
                                    const x = _.handlers
                                      , M = {
                                        ...v,
                                        intersections: m
                                    };
                                    x.onPointerOut == null || x.onPointerOut(M),
                                    x.onPointerLeave == null || x.onPointerLeave(M)
                                }
                            }
                    }
                    function f(m, g) {
                        for (let v = 0; v < g.length; v++) {
                            const _ = g[v].__r3f;
                            _ == null || _.handlers.onPointerMissed == null || _.handlers.onPointerMissed(m)
                        }
                    }
                    function p(m) {
                        switch (m) {
                        case "onPointerLeave":
                        case "onPointerCancel":
                            return () => c([]);
                        case "onLostPointerCapture":
                            return g => {
                                const {internal: v} = e.getState();
                                "pointerId"in g && v.capturedMap.has(g.pointerId) && requestAnimationFrame( () => {
                                    v.capturedMap.has(g.pointerId) && (v.capturedMap.delete(g.pointerId),
                                    c([]))
                                }
                                )
                            }
                        }
                        return function(v) {
                            const {onPointerMissed: _, internal: x} = e.getState();
                            x.lastEvent.current = v;
                            const M = m === "onPointerMove"
                              , C = m === "onClick" || m === "onContextMenu" || m === "onDoubleClick"
                              , R = a(v, M ? n : void 0)
                              , A = C ? t(v) : 0;
                            m === "onPointerDown" && (x.initialClick = [v.offsetX, v.offsetY],
                            x.initialHits = R.map(N => N.eventObject)),
                            C && !R.length && A <= 2 && (f(v, x.interaction),
                            _ && _(v)),
                            M && c(R);
                            function E(N) {
                                const I = N.eventObject
                                  , L = I.__r3f;
                                if (!(L != null && L.eventCount))
                                    return;
                                const k = L.handlers;
                                if (M) {
                                    if (k.onPointerOver || k.onPointerEnter || k.onPointerOut || k.onPointerLeave) {
                                        const B = py(N)
                                          , X = x.hovered.get(B);
                                        X ? X.stopped && N.stopPropagation() : (x.hovered.set(B, N),
                                        k.onPointerOver == null || k.onPointerOver(N),
                                        k.onPointerEnter == null || k.onPointerEnter(N))
                                    }
                                    k.onPointerMove == null || k.onPointerMove(N)
                                } else {
                                    const B = k[m];
                                    B ? (!C || x.initialHits.includes(I)) && (f(v, x.interaction.filter(X => !x.initialHits.includes(X))),
                                    B(N)) : C && x.initialHits.includes(I) && f(v, x.interaction.filter(X => !x.initialHits.includes(X)))
                                }
                            }
                            r(R, v, A, E)
                        }
                    }
                    return {
                        handlePointer: p
                    }
                }
                const eA = e => !!(e != null && e.render)
                  , tA = lt.createContext(null)
                  , qL = (e, t) => {
                    const n = SL( (p, m) => {
                        const g = new Y
                          , v = new Y
                          , _ = new Y;
                        function x(A=m().camera, E=v, N=m().size) {
                            const {width: I, height: L, top: k, left: B} = N
                              , X = I / L;
                            E.isVector3 ? _.copy(E) : _.set(...E);
                            const G = A.getWorldPosition(g).distanceTo(_);
                            if (YE(A))
                                return {
                                    width: I / A.zoom,
                                    height: L / A.zoom,
                                    top: k,
                                    left: B,
                                    factor: 1,
                                    distance: G,
                                    aspect: X
                                };
                            {
                                const P = A.fov * Math.PI / 180
                                  , U = 2 * Math.tan(P / 2) * G
                                  , W = U * (I / L);
                                return {
                                    width: W,
                                    height: U,
                                    top: k,
                                    left: B,
                                    factor: I / W,
                                    distance: G,
                                    aspect: X
                                }
                            }
                        }
                        let M;
                        const C = A => p(E => ({
                            performance: {
                                ...E.performance,
                                current: A
                            }
                        }))
                          , R = new Pe;
                        return {
                            set: p,
                            get: m,
                            gl: null,
                            camera: null,
                            raycaster: null,
                            events: {
                                priority: 1,
                                enabled: !0,
                                connected: !1
                            },
                            scene: null,
                            xr: null,
                            invalidate: (A=1) => e(m(), A),
                            advance: (A, E) => t(A, E, m()),
                            legacy: !1,
                            linear: !1,
                            flat: !1,
                            controls: null,
                            clock: new FS,
                            pointer: R,
                            mouse: R,
                            frameloop: "always",
                            onPointerMissed: void 0,
                            performance: {
                                current: 1,
                                min: .5,
                                max: 1,
                                debounce: 200,
                                regress: () => {
                                    const A = m();
                                    M && clearTimeout(M),
                                    A.performance.current !== A.performance.min && C(A.performance.min),
                                    M = setTimeout( () => C(m().performance.max), A.performance.debounce)
                                }
                            },
                            size: {
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0
                            },
                            viewport: {
                                initialDpr: 0,
                                dpr: 0,
                                width: 0,
                                height: 0,
                                top: 0,
                                left: 0,
                                aspect: 0,
                                distance: 0,
                                factor: 0,
                                getCurrentViewport: x
                            },
                            setEvents: A => p(E => ({
                                ...E,
                                events: {
                                    ...E.events,
                                    ...A
                                }
                            })),
                            setSize: (A, E, N=0, I=0) => {
                                const L = m().camera
                                  , k = {
                                    width: A,
                                    height: E,
                                    top: N,
                                    left: I
                                };
                                p(B => ({
                                    size: k,
                                    viewport: {
                                        ...B.viewport,
                                        ...x(L, v, k)
                                    }
                                }))
                            }
                            ,
                            setDpr: A => p(E => {
                                const N = ZE(A);
                                return {
                                    viewport: {
                                        ...E.viewport,
                                        dpr: N,
                                        initialDpr: E.viewport.initialDpr || N
                                    }
                                }
                            }
                            ),
                            setFrameloop: (A="always") => {
                                const E = m().clock;
                                E.stop(),
                                E.elapsedTime = 0,
                                A !== "never" && (E.start(),
                                E.elapsedTime = 0),
                                p( () => ({
                                    frameloop: A
                                }))
                            }
                            ,
                            previousRoot: void 0,
                            internal: {
                                interaction: [],
                                hovered: new Map,
                                subscribers: [],
                                initialClick: [0, 0],
                                initialHits: [],
                                capturedMap: new Map,
                                lastEvent: lt.createRef(),
                                active: !1,
                                frames: 0,
                                priority: 0,
                                subscribe: (A, E, N) => {
                                    const I = m().internal;
                                    return I.priority = I.priority + (E > 0 ? 1 : 0),
                                    I.subscribers.push({
                                        ref: A,
                                        priority: E,
                                        store: N
                                    }),
                                    I.subscribers = I.subscribers.sort( (L, k) => L.priority - k.priority),
                                    () => {
                                        const L = m().internal;
                                        L != null && L.subscribers && (L.priority = L.priority - (E > 0 ? 1 : 0),
                                        L.subscribers = L.subscribers.filter(k => k.ref !== A))
                                    }
                                }
                            }
                        }
                    }
                    )
                      , a = n.getState();
                    let r = a.size
                      , c = a.viewport.dpr
                      , f = a.camera;
                    return n.subscribe( () => {
                        const {camera: p, size: m, viewport: g, gl: v, set: _} = n.getState();
                        if (m.width !== r.width || m.height !== r.height || g.dpr !== c) {
                            r = m,
                            c = g.dpr,
                            GL(p, m),
                            g.dpr > 0 && v.setPixelRatio(g.dpr);
                            const x = typeof HTMLCanvasElement < "u" && v.domElement instanceof HTMLCanvasElement;
                            v.setSize(m.width, m.height, x)
                        }
                        p !== f && (f = p,
                        _(x => ({
                            viewport: {
                                ...x.viewport,
                                ...x.viewport.getCurrentViewport(p)
                            }
                        })))
                    }
                    ),
                    n.subscribe(p => e(p)),
                    n
                }
                ;
                function YL() {
                    const e = lt.useContext(tA);
                    if (!e)
                        throw new Error("R3F: Hooks can only be used within the Canvas component!");
                    return e
                }
                function my(e, t=0) {
                    const n = YL()
                      , a = n.getState().internal.subscribe
                      , r = jE(e);
                    return Mm( () => a(r, t, n), [t, a, n]),
                    null
                }
                const nA = new WeakMap
                  , jL = e => {
                    var t;
                    return typeof e == "function" && (e == null || (t = e.prototype) == null ? void 0 : t.constructor) === e
                }
                ;
                function iA(e, t) {
                    return function(n, ...a) {
                        let r;
                        return jL(n) ? (r = nA.get(n),
                        r || (r = new n,
                        nA.set(n, r))) : r = n,
                        e && e(r),
                        Promise.all(a.map(c => new Promise( (f, p) => r.load(c, m => {
                            as(m?.scene) && Object.assign(m, PL(m.scene)),
                            f(m)
                        }
                        , t, m => p(new Error(`Could not load ${c}: ${m?.message}`))))))
                    }
                }
                function aA(e, t, n, a) {
                    const r = Array.isArray(t) ? t : [t]
                      , c = bL(iA(n, a), [e, ...r], {
                        equal: fi.equ
                    });
                    return Array.isArray(t) ? c : c[0]
                }
                aA.preload = function(e, t, n) {
                    const a = Array.isArray(t) ? t : [t];
                    return ML(iA(n), [e, ...a])
                }
                ,
                aA.clear = function(e, t) {
                    return TL([e, ...Array.isArray(t) ? t : [t]])
                }
                ;
                const ZL = 1
                  , QL = 8
                  , KL = 32
                  , JL = 2;
                var $L = {
                    name: "@react-three/fiber",
                    version: "9.5.0",
                    description: "A React renderer for Threejs",
                    keywords: ["react", "renderer", "fiber", "three", "threejs"],
                    author: "Paul Henschel (https://github.com/drcmda)",
                    license: "MIT",
                    maintainers: ["Josh Ellis (https://github.com/joshuaellis)", "Cody Bennett (https://github.com/codyjasonbennett)", "Kris Baumgarter (https://github.com/krispya)"],
                    bugs: {
                        url: "https://github.com/pmndrs/react-three-fiber/issues"
                    },
                    homepage: "https://github.com/pmndrs/react-three-fiber#readme",
                    repository: {
                        type: "git",
                        url: "git+https://github.com/pmndrs/react-three-fiber.git"
                    },
                    collective: {
                        type: "opencollective",
                        url: "https://opencollective.com/react-three-fiber"
                    },
                    main: "dist/react-three-fiber.cjs.js",
                    module: "dist/react-three-fiber.esm.js",
                    types: "dist/react-three-fiber.cjs.d.ts",
                    "react-native": "native/dist/react-three-fiber-native.cjs.js",
                    sideEffects: !1,
                    preconstruct: {
                        entrypoints: ["index.tsx", "native.tsx"]
                    },
                    scripts: {
                        prebuild: "cp ../../readme.md readme.md"
                    },
                    devDependencies: {
                        "@types/react-reconciler": "^0.32.3",
                        "react-reconciler": "^0.33.0"
                    },
                    dependencies: {
                        "@babel/runtime": "^7.17.8",
                        "@types/webxr": "*",
                        "base64-js": "^1.5.1",
                        buffer: "^6.0.3",
                        "its-fine": "^2.0.0",
                        "react-use-measure": "^2.1.7",
                        scheduler: "^0.27.0",
                        "suspend-react": "^0.1.3",
                        "use-sync-external-store": "^1.4.0",
                        zustand: "^5.0.3"
                    },
                    peerDependencies: {
                        expo: ">=43.0",
                        "expo-asset": ">=8.4",
                        "expo-file-system": ">=11.0",
                        "expo-gl": ">=11.0",
                        react: ">=19 <19.3",
                        "react-dom": ">=19 <19.3",
                        "react-native": ">=0.78",
                        three: ">=0.156"
                    },
                    peerDependenciesMeta: {
                        "react-dom": {
                            optional: !0
                        },
                        "react-native": {
                            optional: !0
                        },
                        expo: {
                            optional: !0
                        },
                        "expo-asset": {
                            optional: !0
                        },
                        "expo-file-system": {
                            optional: !0
                        },
                        "expo-gl": {
                            optional: !0
                        }
                    }
                };
                function eU(e) {
                    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
                }
                var sA = {
                    exports: {}
                }
                  , ox = {
                    exports: {}
                };
                ox.exports;
                var rA;
                function tU() {
                    return rA || (rA = 1,
                    (function(e) {
                        e.exports = function(t) {
                            function n(o, l, d, y) {
                                return new Jo(o,l,d,y)
                            }
                            function a() {}
                            function r(o) {
                                var l = "https://react.dev/errors/" + o;
                                if (1 < arguments.length) {
                                    l += "?args[]=" + encodeURIComponent(arguments[1]);
                                    for (var d = 2; d < arguments.length; d++)
                                        l += "&args[]=" + encodeURIComponent(arguments[d])
                                }
                                return "Minified React error #" + o + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                            }
                            function c(o) {
                                var l = o
                                  , d = o;
                                if (o.alternate)
                                    for (; l.return; )
                                        l = l.return;
                                else {
                                    o = l;
                                    do
                                        l = o,
                                        l.flags & 4098 && (d = l.return),
                                        o = l.return;
                                    while (o)
                                }
                                return l.tag === 3 ? d : null
                            }
                            function f(o) {
                                if (c(o) !== o)
                                    throw Error(r(188))
                            }
                            function p(o) {
                                var l = o.alternate;
                                if (!l) {
                                    if (l = c(o),
                                    l === null)
                                        throw Error(r(188));
                                    return l !== o ? null : o
                                }
                                for (var d = o, y = l; ; ) {
                                    var T = d.return;
                                    if (T === null)
                                        break;
                                    var w = T.alternate;
                                    if (w === null) {
                                        if (y = T.return,
                                        y !== null) {
                                            d = y;
                                            continue
                                        }
                                        break
                                    }
                                    if (T.child === w.child) {
                                        for (w = T.child; w; ) {
                                            if (w === d)
                                                return f(T),
                                                o;
                                            if (w === y)
                                                return f(T),
                                                l;
                                            w = w.sibling
                                        }
                                        throw Error(r(188))
                                    }
                                    if (d.return !== y.return)
                                        d = T,
                                        y = w;
                                    else {
                                        for (var z = !1, $ = T.child; $; ) {
                                            if ($ === d) {
                                                z = !0,
                                                d = T,
                                                y = w;
                                                break
                                            }
                                            if ($ === y) {
                                                z = !0,
                                                y = T,
                                                d = w;
                                                break
                                            }
                                            $ = $.sibling
                                        }
                                        if (!z) {
                                            for ($ = w.child; $; ) {
                                                if ($ === d) {
                                                    z = !0,
                                                    d = w,
                                                    y = T;
                                                    break
                                                }
                                                if ($ === y) {
                                                    z = !0,
                                                    y = w,
                                                    d = T;
                                                    break
                                                }
                                                $ = $.sibling
                                            }
                                            if (!z)
                                                throw Error(r(189))
                                        }
                                    }
                                    if (d.alternate !== y)
                                        throw Error(r(190))
                                }
                                if (d.tag !== 3)
                                    throw Error(r(188));
                                return d.stateNode.current === d ? o : l
                            }
                            function m(o) {
                                var l = o.tag;
                                if (l === 5 || l === 26 || l === 27 || l === 6)
                                    return o;
                                for (o = o.child; o !== null; ) {
                                    if (l = m(o),
                                    l !== null)
                                        return l;
                                    o = o.sibling
                                }
                                return null
                            }
                            function g(o) {
                                var l = o.tag;
                                if (l === 5 || l === 26 || l === 27 || l === 6)
                                    return o;
                                for (o = o.child; o !== null; ) {
                                    if (o.tag !== 4 && (l = g(o),
                                    l !== null))
                                        return l;
                                    o = o.sibling
                                }
                                return null
                            }
                            function v(o) {
                                return o === null || typeof o != "object" ? null : (o = gu && o[gu] || o["@@iterator"],
                                typeof o == "function" ? o : null)
                            }
                            function _(o) {
                                if (o == null)
                                    return null;
                                if (typeof o == "function")
                                    return o.$$typeof === Km ? null : o.displayName || o.name || null;
                                if (typeof o == "string")
                                    return o;
                                switch (o) {
                                case lo:
                                    return "Fragment";
                                case wr:
                                    return "Profiler";
                                case Of:
                                    return "StrictMode";
                                case mu:
                                    return "Suspense";
                                case nl:
                                    return "SuspenseList";
                                case Pf:
                                    return "Activity"
                                }
                                if (typeof o == "object")
                                    switch (o.$$typeof) {
                                    case Va:
                                        return "Portal";
                                    case hs:
                                        return o.displayName || "Context";
                                    case co:
                                        return (o._context.displayName || "Context") + ".Consumer";
                                    case pu:
                                        var l = o.render;
                                        return o = o.displayName,
                                        o || (o = l.displayName || l.name || "",
                                        o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"),
                                        o;
                                    case il:
                                        return l = o.displayName || null,
                                        l !== null ? l : _(o.type) || "Memo";
                                    case Cr:
                                        l = o._payload,
                                        o = o._init;
                                        try {
                                            return _(o(l))
                                        } catch {}
                                    }
                                return null
                            }
                            function x(o) {
                                return {
                                    current: o
                                }
                            }
                            function M(o) {
                                0 > ol || (o.current = $f[ol],
                                $f[ol] = null,
                                ol--)
                            }
                            function C(o, l) {
                                ol++,
                                $f[ol] = o.current,
                                o.current = l
                            }
                            function R(o) {
                                return o >>>= 0,
                                o === 0 ? 32 : 31 - (fp(o) / Ig | 0) | 0
                            }
                            function A(o) {
                                var l = o & 42;
                                if (l !== 0)
                                    return l;
                                switch (o & -o) {
                                case 1:
                                    return 1;
                                case 2:
                                    return 2;
                                case 4:
                                    return 4;
                                case 8:
                                    return 8;
                                case 16:
                                    return 16;
                                case 32:
                                    return 32;
                                case 64:
                                    return 64;
                                case 128:
                                    return 128;
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                    return o & 261888;
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                    return o & 3932160;
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    return o & 62914560;
                                case 67108864:
                                    return 67108864;
                                case 134217728:
                                    return 134217728;
                                case 268435456:
                                    return 268435456;
                                case 536870912:
                                    return 536870912;
                                case 1073741824:
                                    return 0;
                                default:
                                    return o
                                }
                            }
                            function E(o, l, d) {
                                var y = o.pendingLanes;
                                if (y === 0)
                                    return 0;
                                var T = 0
                                  , w = o.suspendedLanes
                                  , z = o.pingedLanes;
                                o = o.warmLanes;
                                var $ = y & 134217727;
                                return $ !== 0 ? (y = $ & ~w,
                                y !== 0 ? T = A(y) : (z &= $,
                                z !== 0 ? T = A(z) : d || (d = $ & ~o,
                                d !== 0 && (T = A(d))))) : ($ = y & ~w,
                                $ !== 0 ? T = A($) : z !== 0 ? T = A(z) : d || (d = y & ~o,
                                d !== 0 && (T = A(d)))),
                                T === 0 ? 0 : l !== 0 && l !== T && (l & w) === 0 && (w = T & -T,
                                d = l & -l,
                                w >= d || w === 32 && (d & 4194048) !== 0) ? l : T
                            }
                            function N(o, l) {
                                return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & l) === 0
                            }
                            function I(o, l) {
                                switch (o) {
                                case 1:
                                case 2:
                                case 4:
                                case 8:
                                case 64:
                                    return l + 250;
                                case 16:
                                case 32:
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                    return l + 5e3;
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    return -1;
                                case 67108864:
                                case 134217728:
                                case 268435456:
                                case 536870912:
                                case 1073741824:
                                    return -1;
                                default:
                                    return -1
                                }
                            }
                            function L() {
                                var o = $l;
                                return $l <<= 1,
                                !($l & 62914560) && ($l = 4194304),
                                o
                            }
                            function k(o) {
                                for (var l = [], d = 0; 31 > d; d++)
                                    l.push(o);
                                return l
                            }
                            function B(o, l) {
                                o.pendingLanes |= l,
                                l !== 268435456 && (o.suspendedLanes = 0,
                                o.pingedLanes = 0,
                                o.warmLanes = 0)
                            }
                            function X(o, l, d, y, T, w) {
                                var z = o.pendingLanes;
                                o.pendingLanes = d,
                                o.suspendedLanes = 0,
                                o.pingedLanes = 0,
                                o.warmLanes = 0,
                                o.expiredLanes &= d,
                                o.entangledLanes &= d,
                                o.errorRecoveryDisabledLanes &= d,
                                o.shellSuspendCounter = 0;
                                var $ = o.entanglements
                                  , be = o.expirationTimes
                                  , Oe = o.hiddenUpdates;
                                for (d = z & ~d; 0 < d; ) {
                                    var it = 31 - ga(d)
                                      , Qe = 1 << it;
                                    $[it] = 0,
                                    be[it] = -1;
                                    var gt = Oe[it];
                                    if (gt !== null)
                                        for (Oe[it] = null,
                                        it = 0; it < gt.length; it++) {
                                            var Ht = gt[it];
                                            Ht !== null && (Ht.lane &= -536870913)
                                        }
                                    d &= ~Qe
                                }
                                y !== 0 && G(o, y, 0),
                                w !== 0 && T === 0 && o.tag !== 0 && (o.suspendedLanes |= w & ~(z & ~l))
                            }
                            function G(o, l, d) {
                                o.pendingLanes |= l,
                                o.suspendedLanes &= ~l;
                                var y = 31 - ga(l);
                                o.entangledLanes |= l,
                                o.entanglements[y] = o.entanglements[y] | 1073741824 | d & 261930
                            }
                            function P(o, l) {
                                var d = o.entangledLanes |= l;
                                for (o = o.entanglements; d; ) {
                                    var y = 31 - ga(d)
                                      , T = 1 << y;
                                    T & l | o[y] & l && (o[y] |= l),
                                    d &= ~T
                                }
                            }
                            function U(o, l) {
                                var d = l & -l;
                                return d = (d & 42) !== 0 ? 1 : W(d),
                                (d & (o.suspendedLanes | l)) !== 0 ? 0 : d
                            }
                            function W(o) {
                                switch (o) {
                                case 2:
                                    o = 1;
                                    break;
                                case 8:
                                    o = 4;
                                    break;
                                case 32:
                                    o = 16;
                                    break;
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                    o = 128;
                                    break;
                                case 268435456:
                                    o = 134217728;
                                    break;
                                default:
                                    o = 0
                                }
                                return o
                            }
                            function K(o) {
                                return o &= -o,
                                2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
                            }
                            function q(o) {
                                if (typeof Bg == "function" && eh(o),
                                ln && typeof ln.setStrictMode == "function")
                                    try {
                                        ln.setStrictMode(Nr, o)
                                    } catch {}
                            }
                            function te(o, l) {
                                return o === l && (o !== 0 || 1 / o === 1 / l) || o !== o && l !== l
                            }
                            function ce(o) {
                                if (cl === void 0)
                                    try {
                                        throw Error()
                                    } catch (d) {
                                        var l = d.stack.trim().match(/\n( *(at )?)/);
                                        cl = l && l[1] || "",
                                        Lr = -1 < d.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < d.stack.indexOf("@") ? "@unknown:0:0" : ""
                                    }
                                return `
` + cl + o + Lr
                            }
                            function J(o, l) {
                                if (!o || th)
                                    return "";
                                th = !0;
                                var d = Error.prepareStackTrace;
                                Error.prepareStackTrace = void 0;
                                try {
                                    var y = {
                                        DetermineComponentFrameRoot: function() {
                                            try {
                                                if (l) {
                                                    var Qe = function() {
                                                        throw Error()
                                                    };
                                                    if (Object.defineProperty(Qe.prototype, "props", {
                                                        set: function() {
                                                            throw Error()
                                                        }
                                                    }),
                                                    typeof Reflect == "object" && Reflect.construct) {
                                                        try {
                                                            Reflect.construct(Qe, [])
                                                        } catch (Ht) {
                                                            var gt = Ht
                                                        }
                                                        Reflect.construct(o, [], Qe)
                                                    } else {
                                                        try {
                                                            Qe.call()
                                                        } catch (Ht) {
                                                            gt = Ht
                                                        }
                                                        o.call(Qe.prototype)
                                                    }
                                                } else {
                                                    try {
                                                        throw Error()
                                                    } catch (Ht) {
                                                        gt = Ht
                                                    }
                                                    (Qe = o()) && typeof Qe.catch == "function" && Qe.catch(function() {})
                                                }
                                            } catch (Ht) {
                                                if (Ht && gt && typeof Ht.stack == "string")
                                                    return [Ht.stack, gt.stack]
                                            }
                                            return [null, null]
                                        }
                                    };
                                    y.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                                    var T = Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot, "name");
                                    T && T.configurable && Object.defineProperty(y.DetermineComponentFrameRoot, "name", {
                                        value: "DetermineComponentFrameRoot"
                                    });
                                    var w = y.DetermineComponentFrameRoot()
                                      , z = w[0]
                                      , $ = w[1];
                                    if (z && $) {
                                        var be = z.split(`
`)
                                          , Oe = $.split(`
`);
                                        for (T = y = 0; y < be.length && !be[y].includes("DetermineComponentFrameRoot"); )
                                            y++;
                                        for (; T < Oe.length && !Oe[T].includes("DetermineComponentFrameRoot"); )
                                            T++;
                                        if (y === be.length || T === Oe.length)
                                            for (y = be.length - 1,
                                            T = Oe.length - 1; 1 <= y && 0 <= T && be[y] !== Oe[T]; )
                                                T--;
                                        for (; 1 <= y && 0 <= T; y--,
                                        T--)
                                            if (be[y] !== Oe[T]) {
                                                if (y !== 1 || T !== 1)
                                                    do
                                                        if (y--,
                                                        T--,
                                                        0 > T || be[y] !== Oe[T]) {
                                                            var it = `
` + be[y].replace(" at new ", " at ");
                                                            return o.displayName && it.includes("<anonymous>") && (it = it.replace("<anonymous>", o.displayName)),
                                                            it
                                                        }
                                                    while (1 <= y && 0 <= T);
                                                break
                                            }
                                    }
                                } finally {
                                    th = !1,
                                    Error.prepareStackTrace = d
                                }
                                return (d = o ? o.displayName || o.name : "") ? ce(d) : ""
                            }
                            function Q(o, l) {
                                switch (o.tag) {
                                case 26:
                                case 27:
                                case 5:
                                    return ce(o.type);
                                case 16:
                                    return ce("Lazy");
                                case 13:
                                    return o.child !== l && l !== null ? ce("Suspense Fallback") : ce("Suspense");
                                case 19:
                                    return ce("SuspenseList");
                                case 0:
                                case 15:
                                    return J(o.type, !1);
                                case 11:
                                    return J(o.type.render, !1);
                                case 1:
                                    return J(o.type, !0);
                                case 31:
                                    return ce("Activity");
                                default:
                                    return ""
                                }
                            }
                            function se(o) {
                                try {
                                    var l = ""
                                      , d = null;
                                    do
                                        l += Q(o, d),
                                        d = o,
                                        o = o.return;
                                    while (o);
                                    return l
                                } catch (y) {
                                    return `
Error generating stack: ` + y.message + `
` + y.stack
                                }
                            }
                            function Te(o, l) {
                                if (typeof o == "object" && o !== null) {
                                    var d = dp.get(o);
                                    return d !== void 0 ? d : (l = {
                                        value: o,
                                        source: l,
                                        stack: se(l)
                                    },
                                    dp.set(o, l),
                                    l)
                                }
                                return {
                                    value: o,
                                    source: l,
                                    stack: se(l)
                                }
                            }
                            function Ee(o, l) {
                                Ks[va++] = ul,
                                Ks[va++] = bu,
                                bu = o,
                                ul = l
                            }
                            function Be(o, l, d) {
                                Xa[Ma++] = qa,
                                Xa[Ma++] = Us,
                                Xa[Ma++] = Js,
                                Js = o;
                                var y = qa;
                                o = Us;
                                var T = 32 - ga(y) - 1;
                                y &= ~(1 << T),
                                d += 1;
                                var w = 32 - ga(l) + T;
                                if (30 < w) {
                                    var z = T - T % 5;
                                    w = (y & (1 << z) - 1).toString(32),
                                    y >>= z,
                                    T -= z,
                                    qa = 1 << 32 - ga(l) + T | d << T | y,
                                    Us = w + o
                                } else
                                    qa = 1 << w | d << T | y,
                                    Us = o
                            }
                            function j(o) {
                                o.return !== null && (Ee(o, 1),
                                Be(o, 1, 0))
                            }
                            function ve(o) {
                                for (; o === bu; )
                                    bu = Ks[--va],
                                    Ks[va] = null,
                                    ul = Ks[--va],
                                    Ks[va] = null;
                                for (; o === Js; )
                                    Js = Xa[--Ma],
                                    Xa[Ma] = null,
                                    Us = Xa[--Ma],
                                    Xa[Ma] = null,
                                    qa = Xa[--Ma],
                                    Xa[Ma] = null
                            }
                            function Re(o, l) {
                                Xa[Ma++] = qa,
                                Xa[Ma++] = Us,
                                Xa[Ma++] = Js,
                                qa = l.id,
                                Us = l.overflow,
                                Js = o
                            }
                            function le(o, l) {
                                C($s, l),
                                C(Qn, o),
                                C(Wn, null),
                                o = Jm(l),
                                M(Wn),
                                C(Wn, o)
                            }
                            function Ae() {
                                M(Wn),
                                M(Qn),
                                M($s)
                            }
                            function Ne(o) {
                                o.memoizedState !== null && C(Mu, o);
                                var l = Wn.current
                                  , d = uo(l, o.type);
                                l !== d && (C(Qn, o),
                                C(Wn, d))
                            }
                            function ke(o) {
                                Qn.current === o && (M(Wn),
                                M(Qn)),
                                Mu.current === o && (M(Mu),
                                ps ? ma._currentValue = fo : ma._currentValue2 = fo)
                            }
                            function at(o) {
                                throw Ve(Te(Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", "")), o)),
                                aa
                            }
                            function Je(o, l) {
                                if (!na)
                                    throw Error(r(175));
                                xg(o.stateNode, o.type, o.memoizedProps, l, o) || at(o, !0)
                            }
                            function Ft(o) {
                                for (vn = o.return; vn; )
                                    switch (vn.tag) {
                                    case 5:
                                    case 31:
                                    case 13:
                                        mn = !1;
                                        return;
                                    case 27:
                                    case 3:
                                        mn = !0;
                                        return;
                                    default:
                                        vn = vn.return
                                    }
                            }
                            function Vt(o) {
                                if (!na || o !== vn)
                                    return !1;
                                if (!hn)
                                    return Ft(o),
                                    hn = !0,
                                    !1;
                                var l = o.tag;
                                if (ri ? l !== 3 && l !== 27 && (l !== 5 || Cg(o.type) && !wn(o.type, o.memoizedProps)) && $n && at(o) : l !== 3 && (l !== 5 || Cg(o.type) && !wn(o.type, o.memoizedProps)) && $n && at(o),
                                Ft(o),
                                l === 13) {
                                    if (!na)
                                        throw Error(r(316));
                                    if (o = o.memoizedState,
                                    o = o !== null ? o.dehydrated : null,
                                    !o)
                                        throw Error(r(317));
                                    $n = Mg(o)
                                } else if (l === 31) {
                                    if (o = o.memoizedState,
                                    o = o !== null ? o.dehydrated : null,
                                    !o)
                                        throw Error(r(317));
                                    $n = bg(o)
                                } else
                                    $n = ri && l === 27 ? gg(o.type, $n) : vn ? tp(o.stateNode) : null;
                                return !0
                            }
                            function we() {
                                na && ($n = vn = null,
                                hn = !1)
                            }
                            function Ye() {
                                var o = Ur;
                                return o !== null && (ya === null ? ya = o : ya.push.apply(ya, o),
                                Ur = null),
                                o
                            }
                            function Ve(o) {
                                Ur === null ? Ur = [o] : Ur.push(o)
                            }
                            function tt(o, l, d) {
                                ps ? (C(gs, l._currentValue),
                                l._currentValue = d) : (C(gs, l._currentValue2),
                                l._currentValue2 = d)
                            }
                            function Z(o) {
                                var l = gs.current;
                                ps ? o._currentValue = l : o._currentValue2 = l,
                                M(gs)
                            }
                            function At(o, l, d) {
                                for (; o !== null; ) {
                                    var y = o.alternate;
                                    if ((o.childLanes & l) !== l ? (o.childLanes |= l,
                                    y !== null && (y.childLanes |= l)) : y !== null && (y.childLanes & l) !== l && (y.childLanes |= l),
                                    o === d)
                                        break;
                                    o = o.return
                                }
                            }
                            function $e(o, l, d, y) {
                                var T = o.child;
                                for (T !== null && (T.return = o); T !== null; ) {
                                    var w = T.dependencies;
                                    if (w !== null) {
                                        var z = T.child;
                                        w = w.firstContext;
                                        e: for (; w !== null; ) {
                                            var $ = w;
                                            w = T;
                                            for (var be = 0; be < l.length; be++)
                                                if ($.context === l[be]) {
                                                    w.lanes |= d,
                                                    $ = w.alternate,
                                                    $ !== null && ($.lanes |= d),
                                                    At(w.return, d, o),
                                                    y || (z = null);
                                                    break e
                                                }
                                            w = $.next
                                        }
                                    } else if (T.tag === 18) {
                                        if (z = T.return,
                                        z === null)
                                            throw Error(r(341));
                                        z.lanes |= d,
                                        w = z.alternate,
                                        w !== null && (w.lanes |= d),
                                        At(z, d, o),
                                        z = null
                                    } else
                                        z = T.child;
                                    if (z !== null)
                                        z.return = T;
                                    else
                                        for (z = T; z !== null; ) {
                                            if (z === o) {
                                                z = null;
                                                break
                                            }
                                            if (T = z.sibling,
                                            T !== null) {
                                                T.return = z.return,
                                                z = T;
                                                break
                                            }
                                            z = z.return
                                        }
                                    T = z
                                }
                            }
                            function xt(o, l, d, y) {
                                o = null;
                                for (var T = l, w = !1; T !== null; ) {
                                    if (!w) {
                                        if ((T.flags & 524288) !== 0)
                                            w = !0;
                                        else if ((T.flags & 262144) !== 0)
                                            break
                                    }
                                    if (T.tag === 10) {
                                        var z = T.alternate;
                                        if (z === null)
                                            throw Error(r(387));
                                        if (z = z.memoizedProps,
                                        z !== null) {
                                            var $ = T.type;
                                            Wa(T.pendingProps.value, z.value) || (o !== null ? o.push($) : o = [$])
                                        }
                                    } else if (T === Mu.current) {
                                        if (z = T.alternate,
                                        z === null)
                                            throw Error(r(387));
                                        z.memoizedState.memoizedState !== T.memoizedState.memoizedState && (o !== null ? o.push(ma) : o = [ma])
                                    }
                                    T = T.return
                                }
                                o !== null && $e(l, o, d, y),
                                l.flags |= 262144
                            }
                            function Ke(o) {
                                for (o = o.firstContext; o !== null; ) {
                                    var l = o.context;
                                    if (!Wa(ps ? l._currentValue : l._currentValue2, o.memoizedValue))
                                        return !0;
                                    o = o.next
                                }
                                return !1
                            }
                            function wt(o) {
                                po = o,
                                er = null,
                                o = o.dependencies,
                                o !== null && (o.firstContext = null)
                            }
                            function H(o) {
                                return oe(po, o)
                            }
                            function O(o, l) {
                                return po === null && wt(o),
                                oe(o, l)
                            }
                            function oe(o, l) {
                                var d = ps ? l._currentValue : l._currentValue2;
                                if (l = {
                                    context: l,
                                    memoizedValue: d,
                                    next: null
                                },
                                er === null) {
                                    if (o === null)
                                        throw Error(r(308));
                                    er = l,
                                    o.dependencies = {
                                        lanes: 0,
                                        firstContext: l
                                    },
                                    o.flags |= 524288
                                } else
                                    er = er.next = l;
                                return d
                            }
                            function Ce() {
                                return {
                                    controller: new kg,
                                    data: new Map,
                                    refCount: 0
                                }
                            }
                            function Ue(o) {
                                o.refCount--,
                                o.refCount === 0 && Oy(nh, function() {
                                    o.controller.abort()
                                })
                            }
                            function Me() {}
                            function st(o) {
                                o !== fl && o.next === null && (fl === null ? Ta = fl = o : fl = fl.next = o),
                                Tu = !0,
                                sa || (sa = !0,
                                ft())
                            }
                            function je(o, l) {
                                if (!Is && Tu) {
                                    Is = !0;
                                    do
                                        for (var d = !1, y = Ta; y !== null; ) {
                                            if (!l)
                                                if (o !== 0) {
                                                    var T = y.pendingLanes;
                                                    if (T === 0)
                                                        var w = 0;
                                                    else {
                                                        var z = y.suspendedLanes
                                                          , $ = y.pingedLanes;
                                                        w = (1 << 31 - ga(42 | o) + 1) - 1,
                                                        w &= T & ~(z & ~$),
                                                        w = w & 201326741 ? w & 201326741 | 1 : w ? w | 2 : 0
                                                    }
                                                    w !== 0 && (d = !0,
                                                    rt(y, w))
                                                } else
                                                    w = Jt,
                                                    w = E(y, y === Ln ? w : 0, y.cancelPendingCommit !== null || y.timeoutHandle !== Ga),
                                                    !(w & 3) || N(y, w) || (d = !0,
                                                    rt(y, w));
                                            y = y.next
                                        }
                                    while (d);
                                    Is = !1
                                }
                            }
                            function St() {
                                Ct()
                            }
                            function Ct() {
                                Tu = sa = !1;
                                var o = 0;
                                Ya !== 0 && Ey() && (o = Ya);
                                for (var l = ia(), d = null, y = Ta; y !== null; ) {
                                    var T = y.next
                                      , w = He(y, l);
                                    w === 0 ? (y.next = null,
                                    d === null ? Ta = T : d.next = T,
                                    T === null && (fl = d)) : (d = y,
                                    (o !== 0 || w & 3) && (Tu = !0)),
                                    y = T
                                }
                                Ei !== 0 && Ei !== 5 || je(o, !1),
                                Ya !== 0 && (Ya = 0)
                            }
                            function He(o, l) {
                                for (var d = o.suspendedLanes, y = o.pingedLanes, T = o.expirationTimes, w = o.pendingLanes & -62914561; 0 < w; ) {
                                    var z = 31 - ga(w)
                                      , $ = 1 << z
                                      , be = T[z];
                                    be === -1 ? (($ & d) === 0 || ($ & y) !== 0) && (T[z] = I($, l)) : be <= l && (o.expiredLanes |= $),
                                    w &= ~$
                                }
                                if (l = Ln,
                                d = Jt,
                                d = E(o, o === l ? d : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== Ga),
                                y = o.callbackNode,
                                d === 0 || o === l && (Cn === 2 || Cn === 9) || o.cancelPendingCommit !== null)
                                    return y !== null && y !== null && xu(y),
                                    o.callbackNode = null,
                                    o.callbackPriority = 0;
                                if ((d & 3) === 0 || N(o, d)) {
                                    if (l = d & -d,
                                    l === o.callbackPriority)
                                        return l;
                                    switch (y !== null && xu(y),
                                    K(d)) {
                                    case 2:
                                    case 8:
                                        d = zg;
                                        break;
                                    case 32:
                                        d = Ls;
                                        break;
                                    case 268435456:
                                        d = hp;
                                        break;
                                    default:
                                        d = Ls
                                    }
                                    return y = We.bind(null, o),
                                    d = Su(d, y),
                                    o.callbackPriority = l,
                                    o.callbackNode = d,
                                    l
                                }
                                return y !== null && y !== null && xu(y),
                                o.callbackPriority = 2,
                                o.callbackNode = null,
                                2
                            }
                            function We(o, l) {
                                if (Ei !== 0 && Ei !== 5)
                                    return o.callbackNode = null,
                                    o.callbackPriority = 0,
                                    null;
                                var d = o.callbackNode;
                                if (Ko() && o.callbackNode !== d)
                                    return null;
                                var y = Jt;
                                return y = E(o, o === Ln ? y : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== Ga),
                                y === 0 ? null : (Fa(o, y, l),
                                He(o, ia()),
                                o.callbackNode != null && o.callbackNode === d ? We.bind(null, o) : null)
                            }
                            function rt(o, l) {
                                if (Ko())
                                    return null;
                                Fa(o, l, !0)
                            }
                            function ft() {
                                Wd ? Xd(function() {
                                    (sn & 6) !== 0 ? Su(Pg, St) : Ct()
                                }) : Su(Pg, St)
                            }
                            function et() {
                                if (Ya === 0) {
                                    var o = mo;
                                    o === 0 && (o = Jl,
                                    Jl <<= 1,
                                    !(Jl & 261888) && (Jl = 256)),
                                    Ya = o
                                }
                                return Ya
                            }
                            function qt(o, l) {
                                if (ja === null) {
                                    var d = ja = [];
                                    Eu = 0,
                                    mo = et(),
                                    ra = {
                                        status: "pending",
                                        value: void 0,
                                        then: function(y) {
                                            d.push(y)
                                        }
                                    }
                                }
                                return Eu++,
                                l.then(ae, ae),
                                l
                            }
                            function ae() {
                                if (--Eu === 0 && ja !== null) {
                                    ra !== null && (ra.status = "fulfilled");
                                    var o = ja;
                                    ja = null,
                                    mo = 0,
                                    ra = null;
                                    for (var l = 0; l < o.length; l++)
                                        (0,
                                        o[l])()
                                }
                            }
                            function nt(o, l) {
                                var d = []
                                  , y = {
                                    status: "pending",
                                    value: null,
                                    reason: null,
                                    then: function(T) {
                                        d.push(T)
                                    }
                                };
                                return o.then(function() {
                                    y.status = "fulfilled",
                                    y.value = l;
                                    for (var T = 0; T < d.length; T++)
                                        (0,
                                        d[T])(l)
                                }, function(T) {
                                    for (y.status = "rejected",
                                    y.reason = T,
                                    T = 0; T < d.length; T++)
                                        (0,
                                        d[T])(void 0)
                                }),
                                y
                            }
                            function Ge() {
                                var o = vs.current;
                                return o !== null ? o : Ln.pooledCache
                            }
                            function ht(o, l) {
                                l === null ? C(vs, vs.current) : C(vs, l.pool)
                            }
                            function Fe() {
                                var o = Ge();
                                return o === null ? null : {
                                    parent: ps ? dn._currentValue : dn._currentValue2,
                                    pool: o
                                }
                            }
                            function xe(o, l) {
                                if (Wa(o, l))
                                    return !0;
                                if (typeof o != "object" || o === null || typeof l != "object" || l === null)
                                    return !1;
                                var d = Object.keys(o)
                                  , y = Object.keys(l);
                                if (d.length !== y.length)
                                    return !1;
                                for (y = 0; y < d.length; y++) {
                                    var T = d[y];
                                    if (!Vg.call(l, T) || !Wa(o[T], l[T]))
                                        return !1
                                }
                                return !0
                            }
                            function pt(o) {
                                return o = o.status,
                                o === "fulfilled" || o === "rejected"
                            }
                            function Mt(o, l, d) {
                                switch (d = o[d],
                                d === void 0 ? o.push(l) : d !== l && (l.then(Me, Me),
                                l = d),
                                l.status) {
                                case "fulfilled":
                                    return l.value;
                                case "rejected":
                                    throw o = l.reason,
                                    xa(o),
                                    o;
                                default:
                                    if (typeof l.status == "string")
                                        l.then(Me, Me);
                                    else {
                                        if (o = Ln,
                                        o !== null && 100 < o.shellSuspendCounter)
                                            throw Error(r(482));
                                        o = l,
                                        o.status = "pending",
                                        o.then(function(y) {
                                            if (l.status === "pending") {
                                                var T = l;
                                                T.status = "fulfilled",
                                                T.value = y
                                            }
                                        }, function(y) {
                                            if (l.status === "pending") {
                                                var T = l;
                                                T.status = "rejected",
                                                T.reason = y
                                            }
                                        })
                                    }
                                    switch (l.status) {
                                    case "fulfilled":
                                        return l.value;
                                    case "rejected":
                                        throw o = l.reason,
                                        xa(o),
                                        o
                                    }
                                    throw go = l,
                                    tr
                                }
                            }
                            function In(o) {
                                try {
                                    var l = o._init;
                                    return l(o._payload)
                                } catch (d) {
                                    throw d !== null && typeof d == "object" && typeof d.then == "function" ? (go = d,
                                    tr) : d
                                }
                            }
                            function xn() {
                                if (go === null)
                                    throw Error(r(459));
                                var o = go;
                                return go = null,
                                o
                            }
                            function xa(o) {
                                if (o === tr || o === Ir)
                                    throw Error(r(483))
                            }
                            function Gi(o) {
                                var l = ec;
                                return ec += 1,
                                nr === null && (nr = []),
                                Mt(nr, o, l)
                            }
                            function qr(o, l) {
                                l = l.props.ref,
                                o.ref = l !== void 0 ? l : null
                            }
                            function mr(o, l) {
                                throw l.$$typeof === tl ? Error(r(525)) : (o = Object.prototype.toString.call(l),
                                Error(r(31, o === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : o)))
                            }
                            function zc(o) {
                                function l(me, ne) {
                                    if (o) {
                                        var _e = me.deletions;
                                        _e === null ? (me.deletions = [ne],
                                        me.flags |= 16) : _e.push(ne)
                                    }
                                }
                                function d(me, ne) {
                                    if (!o)
                                        return null;
                                    for (; ne !== null; )
                                        l(me, ne),
                                        ne = ne.sibling;
                                    return null
                                }
                                function y(me) {
                                    for (var ne = new Map; me !== null; )
                                        me.key !== null ? ne.set(me.key, me) : ne.set(me.index, me),
                                        me = me.sibling;
                                    return ne
                                }
                                function T(me, ne) {
                                    return me = fs(me, ne),
                                    me.index = 0,
                                    me.sibling = null,
                                    me
                                }
                                function w(me, ne, _e) {
                                    return me.index = _e,
                                    o ? (_e = me.alternate,
                                    _e !== null ? (_e = _e.index,
                                    _e < ne ? (me.flags |= 67108866,
                                    ne) : _e) : (me.flags |= 67108866,
                                    ne)) : (me.flags |= 1048576,
                                    ne)
                                }
                                function z(me) {
                                    return o && me.alternate === null && (me.flags |= 67108866),
                                    me
                                }
                                function $(me, ne, _e, Xe) {
                                    return ne === null || ne.tag !== 6 ? (ne = Gl(_e, me.mode, Xe),
                                    ne.return = me,
                                    ne) : (ne = T(ne, _e),
                                    ne.return = me,
                                    ne)
                                }
                                function be(me, ne, _e, Xe) {
                                    var Lt = _e.type;
                                    return Lt === lo ? it(me, ne, _e.props.children, Xe, _e.key) : ne !== null && (ne.elementType === Lt || typeof Lt == "object" && Lt !== null && Lt.$$typeof === Cr && In(Lt) === ne.type) ? (ne = T(ne, _e.props),
                                    qr(ne, _e),
                                    ne.return = me,
                                    ne) : (ne = Er(_e.type, _e.key, _e.props, null, me.mode, Xe),
                                    qr(ne, _e),
                                    ne.return = me,
                                    ne)
                                }
                                function Oe(me, ne, _e, Xe) {
                                    return ne === null || ne.tag !== 4 || ne.stateNode.containerInfo !== _e.containerInfo || ne.stateNode.implementation !== _e.implementation ? (ne = Uf(_e, me.mode, Xe),
                                    ne.return = me,
                                    ne) : (ne = T(ne, _e.children || []),
                                    ne.return = me,
                                    ne)
                                }
                                function it(me, ne, _e, Xe, Lt) {
                                    return ne === null || ne.tag !== 7 ? (ne = Ar(_e, me.mode, Xe, Lt),
                                    ne.return = me,
                                    ne) : (ne = T(ne, _e),
                                    ne.return = me,
                                    ne)
                                }
                                function Qe(me, ne, _e) {
                                    if (typeof ne == "string" && ne !== "" || typeof ne == "number" || typeof ne == "bigint")
                                        return ne = Gl("" + ne, me.mode, _e),
                                        ne.return = me,
                                        ne;
                                    if (typeof ne == "object" && ne !== null) {
                                        switch (ne.$$typeof) {
                                        case du:
                                            return _e = Er(ne.type, ne.key, ne.props, null, me.mode, _e),
                                            qr(_e, ne),
                                            _e.return = me,
                                            _e;
                                        case Va:
                                            return ne = Uf(ne, me.mode, _e),
                                            ne.return = me,
                                            ne;
                                        case Cr:
                                            return ne = In(ne),
                                            Qe(me, ne, _e)
                                        }
                                        if (Xl(ne) || v(ne))
                                            return ne = Ar(ne, me.mode, _e, null),
                                            ne.return = me,
                                            ne;
                                        if (typeof ne.then == "function")
                                            return Qe(me, Gi(ne), _e);
                                        if (ne.$$typeof === hs)
                                            return Qe(me, O(me, ne), _e);
                                        mr(me, ne)
                                    }
                                    return null
                                }
                                function gt(me, ne, _e, Xe) {
                                    var Lt = ne !== null ? ne.key : null;
                                    if (typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint")
                                        return Lt !== null ? null : $(me, ne, "" + _e, Xe);
                                    if (typeof _e == "object" && _e !== null) {
                                        switch (_e.$$typeof) {
                                        case du:
                                            return _e.key === Lt ? be(me, ne, _e, Xe) : null;
                                        case Va:
                                            return _e.key === Lt ? Oe(me, ne, _e, Xe) : null;
                                        case Cr:
                                            return _e = In(_e),
                                            gt(me, ne, _e, Xe)
                                        }
                                        if (Xl(_e) || v(_e))
                                            return Lt !== null ? null : it(me, ne, _e, Xe, null);
                                        if (typeof _e.then == "function")
                                            return gt(me, ne, Gi(_e), Xe);
                                        if (_e.$$typeof === hs)
                                            return gt(me, ne, O(me, _e), Xe);
                                        mr(me, _e)
                                    }
                                    return null
                                }
                                function Ht(me, ne, _e, Xe, Lt) {
                                    if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number" || typeof Xe == "bigint")
                                        return me = me.get(_e) || null,
                                        $(ne, me, "" + Xe, Lt);
                                    if (typeof Xe == "object" && Xe !== null) {
                                        switch (Xe.$$typeof) {
                                        case du:
                                            return me = me.get(Xe.key === null ? _e : Xe.key) || null,
                                            be(ne, me, Xe, Lt);
                                        case Va:
                                            return me = me.get(Xe.key === null ? _e : Xe.key) || null,
                                            Oe(ne, me, Xe, Lt);
                                        case Cr:
                                            return Xe = In(Xe),
                                            Ht(me, ne, _e, Xe, Lt)
                                        }
                                        if (Xl(Xe) || v(Xe))
                                            return me = me.get(_e) || null,
                                            it(ne, me, Xe, Lt, null);
                                        if (typeof Xe.then == "function")
                                            return Ht(me, ne, _e, Gi(Xe), Lt);
                                        if (Xe.$$typeof === hs)
                                            return Ht(me, ne, _e, O(ne, Xe), Lt);
                                        mr(ne, Xe)
                                    }
                                    return null
                                }
                                function ui(me, ne, _e, Xe) {
                                    for (var Lt = null, Kn = null, It = ne, pn = ne = 0, yi = null; It !== null && pn < _e.length; pn++) {
                                        It.index > pn ? (yi = It,
                                        It = null) : yi = It.sibling;
                                        var An = gt(me, It, _e[pn], Xe);
                                        if (An === null) {
                                            It === null && (It = yi);
                                            break
                                        }
                                        o && It && An.alternate === null && l(me, It),
                                        ne = w(An, ne, pn),
                                        Kn === null ? Lt = An : Kn.sibling = An,
                                        Kn = An,
                                        It = yi
                                    }
                                    if (pn === _e.length)
                                        return d(me, It),
                                        hn && Ee(me, pn),
                                        Lt;
                                    if (It === null) {
                                        for (; pn < _e.length; pn++)
                                            It = Qe(me, _e[pn], Xe),
                                            It !== null && (ne = w(It, ne, pn),
                                            Kn === null ? Lt = It : Kn.sibling = It,
                                            Kn = It);
                                        return hn && Ee(me, pn),
                                        Lt
                                    }
                                    for (It = y(It); pn < _e.length; pn++)
                                        yi = Ht(It, me, pn, _e[pn], Xe),
                                        yi !== null && (o && yi.alternate !== null && It.delete(yi.key === null ? pn : yi.key),
                                        ne = w(yi, ne, pn),
                                        Kn === null ? Lt = yi : Kn.sibling = yi,
                                        Kn = yi);
                                    return o && It.forEach(function(Fr) {
                                        return l(me, Fr)
                                    }),
                                    hn && Ee(me, pn),
                                    Lt
                                }
                                function Br(me, ne, _e, Xe) {
                                    if (_e == null)
                                        throw Error(r(151));
                                    for (var Lt = null, Kn = null, It = ne, pn = ne = 0, yi = null, An = _e.next(); It !== null && !An.done; pn++,
                                    An = _e.next()) {
                                        It.index > pn ? (yi = It,
                                        It = null) : yi = It.sibling;
                                        var Fr = gt(me, It, An.value, Xe);
                                        if (Fr === null) {
                                            It === null && (It = yi);
                                            break
                                        }
                                        o && It && Fr.alternate === null && l(me, It),
                                        ne = w(Fr, ne, pn),
                                        Kn === null ? Lt = Fr : Kn.sibling = Fr,
                                        Kn = Fr,
                                        It = yi
                                    }
                                    if (An.done)
                                        return d(me, It),
                                        hn && Ee(me, pn),
                                        Lt;
                                    if (It === null) {
                                        for (; !An.done; pn++,
                                        An = _e.next())
                                            An = Qe(me, An.value, Xe),
                                            An !== null && (ne = w(An, ne, pn),
                                            Kn === null ? Lt = An : Kn.sibling = An,
                                            Kn = An);
                                        return hn && Ee(me, pn),
                                        Lt
                                    }
                                    for (It = y(It); !An.done; pn++,
                                    An = _e.next())
                                        An = Ht(It, me, pn, An.value, Xe),
                                        An !== null && (o && An.alternate !== null && It.delete(An.key === null ? pn : An.key),
                                        ne = w(An, ne, pn),
                                        Kn === null ? Lt = An : Kn.sibling = An,
                                        Kn = An);
                                    return o && It.forEach(function(Py) {
                                        return l(me, Py)
                                    }),
                                    hn && Ee(me, pn),
                                    Lt
                                }
                                function ml(me, ne, _e, Xe) {
                                    if (typeof _e == "object" && _e !== null && _e.type === lo && _e.key === null && (_e = _e.props.children),
                                    typeof _e == "object" && _e !== null) {
                                        switch (_e.$$typeof) {
                                        case du:
                                            e: {
                                                for (var Lt = _e.key; ne !== null; ) {
                                                    if (ne.key === Lt) {
                                                        if (Lt = _e.type,
                                                        Lt === lo) {
                                                            if (ne.tag === 7) {
                                                                d(me, ne.sibling),
                                                                Xe = T(ne, _e.props.children),
                                                                Xe.return = me,
                                                                me = Xe;
                                                                break e
                                                            }
                                                        } else if (ne.elementType === Lt || typeof Lt == "object" && Lt !== null && Lt.$$typeof === Cr && In(Lt) === ne.type) {
                                                            d(me, ne.sibling),
                                                            Xe = T(ne, _e.props),
                                                            qr(Xe, _e),
                                                            Xe.return = me,
                                                            me = Xe;
                                                            break e
                                                        }
                                                        d(me, ne);
                                                        break
                                                    } else
                                                        l(me, ne);
                                                    ne = ne.sibling
                                                }
                                                _e.type === lo ? (Xe = Ar(_e.props.children, me.mode, Xe, _e.key),
                                                Xe.return = me,
                                                me = Xe) : (Xe = Er(_e.type, _e.key, _e.props, null, me.mode, Xe),
                                                qr(Xe, _e),
                                                Xe.return = me,
                                                me = Xe)
                                            }
                                            return z(me);
                                        case Va:
                                            e: {
                                                for (Lt = _e.key; ne !== null; ) {
                                                    if (ne.key === Lt)
                                                        if (ne.tag === 4 && ne.stateNode.containerInfo === _e.containerInfo && ne.stateNode.implementation === _e.implementation) {
                                                            d(me, ne.sibling),
                                                            Xe = T(ne, _e.children || []),
                                                            Xe.return = me,
                                                            me = Xe;
                                                            break e
                                                        } else {
                                                            d(me, ne);
                                                            break
                                                        }
                                                    else
                                                        l(me, ne);
                                                    ne = ne.sibling
                                                }
                                                Xe = Uf(_e, me.mode, Xe),
                                                Xe.return = me,
                                                me = Xe
                                            }
                                            return z(me);
                                        case Cr:
                                            return _e = In(_e),
                                            ml(me, ne, _e, Xe)
                                        }
                                        if (Xl(_e))
                                            return ui(me, ne, _e, Xe);
                                        if (v(_e)) {
                                            if (Lt = v(_e),
                                            typeof Lt != "function")
                                                throw Error(r(150));
                                            return _e = Lt.call(_e),
                                            Br(me, ne, _e, Xe)
                                        }
                                        if (typeof _e.then == "function")
                                            return ml(me, ne, Gi(_e), Xe);
                                        if (_e.$$typeof === hs)
                                            return ml(me, ne, O(me, _e), Xe);
                                        mr(me, _e)
                                    }
                                    return typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint" ? (_e = "" + _e,
                                    ne !== null && ne.tag === 6 ? (d(me, ne.sibling),
                                    Xe = T(ne, _e),
                                    Xe.return = me,
                                    me = Xe) : (d(me, ne),
                                    Xe = Gl(_e, me.mode, Xe),
                                    Xe.return = me,
                                    me = Xe),
                                    z(me)) : d(me, ne)
                                }
                                return function(me, ne, _e, Xe) {
                                    try {
                                        ec = 0;
                                        var Lt = ml(me, ne, _e, Xe);
                                        return nr = null,
                                        Lt
                                    } catch (It) {
                                        if (It === tr || It === Ir)
                                            throw It;
                                        var Kn = n(29, It, null, me.mode);
                                        return Kn.lanes = Xe,
                                        Kn.return = me,
                                        Kn
                                    }
                                }
                            }
                            function Yr() {
                                for (var o = tc, l = Mn = tc = 0; l < o; ) {
                                    var d = ys[l];
                                    ys[l++] = null;
                                    var y = ys[l];
                                    ys[l++] = null;
                                    var T = ys[l];
                                    ys[l++] = null;
                                    var w = ys[l];
                                    if (ys[l++] = null,
                                    y !== null && T !== null) {
                                        var z = y.pending;
                                        z === null ? T.next = T : (T.next = z.next,
                                        z.next = T),
                                        y.pending = T
                                    }
                                    w !== 0 && Rl(d, T, w)
                                }
                            }
                            function jr(o, l, d, y) {
                                ys[tc++] = o,
                                ys[tc++] = l,
                                ys[tc++] = d,
                                ys[tc++] = y,
                                Mn |= y,
                                o.lanes |= y,
                                o = o.alternate,
                                o !== null && (o.lanes |= y)
                            }
                            function Ua(o, l, d, y) {
                                return jr(o, l, d, y),
                                ba(o)
                            }
                            function ss(o, l) {
                                return jr(o, null, null, l),
                                ba(o)
                            }
                            function Rl(o, l, d) {
                                o.lanes |= d;
                                var y = o.alternate;
                                y !== null && (y.lanes |= d);
                                for (var T = !1, w = o.return; w !== null; )
                                    w.childLanes |= d,
                                    y = w.alternate,
                                    y !== null && (y.childLanes |= d),
                                    w.tag === 22 && (o = w.stateNode,
                                    o === null || o._visibility & 1 || (T = !0)),
                                    o = w,
                                    w = w.return;
                                return o.tag === 3 ? (w = o.stateNode,
                                T && l !== null && (T = 31 - ga(d),
                                o = w.hiddenUpdates,
                                y = o[T],
                                y === null ? o[T] = [l] : y.push(l),
                                l.lane = d | 536870912),
                                w) : null
                            }
                            function ba(o) {
                                if (50 < Eo)
                                    throw Eo = 0,
                                    Nu = null,
                                    Error(r(185));
                                for (var l = o.return; l !== null; )
                                    o = l,
                                    l = o.return;
                                return o.tag === 3 ? o.stateNode : null
                            }
                            function Zn(o) {
                                o.updateQueue = {
                                    baseState: o.memoizedState,
                                    firstBaseUpdate: null,
                                    lastBaseUpdate: null,
                                    shared: {
                                        pending: null,
                                        lanes: 0,
                                        hiddenCallbacks: null
                                    },
                                    callbacks: null
                                }
                            }
                            function Ci(o, l) {
                                o = o.updateQueue,
                                l.updateQueue === o && (l.updateQueue = {
                                    baseState: o.baseState,
                                    firstBaseUpdate: o.firstBaseUpdate,
                                    lastBaseUpdate: o.lastBaseUpdate,
                                    shared: o.shared,
                                    callbacks: null
                                })
                            }
                            function Wi(o) {
                                return {
                                    lane: o,
                                    tag: 0,
                                    payload: null,
                                    callback: null,
                                    next: null
                                }
                            }
                            function Ia(o, l, d) {
                                var y = o.updateQueue;
                                if (y === null)
                                    return null;
                                if (y = y.shared,
                                (sn & 2) !== 0) {
                                    var T = y.pending;
                                    return T === null ? l.next = l : (l.next = T.next,
                                    T.next = l),
                                    y.pending = l,
                                    l = ba(o),
                                    Rl(o, null, d),
                                    l
                                }
                                return jr(o, y, l, d),
                                ba(o)
                            }
                            function Zr(o, l, d) {
                                if (l = l.updateQueue,
                                l !== null && (l = l.shared,
                                (d & 4194048) !== 0)) {
                                    var y = l.lanes;
                                    y &= o.pendingLanes,
                                    d |= y,
                                    l.lanes = d,
                                    P(o, d)
                                }
                            }
                            function Bc(o, l) {
                                var d = o.updateQueue
                                  , y = o.alternate;
                                if (y !== null && (y = y.updateQueue,
                                d === y)) {
                                    var T = null
                                      , w = null;
                                    if (d = d.firstBaseUpdate,
                                    d !== null) {
                                        do {
                                            var z = {
                                                lane: d.lane,
                                                tag: d.tag,
                                                payload: d.payload,
                                                callback: null,
                                                next: null
                                            };
                                            w === null ? T = w = z : w = w.next = z,
                                            d = d.next
                                        } while (d !== null);
                                        w === null ? T = w = l : w = w.next = l
                                    } else
                                        T = w = l;
                                    d = {
                                        baseState: y.baseState,
                                        firstBaseUpdate: T,
                                        lastBaseUpdate: w,
                                        shared: y.shared,
                                        callbacks: y.callbacks
                                    },
                                    o.updateQueue = d;
                                    return
                                }
                                o = d.lastBaseUpdate,
                                o === null ? d.firstBaseUpdate = l : o.next = l,
                                d.lastBaseUpdate = l
                            }
                            function Qr() {
                                if (Kt) {
                                    var o = ra;
                                    if (o !== null)
                                        throw o
                                }
                            }
                            function Es(o, l, d, y) {
                                Kt = !1;
                                var T = o.updateQueue;
                                yn = !1;
                                var w = T.firstBaseUpdate
                                  , z = T.lastBaseUpdate
                                  , $ = T.shared.pending;
                                if ($ !== null) {
                                    T.shared.pending = null;
                                    var be = $
                                      , Oe = be.next;
                                    be.next = null,
                                    z === null ? w = Oe : z.next = Oe,
                                    z = be;
                                    var it = o.alternate;
                                    it !== null && (it = it.updateQueue,
                                    $ = it.lastBaseUpdate,
                                    $ !== z && ($ === null ? it.firstBaseUpdate = Oe : $.next = Oe,
                                    it.lastBaseUpdate = be))
                                }
                                if (w !== null) {
                                    var Qe = T.baseState;
                                    z = 0,
                                    it = Oe = be = null,
                                    $ = w;
                                    do {
                                        var gt = $.lane & -536870913
                                          , Ht = gt !== $.lane;
                                        if (Ht ? (Jt & gt) === gt : (y & gt) === gt) {
                                            gt !== 0 && gt === mo && (Kt = !0),
                                            it !== null && (it = it.next = {
                                                lane: 0,
                                                tag: $.tag,
                                                payload: $.payload,
                                                callback: null,
                                                next: null
                                            });
                                            e: {
                                                var ui = o
                                                  , Br = $;
                                                gt = l;
                                                var ml = d;
                                                switch (Br.tag) {
                                                case 1:
                                                    if (ui = Br.payload,
                                                    typeof ui == "function") {
                                                        Qe = ui.call(ml, Qe, gt);
                                                        break e
                                                    }
                                                    Qe = ui;
                                                    break e;
                                                case 3:
                                                    ui.flags = ui.flags & -65537 | 128;
                                                case 0:
                                                    if (ui = Br.payload,
                                                    gt = typeof ui == "function" ? ui.call(ml, Qe, gt) : ui,
                                                    gt == null)
                                                        break e;
                                                    Qe = If({}, Qe, gt);
                                                    break e;
                                                case 2:
                                                    yn = !0
                                                }
                                            }
                                            gt = $.callback,
                                            gt !== null && (o.flags |= 64,
                                            Ht && (o.flags |= 8192),
                                            Ht = T.callbacks,
                                            Ht === null ? T.callbacks = [gt] : Ht.push(gt))
                                        } else
                                            Ht = {
                                                lane: gt,
                                                tag: $.tag,
                                                payload: $.payload,
                                                callback: $.callback,
                                                next: null
                                            },
                                            it === null ? (Oe = it = Ht,
                                            be = Qe) : it = it.next = Ht,
                                            z |= gt;
                                        if ($ = $.next,
                                        $ === null) {
                                            if ($ = T.shared.pending,
                                            $ === null)
                                                break;
                                            Ht = $,
                                            $ = Ht.next,
                                            Ht.next = null,
                                            T.lastBaseUpdate = Ht,
                                            T.shared.pending = null
                                        }
                                    } while (!0);
                                    it === null && (be = Qe),
                                    T.baseState = be,
                                    T.firstBaseUpdate = Oe,
                                    T.lastBaseUpdate = it,
                                    w === null && (T.shared.lanes = 0),
                                    zs |= z,
                                    o.lanes = z,
                                    o.memoizedState = Qe
                                }
                            }
                            function Dl(o, l) {
                                if (typeof o != "function")
                                    throw Error(r(191, o));
                                o.call(l)
                            }
                            function gr(o, l) {
                                var d = o.callbacks;
                                if (d !== null)
                                    for (o.callbacks = null,
                                    o = 0; o < d.length; o++)
                                        Dl(d[o], l)
                            }
                            function vr(o, l) {
                                o = or,
                                C(En, o),
                                C(Yt, l),
                                or = o | l.baseLanes
                            }
                            function V() {
                                C(En, or),
                                C(Yt, Yt.current)
                            }
                            function re() {
                                or = En.current,
                                M(Yt),
                                M(En)
                            }
                            function he(o) {
                                var l = o.alternate;
                                C(kn, kn.current & 1),
                                C(Xn, o),
                                Vi === null && (l === null || Yt.current !== null || l.memoizedState !== null) && (Vi = o)
                            }
                            function ye(o) {
                                C(kn, kn.current),
                                C(Xn, o),
                                Vi === null && (Vi = o)
                            }
                            function fe(o) {
                                o.tag === 22 ? (C(kn, kn.current),
                                C(Xn, o),
                                Vi === null && (Vi = o)) : ze()
                            }
                            function ze() {
                                C(kn, kn.current),
                                C(Xn, Xn.current)
                            }
                            function qe(o) {
                                M(Xn),
                                Vi === o && (Vi = null),
                                M(kn)
                            }
                            function mt(o) {
                                for (var l = o; l !== null; ) {
                                    if (l.tag === 13) {
                                        var d = l.memoizedState;
                                        if (d !== null && (d = d.dehydrated,
                                        d === null || Xf(d) || qf(d)))
                                            return l
                                    } else if (l.tag === 19 && (l.memoizedProps.revealOrder === "forwards" || l.memoizedProps.revealOrder === "backwards" || l.memoizedProps.revealOrder === "unstable_legacy-backwards" || l.memoizedProps.revealOrder === "together")) {
                                        if ((l.flags & 128) !== 0)
                                            return l
                                    } else if (l.child !== null) {
                                        l.child.return = l,
                                        l = l.child;
                                        continue
                                    }
                                    if (l === o)
                                        break;
                                    for (; l.sibling === null; ) {
                                        if (l.return === null || l.return === o)
                                            return null;
                                        l = l.return
                                    }
                                    l.sibling.return = l.return,
                                    l = l.sibling
                                }
                                return null
                            }
                            function Ze() {
                                throw Error(r(321))
                            }
                            function Rt(o, l) {
                                if (l === null)
                                    return !1;
                                for (var d = 0; d < l.length && d < o.length; d++)
                                    if (!Wa(o[d], l[d]))
                                        return !1;
                                return !0
                            }
                            function Ot(o, l, d, y, T, w) {
                                return Os = w,
                                Ut = l,
                                l.memoizedState = null,
                                l.updateQueue = null,
                                l.lanes = 0,
                                Dt.H = o === null || o.memoizedState === null ? vp : nc,
                                Li = !1,
                                w = d(y, T),
                                Li = !1,
                                vo && (w = Qt(l, d, y, T)),
                                Tt(o),
                                w
                            }
                            function Tt(o) {
                                Dt.H = yo;
                                var l = Pt !== null && Pt.next !== null;
                                if (Os = 0,
                                Pn = Pt = Ut = null,
                                ar = !1,
                                Pr = 0,
                                Ui = null,
                                l)
                                    throw Error(r(300));
                                o === null || zn || (o = o.dependencies,
                                o !== null && Ke(o) && (zn = !0))
                            }
                            function Qt(o, l, d, y) {
                                Ut = o;
                                var T = 0;
                                do {
                                    if (vo && (Ui = null),
                                    Pr = 0,
                                    vo = !1,
                                    25 <= T)
                                        throw Error(r(301));
                                    if (T += 1,
                                    Pn = Pt = null,
                                    o.updateQueue != null) {
                                        var w = o.updateQueue;
                                        w.lastEffect = null,
                                        w.events = null,
                                        w.stores = null,
                                        w.memoCache != null && (w.memoCache.index = 0)
                                    }
                                    Dt.H = wu,
                                    w = l(d, y)
                                } while (vo);
                                return w
                            }
                            function cn() {
                                var o = Dt.H
                                  , l = o.useState()[0];
                                return l = typeof l.then == "function" ? Xi(l) : l,
                                o = o.useState()[0],
                                (Pt !== null ? Pt.memoizedState : null) !== o && (Ut.flags |= 1024),
                                l
                            }
                            function nn() {
                                var o = Or !== 0;
                                return Or = 0,
                                o
                            }
                            function On(o, l, d) {
                                l.updateQueue = o.updateQueue,
                                l.flags &= -2053,
                                o.lanes &= ~d
                            }
                            function un(o) {
                                if (ar) {
                                    for (o = o.memoizedState; o !== null; ) {
                                        var l = o.queue;
                                        l !== null && (l.pending = null),
                                        o = o.next
                                    }
                                    ar = !1
                                }
                                Os = 0,
                                Pn = Pt = Ut = null,
                                vo = !1,
                                Pr = Or = 0,
                                Ui = null
                            }
                            function ut() {
                                var o = {
                                    memoizedState: null,
                                    baseState: null,
                                    baseQueue: null,
                                    queue: null,
                                    next: null
                                };
                                return Pn === null ? Ut.memoizedState = Pn = o : Pn = Pn.next = o,
                                Pn
                            }
                            function kt() {
                                if (Pt === null) {
                                    var o = Ut.alternate;
                                    o = o !== null ? o.memoizedState : null
                                } else
                                    o = Pt.next;
                                var l = Pn === null ? Ut.memoizedState : Pn.next;
                                if (l !== null)
                                    Pn = l,
                                    Pt = o;
                                else {
                                    if (o === null)
                                        throw Ut.alternate === null ? Error(r(467)) : Error(r(310));
                                    Pt = o,
                                    o = {
                                        memoizedState: Pt.memoizedState,
                                        baseState: Pt.baseState,
                                        baseQueue: Pt.baseQueue,
                                        queue: Pt.queue,
                                        next: null
                                    },
                                    Pn === null ? Ut.memoizedState = Pn = o : Pn = Pn.next = o
                                }
                                return Pn
                            }
                            function an() {
                                return {
                                    lastEffect: null,
                                    events: null,
                                    stores: null,
                                    memoCache: null
                                }
                            }
                            function Xi(o) {
                                var l = Pr;
                                return Pr += 1,
                                Ui === null && (Ui = []),
                                o = Mt(Ui, o, l),
                                l = Ut,
                                (Pn === null ? l.memoizedState : Pn.next) === null && (l = l.alternate,
                                Dt.H = l === null || l.memoizedState === null ? vp : nc),
                                o
                            }
                            function ni(o) {
                                if (o !== null && typeof o == "object") {
                                    if (typeof o.then == "function")
                                        return Xi(o);
                                    if (o.$$typeof === hs)
                                        return H(o)
                                }
                                throw Error(r(438, String(o)))
                            }
                            function Ri(o) {
                                var l = null
                                  , d = Ut.updateQueue;
                                if (d !== null && (l = d.memoCache),
                                l == null) {
                                    var y = Ut.alternate;
                                    y !== null && (y = y.updateQueue,
                                    y !== null && (y = y.memoCache,
                                    y != null && (l = {
                                        data: y.data.map(function(T) {
                                            return T.slice()
                                        }),
                                        index: 0
                                    })))
                                }
                                if (l ??= {
                                    data: [],
                                    index: 0
                                },
                                d === null && (d = an(),
                                Ut.updateQueue = d),
                                d.memoCache = l,
                                d = l.data[l.index],
                                d === void 0)
                                    for (d = l.data[l.index] = Array(o),
                                    y = 0; y < o; y++)
                                        d[y] = Wl;
                                return l.index++,
                                d
                            }
                            function Ji(o, l) {
                                return typeof l == "function" ? l(o) : l
                            }
                            function bn(o) {
                                return Jn(kt(), Pt, o)
                            }
                            function Jn(o, l, d) {
                                var y = o.queue;
                                if (y === null)
                                    throw Error(r(311));
                                y.lastRenderedReducer = d;
                                var T = o.baseQueue
                                  , w = y.pending;
                                if (w !== null) {
                                    if (T !== null) {
                                        var z = T.next;
                                        T.next = w.next,
                                        w.next = z
                                    }
                                    l.baseQueue = T = w,
                                    y.pending = null
                                }
                                if (w = o.baseState,
                                T === null)
                                    o.memoizedState = w;
                                else {
                                    l = T.next;
                                    var $ = z = null
                                      , be = null
                                      , Oe = l
                                      , it = !1;
                                    do {
                                        var Qe = Oe.lane & -536870913;
                                        if (Qe !== Oe.lane ? (Jt & Qe) === Qe : (Os & Qe) === Qe) {
                                            var gt = Oe.revertLane;
                                            if (gt === 0)
                                                be !== null && (be = be.next = {
                                                    lane: 0,
                                                    revertLane: 0,
                                                    gesture: null,
                                                    action: Oe.action,
                                                    hasEagerState: Oe.hasEagerState,
                                                    eagerState: Oe.eagerState,
                                                    next: null
                                                }),
                                                Qe === mo && (it = !0);
                                            else if ((Os & gt) === gt) {
                                                Oe = Oe.next,
                                                gt === mo && (it = !0);
                                                continue
                                            } else
                                                Qe = {
                                                    lane: 0,
                                                    revertLane: Oe.revertLane,
                                                    gesture: null,
                                                    action: Oe.action,
                                                    hasEagerState: Oe.hasEagerState,
                                                    eagerState: Oe.eagerState,
                                                    next: null
                                                },
                                                be === null ? ($ = be = Qe,
                                                z = w) : be = be.next = Qe,
                                                Ut.lanes |= gt,
                                                zs |= gt;
                                            Qe = Oe.action,
                                            Li && d(w, Qe),
                                            w = Oe.hasEagerState ? Oe.eagerState : d(w, Qe)
                                        } else
                                            gt = {
                                                lane: Qe,
                                                revertLane: Oe.revertLane,
                                                gesture: Oe.gesture,
                                                action: Oe.action,
                                                hasEagerState: Oe.hasEagerState,
                                                eagerState: Oe.eagerState,
                                                next: null
                                            },
                                            be === null ? ($ = be = gt,
                                            z = w) : be = be.next = gt,
                                            Ut.lanes |= Qe,
                                            zs |= Qe;
                                        Oe = Oe.next
                                    } while (Oe !== null && Oe !== l);
                                    if (be === null ? z = w : be.next = $,
                                    !Wa(w, o.memoizedState) && (zn = !0,
                                    it && (d = ra,
                                    d !== null)))
                                        throw d;
                                    o.memoizedState = w,
                                    o.baseState = z,
                                    o.baseQueue = be,
                                    y.lastRenderedState = w
                                }
                                return T === null && (y.lanes = 0),
                                [o.memoizedState, y.dispatch]
                            }
                            function qi(o) {
                                var l = kt()
                                  , d = l.queue;
                                if (d === null)
                                    throw Error(r(311));
                                d.lastRenderedReducer = o;
                                var y = d.dispatch
                                  , T = d.pending
                                  , w = l.memoizedState;
                                if (T !== null) {
                                    d.pending = null;
                                    var z = T = T.next;
                                    do
                                        w = o(w, z.action),
                                        z = z.next;
                                    while (z !== T);
                                    Wa(w, l.memoizedState) || (zn = !0),
                                    l.memoizedState = w,
                                    l.baseQueue === null && (l.baseState = w),
                                    d.lastRenderedState = w
                                }
                                return [w, y]
                            }
                            function hi(o, l, d) {
                                var y = Ut
                                  , T = kt()
                                  , w = hn;
                                if (w) {
                                    if (d === void 0)
                                        throw Error(r(407));
                                    d = d()
                                } else
                                    d = l();
                                var z = !Wa((Pt || T).memoizedState, d);
                                if (z && (T.memoizedState = d,
                                zn = !0),
                                T = T.queue,
                                Il(As.bind(null, y, T, o), [o]),
                                T.getSnapshot !== l || z || Pn !== null && Pn.memoizedState.tag & 1) {
                                    if (y.flags |= 2048,
                                    Ws(9, {
                                        destroy: void 0
                                    }, Nl.bind(null, y, T, d, l), null),
                                    Ln === null)
                                        throw Error(r(349));
                                    w || Os & 127 || Di(y, l, d)
                                }
                                return d
                            }
                            function Di(o, l, d) {
                                o.flags |= 16384,
                                o = {
                                    getSnapshot: l,
                                    value: d
                                },
                                l = Ut.updateQueue,
                                l === null ? (l = an(),
                                Ut.updateQueue = l,
                                l.stores = [o]) : (d = l.stores,
                                d === null ? l.stores = [o] : d.push(o))
                            }
                            function Nl(o, l, d, y) {
                                l.value = d,
                                l.getSnapshot = y,
                                rd(l) && cf(o)
                            }
                            function As(o, l, d) {
                                return d(function() {
                                    rd(l) && cf(o)
                                })
                            }
                            function rd(o) {
                                var l = o.getSnapshot;
                                o = o.value;
                                try {
                                    var d = l();
                                    return !Wa(o, d)
                                } catch {
                                    return !0
                                }
                            }
                            function cf(o) {
                                var l = ss(o, 2);
                                l !== null && di(l, o, 2)
                            }
                            function od(o) {
                                var l = ut();
                                if (typeof o == "function") {
                                    var d = o;
                                    if (o = d(),
                                    Li) {
                                        q(!0);
                                        try {
                                            d()
                                        } finally {
                                            q(!1)
                                        }
                                    }
                                }
                                return l.memoizedState = l.baseState = o,
                                l.queue = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: Ji,
                                    lastRenderedState: o
                                },
                                l
                            }
                            function Am(o, l, d, y) {
                                return o.baseState = d,
                                Jn(o, Pt, typeof y == "function" ? y : Ji)
                            }
                            function uf(o, l, d, y, T) {
                                if (Pl(o))
                                    throw Error(r(485));
                                if (o = l.action,
                                o !== null) {
                                    var w = {
                                        payload: T,
                                        action: o,
                                        next: null,
                                        isTransition: !0,
                                        status: "pending",
                                        value: null,
                                        reason: null,
                                        listeners: [],
                                        then: function(z) {
                                            w.listeners.push(z)
                                        }
                                    };
                                    Dt.T !== null ? d(!0) : w.isTransition = !1,
                                    y(w),
                                    d = l.pending,
                                    d === null ? (w.next = l.pending = w,
                                    Gs(l, w)) : (w.next = d.next,
                                    l.pending = d.next = w)
                                }
                            }
                            function Gs(o, l) {
                                var d = l.action
                                  , y = l.payload
                                  , T = o.state;
                                if (l.isTransition) {
                                    var w = Dt.T
                                      , z = {};
                                    Dt.T = z;
                                    try {
                                        var $ = d(T, y)
                                          , be = Dt.S;
                                        be !== null && be(z, $),
                                        ff(o, l, $)
                                    } catch (Oe) {
                                        Kr(o, l, Oe)
                                    } finally {
                                        w !== null && z.types !== null && (w.types = z.types),
                                        Dt.T = w
                                    }
                                } else
                                    try {
                                        w = d(T, y),
                                        ff(o, l, w)
                                    } catch (Oe) {
                                        Kr(o, l, Oe)
                                    }
                            }
                            function ff(o, l, d) {
                                d !== null && typeof d == "object" && typeof d.then == "function" ? d.then(function(y) {
                                    hf(o, l, y)
                                }, function(y) {
                                    return Kr(o, l, y)
                                }) : hf(o, l, d)
                            }
                            function hf(o, l, d) {
                                l.status = "fulfilled",
                                l.value = d,
                                Fo(l),
                                o.state = d,
                                l = o.pending,
                                l !== null && (d = l.next,
                                d === l ? o.pending = null : (d = d.next,
                                l.next = d,
                                Gs(o, d)))
                            }
                            function Kr(o, l, d) {
                                var y = o.pending;
                                if (o.pending = null,
                                y !== null) {
                                    y = y.next;
                                    do
                                        l.status = "rejected",
                                        l.reason = d,
                                        Fo(l),
                                        l = l.next;
                                    while (l !== y)
                                }
                                o.action = null
                            }
                            function Fo(o) {
                                o = o.listeners;
                                for (var l = 0; l < o.length; l++)
                                    (0,
                                    o[l])()
                            }
                            function ld(o, l) {
                                return l
                            }
                            function df(o, l) {
                                if (hn) {
                                    var d = Ln.formState;
                                    if (d !== null) {
                                        e: {
                                            var y = Ut;
                                            if (hn) {
                                                if ($n) {
                                                    var T = mg($n, mn);
                                                    if (T) {
                                                        $n = tp(T),
                                                        y = ep(T);
                                                        break e
                                                    }
                                                }
                                                at(y)
                                            }
                                            y = !1
                                        }
                                        y && (l = d[0])
                                    }
                                }
                                d = ut(),
                                d.memoizedState = d.baseState = l,
                                y = {
                                    pending: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: ld,
                                    lastRenderedState: l
                                },
                                d.queue = y,
                                d = Nm.bind(null, Ut, y),
                                y.dispatch = d,
                                y = od(!1);
                                var w = pd.bind(null, Ut, !1, y.queue);
                                return y = ut(),
                                T = {
                                    state: l,
                                    dispatch: null,
                                    action: o,
                                    pending: null
                                },
                                y.queue = T,
                                d = uf.bind(null, Ut, T, w, d),
                                T.dispatch = d,
                                y.memoizedState = o,
                                [l, d, !1]
                            }
                            function cd(o) {
                                return Ll(kt(), Pt, o)
                            }
                            function Ll(o, l, d) {
                                if (l = Jn(o, l, ld)[0],
                                o = bn(Ji)[0],
                                typeof l == "object" && l !== null && typeof l.then == "function")
                                    try {
                                        var y = Xi(l)
                                    } catch (z) {
                                        throw z === tr ? Ir : z
                                    }
                                else
                                    y = l;
                                l = kt();
                                var T = l.queue
                                  , w = T.dispatch;
                                return d !== l.memoizedState && (Ut.flags |= 2048,
                                Ws(9, {
                                    destroy: void 0
                                }, yr.bind(null, T, d), null)),
                                [y, w, o]
                            }
                            function yr(o, l) {
                                o.action = l
                            }
                            function pf(o) {
                                var l = kt()
                                  , d = Pt;
                                if (d !== null)
                                    return Ll(l, d, o);
                                kt(),
                                l = l.memoizedState,
                                d = kt();
                                var y = d.queue.dispatch;
                                return d.memoizedState = o,
                                [l, y, !1]
                            }
                            function Ws(o, l, d, y) {
                                return o = {
                                    tag: o,
                                    create: d,
                                    deps: y,
                                    inst: l,
                                    next: null
                                },
                                l = Ut.updateQueue,
                                l === null && (l = an(),
                                Ut.updateQueue = l),
                                d = l.lastEffect,
                                d === null ? l.lastEffect = o.next = o : (y = d.next,
                                d.next = o,
                                o.next = y,
                                l.lastEffect = o),
                                o
                            }
                            function _r() {
                                return kt().memoizedState
                            }
                            function Ul(o, l, d, y) {
                                var T = ut();
                                Ut.flags |= o,
                                T.memoizedState = Ws(1 | l, {
                                    destroy: void 0
                                }, d, y === void 0 ? null : y)
                            }
                            function Vo(o, l, d, y) {
                                var T = kt();
                                y = y === void 0 ? null : y;
                                var w = T.memoizedState.inst;
                                Pt !== null && y !== null && Rt(y, Pt.memoizedState.deps) ? T.memoizedState = Ws(l, w, d, y) : (Ut.flags |= o,
                                T.memoizedState = Ws(1 | l, w, d, y))
                            }
                            function ud(o, l) {
                                Ul(8390656, 8, o, l)
                            }
                            function Il(o, l) {
                                Vo(2048, 8, o, l)
                            }
                            function mf(o) {
                                Ut.flags |= 4;
                                var l = Ut.updateQueue;
                                if (l === null)
                                    l = an(),
                                    Ut.updateQueue = l,
                                    l.events = [o];
                                else {
                                    var d = l.events;
                                    d === null ? l.events = [o] : d.push(o)
                                }
                            }
                            function fd(o) {
                                var l = kt().memoizedState;
                                return mf({
                                    ref: l,
                                    nextImpl: o
                                }),
                                function() {
                                    if ((sn & 2) !== 0)
                                        throw Error(r(440));
                                    return l.impl.apply(void 0, arguments)
                                }
                            }
                            function ua(o, l) {
                                return Vo(4, 2, o, l)
                            }
                            function Jr(o, l) {
                                return Vo(4, 4, o, l)
                            }
                            function Fc(o, l) {
                                if (typeof l == "function") {
                                    o = o();
                                    var d = l(o);
                                    return function() {
                                        typeof d == "function" ? d() : l(null)
                                    }
                                }
                                if (l != null)
                                    return o = o(),
                                    l.current = o,
                                    function() {
                                        l.current = null
                                    }
                            }
                            function Ol(o, l, d) {
                                d = d != null ? d.concat([o]) : null,
                                Vo(4, 4, Fc.bind(null, l, o), d)
                            }
                            function hd() {}
                            function gf(o, l) {
                                var d = kt();
                                l = l === void 0 ? null : l;
                                var y = d.memoizedState;
                                return l !== null && Rt(l, y[1]) ? y[0] : (d.memoizedState = [o, l],
                                o)
                            }
                            function vf(o, l) {
                                var d = kt();
                                l = l === void 0 ? null : l;
                                var y = d.memoizedState;
                                if (l !== null && Rt(l, y[1]))
                                    return y[0];
                                if (y = o(),
                                Li) {
                                    q(!0);
                                    try {
                                        o()
                                    } finally {
                                        q(!1)
                                    }
                                }
                                return d.memoizedState = [y, l],
                                y
                            }
                            function ko(o, l, d) {
                                return d === void 0 || (Os & 1073741824) !== 0 && (Jt & 261930) === 0 ? o.memoizedState = l : (o.memoizedState = d,
                                o = fn(),
                                Ut.lanes |= o,
                                zs |= o,
                                d)
                            }
                            function Vc(o, l, d, y) {
                                return Wa(d, l) ? d : Yt.current !== null ? (o = ko(o, d, y),
                                Wa(o, l) || (zn = !0),
                                o) : (Os & 42) === 0 || (Os & 1073741824) !== 0 && (Jt & 261930) === 0 ? (zn = !0,
                                o.memoizedState = d) : (o = fn(),
                                Ut.lanes |= o,
                                zs |= o,
                                l)
                            }
                            function dd(o, l, d, y, T) {
                                var w = Qs();
                                Mi(w !== 0 && 8 > w ? w : 8);
                                var z = Dt.T
                                  , $ = {};
                                Dt.T = $,
                                pd(o, !1, l, d);
                                try {
                                    var be = T()
                                      , Oe = Dt.S;
                                    Oe !== null && Oe($, be),
                                    be !== null && typeof be == "object" && typeof be.then == "function" ? Hc(o, l, nt(be, y), on(o)) : Hc(o, l, y, on(o))
                                } catch (it) {
                                    Hc(o, l, {
                                        then: function() {},
                                        status: "rejected",
                                        reason: it
                                    }, on())
                                } finally {
                                    Mi(w),
                                    z !== null && $.types !== null && (z.types = $.types),
                                    Dt.T = z
                                }
                            }
                            function wm(o) {
                                var l = o.memoizedState;
                                if (l !== null)
                                    return l;
                                l = {
                                    memoizedState: fo,
                                    baseState: fo,
                                    baseQueue: null,
                                    queue: {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: Ji,
                                        lastRenderedState: fo
                                    },
                                    next: null
                                };
                                var d = {};
                                return l.next = {
                                    memoizedState: d,
                                    baseState: d,
                                    baseQueue: null,
                                    queue: {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: Ji,
                                        lastRenderedState: d
                                    },
                                    next: null
                                },
                                o.memoizedState = l,
                                o = o.alternate,
                                o !== null && (o.memoizedState = l),
                                l
                            }
                            function kc() {
                                return H(ma)
                            }
                            function Cm() {
                                return kt().memoizedState
                            }
                            function Rm() {
                                return kt().memoizedState
                            }
                            function Dm(o) {
                                for (var l = o.return; l !== null; ) {
                                    switch (l.tag) {
                                    case 24:
                                    case 3:
                                        var d = on();
                                        o = Wi(d);
                                        var y = Ia(l, o, d);
                                        y !== null && (di(y, l, d),
                                        Zr(y, l, d)),
                                        l = {
                                            cache: Ce()
                                        },
                                        o.payload = l;
                                        return
                                    }
                                    l = l.return
                                }
                            }
                            function by(o, l, d) {
                                var y = on();
                                d = {
                                    lane: y,
                                    revertLane: 0,
                                    gesture: null,
                                    action: d,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                },
                                Pl(o) ? Lm(l, d) : (d = Ua(o, l, d, y),
                                d !== null && (di(d, o, y),
                                md(d, l, y)))
                            }
                            function Nm(o, l, d) {
                                Hc(o, l, d, on())
                            }
                            function Hc(o, l, d, y) {
                                var T = {
                                    lane: y,
                                    revertLane: 0,
                                    gesture: null,
                                    action: d,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                };
                                if (Pl(o))
                                    Lm(l, T);
                                else {
                                    var w = o.alternate;
                                    if (o.lanes === 0 && (w === null || w.lanes === 0) && (w = l.lastRenderedReducer,
                                    w !== null))
                                        try {
                                            var z = l.lastRenderedState
                                              , $ = w(z, d);
                                            if (T.hasEagerState = !0,
                                            T.eagerState = $,
                                            Wa($, z))
                                                return jr(o, l, T, 0),
                                                Ln === null && Yr(),
                                                !1
                                        } catch {}
                                    if (d = Ua(o, l, T, y),
                                    d !== null)
                                        return di(d, o, y),
                                        md(d, l, y),
                                        !0
                                }
                                return !1
                            }
                            function pd(o, l, d, y) {
                                if (y = {
                                    lane: 2,
                                    revertLane: et(),
                                    gesture: null,
                                    action: y,
                                    hasEagerState: !1,
                                    eagerState: null,
                                    next: null
                                },
                                Pl(o)) {
                                    if (l)
                                        throw Error(r(479))
                                } else
                                    l = Ua(o, d, y, 2),
                                    l !== null && di(l, o, 2)
                            }
                            function Pl(o) {
                                var l = o.alternate;
                                return o === Ut || l !== null && l === Ut
                            }
                            function Lm(o, l) {
                                vo = ar = !0;
                                var d = o.pending;
                                d === null ? l.next = l : (l.next = d.next,
                                d.next = l),
                                o.pending = l
                            }
                            function md(o, l, d) {
                                if ((d & 4194048) !== 0) {
                                    var y = l.lanes;
                                    y &= o.pendingLanes,
                                    d |= y,
                                    l.lanes = d,
                                    P(o, d)
                                }
                            }
                            function gd(o, l, d, y) {
                                l = o.memoizedState,
                                d = d(y, l),
                                d = d == null ? l : If({}, l, d),
                                o.memoizedState = d,
                                o.lanes === 0 && (o.updateQueue.baseState = d)
                            }
                            function Um(o, l, d, y, T, w, z) {
                                return o = o.stateNode,
                                typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(y, w, z) : l.prototype && l.prototype.isPureReactComponent ? !xe(d, y) || !xe(T, w) : !0
                            }
                            function Im(o, l, d, y) {
                                o = l.state,
                                typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(d, y),
                                typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(d, y),
                                l.state !== o && sr.enqueueReplaceState(l, l.state, null)
                            }
                            function Ho(o, l) {
                                var d = l;
                                if ("ref"in l) {
                                    d = {};
                                    for (var y in l)
                                        y !== "ref" && (d[y] = l[y])
                                }
                                if (o = o.defaultProps) {
                                    d === l && (d = If({}, d));
                                    for (var T in o)
                                        d[T] === void 0 && (d[T] = o[T])
                                }
                                return d
                            }
                            function yf(o, l) {
                                try {
                                    var d = o.onUncaughtError;
                                    d(l.value, {
                                        componentStack: l.stack
                                    })
                                } catch (y) {
                                    setTimeout(function() {
                                        throw y
                                    })
                                }
                            }
                            function _f(o, l, d) {
                                try {
                                    var y = o.onCaughtError;
                                    y(d.value, {
                                        componentStack: d.stack,
                                        errorBoundary: l.tag === 1 ? l.stateNode : null
                                    })
                                } catch (T) {
                                    setTimeout(function() {
                                        throw T
                                    })
                                }
                            }
                            function Go(o, l, d) {
                                return d = Wi(d),
                                d.tag = 3,
                                d.payload = {
                                    element: null
                                },
                                d.callback = function() {
                                    yf(o, l)
                                }
                                ,
                                d
                            }
                            function Om(o) {
                                return o = Wi(o),
                                o.tag = 3,
                                o
                            }
                            function vd(o, l, d, y) {
                                var T = d.type.getDerivedStateFromError;
                                if (typeof T == "function") {
                                    var w = y.value;
                                    o.payload = function() {
                                        return T(w)
                                    }
                                    ,
                                    o.callback = function() {
                                        _f(l, d, y)
                                    }
                                }
                                var z = d.stateNode;
                                z !== null && typeof z.componentDidCatch == "function" && (o.callback = function() {
                                    _f(l, d, y),
                                    typeof T != "function" && (bo === null ? bo = new Set([this]) : bo.add(this));
                                    var $ = y.stack;
                                    this.componentDidCatch(y.value, {
                                        componentStack: $ !== null ? $ : ""
                                    })
                                }
                                )
                            }
                            function Pm(o, l, d, y, T) {
                                if (d.flags |= 32768,
                                y !== null && typeof y == "object" && typeof y.then == "function") {
                                    if (l = d.alternate,
                                    l !== null && xt(l, d, T, !0),
                                    d = Xn.current,
                                    d !== null) {
                                        switch (d.tag) {
                                        case 31:
                                        case 13:
                                            return Vi === null ? cs() : d.alternate === null && Bn === 0 && (Bn = 3),
                                            d.flags &= -257,
                                            d.flags |= 65536,
                                            d.lanes = T,
                                            y === Au ? d.flags |= 16384 : (l = d.updateQueue,
                                            l === null ? d.updateQueue = new Set([y]) : l.add(y),
                                            so(o, y, T)),
                                            !1;
                                        case 22:
                                            return d.flags |= 65536,
                                            y === Au ? d.flags |= 16384 : (l = d.updateQueue,
                                            l === null ? (l = {
                                                transitions: null,
                                                markerInstances: null,
                                                retryQueue: new Set([y])
                                            },
                                            d.updateQueue = l) : (d = l.retryQueue,
                                            d === null ? l.retryQueue = new Set([y]) : d.add(y)),
                                            so(o, y, T)),
                                            !1
                                        }
                                        throw Error(r(435, d.tag))
                                    }
                                    return so(o, y, T),
                                    cs(),
                                    !1
                                }
                                if (hn)
                                    return l = Xn.current,
                                    l !== null ? (!(l.flags & 65536) && (l.flags |= 256),
                                    l.flags |= 65536,
                                    l.lanes = T,
                                    y !== aa && (o = Error(r(422), {
                                        cause: y
                                    }),
                                    Ve(Te(o, d)))) : (y !== aa && (l = Error(r(423), {
                                        cause: y
                                    }),
                                    Ve(Te(l, d))),
                                    o = o.current.alternate,
                                    o.flags |= 65536,
                                    T &= -T,
                                    o.lanes |= T,
                                    y = Te(y, d),
                                    T = Go(o.stateNode, y, T),
                                    Bc(o, T),
                                    Bn !== 4 && (Bn = 2)),
                                    !1;
                                var w = Error(r(520), {
                                    cause: y
                                });
                                if (w = Te(w, d),
                                sc === null ? sc = [w] : sc.push(w),
                                Bn !== 4 && (Bn = 2),
                                l === null)
                                    return !0;
                                y = Te(y, d),
                                d = l;
                                do {
                                    switch (d.tag) {
                                    case 3:
                                        return d.flags |= 65536,
                                        o = T & -T,
                                        d.lanes |= o,
                                        o = Go(d.stateNode, y, o),
                                        Bc(d, o),
                                        !1;
                                    case 1:
                                        if (l = d.type,
                                        w = d.stateNode,
                                        (d.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (bo === null || !bo.has(w))))
                                            return d.flags |= 65536,
                                            T &= -T,
                                            d.lanes |= T,
                                            T = Om(T),
                                            vd(T, o, d, y),
                                            Bc(d, T),
                                            !1
                                    }
                                    d = d.return
                                } while (d !== null);
                                return !1
                            }
                            function zi(o, l, d, y) {
                                l.child = o === null ? mp(l, null, d, y) : ir(l, o.child, d, y)
                            }
                            function yd(o, l, d, y, T) {
                                d = d.render;
                                var w = l.ref;
                                if ("ref"in y) {
                                    var z = {};
                                    for (var $ in y)
                                        $ !== "ref" && (z[$] = y[$])
                                } else
                                    z = y;
                                return wt(l),
                                y = Ot(o, l, d, z, w, T),
                                $ = nn(),
                                o !== null && !zn ? (On(o, l, T),
                                Sr(o, l, T)) : (hn && $ && j(l),
                                l.flags |= 1,
                                zi(o, l, y, T),
                                l.child)
                            }
                            function _d(o, l, d, y, T) {
                                if (o === null) {
                                    var w = d.type;
                                    return typeof w == "function" && !uu(w) && w.defaultProps === void 0 && d.compare === null ? (l.tag = 15,
                                    l.type = w,
                                    Wo(o, l, w, y, T)) : (o = Er(d.type, null, y, l, l.mode, T),
                                    o.ref = l.ref,
                                    o.return = l,
                                    l.child = o)
                                }
                                if (w = o.child,
                                !fa(o, T)) {
                                    var z = w.memoizedProps;
                                    if (d = d.compare,
                                    d = d !== null ? d : xe,
                                    d(z, y) && o.ref === l.ref)
                                        return Sr(o, l, T)
                                }
                                return l.flags |= 1,
                                o = fs(w, y),
                                o.ref = l.ref,
                                o.return = l,
                                l.child = o
                            }
                            function Wo(o, l, d, y, T) {
                                if (o !== null) {
                                    var w = o.memoizedProps;
                                    if (xe(w, y) && o.ref === l.ref)
                                        if (zn = !1,
                                        l.pendingProps = y = w,
                                        fa(o, T))
                                            o.flags & 131072 && (zn = !0);
                                        else
                                            return l.lanes = o.lanes,
                                            Sr(o, l, T)
                                }
                                return xd(o, l, d, y, T)
                            }
                            function zm(o, l, d, y) {
                                var T = y.children
                                  , w = o !== null ? o.memoizedState : null;
                                if (o === null && l.stateNode === null && (l.stateNode = {
                                    _visibility: 1,
                                    _pendingMarkers: null,
                                    _retryCache: null,
                                    _transitions: null
                                }),
                                y.mode === "hidden") {
                                    if ((l.flags & 128) !== 0) {
                                        if (w = w !== null ? w.baseLanes | d : d,
                                        o !== null) {
                                            for (y = l.child = o.child,
                                            T = 0; y !== null; )
                                                T = T | y.lanes | y.childLanes,
                                                y = y.sibling;
                                            y = T & ~w
                                        } else
                                            y = 0,
                                            l.child = null;
                                        return Bm(o, l, w, d, y)
                                    }
                                    if ((d & 536870912) !== 0)
                                        l.memoizedState = {
                                            baseLanes: 0,
                                            cachePool: null
                                        },
                                        o !== null && ht(l, w !== null ? w.cachePool : null),
                                        w !== null ? vr(l, w) : V(),
                                        fe(l);
                                    else
                                        return y = l.lanes = 536870912,
                                        Bm(o, l, w !== null ? w.baseLanes | d : d, d, y)
                                } else
                                    w !== null ? (ht(l, w.cachePool),
                                    vr(l, w),
                                    ze(),
                                    l.memoizedState = null) : (o !== null && ht(l, null),
                                    V(),
                                    ze());
                                return zi(o, l, T, d),
                                l.child
                            }
                            function Gc(o, l) {
                                return o !== null && o.tag === 22 || l.stateNode !== null || (l.stateNode = {
                                    _visibility: 1,
                                    _pendingMarkers: null,
                                    _retryCache: null,
                                    _transitions: null
                                }),
                                l.sibling
                            }
                            function Bm(o, l, d, y, T) {
                                var w = Ge();
                                return w = w === null ? null : {
                                    parent: ps ? dn._currentValue : dn._currentValue2,
                                    pool: w
                                },
                                l.memoizedState = {
                                    baseLanes: d,
                                    cachePool: w
                                },
                                o !== null && ht(l, null),
                                V(),
                                fe(l),
                                o !== null && xt(o, l, y, !0),
                                l.childLanes = T,
                                null
                            }
                            function Wc(o, l) {
                                return l = Zc({
                                    mode: l.mode,
                                    children: l.children
                                }, o.mode),
                                l.ref = o.ref,
                                o.child = l,
                                l.return = o,
                                l
                            }
                            function Sd(o, l, d) {
                                return ir(l, o.child, null, d),
                                o = Wc(l, l.pendingProps),
                                o.flags |= 2,
                                qe(l),
                                l.memoizedState = null,
                                o
                            }
                            function Xc(o, l, d) {
                                var y = l.pendingProps
                                  , T = (l.flags & 128) !== 0;
                                if (l.flags &= -129,
                                o === null) {
                                    if (hn) {
                                        if (y.mode === "hidden")
                                            return o = Wc(l, y),
                                            l.lanes = 536870912,
                                            Gc(null, o);
                                        if (ye(l),
                                        (o = $n) ? (o = Dy(o, mn),
                                        o !== null && (l.memoizedState = {
                                            dehydrated: o,
                                            treeContext: Js !== null ? {
                                                id: qa,
                                                overflow: Us
                                            } : null,
                                            retryLane: 536870912,
                                            hydrationErrors: null
                                        },
                                        d = fu(o),
                                        d.return = l,
                                        l.child = d,
                                        vn = l,
                                        $n = null)) : o = null,
                                        o === null)
                                            throw at(l);
                                        return l.lanes = 536870912,
                                        null
                                    }
                                    return Wc(l, y)
                                }
                                var w = o.memoizedState;
                                if (w !== null) {
                                    var z = w.dehydrated;
                                    if (ye(l),
                                    T)
                                        if (l.flags & 256)
                                            l.flags &= -257,
                                            l = Sd(o, l, d);
                                        else if (l.memoizedState !== null)
                                            l.child = o.child,
                                            l.flags |= 128,
                                            l = null;
                                        else
                                            throw Error(r(558));
                                    else if (zn || xt(o, l, d, !1),
                                    T = (d & o.childLanes) !== 0,
                                    zn || T) {
                                        if (y = Ln,
                                        y !== null && (z = U(y, d),
                                        z !== 0 && z !== w.retryLane))
                                            throw w.retryLane = z,
                                            ss(o, z),
                                            di(y, o, z),
                                            vi;
                                        cs(),
                                        l = Sd(o, l, d)
                                    } else
                                        o = w.treeContext,
                                        na && ($n = vg(z),
                                        vn = l,
                                        hn = !0,
                                        Ur = null,
                                        mn = !1,
                                        o !== null && Re(l, o)),
                                        l = Wc(l, y),
                                        l.flags |= 4096;
                                    return l
                                }
                                return o = fs(o.child, {
                                    mode: y.mode,
                                    children: y.children
                                }),
                                o.ref = l.ref,
                                l.child = o,
                                o.return = l,
                                o
                            }
                            function $r(o, l) {
                                var d = l.ref;
                                if (d === null)
                                    o !== null && o.ref !== null && (l.flags |= 4194816);
                                else {
                                    if (typeof d != "function" && typeof d != "object")
                                        throw Error(r(284));
                                    (o === null || o.ref !== d) && (l.flags |= 4194816)
                                }
                            }
                            function xd(o, l, d, y, T) {
                                return wt(l),
                                d = Ot(o, l, d, y, void 0, T),
                                y = nn(),
                                o !== null && !zn ? (On(o, l, T),
                                Sr(o, l, T)) : (hn && y && j(l),
                                l.flags |= 1,
                                zi(o, l, d, T),
                                l.child)
                            }
                            function qc(o, l, d, y, T, w) {
                                return wt(l),
                                l.updateQueue = null,
                                d = Qt(l, y, d, T),
                                Tt(o),
                                y = nn(),
                                o !== null && !zn ? (On(o, l, w),
                                Sr(o, l, w)) : (hn && y && j(l),
                                l.flags |= 1,
                                zi(o, l, d, w),
                                l.child)
                            }
                            function bd(o, l, d, y, T) {
                                if (wt(l),
                                l.stateNode === null) {
                                    var w = ho
                                      , z = d.contextType;
                                    typeof z == "object" && z !== null && (w = H(z)),
                                    w = new d(y,w),
                                    l.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null,
                                    w.updater = sr,
                                    l.stateNode = w,
                                    w._reactInternals = l,
                                    w = l.stateNode,
                                    w.props = y,
                                    w.state = l.memoizedState,
                                    w.refs = {},
                                    Zn(l),
                                    z = d.contextType,
                                    w.context = typeof z == "object" && z !== null ? H(z) : ho,
                                    w.state = l.memoizedState,
                                    z = d.getDerivedStateFromProps,
                                    typeof z == "function" && (gd(l, d, z, y),
                                    w.state = l.memoizedState),
                                    typeof d.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (z = w.state,
                                    typeof w.componentWillMount == "function" && w.componentWillMount(),
                                    typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(),
                                    z !== w.state && sr.enqueueReplaceState(w, w.state, null),
                                    Es(l, y, w, T),
                                    Qr(),
                                    w.state = l.memoizedState),
                                    typeof w.componentDidMount == "function" && (l.flags |= 4194308),
                                    y = !0
                                } else if (o === null) {
                                    w = l.stateNode;
                                    var $ = l.memoizedProps
                                      , be = Ho(d, $);
                                    w.props = be;
                                    var Oe = w.context
                                      , it = d.contextType;
                                    z = ho,
                                    typeof it == "object" && it !== null && (z = H(it));
                                    var Qe = d.getDerivedStateFromProps;
                                    it = typeof Qe == "function" || typeof w.getSnapshotBeforeUpdate == "function",
                                    $ = l.pendingProps !== $,
                                    it || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || ($ || Oe !== z) && Im(l, w, y, z),
                                    yn = !1;
                                    var gt = l.memoizedState;
                                    w.state = gt,
                                    Es(l, y, w, T),
                                    Qr(),
                                    Oe = l.memoizedState,
                                    $ || gt !== Oe || yn ? (typeof Qe == "function" && (gd(l, d, Qe, y),
                                    Oe = l.memoizedState),
                                    (be = yn || Um(l, d, be, y, gt, Oe, z)) ? (it || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(),
                                    typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()),
                                    typeof w.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (l.flags |= 4194308),
                                    l.memoizedProps = y,
                                    l.memoizedState = Oe),
                                    w.props = y,
                                    w.state = Oe,
                                    w.context = z,
                                    y = be) : (typeof w.componentDidMount == "function" && (l.flags |= 4194308),
                                    y = !1)
                                } else {
                                    w = l.stateNode,
                                    Ci(o, l),
                                    z = l.memoizedProps,
                                    it = Ho(d, z),
                                    w.props = it,
                                    Qe = l.pendingProps,
                                    gt = w.context,
                                    Oe = d.contextType,
                                    be = ho,
                                    typeof Oe == "object" && Oe !== null && (be = H(Oe)),
                                    $ = d.getDerivedStateFromProps,
                                    (Oe = typeof $ == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (z !== Qe || gt !== be) && Im(l, w, y, be),
                                    yn = !1,
                                    gt = l.memoizedState,
                                    w.state = gt,
                                    Es(l, y, w, T),
                                    Qr();
                                    var Ht = l.memoizedState;
                                    z !== Qe || gt !== Ht || yn || o !== null && o.dependencies !== null && Ke(o.dependencies) ? (typeof $ == "function" && (gd(l, d, $, y),
                                    Ht = l.memoizedState),
                                    (it = yn || Um(l, d, it, y, gt, Ht, be) || o !== null && o.dependencies !== null && Ke(o.dependencies)) ? (Oe || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(y, Ht, be),
                                    typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(y, Ht, be)),
                                    typeof w.componentDidUpdate == "function" && (l.flags |= 4),
                                    typeof w.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || z === o.memoizedProps && gt === o.memoizedState || (l.flags |= 4),
                                    typeof w.getSnapshotBeforeUpdate != "function" || z === o.memoizedProps && gt === o.memoizedState || (l.flags |= 1024),
                                    l.memoizedProps = y,
                                    l.memoizedState = Ht),
                                    w.props = y,
                                    w.state = Ht,
                                    w.context = be,
                                    y = it) : (typeof w.componentDidUpdate != "function" || z === o.memoizedProps && gt === o.memoizedState || (l.flags |= 4),
                                    typeof w.getSnapshotBeforeUpdate != "function" || z === o.memoizedProps && gt === o.memoizedState || (l.flags |= 1024),
                                    y = !1)
                                }
                                return w = y,
                                $r(o, l),
                                y = (l.flags & 128) !== 0,
                                w || y ? (w = l.stateNode,
                                d = y && typeof d.getDerivedStateFromError != "function" ? null : w.render(),
                                l.flags |= 1,
                                o !== null && y ? (l.child = ir(l, o.child, null, T),
                                l.child = ir(l, null, d, T)) : zi(o, l, d, T),
                                l.memoizedState = w.state,
                                o = l.child) : o = Sr(o, l, T),
                                o
                            }
                            function Md(o, l, d, y) {
                                return we(),
                                l.flags |= 256,
                                zi(o, l, d, y),
                                l.child
                            }
                            function Yc(o) {
                                return {
                                    baseLanes: o,
                                    cachePool: Fe()
                                }
                            }
                            function jc(o, l, d) {
                                return o = o !== null ? o.childLanes & ~d : 0,
                                l && (o |= Ea),
                                o
                            }
                            function Td(o, l, d) {
                                var y = l.pendingProps, T = !1, w = (l.flags & 128) !== 0, z;
                                if ((z = w) || (z = o !== null && o.memoizedState === null ? !1 : (kn.current & 2) !== 0),
                                z && (T = !0,
                                l.flags &= -129),
                                z = (l.flags & 32) !== 0,
                                l.flags &= -33,
                                o === null) {
                                    if (hn) {
                                        if (T ? he(l) : ze(),
                                        (o = $n) ? (o = Ny(o, mn),
                                        o !== null && (l.memoizedState = {
                                            dehydrated: o,
                                            treeContext: Js !== null ? {
                                                id: qa,
                                                overflow: Us
                                            } : null,
                                            retryLane: 536870912,
                                            hydrationErrors: null
                                        },
                                        d = fu(o),
                                        d.return = l,
                                        l.child = d,
                                        vn = l,
                                        $n = null)) : o = null,
                                        o === null)
                                            throw at(l);
                                        return qf(o) ? l.lanes = 32 : l.lanes = 536870912,
                                        null
                                    }
                                    var $ = y.children;
                                    return y = y.fallback,
                                    T ? (ze(),
                                    T = l.mode,
                                    $ = Zc({
                                        mode: "hidden",
                                        children: $
                                    }, T),
                                    y = Ar(y, T, d, null),
                                    $.return = l,
                                    y.return = l,
                                    $.sibling = y,
                                    l.child = $,
                                    y = l.child,
                                    y.memoizedState = Yc(d),
                                    y.childLanes = jc(o, z, d),
                                    l.memoizedState = _o,
                                    Gc(null, y)) : (he(l),
                                    Sf(l, $))
                                }
                                var be = o.memoizedState;
                                if (be !== null && ($ = be.dehydrated,
                                $ !== null)) {
                                    if (w)
                                        l.flags & 256 ? (he(l),
                                        l.flags &= -257,
                                        l = Ed(o, l, d)) : l.memoizedState !== null ? (ze(),
                                        l.child = o.child,
                                        l.flags |= 128,
                                        l = null) : (ze(),
                                        $ = y.fallback,
                                        T = l.mode,
                                        y = Zc({
                                            mode: "visible",
                                            children: y.children
                                        }, T),
                                        $ = Ar($, T, d, null),
                                        $.flags |= 2,
                                        y.return = l,
                                        $.return = l,
                                        y.sibling = $,
                                        l.child = y,
                                        ir(l, o.child, null, d),
                                        y = l.child,
                                        y.memoizedState = Yc(d),
                                        y.childLanes = jc(o, z, d),
                                        l.memoizedState = _o,
                                        l = Gc(null, y));
                                    else if (he(l),
                                    qf($))
                                        z = $d($).digest,
                                        y = Error(r(419)),
                                        y.stack = "",
                                        y.digest = z,
                                        Ve({
                                            value: y,
                                            source: null,
                                            stack: null
                                        }),
                                        l = Ed(o, l, d);
                                    else if (zn || xt(o, l, d, !1),
                                    z = (d & o.childLanes) !== 0,
                                    zn || z) {
                                        if (z = Ln,
                                        z !== null && (y = U(z, d),
                                        y !== 0 && y !== be.retryLane))
                                            throw be.retryLane = y,
                                            ss(o, y),
                                            di(z, o, y),
                                            vi;
                                        Xf($) || cs(),
                                        l = Ed(o, l, d)
                                    } else
                                        Xf($) ? (l.flags |= 192,
                                        l.child = o.child,
                                        l = null) : (o = be.treeContext,
                                        na && ($n = yg($),
                                        vn = l,
                                        hn = !0,
                                        Ur = null,
                                        mn = !1,
                                        o !== null && Re(l, o)),
                                        l = Sf(l, y.children),
                                        l.flags |= 4096);
                                    return l
                                }
                                return T ? (ze(),
                                $ = y.fallback,
                                T = l.mode,
                                be = o.child,
                                w = be.sibling,
                                y = fs(be, {
                                    mode: "hidden",
                                    children: y.children
                                }),
                                y.subtreeFlags = be.subtreeFlags & 65011712,
                                w !== null ? $ = fs(w, $) : ($ = Ar($, T, d, null),
                                $.flags |= 2),
                                $.return = l,
                                y.return = l,
                                y.sibling = $,
                                l.child = y,
                                Gc(null, y),
                                y = l.child,
                                $ = o.child.memoizedState,
                                $ === null ? $ = Yc(d) : (T = $.cachePool,
                                T !== null ? (be = ps ? dn._currentValue : dn._currentValue2,
                                T = T.parent !== be ? {
                                    parent: be,
                                    pool: be
                                } : T) : T = Fe(),
                                $ = {
                                    baseLanes: $.baseLanes | d,
                                    cachePool: T
                                }),
                                y.memoizedState = $,
                                y.childLanes = jc(o, z, d),
                                l.memoizedState = _o,
                                Gc(o.child, y)) : (he(l),
                                d = o.child,
                                o = d.sibling,
                                d = fs(d, {
                                    mode: "visible",
                                    children: y.children
                                }),
                                d.return = l,
                                d.sibling = null,
                                o !== null && (z = l.deletions,
                                z === null ? (l.deletions = [o],
                                l.flags |= 16) : z.push(o)),
                                l.child = d,
                                l.memoizedState = null,
                                d)
                            }
                            function Sf(o, l) {
                                return l = Zc({
                                    mode: "visible",
                                    children: l
                                }, o.mode),
                                l.return = o,
                                o.child = l
                            }
                            function Zc(o, l) {
                                return o = n(22, o, null, l),
                                o.lanes = 0,
                                o
                            }
                            function Ed(o, l, d) {
                                return ir(l, o.child, null, d),
                                o = Sf(l, l.pendingProps.children),
                                o.flags |= 2,
                                l.memoizedState = null,
                                o
                            }
                            function Fm(o, l, d) {
                                o.lanes |= l;
                                var y = o.alternate;
                                y !== null && (y.lanes |= l),
                                At(o.return, l, d)
                            }
                            function Ad(o, l, d, y, T, w) {
                                var z = o.memoizedState;
                                z === null ? o.memoizedState = {
                                    isBackwards: l,
                                    rendering: null,
                                    renderingStartTime: 0,
                                    last: y,
                                    tail: d,
                                    tailMode: T,
                                    treeForkCount: w
                                } : (z.isBackwards = l,
                                z.rendering = null,
                                z.renderingStartTime = 0,
                                z.last = y,
                                z.tail = d,
                                z.tailMode = T,
                                z.treeForkCount = w)
                            }
                            function Vm(o, l, d) {
                                var y = l.pendingProps
                                  , T = y.revealOrder
                                  , w = y.tail;
                                y = y.children;
                                var z = kn.current
                                  , $ = (z & 2) !== 0;
                                if ($ ? (z = z & 1 | 2,
                                l.flags |= 128) : z &= 1,
                                C(kn, z),
                                zi(o, l, y, d),
                                y = hn ? ul : 0,
                                !$ && o !== null && (o.flags & 128) !== 0)
                                    e: for (o = l.child; o !== null; ) {
                                        if (o.tag === 13)
                                            o.memoizedState !== null && Fm(o, d, l);
                                        else if (o.tag === 19)
                                            Fm(o, d, l);
                                        else if (o.child !== null) {
                                            o.child.return = o,
                                            o = o.child;
                                            continue
                                        }
                                        if (o === l)
                                            break e;
                                        for (; o.sibling === null; ) {
                                            if (o.return === null || o.return === l)
                                                break e;
                                            o = o.return
                                        }
                                        o.sibling.return = o.return,
                                        o = o.sibling
                                    }
                                switch (T) {
                                case "forwards":
                                    for (d = l.child,
                                    T = null; d !== null; )
                                        o = d.alternate,
                                        o !== null && mt(o) === null && (T = d),
                                        d = d.sibling;
                                    d = T,
                                    d === null ? (T = l.child,
                                    l.child = null) : (T = d.sibling,
                                    d.sibling = null),
                                    Ad(l, !1, T, d, w, y);
                                    break;
                                case "backwards":
                                case "unstable_legacy-backwards":
                                    for (d = null,
                                    T = l.child,
                                    l.child = null; T !== null; ) {
                                        if (o = T.alternate,
                                        o !== null && mt(o) === null) {
                                            l.child = T;
                                            break
                                        }
                                        o = T.sibling,
                                        T.sibling = d,
                                        d = T,
                                        T = o
                                    }
                                    Ad(l, !0, d, null, w, y);
                                    break;
                                case "together":
                                    Ad(l, !1, null, null, void 0, y);
                                    break;
                                default:
                                    l.memoizedState = null
                                }
                                return l.child
                            }
                            function Sr(o, l, d) {
                                if (o !== null && (l.dependencies = o.dependencies),
                                zs |= l.lanes,
                                (d & l.childLanes) === 0)
                                    if (o !== null) {
                                        if (xt(o, l, d, !1),
                                        (d & l.childLanes) === 0)
                                            return null
                                    } else
                                        return null;
                                if (o !== null && l.child !== o.child)
                                    throw Error(r(153));
                                if (l.child !== null) {
                                    for (o = l.child,
                                    d = fs(o, o.pendingProps),
                                    l.child = d,
                                    d.return = l; o.sibling !== null; )
                                        o = o.sibling,
                                        d = d.sibling = fs(o, o.pendingProps),
                                        d.return = l;
                                    d.sibling = null
                                }
                                return l.child
                            }
                            function fa(o, l) {
                                return (o.lanes & l) !== 0 ? !0 : (o = o.dependencies,
                                !!(o !== null && Ke(o)))
                            }
                            function Qc(o, l, d) {
                                switch (l.tag) {
                                case 3:
                                    le(l, l.stateNode.containerInfo),
                                    tt(l, dn, o.memoizedState.cache),
                                    we();
                                    break;
                                case 27:
                                case 5:
                                    Ne(l);
                                    break;
                                case 4:
                                    le(l, l.stateNode.containerInfo);
                                    break;
                                case 10:
                                    tt(l, l.type, l.memoizedProps.value);
                                    break;
                                case 31:
                                    if (l.memoizedState !== null)
                                        return l.flags |= 128,
                                        ye(l),
                                        null;
                                    break;
                                case 13:
                                    var y = l.memoizedState;
                                    if (y !== null)
                                        return y.dehydrated !== null ? (he(l),
                                        l.flags |= 128,
                                        null) : (d & l.child.childLanes) !== 0 ? Td(o, l, d) : (he(l),
                                        o = Sr(o, l, d),
                                        o !== null ? o.sibling : null);
                                    he(l);
                                    break;
                                case 19:
                                    var T = (o.flags & 128) !== 0;
                                    if (y = (d & l.childLanes) !== 0,
                                    y || (xt(o, l, d, !1),
                                    y = (d & l.childLanes) !== 0),
                                    T) {
                                        if (y)
                                            return Vm(o, l, d);
                                        l.flags |= 128
                                    }
                                    if (T = l.memoizedState,
                                    T !== null && (T.rendering = null,
                                    T.tail = null,
                                    T.lastEffect = null),
                                    C(kn, kn.current),
                                    y)
                                        break;
                                    return null;
                                case 22:
                                    return l.lanes = 0,
                                    zm(o, l, d, l.pendingProps);
                                case 24:
                                    tt(l, dn, o.memoizedState.cache)
                                }
                                return Sr(o, l, d)
                            }
                            function wd(o, l, d) {
                                if (o !== null)
                                    if (o.memoizedProps !== l.pendingProps)
                                        zn = !0;
                                    else {
                                        if (!fa(o, d) && (l.flags & 128) === 0)
                                            return zn = !1,
                                            Qc(o, l, d);
                                        zn = (o.flags & 131072) !== 0
                                    }
                                else
                                    zn = !1,
                                    hn && l.flags & 1048576 && Be(l, ul, l.index);
                                switch (l.lanes = 0,
                                l.tag) {
                                case 16:
                                    e: {
                                        var y = l.pendingProps;
                                        if (o = In(l.elementType),
                                        l.type = o,
                                        typeof o == "function")
                                            uu(o) ? (y = Ho(o, y),
                                            l.tag = 1,
                                            l = bd(null, l, o, y, d)) : (l.tag = 0,
                                            l = xd(null, l, o, y, d));
                                        else {
                                            if (o != null) {
                                                var T = o.$$typeof;
                                                if (T === pu) {
                                                    l.tag = 11,
                                                    l = yd(null, l, o, y, d);
                                                    break e
                                                } else if (T === il) {
                                                    l.tag = 14,
                                                    l = _d(null, l, o, y, d);
                                                    break e
                                                }
                                            }
                                            throw l = _(o) || o,
                                            Error(r(306, l, ""))
                                        }
                                    }
                                    return l;
                                case 0:
                                    return xd(o, l, l.type, l.pendingProps, d);
                                case 1:
                                    return y = l.type,
                                    T = Ho(y, l.pendingProps),
                                    bd(o, l, y, T, d);
                                case 3:
                                    e: {
                                        if (le(l, l.stateNode.containerInfo),
                                        o === null)
                                            throw Error(r(387));
                                        var w = l.pendingProps;
                                        T = l.memoizedState,
                                        y = T.element,
                                        Ci(o, l),
                                        Es(l, w, null, d);
                                        var z = l.memoizedState;
                                        if (w = z.cache,
                                        tt(l, dn, w),
                                        w !== T.cache && $e(l, [dn], d, !0),
                                        Qr(),
                                        w = z.element,
                                        na && T.isDehydrated)
                                            if (T = {
                                                element: w,
                                                isDehydrated: !1,
                                                cache: z.cache
                                            },
                                            l.updateQueue.baseState = T,
                                            l.memoizedState = T,
                                            l.flags & 256) {
                                                l = Md(o, l, w, d);
                                                break e
                                            } else if (w !== y) {
                                                y = Te(Error(r(424)), l),
                                                Ve(y),
                                                l = Md(o, l, w, d);
                                                break e
                                            } else
                                                for (na && ($n = np(l.stateNode.containerInfo),
                                                vn = l,
                                                hn = !0,
                                                Ur = null,
                                                mn = !0),
                                                d = mp(l, null, w, d),
                                                l.child = d; d; )
                                                    d.flags = d.flags & -3 | 4096,
                                                    d = d.sibling;
                                        else {
                                            if (we(),
                                            w === y) {
                                                l = Sr(o, l, d);
                                                break e
                                            }
                                            zi(o, l, w, d)
                                        }
                                        l = l.child
                                    }
                                    return l;
                                case 26:
                                    if (ms)
                                        return $r(o, l),
                                        o === null ? (d = lp(l.type, null, l.pendingProps, null)) ? l.memoizedState = d : hn || (l.stateNode = Dg(l.type, l.pendingProps, $s.current, l)) : l.memoizedState = lp(l.type, o.memoizedProps, l.pendingProps, o.memoizedState),
                                        null;
                                case 27:
                                    if (ri)
                                        return Ne(l),
                                        o === null && ri && hn && (y = l.stateNode = up(l.type, l.pendingProps, $s.current, Wn.current, !1),
                                        vn = l,
                                        mn = !0,
                                        $n = ip(l.type, y, $n)),
                                        zi(o, l, l.pendingProps.children, d),
                                        $r(o, l),
                                        o === null && (l.flags |= 4194304),
                                        l.child;
                                case 5:
                                    return o === null && hn && (Uy(l.type, l.pendingProps, Wn.current),
                                    (T = y = $n) && (y = _g(y, l.type, l.pendingProps, mn),
                                    y !== null ? (l.stateNode = y,
                                    vn = l,
                                    $n = Ry(y),
                                    mn = !1,
                                    T = !0) : T = !1),
                                    T || at(l)),
                                    Ne(l),
                                    T = l.type,
                                    w = l.pendingProps,
                                    z = o !== null ? o.memoizedProps : null,
                                    y = w.children,
                                    wn(T, w) ? y = null : z !== null && wn(T, z) && (l.flags |= 32),
                                    l.memoizedState !== null && (T = Ot(o, l, cn, null, null, d),
                                    ps ? ma._currentValue = T : ma._currentValue2 = T),
                                    $r(o, l),
                                    zi(o, l, y, d),
                                    l.child;
                                case 6:
                                    return o === null && hn && (jf(l.pendingProps, Wn.current),
                                    (o = d = $n) && (d = Sg(d, l.pendingProps, mn),
                                    d !== null ? (l.stateNode = d,
                                    vn = l,
                                    $n = null,
                                    o = !0) : o = !1),
                                    o || at(l)),
                                    null;
                                case 13:
                                    return Td(o, l, d);
                                case 4:
                                    return le(l, l.stateNode.containerInfo),
                                    y = l.pendingProps,
                                    o === null ? l.child = ir(l, null, y, d) : zi(o, l, y, d),
                                    l.child;
                                case 11:
                                    return yd(o, l, l.type, l.pendingProps, d);
                                case 7:
                                    return zi(o, l, l.pendingProps, d),
                                    l.child;
                                case 8:
                                    return zi(o, l, l.pendingProps.children, d),
                                    l.child;
                                case 12:
                                    return zi(o, l, l.pendingProps.children, d),
                                    l.child;
                                case 10:
                                    return y = l.pendingProps,
                                    tt(l, l.type, y.value),
                                    zi(o, l, y.children, d),
                                    l.child;
                                case 9:
                                    return T = l.type._context,
                                    y = l.pendingProps.children,
                                    wt(l),
                                    T = H(T),
                                    y = y(T),
                                    l.flags |= 1,
                                    zi(o, l, y, d),
                                    l.child;
                                case 14:
                                    return _d(o, l, l.type, l.pendingProps, d);
                                case 15:
                                    return Wo(o, l, l.type, l.pendingProps, d);
                                case 19:
                                    return Vm(o, l, d);
                                case 31:
                                    return Xc(o, l, d);
                                case 22:
                                    return zm(o, l, d, l.pendingProps);
                                case 24:
                                    return wt(l),
                                    y = H(dn),
                                    o === null ? (T = Ge(),
                                    T === null && (T = Ln,
                                    w = Ce(),
                                    T.pooledCache = w,
                                    w.refCount++,
                                    w !== null && (T.pooledCacheLanes |= d),
                                    T = w),
                                    l.memoizedState = {
                                        parent: y,
                                        cache: T
                                    },
                                    Zn(l),
                                    tt(l, dn, T)) : ((o.lanes & d) !== 0 && (Ci(o, l),
                                    Es(l, null, null, d),
                                    Qr()),
                                    T = o.memoizedState,
                                    w = l.memoizedState,
                                    T.parent !== y ? (T = {
                                        parent: y,
                                        cache: y
                                    },
                                    l.memoizedState = T,
                                    l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = T),
                                    tt(l, dn, y)) : (y = w.cache,
                                    tt(l, dn, y),
                                    y !== T.cache && $e(l, [dn], d, !0))),
                                    zi(o, l, l.pendingProps.children, d),
                                    l.child;
                                case 29:
                                    throw l.pendingProps
                                }
                                throw Error(r(156, l.tag))
                            }
                            function rs(o) {
                                o.flags |= 4
                            }
                            function Kc(o) {
                                pa && (o.flags |= 8)
                            }
                            function Cd(o, l) {
                                if (o !== null && o.child === l.child)
                                    return !1;
                                if ((l.flags & 16) !== 0)
                                    return !0;
                                for (o = l.child; o !== null; ) {
                                    if ((o.flags & 8218) !== 0 || (o.subtreeFlags & 8218) !== 0)
                                        return !0;
                                    o = o.sibling
                                }
                                return !1
                            }
                            function Jc(o, l, d, y) {
                                if (bi)
                                    for (d = l.child; d !== null; ) {
                                        if (d.tag === 5 || d.tag === 6)
                                            Ns(o, d.stateNode);
                                        else if (!(d.tag === 4 || ri && d.tag === 27) && d.child !== null) {
                                            d.child.return = d,
                                            d = d.child;
                                            continue
                                        }
                                        if (d === l)
                                            break;
                                        for (; d.sibling === null; ) {
                                            if (d.return === null || d.return === l)
                                                return;
                                            d = d.return
                                        }
                                        d.sibling.return = d.return,
                                        d = d.sibling
                                    }
                                else if (pa)
                                    for (var T = l.child; T !== null; ) {
                                        if (T.tag === 5) {
                                            var w = T.stateNode;
                                            d && y && (w = Kd(w, T.type, T.memoizedProps)),
                                            Ns(o, w)
                                        } else if (T.tag === 6)
                                            w = T.stateNode,
                                            d && y && (w = Jd(w, T.memoizedProps)),
                                            Ns(o, w);
                                        else if (T.tag !== 4) {
                                            if (T.tag === 22 && T.memoizedState !== null)
                                                w = T.child,
                                                w !== null && (w.return = T),
                                                Jc(o, T, !0, !0);
                                            else if (T.child !== null) {
                                                T.child.return = T,
                                                T = T.child;
                                                continue
                                            }
                                        }
                                        if (T === l)
                                            break;
                                        for (; T.sibling === null; ) {
                                            if (T.return === null || T.return === l)
                                                return;
                                            T = T.return
                                        }
                                        T.sibling.return = T.return,
                                        T = T.sibling
                                    }
                            }
                            function km(o, l, d, y) {
                                var T = !1;
                                if (pa)
                                    for (var w = l.child; w !== null; ) {
                                        if (w.tag === 5) {
                                            var z = w.stateNode;
                                            d && y && (z = Kd(z, w.type, w.memoizedProps)),
                                            Wf(o, z)
                                        } else if (w.tag === 6)
                                            z = w.stateNode,
                                            d && y && (z = Jd(z, w.memoizedProps)),
                                            Wf(o, z);
                                        else if (w.tag !== 4) {
                                            if (w.tag === 22 && w.memoizedState !== null)
                                                T = w.child,
                                                T !== null && (T.return = w),
                                                km(o, w, !0, !0),
                                                T = !0;
                                            else if (w.child !== null) {
                                                w.child.return = w,
                                                w = w.child;
                                                continue
                                            }
                                        }
                                        if (w === l)
                                            break;
                                        for (; w.sibling === null; ) {
                                            if (w.return === null || w.return === l)
                                                return T;
                                            w = w.return
                                        }
                                        w.sibling.return = w.return,
                                        w = w.sibling
                                    }
                                return T
                            }
                            function Xo(o, l) {
                                if (pa && Cd(o, l)) {
                                    o = l.stateNode;
                                    var d = o.containerInfo
                                      , y = Zd();
                                    km(y, l, !1, !1),
                                    o.pendingChildren = y,
                                    rs(l),
                                    Cy(d, y)
                                }
                            }
                            function $c(o, l, d, y) {
                                if (bi)
                                    o.memoizedProps !== y && rs(l);
                                else if (pa) {
                                    var T = o.stateNode
                                      , w = o.memoizedProps;
                                    if ((o = Cd(o, l)) || w !== y) {
                                        var z = Wn.current;
                                        w = Gf(T, d, w, y, !o, null),
                                        w === T ? l.stateNode = T : (Kc(l),
                                        Gt(w, d, y, z) && rs(l),
                                        l.stateNode = w,
                                        o && Jc(w, l, !1, !1))
                                    } else
                                        l.stateNode = T
                                }
                            }
                            function qo(o, l, d, y, T) {
                                if ((o.mode & 32) !== 0 && (d === null ? Hd(l, y) : Gd(l, d, y))) {
                                    if (o.flags |= 16777216,
                                    (T & 335544128) === T || ji(l, y))
                                        if (si(o.stateNode, l, y))
                                            o.flags |= 8192;
                                        else if (Fl())
                                            o.flags |= 8192;
                                        else
                                            throw go = Au,
                                            hl
                                } else
                                    o.flags &= -16777217
                            }
                            function xf(o, l) {
                                if (Lg(l)) {
                                    if (o.flags |= 16777216,
                                    !Kl(l))
                                        if (Fl())
                                            o.flags |= 8192;
                                        else
                                            throw go = Au,
                                            hl
                                } else
                                    o.flags &= -16777217
                            }
                            function eu(o, l) {
                                l !== null && (o.flags |= 4),
                                o.flags & 16384 && (l = o.tag !== 22 ? L() : 536870912,
                                o.lanes |= l,
                                pl |= l)
                            }
                            function ws(o, l) {
                                if (!hn)
                                    switch (o.tailMode) {
                                    case "hidden":
                                        l = o.tail;
                                        for (var d = null; l !== null; )
                                            l.alternate !== null && (d = l),
                                            l = l.sibling;
                                        d === null ? o.tail = null : d.sibling = null;
                                        break;
                                    case "collapsed":
                                        d = o.tail;
                                        for (var y = null; d !== null; )
                                            d.alternate !== null && (y = d),
                                            d = d.sibling;
                                        y === null ? l || o.tail === null ? o.tail = null : o.tail.sibling = null : y.sibling = null
                                    }
                            }
                            function Rn(o) {
                                var l = o.alternate !== null && o.alternate.child === o.child
                                  , d = 0
                                  , y = 0;
                                if (l)
                                    for (var T = o.child; T !== null; )
                                        d |= T.lanes | T.childLanes,
                                        y |= T.subtreeFlags & 65011712,
                                        y |= T.flags & 65011712,
                                        T.return = o,
                                        T = T.sibling;
                                else
                                    for (T = o.child; T !== null; )
                                        d |= T.lanes | T.childLanes,
                                        y |= T.subtreeFlags,
                                        y |= T.flags,
                                        T.return = o,
                                        T = T.sibling;
                                return o.subtreeFlags |= y,
                                o.childLanes = d,
                                l
                            }
                            function Rd(o, l, d) {
                                var y = l.pendingProps;
                                switch (ve(l),
                                l.tag) {
                                case 16:
                                case 15:
                                case 0:
                                case 11:
                                case 7:
                                case 8:
                                case 12:
                                case 9:
                                case 14:
                                    return Rn(l),
                                    null;
                                case 1:
                                    return Rn(l),
                                    null;
                                case 3:
                                    return d = l.stateNode,
                                    y = null,
                                    o !== null && (y = o.memoizedState.cache),
                                    l.memoizedState.cache !== y && (l.flags |= 2048),
                                    Z(dn),
                                    Ae(),
                                    d.pendingContext && (d.context = d.pendingContext,
                                    d.pendingContext = null),
                                    (o === null || o.child === null) && (Vt(l) ? rs(l) : o === null || o.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024,
                                    Ye())),
                                    Xo(o, l),
                                    Rn(l),
                                    null;
                                case 26:
                                    if (ms) {
                                        var T = l.type
                                          , w = l.memoizedState;
                                        return o === null ? (rs(l),
                                        w !== null ? (Rn(l),
                                        xf(l, w)) : (Rn(l),
                                        qo(l, T, null, y, d))) : w ? w !== o.memoizedState ? (rs(l),
                                        Rn(l),
                                        xf(l, w)) : (Rn(l),
                                        l.flags &= -16777217) : (w = o.memoizedProps,
                                        bi ? w !== y && rs(l) : $c(o, l, T, y),
                                        Rn(l),
                                        qo(l, T, w, y, d)),
                                        null
                                    }
                                case 27:
                                    if (ri) {
                                        if (ke(l),
                                        d = $s.current,
                                        T = l.type,
                                        o !== null && l.stateNode != null)
                                            bi ? o.memoizedProps !== y && rs(l) : $c(o, l, T, y);
                                        else {
                                            if (!y) {
                                                if (l.stateNode === null)
                                                    throw Error(r(166));
                                                return Rn(l),
                                                null
                                            }
                                            o = Wn.current,
                                            Vt(l) ? Je(l, o) : (o = up(T, y, d, o, !0),
                                            l.stateNode = o,
                                            rs(l))
                                        }
                                        return Rn(l),
                                        null
                                    }
                                case 5:
                                    if (ke(l),
                                    T = l.type,
                                    o !== null && l.stateNode != null)
                                        $c(o, l, T, y);
                                    else {
                                        if (!y) {
                                            if (l.stateNode === null)
                                                throw Error(r(166));
                                            return Rn(l),
                                            null
                                        }
                                        if (w = Wn.current,
                                        Vt(l))
                                            Je(l, w),
                                            rp(l.stateNode, T, y, w) && (l.flags |= 64);
                                        else {
                                            var z = zf(T, y, $s.current, w, l);
                                            Kc(l),
                                            Jc(z, l, !1, !1),
                                            l.stateNode = z,
                                            Gt(z, T, y, w) && rs(l)
                                        }
                                    }
                                    return Rn(l),
                                    qo(l, l.type, o === null ? null : o.memoizedProps, l.pendingProps, d),
                                    null;
                                case 6:
                                    if (o && l.stateNode != null)
                                        d = o.memoizedProps,
                                        bi ? d !== y && rs(l) : pa && (d !== y ? (o = $s.current,
                                        d = Wn.current,
                                        Kc(l),
                                        l.stateNode = gi(y, o, d, l)) : l.stateNode = o.stateNode);
                                    else {
                                        if (typeof y != "string" && l.stateNode === null)
                                            throw Error(r(166));
                                        if (o = $s.current,
                                        d = Wn.current,
                                        Vt(l)) {
                                            if (!na)
                                                throw Error(r(176));
                                            if (o = l.stateNode,
                                            d = l.memoizedProps,
                                            y = null,
                                            T = vn,
                                            T !== null)
                                                switch (T.tag) {
                                                case 27:
                                                case 5:
                                                    y = T.memoizedProps
                                                }
                                            vu(o, d, l, y) || at(l, !0)
                                        } else
                                            Kc(l),
                                            l.stateNode = gi(y, o, d, l)
                                    }
                                    return Rn(l),
                                    null;
                                case 31:
                                    if (d = l.memoizedState,
                                    o === null || o.memoizedState !== null) {
                                        if (y = Vt(l),
                                        d !== null) {
                                            if (o === null) {
                                                if (!y)
                                                    throw Error(r(318));
                                                if (!na)
                                                    throw Error(r(556));
                                                if (o = l.memoizedState,
                                                o = o !== null ? o.dehydrated : null,
                                                !o)
                                                    throw Error(r(557));
                                                ap(o, l)
                                            } else
                                                we(),
                                                !(l.flags & 128) && (l.memoizedState = null),
                                                l.flags |= 4;
                                            Rn(l),
                                            o = !1
                                        } else
                                            d = Ye(),
                                            o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = d),
                                            o = !0;
                                        if (!o)
                                            return l.flags & 256 ? (qe(l),
                                            l) : (qe(l),
                                            null);
                                        if ((l.flags & 128) !== 0)
                                            throw Error(r(558))
                                    }
                                    return Rn(l),
                                    null;
                                case 13:
                                    if (y = l.memoizedState,
                                    o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
                                        if (T = Vt(l),
                                        y !== null && y.dehydrated !== null) {
                                            if (o === null) {
                                                if (!T)
                                                    throw Error(r(318));
                                                if (!na)
                                                    throw Error(r(344));
                                                if (T = l.memoizedState,
                                                T = T !== null ? T.dehydrated : null,
                                                !T)
                                                    throw Error(r(317));
                                                Yf(T, l)
                                            } else
                                                we(),
                                                !(l.flags & 128) && (l.memoizedState = null),
                                                l.flags |= 4;
                                            Rn(l),
                                            T = !1
                                        } else
                                            T = Ye(),
                                            o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = T),
                                            T = !0;
                                        if (!T)
                                            return l.flags & 256 ? (qe(l),
                                            l) : (qe(l),
                                            null)
                                    }
                                    return qe(l),
                                    (l.flags & 128) !== 0 ? (l.lanes = d,
                                    l) : (d = y !== null,
                                    o = o !== null && o.memoizedState !== null,
                                    d && (y = l.child,
                                    T = null,
                                    y.alternate !== null && y.alternate.memoizedState !== null && y.alternate.memoizedState.cachePool !== null && (T = y.alternate.memoizedState.cachePool.pool),
                                    w = null,
                                    y.memoizedState !== null && y.memoizedState.cachePool !== null && (w = y.memoizedState.cachePool.pool),
                                    w !== T && (y.flags |= 2048)),
                                    d !== o && d && (l.child.flags |= 8192),
                                    eu(l, l.updateQueue),
                                    Rn(l),
                                    null);
                                case 4:
                                    return Ae(),
                                    Xo(o, l),
                                    o === null && Vd(l.stateNode.containerInfo),
                                    Rn(l),
                                    null;
                                case 10:
                                    return Z(l.type),
                                    Rn(l),
                                    null;
                                case 19:
                                    if (M(kn),
                                    y = l.memoizedState,
                                    y === null)
                                        return Rn(l),
                                        null;
                                    if (T = (l.flags & 128) !== 0,
                                    w = y.rendering,
                                    w === null)
                                        if (T)
                                            ws(y, !1);
                                        else {
                                            if (Bn !== 0 || o !== null && (o.flags & 128) !== 0)
                                                for (o = l.child; o !== null; ) {
                                                    if (w = mt(o),
                                                    w !== null) {
                                                        for (l.flags |= 128,
                                                        ws(y, !1),
                                                        o = w.updateQueue,
                                                        l.updateQueue = o,
                                                        eu(l, o),
                                                        l.subtreeFlags = 0,
                                                        o = d,
                                                        d = l.child; d !== null; )
                                                            zd(d, o),
                                                            d = d.sibling;
                                                        return C(kn, kn.current & 1 | 2),
                                                        hn && Ee(l, y.treeForkCount),
                                                        l.child
                                                    }
                                                    o = o.sibling
                                                }
                                            y.tail !== null && ia() > Tn && (l.flags |= 128,
                                            T = !0,
                                            ws(y, !1),
                                            l.lanes = 4194304)
                                        }
                                    else {
                                        if (!T)
                                            if (o = mt(w),
                                            o !== null) {
                                                if (l.flags |= 128,
                                                T = !0,
                                                o = o.updateQueue,
                                                l.updateQueue = o,
                                                eu(l, o),
                                                ws(y, !0),
                                                y.tail === null && y.tailMode === "hidden" && !w.alternate && !hn)
                                                    return Rn(l),
                                                    null
                                            } else
                                                2 * ia() - y.renderingStartTime > Tn && d !== 536870912 && (l.flags |= 128,
                                                T = !0,
                                                ws(y, !1),
                                                l.lanes = 4194304);
                                        y.isBackwards ? (w.sibling = l.child,
                                        l.child = w) : (o = y.last,
                                        o !== null ? o.sibling = w : l.child = w,
                                        y.last = w)
                                    }
                                    return y.tail !== null ? (o = y.tail,
                                    y.rendering = o,
                                    y.tail = o.sibling,
                                    y.renderingStartTime = ia(),
                                    o.sibling = null,
                                    d = kn.current,
                                    C(kn, T ? d & 1 | 2 : d & 1),
                                    hn && Ee(l, y.treeForkCount),
                                    o) : (Rn(l),
                                    null);
                                case 22:
                                case 23:
                                    return qe(l),
                                    re(),
                                    y = l.memoizedState !== null,
                                    o !== null ? o.memoizedState !== null !== y && (l.flags |= 8192) : y && (l.flags |= 8192),
                                    y ? d & 536870912 && !(l.flags & 128) && (Rn(l),
                                    l.subtreeFlags & 6 && (l.flags |= 8192)) : Rn(l),
                                    d = l.updateQueue,
                                    d !== null && eu(l, d.retryQueue),
                                    d = null,
                                    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (d = o.memoizedState.cachePool.pool),
                                    y = null,
                                    l.memoizedState !== null && l.memoizedState.cachePool !== null && (y = l.memoizedState.cachePool.pool),
                                    y !== d && (l.flags |= 2048),
                                    o !== null && M(vs),
                                    null;
                                case 24:
                                    return d = null,
                                    o !== null && (d = o.memoizedState.cache),
                                    l.memoizedState.cache !== d && (l.flags |= 2048),
                                    Z(dn),
                                    Rn(l),
                                    null;
                                case 25:
                                    return null;
                                case 30:
                                    return null
                                }
                                throw Error(r(156, l.tag))
                            }
                            function Hm(o, l) {
                                switch (ve(l),
                                l.tag) {
                                case 1:
                                    return o = l.flags,
                                    o & 65536 ? (l.flags = o & -65537 | 128,
                                    l) : null;
                                case 3:
                                    return Z(dn),
                                    Ae(),
                                    o = l.flags,
                                    (o & 65536) !== 0 && (o & 128) === 0 ? (l.flags = o & -65537 | 128,
                                    l) : null;
                                case 26:
                                case 27:
                                case 5:
                                    return ke(l),
                                    null;
                                case 31:
                                    if (l.memoizedState !== null) {
                                        if (qe(l),
                                        l.alternate === null)
                                            throw Error(r(340));
                                        we()
                                    }
                                    return o = l.flags,
                                    o & 65536 ? (l.flags = o & -65537 | 128,
                                    l) : null;
                                case 13:
                                    if (qe(l),
                                    o = l.memoizedState,
                                    o !== null && o.dehydrated !== null) {
                                        if (l.alternate === null)
                                            throw Error(r(340));
                                        we()
                                    }
                                    return o = l.flags,
                                    o & 65536 ? (l.flags = o & -65537 | 128,
                                    l) : null;
                                case 19:
                                    return M(kn),
                                    null;
                                case 4:
                                    return Ae(),
                                    null;
                                case 10:
                                    return Z(l.type),
                                    null;
                                case 22:
                                case 23:
                                    return qe(l),
                                    re(),
                                    o !== null && M(vs),
                                    o = l.flags,
                                    o & 65536 ? (l.flags = o & -65537 | 128,
                                    l) : null;
                                case 24:
                                    return Z(dn),
                                    null;
                                case 25:
                                    return null;
                                default:
                                    return null
                                }
                            }
                            function eo(o, l) {
                                switch (ve(l),
                                l.tag) {
                                case 3:
                                    Z(dn),
                                    Ae();
                                    break;
                                case 26:
                                case 27:
                                case 5:
                                    ke(l);
                                    break;
                                case 4:
                                    Ae();
                                    break;
                                case 31:
                                    l.memoizedState !== null && qe(l);
                                    break;
                                case 13:
                                    qe(l);
                                    break;
                                case 19:
                                    M(kn);
                                    break;
                                case 10:
                                    Z(l.type);
                                    break;
                                case 22:
                                case 23:
                                    qe(l),
                                    re(),
                                    o !== null && M(vs);
                                    break;
                                case 24:
                                    Z(dn)
                                }
                            }
                            function zl(o, l) {
                                try {
                                    var d = l.updateQueue
                                      , y = d !== null ? d.lastEffect : null;
                                    if (y !== null) {
                                        var T = y.next;
                                        d = T;
                                        do {
                                            if ((d.tag & o) === o) {
                                                y = void 0;
                                                var w = d.create
                                                  , z = d.inst;
                                                y = w(),
                                                z.destroy = y
                                            }
                                            d = d.next
                                        } while (d !== T)
                                    }
                                } catch ($) {
                                    gn(l, l.return, $)
                                }
                            }
                            function xr(o, l, d) {
                                try {
                                    var y = l.updateQueue
                                      , T = y !== null ? y.lastEffect : null;
                                    if (T !== null) {
                                        var w = T.next;
                                        y = w;
                                        do {
                                            if ((y.tag & o) === o) {
                                                var z = y.inst
                                                  , $ = z.destroy;
                                                if ($ !== void 0) {
                                                    z.destroy = void 0,
                                                    T = l;
                                                    var be = d
                                                      , Oe = $;
                                                    try {
                                                        Oe()
                                                    } catch (it) {
                                                        gn(T, be, it)
                                                    }
                                                }
                                            }
                                            y = y.next
                                        } while (y !== w)
                                    }
                                } catch (it) {
                                    gn(l, l.return, it)
                                }
                            }
                            function Dd(o) {
                                var l = o.updateQueue;
                                if (l !== null) {
                                    var d = o.stateNode;
                                    try {
                                        gr(l, d)
                                    } catch (y) {
                                        gn(o, o.return, y)
                                    }
                                }
                            }
                            function Gm(o, l, d) {
                                d.props = Ho(o.type, o.memoizedProps),
                                d.state = o.memoizedState;
                                try {
                                    d.componentWillUnmount()
                                } catch (y) {
                                    gn(o, l, y)
                                }
                            }
                            function tu(o, l) {
                                try {
                                    var d = o.ref;
                                    if (d !== null) {
                                        switch (o.tag) {
                                        case 26:
                                        case 27:
                                        case 5:
                                            var y = al(o.stateNode);
                                            break;
                                        case 30:
                                            y = o.stateNode;
                                            break;
                                        default:
                                            y = o.stateNode
                                        }
                                        typeof d == "function" ? o.refCleanup = d(y) : d.current = y
                                    }
                                } catch (T) {
                                    gn(o, l, T)
                                }
                            }
                            function Xs(o, l) {
                                var d = o.ref
                                  , y = o.refCleanup;
                                if (d !== null)
                                    if (typeof y == "function")
                                        try {
                                            y()
                                        } catch (T) {
                                            gn(o, l, T)
                                        } finally {
                                            o.refCleanup = null,
                                            o = o.alternate,
                                            o != null && (o.refCleanup = null)
                                        }
                                    else if (typeof d == "function")
                                        try {
                                            d(null)
                                        } catch (T) {
                                            gn(o, l, T)
                                        }
                                    else
                                        d.current = null
                            }
                            function Nd(o) {
                                var l = o.type
                                  , d = o.memoizedProps
                                  , y = o.stateNode;
                                try {
                                    og(y, l, d, o)
                                } catch (T) {
                                    gn(o, o.return, T)
                                }
                            }
                            function bf(o, l, d) {
                                try {
                                    Yd(o.stateNode, o.type, d, l, o)
                                } catch (y) {
                                    gn(o, o.return, y)
                                }
                            }
                            function Mf(o) {
                                return o.tag === 5 || o.tag === 3 || (ms ? o.tag === 26 : !1) || (ri ? o.tag === 27 && rl(o.type) : !1) || o.tag === 4
                            }
                            function Oa(o) {
                                e: for (; ; ) {
                                    for (; o.sibling === null; ) {
                                        if (o.return === null || Mf(o.return))
                                            return null;
                                        o = o.return
                                    }
                                    for (o.sibling.return = o.return,
                                    o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
                                        if (ri && o.tag === 27 && rl(o.type) || o.flags & 2 || o.child === null || o.tag === 4)
                                            continue e;
                                        o.child.return = o,
                                        o = o.child
                                    }
                                    if (!(o.flags & 2))
                                        return o.stateNode
                                }
                            }
                            function Bl(o, l, d) {
                                var y = o.tag;
                                if (y === 5 || y === 6)
                                    o = o.stateNode,
                                    l ? cg(d, o, l) : sg(d, o);
                                else if (y !== 4 && (ri && y === 27 && rl(o.type) && (d = o.stateNode,
                                l = null),
                                o = o.child,
                                o !== null))
                                    for (Bl(o, l, d),
                                    o = o.sibling; o !== null; )
                                        Bl(o, l, d),
                                        o = o.sibling
                            }
                            function ha(o, l, d) {
                                var y = o.tag;
                                if (y === 5 || y === 6)
                                    o = o.stateNode,
                                    l ? lg(d, o, l) : Ay(d, o);
                                else if (y !== 4 && (ri && y === 27 && rl(o.type) && (d = o.stateNode),
                                o = o.child,
                                o !== null))
                                    for (ha(o, l, d),
                                    o = o.sibling; o !== null; )
                                        ha(o, l, d),
                                        o = o.sibling
                            }
                            function Yo(o, l, d) {
                                o = o.containerInfo;
                                try {
                                    Qd(o, d)
                                } catch (y) {
                                    gn(l, l.return, y)
                                }
                            }
                            function Tf(o) {
                                var l = o.stateNode
                                  , d = o.memoizedProps;
                                try {
                                    Iy(o.type, d, l, o)
                                } catch (y) {
                                    gn(o, o.return, y)
                                }
                            }
                            function Ef(o, l) {
                                for (Ha(o.containerInfo),
                                li = l; li !== null; )
                                    if (o = li,
                                    l = o.child,
                                    (o.subtreeFlags & 1028) !== 0 && l !== null)
                                        l.return = o,
                                        li = l;
                                    else
                                        for (; li !== null; ) {
                                            o = li;
                                            var d = o.alternate;
                                            switch (l = o.flags,
                                            o.tag) {
                                            case 0:
                                                if ((l & 4) !== 0 && (l = o.updateQueue,
                                                l = l !== null ? l.events : null,
                                                l !== null))
                                                    for (var y = 0; y < l.length; y++) {
                                                        var T = l[y];
                                                        T.ref.impl = T.nextImpl
                                                    }
                                                break;
                                            case 11:
                                            case 15:
                                                break;
                                            case 1:
                                                if ((l & 1024) !== 0 && d !== null) {
                                                    l = void 0,
                                                    y = o,
                                                    T = d.memoizedProps,
                                                    d = d.memoizedState;
                                                    var w = y.stateNode;
                                                    try {
                                                        var z = Ho(y.type, T);
                                                        l = w.getSnapshotBeforeUpdate(z, d),
                                                        w.__reactInternalSnapshotBeforeUpdate = l
                                                    } catch ($) {
                                                        gn(y, y.return, $)
                                                    }
                                                }
                                                break;
                                            case 3:
                                                l & 1024 && bi && Hf(o.stateNode.containerInfo);
                                                break;
                                            case 5:
                                            case 26:
                                            case 27:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            default:
                                                if ((l & 1024) !== 0)
                                                    throw Error(r(163))
                                            }
                                            if (l = o.sibling,
                                            l !== null) {
                                                l.return = o.return,
                                                li = l;
                                                break
                                            }
                                            li = o.return
                                        }
                            }
                            function nu(o, l, d) {
                                var y = d.flags;
                                switch (d.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    da(o, d),
                                    y & 4 && zl(5, d);
                                    break;
                                case 1:
                                    if (da(o, d),
                                    y & 4)
                                        if (o = d.stateNode,
                                        l === null)
                                            try {
                                                o.componentDidMount()
                                            } catch (z) {
                                                gn(d, d.return, z)
                                            }
                                        else {
                                            var T = Ho(d.type, l.memoizedProps);
                                            l = l.memoizedState;
                                            try {
                                                o.componentDidUpdate(T, l, o.__reactInternalSnapshotBeforeUpdate)
                                            } catch (z) {
                                                gn(d, d.return, z)
                                            }
                                        }
                                    y & 64 && Dd(d),
                                    y & 512 && tu(d, d.return);
                                    break;
                                case 3:
                                    if (da(o, d),
                                    y & 64 && (y = d.updateQueue,
                                    y !== null)) {
                                        if (o = null,
                                        d.child !== null)
                                            switch (d.child.tag) {
                                            case 27:
                                            case 5:
                                                o = al(d.child.stateNode);
                                                break;
                                            case 1:
                                                o = d.child.stateNode
                                            }
                                        try {
                                            gr(y, o)
                                        } catch (z) {
                                            gn(d, d.return, z)
                                        }
                                    }
                                    break;
                                case 27:
                                    ri && l === null && y & 4 && Tf(d);
                                case 26:
                                case 5:
                                    if (da(o, d),
                                    l === null) {
                                        if (y & 4)
                                            Nd(d);
                                        else if (y & 64) {
                                            o = d.type,
                                            l = d.memoizedProps,
                                            T = d.stateNode;
                                            try {
                                                yu(T, o, l, d)
                                            } catch (z) {
                                                gn(d, d.return, z)
                                            }
                                        }
                                    }
                                    y & 512 && tu(d, d.return);
                                    break;
                                case 12:
                                    da(o, d);
                                    break;
                                case 31:
                                    da(o, d),
                                    y & 4 && iu(o, d);
                                    break;
                                case 13:
                                    da(o, d),
                                    y & 4 && jo(o, d),
                                    y & 64 && (y = d.memoizedState,
                                    y !== null && (y = y.dehydrated,
                                    y !== null && (d = jm.bind(null, d),
                                    pg(y, d))));
                                    break;
                                case 22:
                                    if (y = d.memoizedState !== null || Zi,
                                    !y) {
                                        l = l !== null && l.memoizedState !== null || oi,
                                        T = Zi;
                                        var w = oi;
                                        Zi = y,
                                        (oi = l) && !w ? Ys(o, d, (d.subtreeFlags & 8772) !== 0) : da(o, d),
                                        Zi = T,
                                        oi = w
                                    }
                                    break;
                                case 30:
                                    break;
                                default:
                                    da(o, d)
                                }
                            }
                            function Af(o) {
                                var l = o.alternate;
                                l !== null && (o.alternate = null,
                                Af(l)),
                                o.child = null,
                                o.deletions = null,
                                o.sibling = null,
                                o.tag === 5 && (l = o.stateNode,
                                l !== null && kd(l)),
                                o.stateNode = null,
                                o.return = null,
                                o.dependencies = null,
                                o.memoizedProps = null,
                                o.memoizedState = null,
                                o.pendingProps = null,
                                o.stateNode = null,
                                o.updateQueue = null
                            }
                            function Yi(o, l, d) {
                                for (d = d.child; d !== null; )
                                    wf(o, l, d),
                                    d = d.sibling
                            }
                            function wf(o, l, d) {
                                if (ln && typeof ln.onCommitFiberUnmount == "function")
                                    try {
                                        ln.onCommitFiberUnmount(Nr, d)
                                    } catch {}
                                switch (d.tag) {
                                case 26:
                                    if (ms) {
                                        oi || Xs(d, l),
                                        Yi(o, l, d),
                                        d.memoizedState ? Kf(d.memoizedState) : d.stateNode && cp(d.stateNode);
                                        break
                                    }
                                case 27:
                                    if (ri) {
                                        oi || Xs(d, l);
                                        var y = ci
                                          , T = qn;
                                        rl(d.type) && (ci = d.stateNode,
                                        qn = !1),
                                        Yi(o, l, d),
                                        _u(d.stateNode),
                                        ci = y,
                                        qn = T;
                                        break
                                    }
                                case 5:
                                    oi || Xs(d, l);
                                case 6:
                                    if (bi) {
                                        if (y = ci,
                                        T = qn,
                                        ci = null,
                                        Yi(o, l, d),
                                        ci = y,
                                        qn = T,
                                        ci !== null)
                                            if (qn)
                                                try {
                                                    fg(ci, d.stateNode)
                                                } catch (w) {
                                                    gn(d, l, w)
                                                }
                                            else
                                                try {
                                                    ug(ci, d.stateNode)
                                                } catch (w) {
                                                    gn(d, l, w)
                                                }
                                    } else
                                        Yi(o, l, d);
                                    break;
                                case 18:
                                    bi && ci !== null && (qn ? wg(ci, d.stateNode) : Ag(ci, d.stateNode));
                                    break;
                                case 4:
                                    bi ? (y = ci,
                                    T = qn,
                                    ci = d.stateNode.containerInfo,
                                    qn = !0,
                                    Yi(o, l, d),
                                    ci = y,
                                    qn = T) : (pa && Yo(d.stateNode, d, Zd()),
                                    Yi(o, l, d));
                                    break;
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    xr(2, d, l),
                                    oi || xr(4, d, l),
                                    Yi(o, l, d);
                                    break;
                                case 1:
                                    oi || (Xs(d, l),
                                    y = d.stateNode,
                                    typeof y.componentWillUnmount == "function" && Gm(d, l, y)),
                                    Yi(o, l, d);
                                    break;
                                case 21:
                                    Yi(o, l, d);
                                    break;
                                case 22:
                                    oi = (y = oi) || d.memoizedState !== null,
                                    Yi(o, l, d),
                                    oi = y;
                                    break;
                                default:
                                    Yi(o, l, d)
                                }
                            }
                            function iu(o, l) {
                                if (na && l.memoizedState === null && (o = l.alternate,
                                o !== null && (o = o.memoizedState,
                                o !== null))) {
                                    o = o.dehydrated;
                                    try {
                                        sp(o)
                                    } catch (d) {
                                        gn(l, l.return, d)
                                    }
                                }
                            }
                            function jo(o, l) {
                                if (na && l.memoizedState === null && (o = l.alternate,
                                o !== null && (o = o.memoizedState,
                                o !== null && (o = o.dehydrated,
                                o !== null))))
                                    try {
                                        Eg(o)
                                    } catch (d) {
                                        gn(l, l.return, d)
                                    }
                            }
                            function My(o) {
                                switch (o.tag) {
                                case 31:
                                case 13:
                                case 19:
                                    var l = o.stateNode;
                                    return l === null && (l = o.stateNode = new yp),
                                    l;
                                case 22:
                                    return o = o.stateNode,
                                    l = o._retryCache,
                                    l === null && (l = o._retryCache = new yp),
                                    l;
                                default:
                                    throw Error(r(435, o.tag))
                                }
                            }
                            function $i(o, l) {
                                var d = My(o);
                                l.forEach(function(y) {
                                    if (!d.has(y)) {
                                        d.add(y);
                                        var T = Ty.bind(null, o, y);
                                        y.then(T, T)
                                    }
                                })
                            }
                            function Bi(o, l) {
                                var d = l.deletions;
                                if (d !== null)
                                    for (var y = 0; y < d.length; y++) {
                                        var T = d[y]
                                          , w = o
                                          , z = l;
                                        if (bi) {
                                            var $ = z;
                                            e: for (; $ !== null; ) {
                                                switch ($.tag) {
                                                case 27:
                                                    if (ri) {
                                                        if (rl($.type)) {
                                                            ci = $.stateNode,
                                                            qn = !1;
                                                            break e
                                                        }
                                                        break
                                                    }
                                                case 5:
                                                    ci = $.stateNode,
                                                    qn = !1;
                                                    break e;
                                                case 3:
                                                case 4:
                                                    ci = $.stateNode.containerInfo,
                                                    qn = !0;
                                                    break e
                                                }
                                                $ = $.return
                                            }
                                            if (ci === null)
                                                throw Error(r(160));
                                            wf(w, z, T),
                                            ci = null,
                                            qn = !1
                                        } else
                                            wf(w, z, T);
                                        w = T.alternate,
                                        w !== null && (w.return = null),
                                        T.return = null
                                    }
                                if (l.subtreeFlags & 13886)
                                    for (l = l.child; l !== null; )
                                        qs(l, o),
                                        l = l.sibling
                            }
                            function qs(o, l) {
                                var d = o.alternate
                                  , y = o.flags;
                                switch (o.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Bi(l, o),
                                    ea(o),
                                    y & 4 && (xr(3, o, o.return),
                                    zl(3, o),
                                    xr(5, o, o.return));
                                    break;
                                case 1:
                                    Bi(l, o),
                                    ea(o),
                                    y & 512 && (oi || d === null || Xs(d, d.return)),
                                    y & 64 && Zi && (o = o.updateQueue,
                                    o !== null && (y = o.callbacks,
                                    y !== null && (d = o.shared.hiddenCallbacks,
                                    o.shared.hiddenCallbacks = d === null ? y : d.concat(y))));
                                    break;
                                case 26:
                                    if (ms) {
                                        var T = _s;
                                        if (Bi(l, o),
                                        ea(o),
                                        y & 512 && (oi || d === null || Xs(d, d.return)),
                                        y & 4) {
                                            y = d !== null ? d.memoizedState : null;
                                            var w = o.memoizedState;
                                            d === null ? w === null ? o.stateNode === null ? o.stateNode = Ti(T, o.type, o.memoizedProps, o) : Fi(T, o.type, o.stateNode) : o.stateNode = Rg(T, w, o.memoizedProps) : y !== w ? (y === null ? d.stateNode !== null && cp(d.stateNode) : Kf(y),
                                            w === null ? Fi(T, o.type, o.stateNode) : Rg(T, w, o.memoizedProps)) : w === null && o.stateNode !== null && bf(o, o.memoizedProps, d.memoizedProps)
                                        }
                                        break
                                    }
                                case 27:
                                    if (ri) {
                                        Bi(l, o),
                                        ea(o),
                                        y & 512 && (oi || d === null || Xs(d, d.return)),
                                        d !== null && y & 4 && bf(o, o.memoizedProps, d.memoizedProps);
                                        break
                                    }
                                case 5:
                                    if (Bi(l, o),
                                    ea(o),
                                    y & 512 && (oi || d === null || Xs(d, d.return)),
                                    bi) {
                                        if (o.flags & 32) {
                                            T = o.stateNode;
                                            try {
                                                jd(T)
                                            } catch (Qe) {
                                                gn(o, o.return, Qe)
                                            }
                                        }
                                        y & 4 && o.stateNode != null && (T = o.memoizedProps,
                                        bf(o, T, d !== null ? d.memoizedProps : T)),
                                        y & 1024 && (Cu = !0)
                                    } else
                                        pa && o.alternate !== null && (o.alternate.stateNode = o.stateNode);
                                    break;
                                case 6:
                                    if (Bi(l, o),
                                    ea(o),
                                    y & 4 && bi) {
                                        if (o.stateNode === null)
                                            throw Error(r(162));
                                        y = o.memoizedProps,
                                        d = d !== null ? d.memoizedProps : y,
                                        T = o.stateNode;
                                        try {
                                            rg(T, d, y)
                                        } catch (Qe) {
                                            gn(o, o.return, Qe)
                                        }
                                    }
                                    break;
                                case 3:
                                    if (ms ? (Ng(),
                                    T = _s,
                                    _s = Qf(l.containerInfo),
                                    Bi(l, o),
                                    _s = T) : Bi(l, o),
                                    ea(o),
                                    y & 4) {
                                        if (bi && na && d !== null && d.memoizedState.isDehydrated)
                                            try {
                                                Tg(l.containerInfo)
                                            } catch (Qe) {
                                                gn(o, o.return, Qe)
                                            }
                                        if (pa) {
                                            y = l.containerInfo,
                                            d = l.pendingChildren;
                                            try {
                                                Qd(y, d)
                                            } catch (Qe) {
                                                gn(o, o.return, Qe)
                                            }
                                        }
                                    }
                                    Cu && (Cu = !1,
                                    au(o));
                                    break;
                                case 4:
                                    ms ? (d = _s,
                                    _s = Qf(o.stateNode.containerInfo),
                                    Bi(l, o),
                                    ea(o),
                                    _s = d) : (Bi(l, o),
                                    ea(o)),
                                    y & 4 && pa && Yo(o.stateNode, o, o.stateNode.pendingChildren);
                                    break;
                                case 12:
                                    Bi(l, o),
                                    ea(o);
                                    break;
                                case 31:
                                    Bi(l, o),
                                    ea(o),
                                    y & 4 && (y = o.updateQueue,
                                    y !== null && (o.updateQueue = null,
                                    $i(o, y)));
                                    break;
                                case 13:
                                    Bi(l, o),
                                    ea(o),
                                    o.child.flags & 8192 && o.memoizedState !== null != (d !== null && d.memoizedState !== null) && (Du = ia()),
                                    y & 4 && (y = o.updateQueue,
                                    y !== null && (o.updateQueue = null,
                                    $i(o, y)));
                                    break;
                                case 22:
                                    T = o.memoizedState !== null;
                                    var z = d !== null && d.memoizedState !== null
                                      , $ = Zi
                                      , be = oi;
                                    if (Zi = $ || T,
                                    oi = be || z,
                                    Bi(l, o),
                                    oi = be,
                                    Zi = $,
                                    ea(o),
                                    y & 8192 && (l = o.stateNode,
                                    l._visibility = T ? l._visibility & -2 : l._visibility | 1,
                                    T && (d === null || z || Zi || oi || br(o)),
                                    bi)) {
                                        e: if (d = null,
                                        bi)
                                            for (l = o; ; ) {
                                                if (l.tag === 5 || ms && l.tag === 26) {
                                                    if (d === null) {
                                                        z = d = l;
                                                        try {
                                                            w = z.stateNode,
                                                            T ? wy(w) : Ql(z.stateNode, z.memoizedProps)
                                                        } catch (Qe) {
                                                            gn(z, z.return, Qe)
                                                        }
                                                    }
                                                } else if (l.tag === 6) {
                                                    if (d === null) {
                                                        z = l;
                                                        try {
                                                            var Oe = z.stateNode;
                                                            T ? hg(Oe) : dg(Oe, z.memoizedProps)
                                                        } catch (Qe) {
                                                            gn(z, z.return, Qe)
                                                        }
                                                    }
                                                } else if (l.tag === 18) {
                                                    if (d === null) {
                                                        z = l;
                                                        try {
                                                            var it = z.stateNode;
                                                            T ? sl(it) : Ly(z.stateNode)
                                                        } catch (Qe) {
                                                            gn(z, z.return, Qe)
                                                        }
                                                    }
                                                } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === o) && l.child !== null) {
                                                    l.child.return = l,
                                                    l = l.child;
                                                    continue
                                                }
                                                if (l === o)
                                                    break e;
                                                for (; l.sibling === null; ) {
                                                    if (l.return === null || l.return === o)
                                                        break e;
                                                    d === l && (d = null),
                                                    l = l.return
                                                }
                                                d === l && (d = null),
                                                l.sibling.return = l.return,
                                                l = l.sibling
                                            }
                                    }
                                    y & 4 && (y = o.updateQueue,
                                    y !== null && (d = y.retryQueue,
                                    d !== null && (y.retryQueue = null,
                                    $i(o, d))));
                                    break;
                                case 19:
                                    Bi(l, o),
                                    ea(o),
                                    y & 4 && (y = o.updateQueue,
                                    y !== null && (o.updateQueue = null,
                                    $i(o, y)));
                                    break;
                                case 30:
                                    break;
                                case 21:
                                    break;
                                default:
                                    Bi(l, o),
                                    ea(o)
                                }
                            }
                            function ea(o) {
                                var l = o.flags;
                                if (l & 2) {
                                    try {
                                        for (var d, y = o.return; y !== null; ) {
                                            if (Mf(y)) {
                                                d = y;
                                                break
                                            }
                                            y = y.return
                                        }
                                        if (bi) {
                                            if (d == null)
                                                throw Error(r(160));
                                            switch (d.tag) {
                                            case 27:
                                                if (ri) {
                                                    var T = d.stateNode;
                                                    ha(o, Oa(o), T);
                                                    break
                                                }
                                            case 5:
                                                var w = d.stateNode;
                                                d.flags & 32 && (jd(w),
                                                d.flags &= -33),
                                                ha(o, Oa(o), w);
                                                break;
                                            case 3:
                                            case 4:
                                                var z = d.stateNode.containerInfo;
                                                Bl(o, Oa(o), z);
                                                break;
                                            default:
                                                throw Error(r(161))
                                            }
                                        }
                                    } catch ($) {
                                        gn(o, o.return, $)
                                    }
                                    o.flags &= -3
                                }
                                l & 4096 && (o.flags &= -4097)
                            }
                            function au(o) {
                                if (o.subtreeFlags & 1024)
                                    for (o = o.child; o !== null; ) {
                                        var l = o;
                                        au(l),
                                        l.tag === 5 && l.flags & 1024 && kf(l.stateNode),
                                        o = o.sibling
                                    }
                            }
                            function da(o, l) {
                                if (l.subtreeFlags & 8772)
                                    for (l = l.child; l !== null; )
                                        nu(o, l.alternate, l),
                                        l = l.sibling
                            }
                            function br(o) {
                                for (o = o.child; o !== null; ) {
                                    var l = o;
                                    switch (l.tag) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        xr(4, l, l.return),
                                        br(l);
                                        break;
                                    case 1:
                                        Xs(l, l.return);
                                        var d = l.stateNode;
                                        typeof d.componentWillUnmount == "function" && Gm(l, l.return, d),
                                        br(l);
                                        break;
                                    case 27:
                                        ri && _u(l.stateNode);
                                    case 26:
                                    case 5:
                                        Xs(l, l.return),
                                        br(l);
                                        break;
                                    case 22:
                                        l.memoizedState === null && br(l);
                                        break;
                                    case 30:
                                        br(l);
                                        break;
                                    default:
                                        br(l)
                                    }
                                    o = o.sibling
                                }
                            }
                            function Ys(o, l, d) {
                                for (d = d && (l.subtreeFlags & 8772) !== 0,
                                l = l.child; l !== null; ) {
                                    var y = l.alternate
                                      , T = o
                                      , w = l
                                      , z = w.flags;
                                    switch (w.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ys(T, w, d),
                                        zl(4, w);
                                        break;
                                    case 1:
                                        if (Ys(T, w, d),
                                        y = w,
                                        T = y.stateNode,
                                        typeof T.componentDidMount == "function")
                                            try {
                                                T.componentDidMount()
                                            } catch (Oe) {
                                                gn(y, y.return, Oe)
                                            }
                                        if (y = w,
                                        T = y.updateQueue,
                                        T !== null) {
                                            var $ = y.stateNode;
                                            try {
                                                var be = T.shared.hiddenCallbacks;
                                                if (be !== null)
                                                    for (T.shared.hiddenCallbacks = null,
                                                    T = 0; T < be.length; T++)
                                                        Dl(be[T], $)
                                            } catch (Oe) {
                                                gn(y, y.return, Oe)
                                            }
                                        }
                                        d && z & 64 && Dd(w),
                                        tu(w, w.return);
                                        break;
                                    case 27:
                                        ri && Tf(w);
                                    case 26:
                                    case 5:
                                        Ys(T, w, d),
                                        d && y === null && z & 4 && Nd(w),
                                        tu(w, w.return);
                                        break;
                                    case 12:
                                        Ys(T, w, d);
                                        break;
                                    case 31:
                                        Ys(T, w, d),
                                        d && z & 4 && iu(T, w);
                                        break;
                                    case 13:
                                        Ys(T, w, d),
                                        d && z & 4 && jo(T, w);
                                        break;
                                    case 22:
                                        w.memoizedState === null && Ys(T, w, d),
                                        tu(w, w.return);
                                        break;
                                    case 30:
                                        break;
                                    default:
                                        Ys(T, w, d)
                                    }
                                    l = l.sibling
                                }
                            }
                            function su(o, l) {
                                var d = null;
                                o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (d = o.memoizedState.cachePool.pool),
                                o = null,
                                l.memoizedState !== null && l.memoizedState.cachePool !== null && (o = l.memoizedState.cachePool.pool),
                                o !== d && (o != null && o.refCount++,
                                d != null && Ue(d))
                            }
                            function Cf(o, l) {
                                o = null,
                                l.alternate !== null && (o = l.alternate.memoizedState.cache),
                                l = l.memoizedState.cache,
                                l !== o && (l.refCount++,
                                o != null && Ue(o))
                            }
                            function ii(o, l, d, y) {
                                if (l.subtreeFlags & 10256)
                                    for (l = l.child; l !== null; )
                                        Zo(o, l, d, y),
                                        l = l.sibling
                            }
                            function Zo(o, l, d, y) {
                                var T = l.flags;
                                switch (l.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ii(o, l, d, y),
                                    T & 2048 && zl(9, l);
                                    break;
                                case 1:
                                    ii(o, l, d, y);
                                    break;
                                case 3:
                                    ii(o, l, d, y),
                                    T & 2048 && (o = null,
                                    l.alternate !== null && (o = l.alternate.memoizedState.cache),
                                    l = l.memoizedState.cache,
                                    l !== o && (l.refCount++,
                                    o != null && Ue(o)));
                                    break;
                                case 12:
                                    if (T & 2048) {
                                        ii(o, l, d, y),
                                        o = l.stateNode;
                                        try {
                                            var w = l.memoizedProps
                                              , z = w.id
                                              , $ = w.onPostCommit;
                                            typeof $ == "function" && $(z, l.alternate === null ? "mount" : "update", o.passiveEffectDuration, -0)
                                        } catch (be) {
                                            gn(l, l.return, be)
                                        }
                                    } else
                                        ii(o, l, d, y);
                                    break;
                                case 31:
                                    ii(o, l, d, y);
                                    break;
                                case 13:
                                    ii(o, l, d, y);
                                    break;
                                case 23:
                                    break;
                                case 22:
                                    w = l.stateNode,
                                    z = l.alternate,
                                    l.memoizedState !== null ? w._visibility & 2 ? ii(o, l, d, y) : to(o, l) : w._visibility & 2 ? ii(o, l, d, y) : (w._visibility |= 2,
                                    Cs(o, l, d, y, (l.subtreeFlags & 10256) !== 0 || !1)),
                                    T & 2048 && su(z, l);
                                    break;
                                case 24:
                                    ii(o, l, d, y),
                                    T & 2048 && Cf(l.alternate, l);
                                    break;
                                default:
                                    ii(o, l, d, y)
                                }
                            }
                            function Cs(o, l, d, y, T) {
                                for (T = T && ((l.subtreeFlags & 10256) !== 0 || !1),
                                l = l.child; l !== null; ) {
                                    var w = o
                                      , z = l
                                      , $ = d
                                      , be = y
                                      , Oe = z.flags;
                                    switch (z.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Cs(w, z, $, be, T),
                                        zl(8, z);
                                        break;
                                    case 23:
                                        break;
                                    case 22:
                                        var it = z.stateNode;
                                        z.memoizedState !== null ? it._visibility & 2 ? Cs(w, z, $, be, T) : to(w, z) : (it._visibility |= 2,
                                        Cs(w, z, $, be, T)),
                                        T && Oe & 2048 && su(z.alternate, z);
                                        break;
                                    case 24:
                                        Cs(w, z, $, be, T),
                                        T && Oe & 2048 && Cf(z.alternate, z);
                                        break;
                                    default:
                                        Cs(w, z, $, be, T)
                                    }
                                    l = l.sibling
                                }
                            }
                            function to(o, l) {
                                if (l.subtreeFlags & 10256)
                                    for (l = l.child; l !== null; ) {
                                        var d = o
                                          , y = l
                                          , T = y.flags;
                                        switch (y.tag) {
                                        case 22:
                                            to(d, y),
                                            T & 2048 && su(y.alternate, y);
                                            break;
                                        case 24:
                                            to(d, y),
                                            T & 2048 && Cf(y.alternate, y);
                                            break;
                                        default:
                                            to(d, y)
                                        }
                                        l = l.sibling
                                    }
                            }
                            function Rs(o, l, d) {
                                if (o.subtreeFlags & Ii)
                                    for (o = o.child; o !== null; )
                                        Pa(o, l, d),
                                        o = o.sibling
                            }
                            function Pa(o, l, d) {
                                switch (o.tag) {
                                case 26:
                                    if (Rs(o, l, d),
                                    o.flags & Ii)
                                        if (o.memoizedState !== null)
                                            Ug(d, _s, o.memoizedState, o.memoizedProps);
                                        else {
                                            var y = o.stateNode
                                              , T = o.type;
                                            o = o.memoizedProps,
                                            ((l & 335544128) === l || ji(T, o)) && Yl(d, y, T, o)
                                        }
                                    break;
                                case 5:
                                    Rs(o, l, d),
                                    o.flags & Ii && (y = o.stateNode,
                                    T = o.type,
                                    o = o.memoizedProps,
                                    ((l & 335544128) === l || ji(T, o)) && Yl(d, y, T, o));
                                    break;
                                case 3:
                                case 4:
                                    ms ? (y = _s,
                                    _s = Qf(o.stateNode.containerInfo),
                                    Rs(o, l, d),
                                    _s = y) : Rs(o, l, d);
                                    break;
                                case 22:
                                    o.memoizedState === null && (y = o.alternate,
                                    y !== null && y.memoizedState !== null ? (y = Ii,
                                    Ii = 16777216,
                                    Rs(o, l, d),
                                    Ii = y) : Rs(o, l, d));
                                    break;
                                default:
                                    Rs(o, l, d)
                                }
                            }
                            function za(o) {
                                var l = o.alternate;
                                if (l !== null && (o = l.child,
                                o !== null)) {
                                    l.child = null;
                                    do
                                        l = o.sibling,
                                        o.sibling = null,
                                        o = l;
                                    while (o !== null)
                                }
                            }
                            function os(o) {
                                var l = o.deletions;
                                if ((o.flags & 16) !== 0) {
                                    if (l !== null)
                                        for (var d = 0; d < l.length; d++) {
                                            var y = l[d];
                                            li = y,
                                            js(y, o)
                                        }
                                    za(o)
                                }
                                if (o.subtreeFlags & 10256)
                                    for (o = o.child; o !== null; )
                                        Ds(o),
                                        o = o.sibling
                            }
                            function Ds(o) {
                                switch (o.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    os(o),
                                    o.flags & 2048 && xr(9, o, o.return);
                                    break;
                                case 3:
                                    os(o);
                                    break;
                                case 12:
                                    os(o);
                                    break;
                                case 22:
                                    var l = o.stateNode;
                                    o.memoizedState !== null && l._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (l._visibility &= -3,
                                    Ba(o)) : os(o);
                                    break;
                                default:
                                    os(o)
                                }
                            }
                            function Ba(o) {
                                var l = o.deletions;
                                if ((o.flags & 16) !== 0) {
                                    if (l !== null)
                                        for (var d = 0; d < l.length; d++) {
                                            var y = l[d];
                                            li = y,
                                            js(y, o)
                                        }
                                    za(o)
                                }
                                for (o = o.child; o !== null; ) {
                                    switch (l = o,
                                    l.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        xr(8, l, l.return),
                                        Ba(l);
                                        break;
                                    case 22:
                                        d = l.stateNode,
                                        d._visibility & 2 && (d._visibility &= -3,
                                        Ba(l));
                                        break;
                                    default:
                                        Ba(l)
                                    }
                                    o = o.sibling
                                }
                            }
                            function js(o, l) {
                                for (; li !== null; ) {
                                    var d = li;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        xr(8, d, l);
                                        break;
                                    case 23:
                                    case 22:
                                        if (d.memoizedState !== null && d.memoizedState.cachePool !== null) {
                                            var y = d.memoizedState.cachePool.pool;
                                            y != null && y.refCount++
                                        }
                                        break;
                                    case 24:
                                        Ue(d.memoizedState.cache)
                                    }
                                    if (y = d.child,
                                    y !== null)
                                        y.return = d,
                                        li = y;
                                    else
                                        e: for (d = o; li !== null; ) {
                                            y = li;
                                            var T = y.sibling
                                              , w = y.return;
                                            if (Af(y),
                                            y === d) {
                                                li = null;
                                                break e
                                            }
                                            if (T !== null) {
                                                T.return = w,
                                                li = T;
                                                break e
                                            }
                                            li = w
                                        }
                                }
                            }
                            function Rf(o) {
                                var l = ai(o);
                                if (l != null) {
                                    if (typeof l.memoizedProps["data-testname"] != "string")
                                        throw Error(r(364));
                                    return l
                                }
                                if (o = eg(o),
                                o === null)
                                    throw Error(r(362));
                                return o.stateNode.current
                            }
                            function ru(o, l) {
                                var d = o.tag;
                                switch (l.$$typeof) {
                                case Ru:
                                    if (o.type === l.value)
                                        return !0;
                                    break;
                                case ih:
                                    e: {
                                        for (l = l.value,
                                        o = [o, 0],
                                        d = 0; d < o.length; ) {
                                            var y = o[d++]
                                              , T = y.tag
                                              , w = o[d++]
                                              , z = l[w];
                                            if (T !== 5 && T !== 26 && T !== 27 || !Zl(y)) {
                                                for (; z != null && ru(y, z); )
                                                    w++,
                                                    z = l[w];
                                                if (w === l.length) {
                                                    l = !0;
                                                    break e
                                                } else
                                                    for (y = y.child; y !== null; )
                                                        o.push(y, w),
                                                        y = y.sibling
                                            }
                                        }
                                        l = !1
                                    }
                                    return l;
                                case Ps:
                                    if ((d === 5 || d === 26 || d === 27) && ig(o.stateNode, l.value))
                                        return !0;
                                    break;
                                case ic:
                                    if ((d === 5 || d === 6 || d === 26 || d === 27) && (o = ng(o),
                                    o !== null && 0 <= o.indexOf(l.value)))
                                        return !0;
                                    break;
                                case dl:
                                    if ((d === 5 || d === 26 || d === 27) && (o = o.memoizedProps["data-testname"],
                                    typeof o == "string" && o.toLowerCase() === l.value.toLowerCase()))
                                        return !0;
                                    break;
                                default:
                                    throw Error(r(365))
                                }
                                return !1
                            }
                            function ou(o) {
                                switch (o.$$typeof) {
                                case Ru:
                                    return "<" + (_(o.value) || "Unknown") + ">";
                                case ih:
                                    return ":has(" + (ou(o) || "") + ")";
                                case Ps:
                                    return '[role="' + o.value + '"]';
                                case ic:
                                    return '"' + o.value + '"';
                                case dl:
                                    return '[data-testname="' + o.value + '"]';
                                default:
                                    throw Error(r(365))
                                }
                            }
                            function Ld(o, l) {
                                var d = [];
                                o = [o, 0];
                                for (var y = 0; y < o.length; ) {
                                    var T = o[y++]
                                      , w = T.tag
                                      , z = o[y++]
                                      , $ = l[z];
                                    if (w !== 5 && w !== 26 && w !== 27 || !Zl(T)) {
                                        for (; $ != null && ru(T, $); )
                                            z++,
                                            $ = l[z];
                                        if (z === l.length)
                                            d.push(T);
                                        else
                                            for (T = T.child; T !== null; )
                                                o.push(T, z),
                                                T = T.sibling
                                    }
                                }
                                return d
                            }
                            function Ni(o, l) {
                                if (!jl)
                                    throw Error(r(363));
                                o = Rf(o),
                                o = Ld(o, l),
                                l = [],
                                o = Array.from(o);
                                for (var d = 0; d < o.length; ) {
                                    var y = o[d++]
                                      , T = y.tag;
                                    if (T === 5 || T === 26 || T === 27)
                                        Zl(y) || l.push(y.stateNode);
                                    else
                                        for (y = y.child; y !== null; )
                                            o.push(y),
                                            y = y.sibling
                                }
                                return l
                            }
                            function on() {
                                return (sn & 2) !== 0 && Jt !== 0 ? Jt & -Jt : Dt.T !== null ? et() : $m()
                            }
                            function fn() {
                                if (Ea === 0)
                                    if ((Jt & 536870912) === 0 || hn) {
                                        var o = ll;
                                        ll <<= 1,
                                        !(ll & 3932160) && (ll = 262144),
                                        Ea = o
                                    } else
                                        Ea = 536870912;
                                return o = Xn.current,
                                o !== null && (o.flags |= 32),
                                Ea
                            }
                            function di(o, l, d) {
                                (o === Ln && (Cn === 2 || Cn === 9) || o.cancelPendingCommit !== null) && (ls(o, 0),
                                Mr(o, Jt, Ea, !1)),
                                B(o, d),
                                (!(sn & 2) || o !== Ln) && (o === Ln && (!(sn & 2) && (xo |= d),
                                Bn === 4 && Mr(o, Jt, Ea, !1)),
                                st(o))
                            }
                            function Fa(o, l, d) {
                                if ((sn & 6) !== 0)
                                    throw Error(r(327));
                                var y = !d && (l & 127) === 0 && (l & o.expiredLanes) === 0 || N(o, l)
                                  , T = y ? Id(o, l) : Zs(o, l, !0)
                                  , w = y;
                                do {
                                    if (T === 0) {
                                        ac && !y && Mr(o, l, 0, !1);
                                        break
                                    } else {
                                        if (d = o.current.alternate,
                                        w && !no(d)) {
                                            T = Zs(o, l, !1),
                                            w = !1;
                                            continue
                                        }
                                        if (T === 2) {
                                            if (w = l,
                                            o.errorRecoveryDisabledLanes & w)
                                                var z = 0;
                                            else
                                                z = o.pendingLanes & -536870913,
                                                z = z !== 0 ? z : z & 536870912 ? 536870912 : 0;
                                            if (z !== 0) {
                                                l = z;
                                                e: {
                                                    var $ = o;
                                                    T = sc;
                                                    var be = na && $.current.memoizedState.isDehydrated;
                                                    if (be && (ls($, z).flags |= 256),
                                                    z = Zs($, z, !1),
                                                    z !== 2) {
                                                        if (ah && !be) {
                                                            $.errorRecoveryDisabledLanes |= w,
                                                            xo |= w,
                                                            T = 4;
                                                            break e
                                                        }
                                                        w = ya,
                                                        ya = T,
                                                        w !== null && (ya === null ? ya = w : ya.push.apply(ya, w))
                                                    }
                                                    T = z
                                                }
                                                if (w = !1,
                                                T !== 2)
                                                    continue
                                            }
                                        }
                                        if (T === 1) {
                                            ls(o, 0),
                                            Mr(o, l, 0, !0);
                                            break
                                        }
                                        e: {
                                            switch (y = o,
                                            w = T,
                                            w) {
                                            case 0:
                                            case 1:
                                                throw Error(r(345));
                                            case 4:
                                                if ((l & 4194048) !== l)
                                                    break;
                                            case 6:
                                                Mr(y, l, Ea, !So);
                                                break e;
                                            case 2:
                                                ya = null;
                                                break;
                                            case 3:
                                            case 5:
                                                break;
                                            default:
                                                throw Error(r(329))
                                            }
                                            if ((l & 62914560) === l && (T = Du + 300 - ia(),
                                            10 < T)) {
                                                if (Mr(y, l, Ea, !So),
                                                E(y, 0, !0) !== 0)
                                                    break e;
                                                zr = l,
                                                y.timeoutHandle = Bf(Df.bind(null, y, d, ya, oc, rc, l, Ea, xo, pl, So, w, "Throttled", -0, 0), T);
                                                break e
                                            }
                                            Df(y, d, ya, oc, rc, l, Ea, xo, pl, So, w, null, -0, 0)
                                        }
                                    }
                                    break
                                } while (!0);
                                st(o)
                            }
                            function Df(o, l, d, y, T, w, z, $, be, Oe, it, Qe, gt, Ht) {
                                if (o.timeoutHandle = Ga,
                                Qe = l.subtreeFlags,
                                Qe & 8192 || (Qe & 16785408) === 16785408) {
                                    Qe = Ff(),
                                    Pa(l, w, Qe);
                                    var ui = (w & 62914560) === w ? Du - ia() : (w & 4194048) === w ? _p - ia() : 0;
                                    if (ui = Vf(Qe, ui),
                                    ui !== null) {
                                        zr = w,
                                        o.cancelPendingCommit = ui(Pd.bind(null, o, l, w, d, y, T, z, $, be, it, Qe, null, gt, Ht)),
                                        Mr(o, w, z, !Oe);
                                        return
                                    }
                                }
                                Pd(o, l, w, d, y, T, z, $, be)
                            }
                            function no(o) {
                                for (var l = o; ; ) {
                                    var d = l.tag;
                                    if ((d === 0 || d === 11 || d === 15) && l.flags & 16384 && (d = l.updateQueue,
                                    d !== null && (d = d.stores,
                                    d !== null)))
                                        for (var y = 0; y < d.length; y++) {
                                            var T = d[y]
                                              , w = T.getSnapshot;
                                            T = T.value;
                                            try {
                                                if (!Wa(w(), T))
                                                    return !1
                                            } catch {
                                                return !1
                                            }
                                        }
                                    if (d = l.child,
                                    l.subtreeFlags & 16384 && d !== null)
                                        d.return = l,
                                        l = d;
                                    else {
                                        if (l === o)
                                            break;
                                        for (; l.sibling === null; ) {
                                            if (l.return === null || l.return === o)
                                                return !0;
                                            l = l.return
                                        }
                                        l.sibling.return = l.return,
                                        l = l.sibling
                                    }
                                }
                                return !0
                            }
                            function Mr(o, l, d, y) {
                                l &= ~sh,
                                l &= ~xo,
                                o.suspendedLanes |= l,
                                o.pingedLanes &= ~l,
                                y && (o.warmLanes |= l),
                                y = o.expirationTimes;
                                for (var T = l; 0 < T; ) {
                                    var w = 31 - ga(T)
                                      , z = 1 << w;
                                    y[w] = -1,
                                    T &= ~z
                                }
                                d !== 0 && G(o, d, l)
                            }
                            function Ud() {
                                return (sn & 6) === 0 ? (je(0, !1),
                                !1) : !0
                            }
                            function io() {
                                if (rn !== null) {
                                    if (Cn === 0)
                                        var o = rn.return;
                                    else
                                        o = rn,
                                        er = po = null,
                                        un(o),
                                        nr = null,
                                        ec = 0,
                                        o = rn;
                                    for (; o !== null; )
                                        eo(o.alternate, o),
                                        o = o.return;
                                    rn = null
                                }
                            }
                            function ls(o, l) {
                                var d = o.timeoutHandle;
                                d !== Ga && (o.timeoutHandle = Ga,
                                ql(d)),
                                d = o.cancelPendingCommit,
                                d !== null && (o.cancelPendingCommit = null,
                                d()),
                                zr = 0,
                                io(),
                                Ln = o,
                                rn = d = fs(o.current, null),
                                Jt = l,
                                Cn = 0,
                                Za = null,
                                So = !1,
                                ac = N(o, l),
                                ah = !1,
                                pl = Ea = sh = xo = zs = Bn = 0,
                                ya = sc = null,
                                rc = !1,
                                l & 8 && (l |= l & 32);
                                var y = o.entangledLanes;
                                if (y !== 0)
                                    for (o = o.entanglements,
                                    y &= l; 0 < y; ) {
                                        var T = 31 - ga(y)
                                          , w = 1 << T;
                                        l |= o[T],
                                        y &= ~w
                                    }
                                return or = l,
                                Yr(),
                                d
                            }
                            function Nf(o, l) {
                                Ut = null,
                                Dt.H = yo,
                                l === tr || l === Ir ? (l = xn(),
                                Cn = 3) : l === hl ? (l = xn(),
                                Cn = 4) : Cn = l === vi ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1,
                                Za = l,
                                rn === null && (Bn = 1,
                                yf(o, Te(l, o.current)))
                            }
                            function Fl() {
                                var o = Xn.current;
                                return o === null ? !0 : (Jt & 4194048) === Jt ? Vi === null : (Jt & 62914560) === Jt || (Jt & 536870912) !== 0 ? o === Vi : !1
                            }
                            function Lf() {
                                var o = Dt.H;
                                return Dt.H = yo,
                                o === null ? yo : o
                            }
                            function ao() {
                                var o = Dt.A;
                                return Dt.A = Hg,
                                o
                            }
                            function cs() {
                                Bn = 4,
                                So || (Jt & 4194048) !== Jt && Xn.current !== null || (ac = !0),
                                !(zs & 134217727) && !(xo & 134217727) || Ln === null || Mr(Ln, Jt, Ea, !1)
                            }
                            function Zs(o, l, d) {
                                var y = sn;
                                sn |= 2;
                                var T = Lf()
                                  , w = ao();
                                (Ln !== o || Jt !== l) && (oc = null,
                                ls(o, l)),
                                l = !1;
                                var z = Bn;
                                e: do
                                    try {
                                        if (Cn !== 0 && rn !== null) {
                                            var $ = rn
                                              , be = Za;
                                            switch (Cn) {
                                            case 8:
                                                io(),
                                                z = 6;
                                                break e;
                                            case 3:
                                            case 2:
                                            case 9:
                                            case 6:
                                                Xn.current === null && (l = !0);
                                                var Oe = Cn;
                                                if (Cn = 0,
                                                Za = null,
                                                us(o, $, be, Oe),
                                                d && ac) {
                                                    z = 0;
                                                    break e
                                                }
                                                break;
                                            default:
                                                Oe = Cn,
                                                Cn = 0,
                                                Za = null,
                                                us(o, $, be, Oe)
                                            }
                                        }
                                        Tr(),
                                        z = Bn;
                                        break
                                    } catch (it) {
                                        Nf(o, it)
                                    }
                                while (!0);
                                return l && o.shellSuspendCounter++,
                                er = po = null,
                                sn = y,
                                Dt.H = T,
                                Dt.A = w,
                                rn === null && (Ln = null,
                                Jt = 0,
                                Yr()),
                                z
                            }
                            function Tr() {
                                for (; rn !== null; )
                                    Qo(rn)
                            }
                            function Id(o, l) {
                                var d = sn;
                                sn |= 2;
                                var y = Lf()
                                  , T = ao();
                                Ln !== o || Jt !== l ? (oc = null,
                                Tn = ia() + 500,
                                ls(o, l)) : ac = N(o, l);
                                e: do
                                    try {
                                        if (Cn !== 0 && rn !== null) {
                                            l = rn;
                                            var w = Za;
                                            t: switch (Cn) {
                                            case 1:
                                                Cn = 0,
                                                Za = null,
                                                us(o, l, w, 1);
                                                break;
                                            case 2:
                                            case 9:
                                                if (pt(w)) {
                                                    Cn = 0,
                                                    Za = null,
                                                    lu(l);
                                                    break
                                                }
                                                l = function() {
                                                    Cn !== 2 && Cn !== 9 || Ln !== o || (Cn = 7),
                                                    st(o)
                                                }
                                                ,
                                                w.then(l, l);
                                                break e;
                                            case 3:
                                                Cn = 7;
                                                break e;
                                            case 4:
                                                Cn = 5;
                                                break e;
                                            case 7:
                                                pt(w) ? (Cn = 0,
                                                Za = null,
                                                lu(l)) : (Cn = 0,
                                                Za = null,
                                                us(o, l, w, 7));
                                                break;
                                            case 5:
                                                var z = null;
                                                switch (rn.tag) {
                                                case 26:
                                                    z = rn.memoizedState;
                                                case 5:
                                                case 27:
                                                    var $ = rn
                                                      , be = $.type
                                                      , Oe = $.pendingProps;
                                                    if (z ? Kl(z) : si($.stateNode, be, Oe)) {
                                                        Cn = 0,
                                                        Za = null;
                                                        var it = $.sibling;
                                                        if (it !== null)
                                                            rn = it;
                                                        else {
                                                            var Qe = $.return;
                                                            Qe !== null ? (rn = Qe,
                                                            xi(Qe)) : rn = null
                                                        }
                                                        break t
                                                    }
                                                }
                                                Cn = 0,
                                                Za = null,
                                                us(o, l, w, 5);
                                                break;
                                            case 6:
                                                Cn = 0,
                                                Za = null,
                                                us(o, l, w, 6);
                                                break;
                                            case 8:
                                                io(),
                                                Bn = 6;
                                                break e;
                                            default:
                                                throw Error(r(462))
                                            }
                                        }
                                        Od();
                                        break
                                    } catch (gt) {
                                        Nf(o, gt)
                                    }
                                while (!0);
                                return er = po = null,
                                Dt.H = y,
                                Dt.A = T,
                                sn = d,
                                rn !== null ? 0 : (Ln = null,
                                Jt = 0,
                                Yr(),
                                Bn)
                            }
                            function Od() {
                                for (; rn !== null && !Og(); )
                                    Qo(rn)
                            }
                            function Qo(o) {
                                var l = wd(o.alternate, o, or);
                                o.memoizedProps = o.pendingProps,
                                l === null ? xi(o) : rn = l
                            }
                            function lu(o) {
                                var l = o
                                  , d = l.alternate;
                                switch (l.tag) {
                                case 15:
                                case 0:
                                    l = qc(d, l, l.pendingProps, l.type, void 0, Jt);
                                    break;
                                case 11:
                                    l = qc(d, l, l.pendingProps, l.type.render, l.ref, Jt);
                                    break;
                                case 5:
                                    un(l);
                                default:
                                    eo(d, l),
                                    l = rn = zd(l, or),
                                    l = wd(d, l, or)
                                }
                                o.memoizedProps = o.pendingProps,
                                l === null ? xi(o) : rn = l
                            }
                            function us(o, l, d, y) {
                                er = po = null,
                                un(l),
                                nr = null,
                                ec = 0;
                                var T = l.return;
                                try {
                                    if (Pm(o, T, l, d, Jt)) {
                                        Bn = 1,
                                        yf(o, Te(d, o.current)),
                                        rn = null;
                                        return
                                    }
                                } catch (w) {
                                    if (T !== null)
                                        throw rn = T,
                                        w;
                                    Bn = 1,
                                    yf(o, Te(d, o.current)),
                                    rn = null;
                                    return
                                }
                                l.flags & 32768 ? (hn || y === 1 ? o = !0 : ac || (Jt & 536870912) !== 0 ? o = !1 : (So = o = !0,
                                (y === 2 || y === 9 || y === 3 || y === 6) && (y = Xn.current,
                                y !== null && y.tag === 13 && (y.flags |= 16384))),
                                cu(l, o)) : xi(l)
                            }
                            function xi(o) {
                                var l = o;
                                do {
                                    if ((l.flags & 32768) !== 0) {
                                        cu(l, So);
                                        return
                                    }
                                    o = l.return;
                                    var d = Rd(l.alternate, l, or);
                                    if (d !== null) {
                                        rn = d;
                                        return
                                    }
                                    if (l = l.sibling,
                                    l !== null) {
                                        rn = l;
                                        return
                                    }
                                    rn = l = o
                                } while (l !== null);
                                Bn === 0 && (Bn = 5)
                            }
                            function cu(o, l) {
                                do {
                                    var d = Hm(o.alternate, o);
                                    if (d !== null) {
                                        d.flags &= 32767,
                                        rn = d;
                                        return
                                    }
                                    if (d = o.return,
                                    d !== null && (d.flags |= 32768,
                                    d.subtreeFlags = 0,
                                    d.deletions = null),
                                    !l && (o = o.sibling,
                                    o !== null)) {
                                        rn = o;
                                        return
                                    }
                                    rn = o = d
                                } while (o !== null);
                                Bn = 6,
                                rn = null
                            }
                            function Pd(o, l, d, y, T, w, z, $, be) {
                                o.cancelPendingCommit = null;
                                do
                                    Ko();
                                while (Ei !== 0);
                                if ((sn & 6) !== 0)
                                    throw Error(r(327));
                                if (l !== null) {
                                    if (l === o.current)
                                        throw Error(r(177));
                                    if (w = l.lanes | l.childLanes,
                                    w |= Mn,
                                    X(o, d, w, z, $, be),
                                    o === Ln && (rn = Ln = null,
                                    Jt = 0),
                                    lc = l,
                                    Mo = o,
                                    zr = d,
                                    cc = w,
                                    To = T,
                                    rh = y,
                                    (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (o.callbackNode = null,
                                    o.callbackPriority = 0,
                                    Zm(Ls, function() {
                                        return Vl(),
                                        null
                                    })) : (o.callbackNode = null,
                                    o.callbackPriority = 0),
                                    y = (l.flags & 13878) !== 0,
                                    (l.subtreeFlags & 13878) !== 0 || y) {
                                        y = Dt.T,
                                        Dt.T = null,
                                        T = Qs(),
                                        Mi(2),
                                        z = sn,
                                        sn |= 4;
                                        try {
                                            Ef(o, l, d)
                                        } finally {
                                            sn = z,
                                            Mi(T),
                                            Dt.T = y
                                        }
                                    }
                                    Ei = 1,
                                    Wm(),
                                    Xm(),
                                    qm()
                                }
                            }
                            function Wm() {
                                if (Ei === 1) {
                                    Ei = 0;
                                    var o = Mo
                                      , l = lc
                                      , d = (l.flags & 13878) !== 0;
                                    if ((l.subtreeFlags & 13878) !== 0 || d) {
                                        d = Dt.T,
                                        Dt.T = null;
                                        var y = Qs();
                                        Mi(2);
                                        var T = sn;
                                        sn |= 4;
                                        try {
                                            qs(l, o),
                                            mi(o.containerInfo)
                                        } finally {
                                            sn = T,
                                            Mi(y),
                                            Dt.T = d
                                        }
                                    }
                                    o.current = l,
                                    Ei = 2
                                }
                            }
                            function Xm() {
                                if (Ei === 2) {
                                    Ei = 0;
                                    var o = Mo
                                      , l = lc
                                      , d = (l.flags & 8772) !== 0;
                                    if ((l.subtreeFlags & 8772) !== 0 || d) {
                                        d = Dt.T,
                                        Dt.T = null;
                                        var y = Qs();
                                        Mi(2);
                                        var T = sn;
                                        sn |= 4;
                                        try {
                                            nu(o, l.alternate, l)
                                        } finally {
                                            sn = T,
                                            Mi(y),
                                            Dt.T = d
                                        }
                                    }
                                    Ei = 3
                                }
                            }
                            function qm() {
                                if (Ei === 4 || Ei === 3) {
                                    Ei = 0,
                                    Dr();
                                    var o = Mo
                                      , l = lc
                                      , d = zr
                                      , y = rh;
                                    (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? Ei = 5 : (Ei = 0,
                                    lc = Mo = null,
                                    pi(o, o.pendingLanes));
                                    var T = o.pendingLanes;
                                    if (T === 0 && (bo = null),
                                    K(d),
                                    l = l.stateNode,
                                    ln && typeof ln.onCommitFiberRoot == "function")
                                        try {
                                            ln.onCommitFiberRoot(Nr, l, void 0, (l.current.flags & 128) === 128)
                                        } catch {}
                                    if (y !== null) {
                                        l = Dt.T,
                                        T = Qs(),
                                        Mi(2),
                                        Dt.T = null;
                                        try {
                                            for (var w = o.onRecoverableError, z = 0; z < y.length; z++) {
                                                var $ = y[z];
                                                w($.value, {
                                                    componentStack: $.stack
                                                })
                                            }
                                        } finally {
                                            Dt.T = l,
                                            Mi(T)
                                        }
                                    }
                                    zr & 3 && Ko(),
                                    st(o),
                                    T = o.pendingLanes,
                                    (d & 261930) !== 0 && (T & 42) !== 0 ? o === Nu ? Eo++ : (Eo = 0,
                                    Nu = o) : Eo = 0,
                                    na && op(),
                                    je(0, !1)
                                }
                            }
                            function pi(o, l) {
                                (o.pooledCacheLanes &= l) === 0 && (l = o.pooledCache,
                                l != null && (o.pooledCache = null,
                                Ue(l)))
                            }
                            function Ko() {
                                return Wm(),
                                Xm(),
                                qm(),
                                Vl()
                            }
                            function Vl() {
                                if (Ei !== 5)
                                    return !1;
                                var o = Mo
                                  , l = cc;
                                cc = 0;
                                var d = K(zr)
                                  , y = 32 > d ? 32 : d;
                                d = Dt.T;
                                var T = Qs();
                                try {
                                    Mi(y),
                                    Dt.T = null,
                                    y = To,
                                    To = null;
                                    var w = Mo
                                      , z = zr;
                                    if (Ei = 0,
                                    lc = Mo = null,
                                    zr = 0,
                                    (sn & 6) !== 0)
                                        throw Error(r(331));
                                    var $ = sn;
                                    if (sn |= 4,
                                    Ds(w.current),
                                    Zo(w, w.current, z, y),
                                    sn = $,
                                    je(0, !1),
                                    ln && typeof ln.onPostCommitFiberRoot == "function")
                                        try {
                                            ln.onPostCommitFiberRoot(Nr, w)
                                        } catch {}
                                    return !0
                                } finally {
                                    Mi(T),
                                    Dt.T = d,
                                    pi(o, l)
                                }
                            }
                            function kl(o, l, d) {
                                l = Te(d, l),
                                l = Go(o.stateNode, l, 2),
                                o = Ia(o, l, 2),
                                o !== null && (B(o, 2),
                                st(o))
                            }
                            function gn(o, l, d) {
                                if (o.tag === 3)
                                    kl(o, o, d);
                                else
                                    for (; l !== null; ) {
                                        if (l.tag === 3) {
                                            kl(l, o, d);
                                            break
                                        } else if (l.tag === 1) {
                                            var y = l.stateNode;
                                            if (typeof l.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (bo === null || !bo.has(y))) {
                                                o = Te(d, o),
                                                d = Om(2),
                                                y = Ia(l, d, 2),
                                                y !== null && (vd(d, y, l, o),
                                                B(y, 2),
                                                st(y));
                                                break
                                            }
                                        }
                                        l = l.return
                                    }
                            }
                            function so(o, l, d) {
                                var y = o.pingCache;
                                if (y === null) {
                                    y = o.pingCache = new Gg;
                                    var T = new Set;
                                    y.set(l, T)
                                } else
                                    T = y.get(l),
                                    T === void 0 && (T = new Set,
                                    y.set(l, T));
                                T.has(d) || (ah = !0,
                                T.add(d),
                                o = Hl.bind(null, o, l, d),
                                l.then(o, o))
                            }
                            function Hl(o, l, d) {
                                var y = o.pingCache;
                                y !== null && y.delete(l),
                                o.pingedLanes |= o.suspendedLanes & d,
                                o.warmLanes &= ~d,
                                Ln === o && (Jt & d) === d && (Bn === 4 || Bn === 3 && (Jt & 62914560) === Jt && 300 > ia() - Du ? !(sn & 2) && ls(o, 0) : sh |= d,
                                pl === Jt && (pl = 0)),
                                st(o)
                            }
                            function Ym(o, l) {
                                l === 0 && (l = L()),
                                o = ss(o, l),
                                o !== null && (B(o, l),
                                st(o))
                            }
                            function jm(o) {
                                var l = o.memoizedState
                                  , d = 0;
                                l !== null && (d = l.retryLane),
                                Ym(o, d)
                            }
                            function Ty(o, l) {
                                var d = 0;
                                switch (o.tag) {
                                case 31:
                                case 13:
                                    var y = o.stateNode
                                      , T = o.memoizedState;
                                    T !== null && (d = T.retryLane);
                                    break;
                                case 19:
                                    y = o.stateNode;
                                    break;
                                case 22:
                                    y = o.stateNode._retryCache;
                                    break;
                                default:
                                    throw Error(r(314))
                                }
                                y !== null && y.delete(l),
                                Ym(o, d)
                            }
                            function Zm(o, l) {
                                return Su(o, l)
                            }
                            function Jo(o, l, d, y) {
                                this.tag = o,
                                this.key = d,
                                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                                this.index = 0,
                                this.refCleanup = this.ref = null,
                                this.pendingProps = l,
                                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                                this.mode = y,
                                this.subtreeFlags = this.flags = 0,
                                this.deletions = null,
                                this.childLanes = this.lanes = 0,
                                this.alternate = null
                            }
                            function uu(o) {
                                return o = o.prototype,
                                !(!o || !o.isReactComponent)
                            }
                            function fs(o, l) {
                                var d = o.alternate;
                                return d === null ? (d = n(o.tag, l, o.key, o.mode),
                                d.elementType = o.elementType,
                                d.type = o.type,
                                d.stateNode = o.stateNode,
                                d.alternate = o,
                                o.alternate = d) : (d.pendingProps = l,
                                d.type = o.type,
                                d.flags = 0,
                                d.subtreeFlags = 0,
                                d.deletions = null),
                                d.flags = o.flags & 65011712,
                                d.childLanes = o.childLanes,
                                d.lanes = o.lanes,
                                d.child = o.child,
                                d.memoizedProps = o.memoizedProps,
                                d.memoizedState = o.memoizedState,
                                d.updateQueue = o.updateQueue,
                                l = o.dependencies,
                                d.dependencies = l === null ? null : {
                                    lanes: l.lanes,
                                    firstContext: l.firstContext
                                },
                                d.sibling = o.sibling,
                                d.index = o.index,
                                d.ref = o.ref,
                                d.refCleanup = o.refCleanup,
                                d
                            }
                            function zd(o, l) {
                                o.flags &= 65011714;
                                var d = o.alternate;
                                return d === null ? (o.childLanes = 0,
                                o.lanes = l,
                                o.child = null,
                                o.subtreeFlags = 0,
                                o.memoizedProps = null,
                                o.memoizedState = null,
                                o.updateQueue = null,
                                o.dependencies = null,
                                o.stateNode = null) : (o.childLanes = d.childLanes,
                                o.lanes = d.lanes,
                                o.child = d.child,
                                o.subtreeFlags = 0,
                                o.deletions = null,
                                o.memoizedProps = d.memoizedProps,
                                o.memoizedState = d.memoizedState,
                                o.updateQueue = d.updateQueue,
                                o.type = d.type,
                                l = d.dependencies,
                                o.dependencies = l === null ? null : {
                                    lanes: l.lanes,
                                    firstContext: l.firstContext
                                }),
                                o
                            }
                            function Er(o, l, d, y, T, w) {
                                var z = 0;
                                if (y = o,
                                typeof o == "function")
                                    uu(o) && (z = 1);
                                else if (typeof o == "string")
                                    z = ms && ri ? Zf(o, d, Wn.current) ? 26 : Jf(o) ? 27 : 5 : ms ? Zf(o, d, Wn.current) ? 26 : 5 : ri && Jf(o) ? 27 : 5;
                                else
                                    e: switch (o) {
                                    case Pf:
                                        return o = n(31, d, l, T),
                                        o.elementType = Pf,
                                        o.lanes = w,
                                        o;
                                    case lo:
                                        return Ar(d.children, T, w, l);
                                    case Of:
                                        z = 8,
                                        T |= 24;
                                        break;
                                    case wr:
                                        return o = n(12, d, l, T | 2),
                                        o.elementType = wr,
                                        o.lanes = w,
                                        o;
                                    case mu:
                                        return o = n(13, d, l, T),
                                        o.elementType = mu,
                                        o.lanes = w,
                                        o;
                                    case nl:
                                        return o = n(19, d, l, T),
                                        o.elementType = nl,
                                        o.lanes = w,
                                        o;
                                    default:
                                        if (typeof o == "object" && o !== null)
                                            switch (o.$$typeof) {
                                            case hs:
                                                z = 10;
                                                break e;
                                            case co:
                                                z = 9;
                                                break e;
                                            case pu:
                                                z = 11;
                                                break e;
                                            case il:
                                                z = 14;
                                                break e;
                                            case Cr:
                                                z = 16,
                                                y = null;
                                                break e
                                            }
                                        z = 29,
                                        d = Error(r(130, o === null ? "null" : typeof o, "")),
                                        y = null
                                    }
                                return l = n(z, d, l, T),
                                l.elementType = o,
                                l.type = y,
                                l.lanes = w,
                                l
                            }
                            function Ar(o, l, d, y) {
                                return o = n(7, o, y, l),
                                o.lanes = d,
                                o
                            }
                            function Gl(o, l, d) {
                                return o = n(6, o, null, l),
                                o.lanes = d,
                                o
                            }
                            function fu(o) {
                                var l = n(18, null, null, 0);
                                return l.stateNode = o,
                                l
                            }
                            function Uf(o, l, d) {
                                return l = n(4, o.children !== null ? o.children : [], o.key, l),
                                l.lanes = d,
                                l.stateNode = {
                                    containerInfo: o.containerInfo,
                                    pendingChildren: null,
                                    implementation: o.implementation
                                },
                                l
                            }
                            function Qm(o, l, d, y, T, w, z, $, be) {
                                this.tag = 1,
                                this.containerInfo = o,
                                this.pingCache = this.current = this.pendingChildren = null,
                                this.timeoutHandle = Ga,
                                this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                                this.callbackPriority = 0,
                                this.expirationTimes = k(-1),
                                this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                                this.entanglements = k(0),
                                this.hiddenUpdates = k(null),
                                this.identifierPrefix = y,
                                this.onUncaughtError = T,
                                this.onCaughtError = w,
                                this.onRecoverableError = z,
                                this.pooledCache = null,
                                this.pooledCacheLanes = 0,
                                this.formState = be,
                                this.incompleteTransitions = new Map
                            }
                            function ro(o, l, d, y, T, w, z, $, be, Oe, it, Qe) {
                                return o = new Qm(o,l,d,z,be,Oe,it,Qe,$),
                                l = 1,
                                w === !0 && (l |= 24),
                                w = n(3, null, null, l),
                                o.current = w,
                                w.stateNode = o,
                                l = Ce(),
                                l.refCount++,
                                o.pooledCache = l,
                                l.refCount++,
                                w.memoizedState = {
                                    element: y,
                                    isDehydrated: d,
                                    cache: l
                                },
                                Zn(w),
                                o
                            }
                            function oo(o) {
                                return o ? (o = ho,
                                o) : ho
                            }
                            function Bd(o) {
                                var l = o._reactInternals;
                                if (l === void 0)
                                    throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","),
                                    Error(r(268, o)));
                                return o = p(l),
                                o = o !== null ? m(o) : null,
                                o === null ? null : al(o.stateNode)
                            }
                            function Fd(o, l, d, y, T, w) {
                                T = oo(T),
                                y.context === null ? y.context = T : y.pendingContext = T,
                                y = Wi(l),
                                y.payload = {
                                    element: d
                                },
                                w = w === void 0 ? null : w,
                                w !== null && (y.callback = w),
                                d = Ia(o, y, l),
                                d !== null && (di(d, o, l),
                                Zr(d, o, l))
                            }
                            function $o(o, l) {
                                if (o = o.memoizedState,
                                o !== null && o.dehydrated !== null) {
                                    var d = o.retryLane;
                                    o.retryLane = d !== 0 && d < l ? d : l
                                }
                            }
                            function el(o, l) {
                                $o(o, l),
                                (o = o.alternate) && $o(o, l)
                            }
                            var jt = {}
                              , hu = lt.default
                              , ta = ix.default
                              , If = Object.assign
                              , tl = Symbol.for("react.element")
                              , du = Symbol.for("react.transitional.element")
                              , Va = Symbol.for("react.portal")
                              , lo = Symbol.for("react.fragment")
                              , Of = Symbol.for("react.strict_mode")
                              , wr = Symbol.for("react.profiler")
                              , co = Symbol.for("react.consumer")
                              , hs = Symbol.for("react.context")
                              , pu = Symbol.for("react.forward_ref")
                              , mu = Symbol.for("react.suspense")
                              , nl = Symbol.for("react.suspense_list")
                              , il = Symbol.for("react.memo")
                              , Cr = Symbol.for("react.lazy")
                              , Pf = Symbol.for("react.activity")
                              , Wl = Symbol.for("react.memo_cache_sentinel")
                              , gu = Symbol.iterator
                              , Km = Symbol.for("react.client.reference")
                              , Xl = Array.isArray
                              , Dt = hu.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
                              , ka = t.rendererVersion
                              , ds = t.rendererPackageName
                              , Rr = t.extraDevToolsConfig
                              , al = t.getPublicInstance
                              , Jm = t.getRootHostContext
                              , uo = t.getChildHostContext
                              , Ha = t.prepareForCommit
                              , mi = t.resetAfterCommit
                              , zf = t.createInstance;
                            t.cloneMutableInstance;
                            var Ns = t.appendInitialChild
                              , Gt = t.finalizeInitialChildren
                              , wn = t.shouldSetTextContent
                              , gi = t.createTextInstance;
                            t.cloneMutableTextInstance;
                            var Bf = t.scheduleTimeout
                              , ql = t.cancelTimeout
                              , Ga = t.noTimeout
                              , ps = t.isPrimaryRenderer;
                            t.warnsIfNotActing;
                            var bi = t.supportsMutation
                              , pa = t.supportsPersistence
                              , na = t.supportsHydration
                              , ai = t.getInstanceFromNode;
                            t.beforeActiveInstanceBlur;
                            var Vd = t.preparePortalMount;
                            t.prepareScopeUpdate,
                            t.getInstanceFromScope;
                            var Mi = t.setCurrentUpdatePriority
                              , Qs = t.getCurrentUpdatePriority
                              , $m = t.resolveUpdatePriority;
                            t.trackSchedulerEvent,
                            t.resolveEventType,
                            t.resolveEventTimeStamp;
                            var Ey = t.shouldAttemptEagerTransition
                              , kd = t.detachDeletedInstance;
                            t.requestPostPaintCallback;
                            var Hd = t.maySuspendCommit
                              , Gd = t.maySuspendCommitOnUpdate
                              , ji = t.maySuspendCommitInSyncRender
                              , si = t.preloadInstance
                              , Ff = t.startSuspendingCommit
                              , Yl = t.suspendInstance;
                            t.suspendOnActiveViewTransition;
                            var Vf = t.waitForCommitToBeReady;
                            t.getSuspendedCommitReason;
                            var fo = t.NotPendingTransition
                              , ma = t.HostTransitionContext
                              , kf = t.resetFormInstance;
                            t.bindToConsole;
                            var Wd = t.supportsMicrotasks
                              , Xd = t.scheduleMicrotask
                              , jl = t.supportsTestSelectors
                              , eg = t.findFiberRoot
                              , tg = t.getBoundingRect
                              , ng = t.getTextContent
                              , Zl = t.isHiddenSubtree
                              , ig = t.matchAccessibilityRole
                              , qd = t.setFocusIfFocusable
                              , ag = t.setupIntersectionObserver
                              , Ay = t.appendChild
                              , sg = t.appendChildToContainer
                              , rg = t.commitTextUpdate
                              , og = t.commitMount
                              , Yd = t.commitUpdate
                              , lg = t.insertBefore
                              , cg = t.insertInContainerBefore
                              , ug = t.removeChild
                              , fg = t.removeChildFromContainer
                              , jd = t.resetTextContent
                              , wy = t.hideInstance
                              , hg = t.hideTextInstance
                              , Ql = t.unhideInstance
                              , dg = t.unhideTextInstance;
                            t.cancelViewTransitionName,
                            t.cancelRootViewTransitionName,
                            t.restoreRootViewTransitionName,
                            t.cloneRootViewTransitionContainer,
                            t.removeRootViewTransitionClone,
                            t.measureClonedInstance,
                            t.hasInstanceChanged,
                            t.hasInstanceAffectedParent,
                            t.startViewTransition,
                            t.startGestureTransition,
                            t.stopViewTransition,
                            t.getCurrentGestureOffset,
                            t.createViewTransitionInstance;
                            var Hf = t.clearContainer;
                            t.createFragmentInstance,
                            t.updateFragmentInstanceFiber,
                            t.commitNewChildToFragmentInstance,
                            t.deleteChildFromFragmentInstance;
                            var Gf = t.cloneInstance
                              , Zd = t.createContainerChildSet
                              , Wf = t.appendChildToContainerChildSet
                              , Cy = t.finalizeContainerChildren
                              , Qd = t.replaceContainerChildren
                              , Kd = t.cloneHiddenInstance
                              , Jd = t.cloneHiddenTextInstance
                              , Xf = t.isSuspenseInstancePending
                              , qf = t.isSuspenseInstanceFallback
                              , $d = t.getSuspenseInstanceFallbackErrorDetails
                              , pg = t.registerSuspenseInstanceRetry
                              , mg = t.canHydrateFormStateMarker
                              , ep = t.isFormStateMarkerMatching
                              , tp = t.getNextHydratableSibling
                              , gg = t.getNextHydratableSiblingAfterSingleton
                              , Ry = t.getFirstHydratableChild
                              , np = t.getFirstHydratableChildWithinContainer
                              , vg = t.getFirstHydratableChildWithinActivityInstance
                              , yg = t.getFirstHydratableChildWithinSuspenseInstance
                              , ip = t.getFirstHydratableChildWithinSingleton
                              , _g = t.canHydrateInstance
                              , Sg = t.canHydrateTextInstance
                              , Dy = t.canHydrateActivityInstance
                              , Ny = t.canHydrateSuspenseInstance
                              , xg = t.hydrateInstance
                              , vu = t.hydrateTextInstance
                              , ap = t.hydrateActivityInstance
                              , Yf = t.hydrateSuspenseInstance
                              , bg = t.getNextHydratableInstanceAfterActivityInstance
                              , Mg = t.getNextHydratableInstanceAfterSuspenseInstance
                              , yu = t.commitHydratedInstance
                              , Tg = t.commitHydratedContainer
                              , sp = t.commitHydratedActivityInstance
                              , Eg = t.commitHydratedSuspenseInstance
                              , rp = t.finalizeHydratedChildren
                              , op = t.flushHydrationEvents;
                            t.clearActivityBoundary;
                            var Ag = t.clearSuspenseBoundary;
                            t.clearActivityBoundaryFromContainer;
                            var wg = t.clearSuspenseBoundaryFromContainer
                              , sl = t.hideDehydratedBoundary
                              , Ly = t.unhideDehydratedBoundary
                              , Cg = t.shouldDeleteUnhydratedTailInstances;
                            t.diffHydratedPropsForDevWarnings,
                            t.diffHydratedTextForDevWarnings,
                            t.describeHydratableInstanceForDevWarnings;
                            var Uy = t.validateHydratableInstance, jf = t.validateHydratableTextInstance, ms = t.supportsResources, Zf = t.isHostHoistableType, Qf = t.getHoistableRoot, lp = t.getResource, Rg = t.acquireResource, Kf = t.releaseResource, Ti = t.hydrateHoistable, Fi = t.mountHoistable, cp = t.unmountHoistable, Dg = t.createHoistableInstance, Ng = t.prepareToCommitHoistables, Lg = t.mayResourceSuspendCommit, Kl = t.preloadResource, Ug = t.suspendResource, ri = t.supportsSingletons, up = t.resolveSingletonInstance, Iy = t.acquireSingletonInstance, _u = t.releaseSingletonInstance, Jf = t.isHostSingletonType, rl = t.isSingletonScope, $f = [], ol = -1, ho = {}, ga = Math.clz32 ? Math.clz32 : R, fp = Math.log, Ig = Math.LN2, Jl = 256, ll = 262144, $l = 4194304, Su = ta.unstable_scheduleCallback, xu = ta.unstable_cancelCallback, Og = ta.unstable_shouldYield, Dr = ta.unstable_requestPaint, ia = ta.unstable_now, Pg = ta.unstable_ImmediatePriority, zg = ta.unstable_UserBlockingPriority, Ls = ta.unstable_NormalPriority, hp = ta.unstable_IdlePriority, Bg = ta.log, eh = ta.unstable_setDisableYieldValue, Nr = null, ln = null, Wa = typeof Object.is == "function" ? Object.is : te, Fg = typeof reportError == "function" ? reportError : function(o) {
                                if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                                    var l = new window.ErrorEvent("error",{
                                        bubbles: !0,
                                        cancelable: !0,
                                        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
                                        error: o
                                    });
                                    if (!window.dispatchEvent(l))
                                        return
                                } else if (typeof process == "object" && typeof process.emit == "function") {
                                    process.emit("uncaughtException", o);
                                    return
                                }
                                console.error(o)
                            }
                            , Vg = Object.prototype.hasOwnProperty, cl, Lr, th = !1, dp = new WeakMap, Ks = [], va = 0, bu = null, ul = 0, Xa = [], Ma = 0, Js = null, qa = 1, Us = "", Wn = x(null), Qn = x(null), $s = x(null), Mu = x(null), vn = null, $n = null, hn = !1, Ur = null, mn = !1, aa = Error(r(519)), gs = x(null), po = null, er = null, kg = typeof AbortController < "u" ? AbortController : function() {
                                var o = []
                                  , l = this.signal = {
                                    aborted: !1,
                                    addEventListener: function(d, y) {
                                        o.push(y)
                                    }
                                };
                                this.abort = function() {
                                    l.aborted = !0,
                                    o.forEach(function(d) {
                                        return d()
                                    })
                                }
                            }
                            , Oy = ta.unstable_scheduleCallback, nh = ta.unstable_NormalPriority, dn = {
                                $$typeof: hs,
                                Consumer: null,
                                Provider: null,
                                _currentValue: null,
                                _currentValue2: null,
                                _threadCount: 0
                            }, Ta = null, fl = null, sa = !1, Tu = !1, Is = !1, Ya = 0, ja = null, Eu = 0, mo = 0, ra = null, pp = Dt.S;
                            Dt.S = function(o, l) {
                                _p = ia(),
                                typeof l == "object" && l !== null && typeof l.then == "function" && qt(o, l),
                                pp !== null && pp(o, l)
                            }
                            ;
                            var vs = x(null)
                              , tr = Error(r(460))
                              , hl = Error(r(474))
                              , Ir = Error(r(542))
                              , Au = {
                                then: function() {}
                            }
                              , go = null
                              , nr = null
                              , ec = 0
                              , ir = zc(!0)
                              , mp = zc(!1)
                              , ys = []
                              , tc = 0
                              , Mn = 0
                              , yn = !1
                              , Kt = !1
                              , Yt = x(null)
                              , En = x(0)
                              , Xn = x(null)
                              , Vi = null
                              , kn = x(0)
                              , Os = 0
                              , Ut = null
                              , Pt = null
                              , Pn = null
                              , ar = !1
                              , vo = !1
                              , Li = !1
                              , Or = 0
                              , Pr = 0
                              , Ui = null
                              , gp = 0
                              , yo = {
                                readContext: H,
                                use: ni,
                                useCallback: Ze,
                                useContext: Ze,
                                useEffect: Ze,
                                useImperativeHandle: Ze,
                                useLayoutEffect: Ze,
                                useInsertionEffect: Ze,
                                useMemo: Ze,
                                useReducer: Ze,
                                useRef: Ze,
                                useState: Ze,
                                useDebugValue: Ze,
                                useDeferredValue: Ze,
                                useTransition: Ze,
                                useSyncExternalStore: Ze,
                                useId: Ze,
                                useHostTransitionStatus: Ze,
                                useFormState: Ze,
                                useActionState: Ze,
                                useOptimistic: Ze,
                                useMemoCache: Ze,
                                useCacheRefresh: Ze
                            };
                            yo.useEffectEvent = Ze;
                            var vp = {
                                readContext: H,
                                use: ni,
                                useCallback: function(o, l) {
                                    return ut().memoizedState = [o, l === void 0 ? null : l],
                                    o
                                },
                                useContext: H,
                                useEffect: ud,
                                useImperativeHandle: function(o, l, d) {
                                    d = d != null ? d.concat([o]) : null,
                                    Ul(4194308, 4, Fc.bind(null, l, o), d)
                                },
                                useLayoutEffect: function(o, l) {
                                    return Ul(4194308, 4, o, l)
                                },
                                useInsertionEffect: function(o, l) {
                                    Ul(4, 2, o, l)
                                },
                                useMemo: function(o, l) {
                                    var d = ut();
                                    l = l === void 0 ? null : l;
                                    var y = o();
                                    if (Li) {
                                        q(!0);
                                        try {
                                            o()
                                        } finally {
                                            q(!1)
                                        }
                                    }
                                    return d.memoizedState = [y, l],
                                    y
                                },
                                useReducer: function(o, l, d) {
                                    var y = ut();
                                    if (d !== void 0) {
                                        var T = d(l);
                                        if (Li) {
                                            q(!0);
                                            try {
                                                d(l)
                                            } finally {
                                                q(!1)
                                            }
                                        }
                                    } else
                                        T = l;
                                    return y.memoizedState = y.baseState = T,
                                    o = {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: o,
                                        lastRenderedState: T
                                    },
                                    y.queue = o,
                                    o = o.dispatch = by.bind(null, Ut, o),
                                    [y.memoizedState, o]
                                },
                                useRef: function(o) {
                                    var l = ut();
                                    return o = {
                                        current: o
                                    },
                                    l.memoizedState = o
                                },
                                useState: function(o) {
                                    o = od(o);
                                    var l = o.queue
                                      , d = Nm.bind(null, Ut, l);
                                    return l.dispatch = d,
                                    [o.memoizedState, d]
                                },
                                useDebugValue: hd,
                                useDeferredValue: function(o, l) {
                                    return ko(ut(), o, l)
                                },
                                useTransition: function() {
                                    var o = od(!1);
                                    return o = dd.bind(null, Ut, o.queue, !0, !1),
                                    ut().memoizedState = o,
                                    [!1, o]
                                },
                                useSyncExternalStore: function(o, l, d) {
                                    var y = Ut
                                      , T = ut();
                                    if (hn) {
                                        if (d === void 0)
                                            throw Error(r(407));
                                        d = d()
                                    } else {
                                        if (d = l(),
                                        Ln === null)
                                            throw Error(r(349));
                                        Jt & 127 || Di(y, l, d)
                                    }
                                    T.memoizedState = d;
                                    var w = {
                                        value: d,
                                        getSnapshot: l
                                    };
                                    return T.queue = w,
                                    ud(As.bind(null, y, w, o), [o]),
                                    y.flags |= 2048,
                                    Ws(9, {
                                        destroy: void 0
                                    }, Nl.bind(null, y, w, d, l), null),
                                    d
                                },
                                useId: function() {
                                    var o = ut()
                                      , l = Ln.identifierPrefix;
                                    if (hn) {
                                        var d = Us
                                          , y = qa;
                                        d = (y & ~(1 << 32 - ga(y) - 1)).toString(32) + d,
                                        l = "_" + l + "R_" + d,
                                        d = Or++,
                                        0 < d && (l += "H" + d.toString(32)),
                                        l += "_"
                                    } else
                                        d = gp++,
                                        l = "_" + l + "r_" + d.toString(32) + "_";
                                    return o.memoizedState = l
                                },
                                useHostTransitionStatus: kc,
                                useFormState: df,
                                useActionState: df,
                                useOptimistic: function(o) {
                                    var l = ut();
                                    l.memoizedState = l.baseState = o;
                                    var d = {
                                        pending: null,
                                        lanes: 0,
                                        dispatch: null,
                                        lastRenderedReducer: null,
                                        lastRenderedState: null
                                    };
                                    return l.queue = d,
                                    l = pd.bind(null, Ut, !0, d),
                                    d.dispatch = l,
                                    [o, l]
                                },
                                useMemoCache: Ri,
                                useCacheRefresh: function() {
                                    return ut().memoizedState = Dm.bind(null, Ut)
                                },
                                useEffectEvent: function(o) {
                                    var l = ut()
                                      , d = {
                                        impl: o
                                    };
                                    return l.memoizedState = d,
                                    function() {
                                        if ((sn & 2) !== 0)
                                            throw Error(r(440));
                                        return d.impl.apply(void 0, arguments)
                                    }
                                }
                            }
                              , nc = {
                                readContext: H,
                                use: ni,
                                useCallback: gf,
                                useContext: H,
                                useEffect: Il,
                                useImperativeHandle: Ol,
                                useInsertionEffect: ua,
                                useLayoutEffect: Jr,
                                useMemo: vf,
                                useReducer: bn,
                                useRef: _r,
                                useState: function() {
                                    return bn(Ji)
                                },
                                useDebugValue: hd,
                                useDeferredValue: function(o, l) {
                                    return Vc(kt(), Pt.memoizedState, o, l)
                                },
                                useTransition: function() {
                                    var o = bn(Ji)[0]
                                      , l = kt().memoizedState;
                                    return [typeof o == "boolean" ? o : Xi(o), l]
                                },
                                useSyncExternalStore: hi,
                                useId: Cm,
                                useHostTransitionStatus: kc,
                                useFormState: cd,
                                useActionState: cd,
                                useOptimistic: function(o, l) {
                                    return Am(kt(), Pt, o, l)
                                },
                                useMemoCache: Ri,
                                useCacheRefresh: Rm
                            };
                            nc.useEffectEvent = fd;
                            var wu = {
                                readContext: H,
                                use: ni,
                                useCallback: gf,
                                useContext: H,
                                useEffect: Il,
                                useImperativeHandle: Ol,
                                useInsertionEffect: ua,
                                useLayoutEffect: Jr,
                                useMemo: vf,
                                useReducer: qi,
                                useRef: _r,
                                useState: function() {
                                    return qi(Ji)
                                },
                                useDebugValue: hd,
                                useDeferredValue: function(o, l) {
                                    var d = kt();
                                    return Pt === null ? ko(d, o, l) : Vc(d, Pt.memoizedState, o, l)
                                },
                                useTransition: function() {
                                    var o = qi(Ji)[0]
                                      , l = kt().memoizedState;
                                    return [typeof o == "boolean" ? o : Xi(o), l]
                                },
                                useSyncExternalStore: hi,
                                useId: Cm,
                                useHostTransitionStatus: kc,
                                useFormState: pf,
                                useActionState: pf,
                                useOptimistic: function(o, l) {
                                    var d = kt();
                                    return Pt !== null ? Am(d, Pt, o, l) : (d.baseState = o,
                                    [o, d.queue.dispatch])
                                },
                                useMemoCache: Ri,
                                useCacheRefresh: Rm
                            };
                            wu.useEffectEvent = fd;
                            var sr = {
                                enqueueSetState: function(o, l, d) {
                                    o = o._reactInternals;
                                    var y = on()
                                      , T = Wi(y);
                                    T.payload = l,
                                    d != null && (T.callback = d),
                                    l = Ia(o, T, y),
                                    l !== null && (di(l, o, y),
                                    Zr(l, o, y))
                                },
                                enqueueReplaceState: function(o, l, d) {
                                    o = o._reactInternals;
                                    var y = on()
                                      , T = Wi(y);
                                    T.tag = 1,
                                    T.payload = l,
                                    d != null && (T.callback = d),
                                    l = Ia(o, T, y),
                                    l !== null && (di(l, o, y),
                                    Zr(l, o, y))
                                },
                                enqueueForceUpdate: function(o, l) {
                                    o = o._reactInternals;
                                    var d = on()
                                      , y = Wi(d);
                                    y.tag = 2,
                                    l != null && (y.callback = l),
                                    l = Ia(o, y, d),
                                    l !== null && (di(l, o, d),
                                    Zr(l, o, d))
                                }
                            }
                              , vi = Error(r(461))
                              , zn = !1
                              , _o = {
                                dehydrated: null,
                                treeContext: null,
                                retryLane: 0,
                                hydrationErrors: null
                            }
                              , Zi = !1
                              , oi = !1
                              , Cu = !1
                              , yp = typeof WeakSet == "function" ? WeakSet : Set
                              , li = null
                              , ci = null
                              , qn = !1
                              , _s = null
                              , Ii = 8192
                              , Hg = {
                                getCacheForType: function(o) {
                                    var l = H(dn)
                                      , d = l.data.get(o);
                                    return d === void 0 && (d = o(),
                                    l.data.set(o, d)),
                                    d
                                },
                                cacheSignal: function() {
                                    return H(dn).controller.signal
                                }
                            }
                              , Ru = 0
                              , ih = 1
                              , Ps = 2
                              , dl = 3
                              , ic = 4;
                            if (typeof Symbol == "function" && Symbol.for) {
                                var rr = Symbol.for;
                                Ru = rr("selector.component"),
                                ih = rr("selector.has_pseudo_class"),
                                Ps = rr("selector.role"),
                                dl = rr("selector.test_id"),
                                ic = rr("selector.text")
                            }
                            var Gg = typeof WeakMap == "function" ? WeakMap : Map
                              , sn = 0
                              , Ln = null
                              , rn = null
                              , Jt = 0
                              , Cn = 0
                              , Za = null
                              , So = !1
                              , ac = !1
                              , ah = !1
                              , or = 0
                              , Bn = 0
                              , zs = 0
                              , xo = 0
                              , sh = 0
                              , Ea = 0
                              , pl = 0
                              , sc = null
                              , ya = null
                              , rc = !1
                              , Du = 0
                              , _p = 0
                              , Tn = 1 / 0
                              , oc = null
                              , bo = null
                              , Ei = 0
                              , Mo = null
                              , lc = null
                              , zr = 0
                              , cc = 0
                              , To = null
                              , rh = null
                              , Eo = 0
                              , Nu = null;
                            return jt.attemptContinuousHydration = function(o) {
                                if (o.tag === 13 || o.tag === 31) {
                                    var l = ss(o, 67108864);
                                    l !== null && di(l, o, 67108864),
                                    el(o, 67108864)
                                }
                            }
                            ,
                            jt.attemptHydrationAtCurrentPriority = function(o) {
                                if (o.tag === 13 || o.tag === 31) {
                                    var l = on();
                                    l = W(l);
                                    var d = ss(o, l);
                                    d !== null && di(d, o, l),
                                    el(o, l)
                                }
                            }
                            ,
                            jt.attemptSynchronousHydration = function(o) {
                                switch (o.tag) {
                                case 3:
                                    if (o = o.stateNode,
                                    o.current.memoizedState.isDehydrated) {
                                        var l = A(o.pendingLanes);
                                        if (l !== 0) {
                                            for (o.pendingLanes |= 2,
                                            o.entangledLanes |= 2; l; ) {
                                                var d = 1 << 31 - ga(l);
                                                o.entanglements[1] |= d,
                                                l &= ~d
                                            }
                                            st(o),
                                            !(sn & 6) && (Tn = ia() + 500,
                                            je(0, !1))
                                        }
                                    }
                                    break;
                                case 31:
                                case 13:
                                    l = ss(o, 2),
                                    l !== null && di(l, o, 2),
                                    Ud(),
                                    el(o, 2)
                                }
                            }
                            ,
                            jt.batchedUpdates = function(o, l) {
                                return o(l)
                            }
                            ,
                            jt.createComponentSelector = function(o) {
                                return {
                                    $$typeof: Ru,
                                    value: o
                                }
                            }
                            ,
                            jt.createContainer = function(o, l, d, y, T, w, z, $, be, Oe) {
                                return ro(o, l, !1, null, d, y, w, null, z, $, be, Oe)
                            }
                            ,
                            jt.createHasPseudoClassSelector = function(o) {
                                return {
                                    $$typeof: ih,
                                    value: o
                                }
                            }
                            ,
                            jt.createHydrationContainer = function(o, l, d, y, T, w, z, $, be, Oe, it, Qe, gt, Ht) {
                                var ui;
                                return o = ro(d, y, !0, o, T, w, $, Ht, be, Oe, it, Qe),
                                o.context = oo(null),
                                d = o.current,
                                y = on(),
                                y = W(y),
                                T = Wi(y),
                                T.callback = (ui = l) != null ? ui : null,
                                Ia(d, T, y),
                                l = y,
                                o.current.lanes = l,
                                B(o, l),
                                st(o),
                                o
                            }
                            ,
                            jt.createPortal = function(o, l, d) {
                                var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                                return {
                                    $$typeof: Va,
                                    key: y == null ? null : "" + y,
                                    children: o,
                                    containerInfo: l,
                                    implementation: d
                                }
                            }
                            ,
                            jt.createRoleSelector = function(o) {
                                return {
                                    $$typeof: Ps,
                                    value: o
                                }
                            }
                            ,
                            jt.createTestNameSelector = function(o) {
                                return {
                                    $$typeof: dl,
                                    value: o
                                }
                            }
                            ,
                            jt.createTextSelector = function(o) {
                                return {
                                    $$typeof: ic,
                                    value: o
                                }
                            }
                            ,
                            jt.defaultOnCaughtError = function(o) {
                                console.error(o)
                            }
                            ,
                            jt.defaultOnRecoverableError = function(o) {
                                Fg(o)
                            }
                            ,
                            jt.defaultOnUncaughtError = function(o) {
                                Fg(o)
                            }
                            ,
                            jt.deferredUpdates = function(o) {
                                var l = Dt.T
                                  , d = Qs();
                                try {
                                    return Mi(32),
                                    Dt.T = null,
                                    o()
                                } finally {
                                    Mi(d),
                                    Dt.T = l
                                }
                            }
                            ,
                            jt.discreteUpdates = function(o, l, d, y, T) {
                                var w = Dt.T
                                  , z = Qs();
                                try {
                                    return Mi(2),
                                    Dt.T = null,
                                    o(l, d, y, T)
                                } finally {
                                    Mi(z),
                                    Dt.T = w,
                                    sn === 0 && (Tn = ia() + 500)
                                }
                            }
                            ,
                            jt.findAllNodes = Ni,
                            jt.findBoundingRects = function(o, l) {
                                if (!jl)
                                    throw Error(r(363));
                                l = Ni(o, l),
                                o = [];
                                for (var d = 0; d < l.length; d++)
                                    o.push(tg(l[d]));
                                for (l = o.length - 1; 0 < l; l--) {
                                    d = o[l];
                                    for (var y = d.x, T = y + d.width, w = d.y, z = w + d.height, $ = l - 1; 0 <= $; $--)
                                        if (l !== $) {
                                            var be = o[$]
                                              , Oe = be.x
                                              , it = Oe + be.width
                                              , Qe = be.y
                                              , gt = Qe + be.height;
                                            if (y >= Oe && w >= Qe && T <= it && z <= gt) {
                                                o.splice(l, 1);
                                                break
                                            } else if (y !== Oe || d.width !== be.width || gt < w || Qe > z) {
                                                if (!(w !== Qe || d.height !== be.height || it < y || Oe > T)) {
                                                    Oe > y && (be.width += Oe - y,
                                                    be.x = y),
                                                    it < T && (be.width = T - Oe),
                                                    o.splice(l, 1);
                                                    break
                                                }
                                            } else {
                                                Qe > w && (be.height += Qe - w,
                                                be.y = w),
                                                gt < z && (be.height = z - Qe),
                                                o.splice(l, 1);
                                                break
                                            }
                                        }
                                }
                                return o
                            }
                            ,
                            jt.findHostInstance = Bd,
                            jt.findHostInstanceWithNoPortals = function(o) {
                                return o = p(o),
                                o = o !== null ? g(o) : null,
                                o === null ? null : al(o.stateNode)
                            }
                            ,
                            jt.findHostInstanceWithWarning = function(o) {
                                return Bd(o)
                            }
                            ,
                            jt.flushPassiveEffects = Ko,
                            jt.flushSyncFromReconciler = function(o) {
                                var l = sn;
                                sn |= 1;
                                var d = Dt.T
                                  , y = Qs();
                                try {
                                    if (Mi(2),
                                    Dt.T = null,
                                    o)
                                        return o()
                                } finally {
                                    Mi(y),
                                    Dt.T = d,
                                    sn = l,
                                    !(sn & 6) && je(0, !1)
                                }
                            }
                            ,
                            jt.flushSyncWork = Ud,
                            jt.focusWithin = function(o, l) {
                                if (!jl)
                                    throw Error(r(363));
                                for (o = Rf(o),
                                l = Ld(o, l),
                                l = Array.from(l),
                                o = 0; o < l.length; ) {
                                    var d = l[o++]
                                      , y = d.tag;
                                    if (!Zl(d)) {
                                        if ((y === 5 || y === 26 || y === 27) && qd(d.stateNode))
                                            return !0;
                                        for (d = d.child; d !== null; )
                                            l.push(d),
                                            d = d.sibling
                                    }
                                }
                                return !1
                            }
                            ,
                            jt.getFindAllNodesFailureDescription = function(o, l) {
                                if (!jl)
                                    throw Error(r(363));
                                var d = 0
                                  , y = [];
                                o = [Rf(o), 0];
                                for (var T = 0; T < o.length; ) {
                                    var w = o[T++]
                                      , z = w.tag
                                      , $ = o[T++]
                                      , be = l[$];
                                    if ((z !== 5 && z !== 26 && z !== 27 || !Zl(w)) && (ru(w, be) && (y.push(ou(be)),
                                    $++,
                                    $ > d && (d = $)),
                                    $ < l.length))
                                        for (w = w.child; w !== null; )
                                            o.push(w, $),
                                            w = w.sibling
                                }
                                if (d < l.length) {
                                    for (o = []; d < l.length; d++)
                                        o.push(ou(l[d]));
                                    return `findAllNodes was able to match part of the selector:
  ` + (y.join(" > ") + `

No matching component was found for:
  `) + o.join(" > ")
                                }
                                return null
                            }
                            ,
                            jt.getPublicRootInstance = function(o) {
                                if (o = o.current,
                                !o.child)
                                    return null;
                                switch (o.child.tag) {
                                case 27:
                                case 5:
                                    return al(o.child.stateNode);
                                default:
                                    return o.child.stateNode
                                }
                            }
                            ,
                            jt.injectIntoDevTools = function() {
                                var o = {
                                    bundleType: 0,
                                    version: ka,
                                    rendererPackageName: ds,
                                    currentDispatcherRef: Dt,
                                    reconcilerVersion: "19.2.0"
                                };
                                if (Rr !== null && (o.rendererConfig = Rr),
                                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
                                    o = !1;
                                else {
                                    var l = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                                    if (l.isDisabled || !l.supportsFiber)
                                        o = !0;
                                    else {
                                        try {
                                            Nr = l.inject(o),
                                            ln = l
                                        } catch {}
                                        o = !!l.checkDCE
                                    }
                                }
                                return o
                            }
                            ,
                            jt.isAlreadyRendering = function() {
                                return (sn & 6) !== 0
                            }
                            ,
                            jt.observeVisibleRects = function(o, l, d, y) {
                                if (!jl)
                                    throw Error(r(363));
                                o = Ni(o, l);
                                var T = ag(o, d, y).disconnect;
                                return {
                                    disconnect: function() {
                                        T()
                                    }
                                }
                            }
                            ,
                            jt.shouldError = function() {
                                return null
                            }
                            ,
                            jt.shouldSuspend = function() {
                                return !1
                            }
                            ,
                            jt.startHostTransition = function(o, l, d, y) {
                                if (o.tag !== 5)
                                    throw Error(r(476));
                                var T = wm(o).queue;
                                dd(o, T, l, fo, d === null ? a : function() {
                                    var w = wm(o);
                                    return w.next === null && (w = o.alternate.memoizedState),
                                    Hc(o, w.next.queue, {}, on()),
                                    d(y)
                                }
                                )
                            }
                            ,
                            jt.updateContainer = function(o, l, d, y) {
                                var T = l.current
                                  , w = on();
                                return Fd(T, w, o, l, d, y),
                                w
                            }
                            ,
                            jt.updateContainerSync = function(o, l, d, y) {
                                return Fd(l.current, 2, o, l, d, y),
                                2
                            }
                            ,
                            jt
                        }
                        ,
                        e.exports.default = e.exports,
                        Object.defineProperty(e.exports, "__esModule", {
                            value: !0
                        })
                    }
                    )(ox)),
                    ox.exports
                }
                var oA;
                function nU() {
                    return oA || (oA = 1,
                    sA.exports = tU()),
                    sA.exports
                }
                const iU = eU(nU());
                function aU(e) {
                    const t = iU(e);
                    return t.injectIntoDevTools(),
                    t
                }
                const lA = 0
                  , td = {}
                  , sU = /^three(?=[A-Z])/
                  , gy = e => `${e[0].toUpperCase()}${e.slice(1)}`;
                let rU = 0;
                const oU = e => typeof e == "function";
                function lU(e) {
                    if (oU(e)) {
                        const t = `${rU++}`;
                        return td[t] = e,
                        t
                    } else
                        Object.assign(td, e)
                }
                function cA(e, t) {
                    const n = gy(e)
                      , a = td[n];
                    if (e !== "primitive" && !a)
                        throw new Error(`R3F: ${n} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
                    if (e === "primitive" && !t.object)
                        throw new Error("R3F: Primitives without 'object' are invalid!");
                    if (t.args !== void 0 && !Array.isArray(t.args))
                        throw new Error("R3F: The args prop must be an array!")
                }
                function cU(e, t, n) {
                    var a;
                    return e = gy(e)in td ? e : e.replace(sU, ""),
                    cA(e, t),
                    e === "primitive" && (a = t.object) != null && a.__r3f && delete t.object.__r3f,
                    fy(t.object, n, e, t)
                }
                function uU(e) {
                    if (!e.isHidden) {
                        var t;
                        e.props.attach && (t = e.parent) != null && t.object ? dy(e.parent, e) : as(e.object) && (e.object.visible = !1),
                        e.isHidden = !0,
                        ed(e)
                    }
                }
                function uA(e) {
                    if (e.isHidden) {
                        var t;
                        e.props.attach && (t = e.parent) != null && t.object ? hy(e.parent, e) : as(e.object) && e.props.visible !== !1 && (e.object.visible = !0),
                        e.isHidden = !1,
                        ed(e)
                    }
                }
                function lx(e, t, n) {
                    const a = t.root.getState();
                    if (!(!e.parent && e.object !== a.scene)) {
                        if (!t.object) {
                            var r, c;
                            const f = td[gy(t.type)];
                            t.object = (r = t.props.object) != null ? r : new f(...(c = t.props.args) != null ? c : []),
                            t.object.__r3f = t
                        }
                        if (Pc(t.object, t.props),
                        t.props.attach)
                            hy(e, t);
                        else if (as(t.object) && as(e.object)) {
                            const f = e.object.children.indexOf(n?.object);
                            if (n && f !== -1) {
                                const p = e.object.children.indexOf(t.object);
                                if (p !== -1) {
                                    e.object.children.splice(p, 1);
                                    const m = p < f ? f - 1 : f;
                                    e.object.children.splice(m, 0, t.object)
                                } else
                                    t.object.parent = e.object,
                                    e.object.children.splice(f, 0, t.object),
                                    t.object.dispatchEvent({
                                        type: "added"
                                    }),
                                    e.object.dispatchEvent({
                                        type: "childadded",
                                        child: t.object
                                    })
                            } else
                                e.object.add(t.object)
                        }
                        for (const f of t.children)
                            lx(t, f);
                        ed(t)
                    }
                }
                function cx(e, t) {
                    t && (t.parent = e,
                    e.children.push(t),
                    lx(e, t))
                }
                function fA(e, t, n) {
                    if (!t || !n)
                        return;
                    t.parent = e;
                    const a = e.children.indexOf(n);
                    a !== -1 ? e.children.splice(a, 0, t) : e.children.push(t),
                    lx(e, t, n)
                }
                function hA(e) {
                    if (typeof e.dispose == "function") {
                        const t = () => {
                            try {
                                e.dispose()
                            } catch {}
                        }
                        ;
                        typeof IS_REACT_ACT_ENVIRONMENT < "u" ? t() : (0,
                        ix.unstable_scheduleCallback)(ix.unstable_IdlePriority, t)
                    }
                }
                function ux(e, t, n) {
                    if (!t)
                        return;
                    t.parent = null;
                    const a = e.children.indexOf(t);
                    a !== -1 && e.children.splice(a, 1),
                    t.props.attach ? dy(e, t) : as(t.object) && as(e.object) && (e.object.remove(t.object),
                    WL(qE(t), t.object));
                    const r = t.props.dispose !== null && n !== !1;
                    for (let c = t.children.length - 1; c >= 0; c--) {
                        const f = t.children[c];
                        ux(t, f, r)
                    }
                    t.children.length = 0,
                    delete t.object.__r3f,
                    r && t.type !== "primitive" && t.object.type !== "Scene" && hA(t.object),
                    n === void 0 && ed(t)
                }
                function fU(e, t) {
                    for (const n of [e, e.alternate])
                        if (n !== null)
                            if (typeof n.ref == "function") {
                                n.refCleanup == null || n.refCleanup();
                                const a = n.ref(t);
                                typeof a == "function" && (n.refCleanup = a)
                            } else
                                n.ref && (n.ref.current = t)
                }
                const vy = [];
                function hU() {
                    for (const [n] of vy) {
                        const a = n.parent;
                        if (a) {
                            n.props.attach ? dy(a, n) : as(n.object) && as(a.object) && a.object.remove(n.object);
                            for (const r of n.children)
                                r.props.attach ? dy(n, r) : as(r.object) && as(n.object) && n.object.remove(r.object)
                        }
                        n.isHidden && uA(n),
                        n.object.__r3f && delete n.object.__r3f,
                        n.type !== "primitive" && hA(n.object)
                    }
                    for (const [n,a,r] of vy) {
                        n.props = a;
                        const c = n.parent;
                        if (c) {
                            var e, t;
                            const f = td[gy(n.type)];
                            n.object = (e = n.props.object) != null ? e : new f(...(t = n.props.args) != null ? t : []),
                            n.object.__r3f = n,
                            fU(r, n.object),
                            Pc(n.object, n.props),
                            n.props.attach ? hy(c, n) : as(n.object) && as(c.object) && c.object.add(n.object);
                            for (const p of n.children)
                                p.props.attach ? hy(n, p) : as(p.object) && as(n.object) && n.object.add(p.object);
                            ed(n)
                        }
                    }
                    vy.length = 0
                }
                const fx = () => {}
                  , dA = {};
                let yy = lA;
                const dU = 0
                  , pU = 4
                  , hx = aU({
                    isPrimaryRenderer: !1,
                    warnsIfNotActing: !1,
                    supportsMutation: !0,
                    supportsPersistence: !1,
                    supportsHydration: !1,
                    createInstance: cU,
                    removeChild: ux,
                    appendChild: cx,
                    appendInitialChild: cx,
                    insertBefore: fA,
                    appendChildToContainer(e, t) {
                        const n = e.getState().scene.__r3f;
                        !t || !n || cx(n, t)
                    },
                    removeChildFromContainer(e, t) {
                        const n = e.getState().scene.__r3f;
                        !t || !n || ux(n, t)
                    },
                    insertInContainerBefore(e, t, n) {
                        const a = e.getState().scene.__r3f;
                        !t || !n || !a || fA(a, t, n)
                    },
                    getRootHostContext: () => dA,
                    getChildHostContext: () => dA,
                    commitUpdate(e, t, n, a, r) {
                        var c, f, p;
                        cA(t, a);
                        let m = !1;
                        if ((e.type === "primitive" && n.object !== a.object || ((c = a.args) == null ? void 0 : c.length) !== ((f = n.args) == null ? void 0 : f.length) || (p = a.args) != null && p.some( (g, v) => {
                            var _;
                            return g !== ((_ = n.args) == null ? void 0 : _[v])
                        }
                        )) && (m = !0),
                        m)
                            vy.push([e, {
                                ...a
                            }, r]);
                        else {
                            const g = VL(e, a);
                            Object.keys(g).length && (Object.assign(e.props, g),
                            Pc(e.object, g))
                        }
                        (r.sibling === null || (r.flags & pU) === dU) && hU()
                    },
                    finalizeInitialChildren: () => !1,
                    commitMount() {},
                    getPublicInstance: e => e?.object,
                    prepareForCommit: () => null,
                    preparePortalMount: e => fy(e.getState().scene, e, "", {}),
                    resetAfterCommit: () => {}
                    ,
                    shouldSetTextContent: () => !1,
                    clearContainer: () => !1,
                    hideInstance: uU,
                    unhideInstance: uA,
                    createTextInstance: fx,
                    hideTextInstance: fx,
                    unhideTextInstance: fx,
                    scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
                    cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
                    noTimeout: -1,
                    getInstanceFromNode: () => null,
                    beforeActiveInstanceBlur() {},
                    afterActiveInstanceBlur() {},
                    detachDeletedInstance() {},
                    prepareScopeUpdate() {},
                    getInstanceFromScope: () => null,
                    shouldAttemptEagerTransition: () => !1,
                    trackSchedulerEvent: () => {}
                    ,
                    resolveEventType: () => null,
                    resolveEventTimeStamp: () => -1.1,
                    requestPostPaintCallback() {},
                    maySuspendCommit: () => !1,
                    preloadInstance: () => !0,
                    suspendInstance() {},
                    waitForCommitToBeReady: () => null,
                    NotPendingTransition: null,
                    HostTransitionContext: lt.createContext(null),
                    setCurrentUpdatePriority(e) {
                        yy = e
                    },
                    getCurrentUpdatePriority() {
                        return yy
                    },
                    resolveUpdatePriority() {
                        var e;
                        if (yy !== lA)
                            return yy;
                        switch (typeof window < "u" && ((e = window.event) == null ? void 0 : e.type)) {
                        case "click":
                        case "contextmenu":
                        case "dblclick":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                            return JL;
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerenter":
                        case "pointerleave":
                        case "wheel":
                            return QL;
                        default:
                            return KL
                        }
                    },
                    resetFormInstance() {},
                    rendererPackageName: "@react-three/fiber",
                    rendererVersion: $L.version,
                    applyViewTransitionName(e, t, n) {},
                    restoreViewTransitionName(e, t) {},
                    cancelViewTransitionName(e, t, n) {},
                    cancelRootViewTransitionName(e) {},
                    restoreRootViewTransitionName(e) {},
                    InstanceMeasurement: null,
                    measureInstance: e => null,
                    wasInstanceInViewport: e => !0,
                    hasInstanceChanged: (e, t) => !1,
                    hasInstanceAffectedParent: (e, t) => !1,
                    suspendOnActiveViewTransition(e, t) {},
                    startGestureTransition: () => null,
                    startViewTransition: () => null,
                    stopViewTransition(e) {},
                    createViewTransitionInstance: e => null,
                    getCurrentGestureOffset(e) {
                        throw new Error("startGestureTransition is not yet supported in react-three-fiber.")
                    },
                    cloneMutableInstance(e, t) {
                        return e
                    },
                    cloneMutableTextInstance(e) {
                        return e
                    },
                    cloneRootViewTransitionContainer(e) {
                        throw new Error("Not implemented.")
                    },
                    removeRootViewTransitionClone(e, t) {
                        throw new Error("Not implemented.")
                    },
                    createFragmentInstance: e => null,
                    updateFragmentInstanceFiber(e, t) {},
                    commitNewChildToFragmentInstance(e, t) {},
                    deleteChildFromFragmentInstance(e, t) {},
                    measureClonedInstance: e => null,
                    maySuspendCommitOnUpdate: (e, t, n) => !1,
                    maySuspendCommitInSyncRender: (e, t) => !1,
                    startSuspendingCommit: () => null,
                    getSuspendedCommitReason: (e, t) => null
                })
                  , lf = new Map
                  , nd = {
                    objects: "shallow",
                    strict: !1
                };
                function mU(e, t) {
                    if (!t && typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && e.parentElement) {
                        const {width: n, height: a, top: r, left: c} = e.parentElement.getBoundingClientRect();
                        return {
                            width: n,
                            height: a,
                            top: r,
                            left: c
                        }
                    } else if (!t && typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)
                        return {
                            width: e.width,
                            height: e.height,
                            top: 0,
                            left: 0
                        };
                    return {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        ...t
                    }
                }
                function gU(e) {
                    const t = lf.get(e)
                      , n = t?.fiber
                      , a = t?.store;
                    t && console.warn("R3F.createRoot should only be called once!");
                    const r = typeof reportError == "function" ? reportError : console.error
                      , c = a || qL(_x, vA)
                      , f = n || hx.createContainer(c, ZL, null, !1, null, "", r, r, r, null);
                    t || lf.set(e, {
                        fiber: f,
                        store: c
                    });
                    let p, m, g = !1, v = null;
                    return {
                        async configure(_={}) {
                            let x;
                            v = new Promise(Be => x = Be);
                            let {gl: M, size: C, scene: R, events: A, onCreated: E, shadows: N=!1, linear: I=!1, flat: L=!1, legacy: k=!1, orthographic: B=!1, frameloop: X="always", dpr: G=[1, 2], performance: P, raycaster: U, camera: W, onPointerMissed: K} = _
                              , q = c.getState()
                              , te = q.gl;
                            if (!q.gl) {
                                const Be = {
                                    canvas: e,
                                    powerPreference: "high-performance",
                                    antialias: !0,
                                    alpha: !0
                                }
                                  , j = typeof M == "function" ? await M(Be) : M;
                                eA(j) ? te = j : te = new BE({
                                    ...Be,
                                    ...M
                                }),
                                q.set({
                                    gl: te
                                })
                            }
                            let ce = q.raycaster;
                            ce || q.set({
                                raycaster: ce = new $T
                            });
                            const {params: J, ...Q} = U || {};
                            if (fi.equ(Q, ce, nd) || Pc(ce, {
                                ...Q
                            }),
                            fi.equ(J, ce.params, nd) || Pc(ce, {
                                params: {
                                    ...ce.params,
                                    ...J
                                }
                            }),
                            !q.camera || q.camera === m && !fi.equ(m, W, nd)) {
                                m = W;
                                const Be = W?.isCamera
                                  , j = Be ? W : B ? new jh(0,0,0,0,.1,1e3) : new ca(75,0,.1,1e3);
                                Be || (j.position.z = 5,
                                W && (Pc(j, W),
                                j.manual || ("aspect"in W || "left"in W || "right"in W || "bottom"in W || "top"in W) && (j.manual = !0,
                                j.updateProjectionMatrix())),
                                !q.camera && !(W != null && W.rotation) && j.lookAt(0, 0, 0)),
                                q.set({
                                    camera: j
                                }),
                                ce.camera = j
                            }
                            if (!q.scene) {
                                let Be;
                                R != null && R.isScene ? (Be = R,
                                fy(Be, c, "", {})) : (Be = new Z_,
                                fy(Be, c, "", {}),
                                R && Pc(Be, R)),
                                q.set({
                                    scene: Be
                                })
                            }
                            A && !q.events.handlers && q.set({
                                events: A(c)
                            });
                            const se = mU(e, C);
                            if (fi.equ(se, q.size, nd) || q.setSize(se.width, se.height, se.top, se.left),
                            G && q.viewport.dpr !== ZE(G) && q.setDpr(G),
                            q.frameloop !== X && q.setFrameloop(X),
                            q.onPointerMissed || q.set({
                                onPointerMissed: K
                            }),
                            P && !fi.equ(P, q.performance, nd) && q.set(Be => ({
                                performance: {
                                    ...Be.performance,
                                    ...P
                                }
                            })),
                            !q.xr) {
                                var Te;
                                const Be = (Re, le) => {
                                    const Ae = c.getState();
                                    Ae.frameloop !== "never" && vA(Re, !0, Ae, le)
                                }
                                  , j = () => {
                                    const Re = c.getState();
                                    Re.gl.xr.enabled = Re.gl.xr.isPresenting,
                                    Re.gl.xr.setAnimationLoop(Re.gl.xr.isPresenting ? Be : null),
                                    Re.gl.xr.isPresenting || _x(Re)
                                }
                                  , ve = {
                                    connect() {
                                        const Re = c.getState().gl;
                                        Re.xr.addEventListener("sessionstart", j),
                                        Re.xr.addEventListener("sessionend", j)
                                    },
                                    disconnect() {
                                        const Re = c.getState().gl;
                                        Re.xr.removeEventListener("sessionstart", j),
                                        Re.xr.removeEventListener("sessionend", j)
                                    }
                                };
                                typeof ((Te = te.xr) == null ? void 0 : Te.addEventListener) == "function" && ve.connect(),
                                q.set({
                                    xr: ve
                                })
                            }
                            if (te.shadowMap) {
                                const Be = te.shadowMap.enabled
                                  , j = te.shadowMap.type;
                                if (te.shadowMap.enabled = !!N,
                                fi.boo(N))
                                    te.shadowMap.type = Cp;
                                else if (fi.str(N)) {
                                    var Ee;
                                    const ve = {
                                        basic: sb,
                                        percentage: fh,
                                        soft: Cp,
                                        variance: Lu
                                    };
                                    te.shadowMap.type = (Ee = ve[N]) != null ? Ee : Cp
                                } else
                                    fi.obj(N) && Object.assign(te.shadowMap, N);
                                (Be !== te.shadowMap.enabled || j !== te.shadowMap.type) && (te.shadowMap.needsUpdate = !0)
                            }
                            return Sn.enabled = !k,
                            g || (te.outputColorSpace = I ? Sc : wa,
                            te.toneMapping = L ? ur : mv),
                            q.legacy !== k && q.set( () => ({
                                legacy: k
                            })),
                            q.linear !== I && q.set( () => ({
                                linear: I
                            })),
                            q.flat !== L && q.set( () => ({
                                flat: L
                            })),
                            M && !fi.fun(M) && !eA(M) && !fi.equ(M, te, nd) && Pc(te, M),
                            p = E,
                            g = !0,
                            x(),
                            this
                        },
                        render(_) {
                            return !g && !v && this.configure(),
                            v.then( () => {
                                hx.updateContainer((0,
                                _t.jsx)(vU, {
                                    store: c,
                                    children: _,
                                    onCreated: p,
                                    rootElement: e
                                }), f, null, () => {}
                                )
                            }
                            ),
                            c
                        },
                        unmount() {
                            pA(e)
                        }
                    }
                }
                function vU({store: e, children: t, onCreated: n, rootElement: a}) {
                    return Mm( () => {
                        const r = e.getState();
                        r.set(c => ({
                            internal: {
                                ...c.internal,
                                active: !0
                            }
                        })),
                        n && n(r),
                        e.getState().events.connected || r.events.connect == null || r.events.connect(a)
                    }
                    , []),
                    (0,
                    _t.jsx)(tA.Provider, {
                        value: e,
                        children: t
                    })
                }
                function pA(e, t) {
                    const n = lf.get(e)
                      , a = n?.fiber;
                    if (a) {
                        const r = n?.store.getState();
                        r && (r.internal.active = !1),
                        hx.updateContainer(null, a, null, () => {
                            r && setTimeout( () => {
                                try {
                                    var c, f, p, m;
                                    r.events.disconnect == null || r.events.disconnect(),
                                    (c = r.gl) == null || (f = c.renderLists) == null || f.dispose == null || f.dispose(),
                                    (p = r.gl) == null || p.forceContextLoss == null || p.forceContextLoss(),
                                    (m = r.gl) != null && m.xr && r.xr.disconnect(),
                                    zL(r.scene),
                                    lf.delete(e),
                                    t && t(e)
                                } catch {}
                            }
                            , 500)
                        }
                        )
                    }
                }
                const yU = new Set
                  , _U = new Set
                  , SU = new Set;
                function dx(e, t) {
                    if (e.size)
                        for (const {callback: n} of e.values())
                            n(t)
                }
                function Em(e, t) {
                    switch (e) {
                    case "before":
                        return dx(yU, t);
                    case "after":
                        return dx(_U, t);
                    case "tail":
                        return dx(SU, t)
                    }
                }
                let px, mx;
                function gx(e, t, n) {
                    let a = t.clock.getDelta();
                    t.frameloop === "never" && typeof e == "number" && (a = e - t.clock.elapsedTime,
                    t.clock.oldTime = t.clock.elapsedTime,
                    t.clock.elapsedTime = e),
                    px = t.internal.subscribers;
                    for (let r = 0; r < px.length; r++)
                        mx = px[r],
                        mx.ref.current(mx.store.getState(), a, n);
                    return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera),
                    t.internal.frames = Math.max(0, t.internal.frames - 1),
                    t.frameloop === "always" ? 1 : t.internal.frames
                }
                let _y = !1, vx = !1, yx, mA, id;
                function gA(e) {
                    mA = requestAnimationFrame(gA),
                    _y = !0,
                    yx = 0,
                    Em("before", e),
                    vx = !0;
                    for (const n of lf.values()) {
                        var t;
                        id = n.store.getState(),
                        id.internal.active && (id.frameloop === "always" || id.internal.frames > 0) && !((t = id.gl.xr) != null && t.isPresenting) && (yx += gx(e, id))
                    }
                    if (vx = !1,
                    Em("after", e),
                    yx === 0)
                        return Em("tail", e),
                        _y = !1,
                        cancelAnimationFrame(mA)
                }
                function _x(e, t=1) {
                    var n;
                    if (!e)
                        return lf.forEach(a => _x(a.store.getState(), t));
                    (n = e.gl.xr) != null && n.isPresenting || !e.internal.active || e.frameloop === "never" || (t > 1 ? e.internal.frames = Math.min(60, e.internal.frames + t) : vx ? e.internal.frames = 2 : e.internal.frames = 1,
                    _y || (_y = !0,
                    requestAnimationFrame(gA)))
                }
                function vA(e, t=!0, n, a) {
                    if (t && Em("before", e),
                    n)
                        gx(e, n, a);
                    else
                        for (const r of lf.values())
                            gx(e, r.store.getState());
                    t && Em("after", e)
                }
                const Sx = {
                    onClick: ["click", !1],
                    onContextMenu: ["contextmenu", !1],
                    onDoubleClick: ["dblclick", !1],
                    onWheel: ["wheel", !0],
                    onPointerDown: ["pointerdown", !0],
                    onPointerUp: ["pointerup", !0],
                    onPointerLeave: ["pointerleave", !0],
                    onPointerMove: ["pointermove", !0],
                    onPointerCancel: ["pointercancel", !0],
                    onLostPointerCapture: ["lostpointercapture", !0]
                };
                function xU(e) {
                    const {handlePointer: t} = XL(e);
                    return {
                        priority: 1,
                        enabled: !0,
                        compute(n, a, r) {
                            a.pointer.set(n.offsetX / a.size.width * 2 - 1, -(n.offsetY / a.size.height) * 2 + 1),
                            a.raycaster.setFromCamera(a.pointer, a.camera)
                        },
                        connected: void 0,
                        handlers: Object.keys(Sx).reduce( (n, a) => ({
                            ...n,
                            [a]: t(a)
                        }), {}),
                        update: () => {
                            var n;
                            const {events: a, internal: r} = e.getState();
                            (n = r.lastEvent) != null && n.current && a.handlers && a.handlers.onPointerMove(r.lastEvent.current)
                        }
                        ,
                        connect: n => {
                            const {set: a, events: r} = e.getState();
                            if (r.disconnect == null || r.disconnect(),
                            a(c => ({
                                events: {
                                    ...c.events,
                                    connected: n
                                }
                            })),
                            r.handlers)
                                for (const c in r.handlers) {
                                    const f = r.handlers[c]
                                      , [p,m] = Sx[c];
                                    n.addEventListener(p, f, {
                                        passive: m
                                    })
                                }
                        }
                        ,
                        disconnect: () => {
                            const {set: n, events: a} = e.getState();
                            if (a.connected) {
                                if (a.handlers)
                                    for (const r in a.handlers) {
                                        const c = a.handlers[r]
                                          , [f] = Sx[r];
                                        a.connected.removeEventListener(f, c)
                                    }
                                n(r => ({
                                    events: {
                                        ...r.events,
                                        connected: void 0
                                    }
                                }))
                            }
                        }
                    }
                }
                function yA(e, t) {
                    let n;
                    return (...a) => {
                        window.clearTimeout(n),
                        n = window.setTimeout( () => e(...a), t)
                    }
                }
                function bU({debounce: e, scroll: t, polyfill: n, offsetSize: a}={
                    debounce: 0,
                    scroll: !1,
                    offsetSize: !1
                }) {
                    const r = n || (typeof window > "u" ? class {
                    }
                    : window.ResizeObserver);
                    if (!r)
                        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
                    const [c,f] = (0,
                    lt.useState)({
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0,
                        bottom: 0,
                        right: 0,
                        x: 0,
                        y: 0
                    })
                      , p = (0,
                    lt.useRef)({
                        element: null,
                        scrollContainers: null,
                        resizeObserver: null,
                        lastBounds: c,
                        orientationHandler: null
                    })
                      , m = e ? typeof e == "number" ? e : e.scroll : null
                      , g = e ? typeof e == "number" ? e : e.resize : null
                      , v = (0,
                    lt.useRef)(!1);
                    (0,
                    lt.useEffect)( () => (v.current = !0,
                    () => {
                        v.current = !1
                    }
                    ));
                    const [_,x,M] = (0,
                    lt.useMemo)( () => {
                        const E = () => {
                            if (!p.current.element)
                                return;
                            const {left: N, top: I, width: L, height: k, bottom: B, right: X, x: G, y: P} = p.current.element.getBoundingClientRect()
                              , U = {
                                left: N,
                                top: I,
                                width: L,
                                height: k,
                                bottom: B,
                                right: X,
                                x: G,
                                y: P
                            };
                            p.current.element instanceof HTMLElement && a && (U.height = p.current.element.offsetHeight,
                            U.width = p.current.element.offsetWidth),
                            Object.freeze(U),
                            v.current && !AU(p.current.lastBounds, U) && f(p.current.lastBounds = U)
                        }
                        ;
                        return [E, g ? yA(E, g) : E, m ? yA(E, m) : E]
                    }
                    , [f, a, m, g]);
                    function C() {
                        p.current.scrollContainers && (p.current.scrollContainers.forEach(E => E.removeEventListener("scroll", M, !0)),
                        p.current.scrollContainers = null),
                        p.current.resizeObserver && (p.current.resizeObserver.disconnect(),
                        p.current.resizeObserver = null),
                        p.current.orientationHandler && ("orientation"in screen && "removeEventListener"in screen.orientation ? screen.orientation.removeEventListener("change", p.current.orientationHandler) : "onorientationchange"in window && window.removeEventListener("orientationchange", p.current.orientationHandler))
                    }
                    function R() {
                        p.current.element && (p.current.resizeObserver = new r(M),
                        p.current.resizeObserver.observe(p.current.element),
                        t && p.current.scrollContainers && p.current.scrollContainers.forEach(E => E.addEventListener("scroll", M, {
                            capture: !0,
                            passive: !0
                        })),
                        p.current.orientationHandler = () => {
                            M()
                        }
                        ,
                        "orientation"in screen && "addEventListener"in screen.orientation ? screen.orientation.addEventListener("change", p.current.orientationHandler) : "onorientationchange"in window && window.addEventListener("orientationchange", p.current.orientationHandler))
                    }
                    const A = E => {
                        !E || E === p.current.element || (C(),
                        p.current.element = E,
                        p.current.scrollContainers = _A(E),
                        R())
                    }
                    ;
                    return TU(M, !!t),
                    MU(x),
                    (0,
                    lt.useEffect)( () => {
                        C(),
                        R()
                    }
                    , [t, M, x]),
                    (0,
                    lt.useEffect)( () => C, []),
                    [A, c, _]
                }
                function MU(e) {
                    (0,
                    lt.useEffect)( () => {
                        const t = e;
                        return window.addEventListener("resize", t),
                        () => {
                            window.removeEventListener("resize", t)
                        }
                    }
                    , [e])
                }
                function TU(e, t) {
                    (0,
                    lt.useEffect)( () => {
                        if (t) {
                            const n = e;
                            return window.addEventListener("scroll", n, {
                                capture: !0,
                                passive: !0
                            }),
                            () => {
                                window.removeEventListener("scroll", n, !0)
                            }
                        }
                    }
                    , [e, t])
                }
                function _A(e) {
                    const t = [];
                    if (!e || e === document.body)
                        return t;
                    const {overflow: n, overflowX: a, overflowY: r} = window.getComputedStyle(e);
                    return [n, a, r].some(c => c === "auto" || c === "scroll") && t.push(e),
                    [...t, ..._A(e.parentElement)]
                }
                const EU = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
                  , AU = (e, t) => EU.every(n => e[n] === t[n]);
                function wU({ref: e, children: t, fallback: n, resize: a, style: r, gl: c, events: f=xU, eventSource: p, eventPrefix: m, shadows: g, linear: v, flat: _, legacy: x, orthographic: M, frameloop: C, dpr: R, performance: A, raycaster: E, camera: N, scene: I, onPointerMissed: L, onCreated: k, ...B}) {
                    lt.useMemo( () => lU(QR), []);
                    const X = UL()
                      , [G,P] = bU({
                        scroll: !0,
                        debounce: {
                            scroll: 50,
                            resize: 0
                        },
                        ...a
                    })
                      , U = lt.useRef(null)
                      , W = lt.useRef(null);
                    lt.useImperativeHandle(e, () => U.current);
                    const K = jE(L)
                      , [q,te] = lt.useState(!1)
                      , [ce,J] = lt.useState(!1);
                    if (q)
                        throw q;
                    if (ce)
                        throw ce;
                    const Q = lt.useRef(null);
                    return Mm( () => {
                        const se = U.current;
                        if (P.width > 0 && P.height > 0 && se) {
                            Q.current || (Q.current = gU(se));
                            async function Te() {
                                await Q.current.configure({
                                    gl: c,
                                    scene: I,
                                    events: f,
                                    shadows: g,
                                    linear: v,
                                    flat: _,
                                    legacy: x,
                                    orthographic: M,
                                    frameloop: C,
                                    dpr: R,
                                    performance: A,
                                    raycaster: E,
                                    camera: N,
                                    size: P,
                                    onPointerMissed: (...Ee) => K.current == null ? void 0 : K.current(...Ee),
                                    onCreated: Ee => {
                                        Ee.events.connect == null || Ee.events.connect(p ? NL(p) ? p.current : p : W.current),
                                        m && Ee.setEvents({
                                            compute: (Be, j) => {
                                                const ve = Be[m + "X"]
                                                  , Re = Be[m + "Y"];
                                                j.pointer.set(ve / j.size.width * 2 - 1, -(Re / j.size.height) * 2 + 1),
                                                j.raycaster.setFromCamera(j.pointer, j.camera)
                                            }
                                        }),
                                        k?.(Ee)
                                    }
                                }),
                                Q.current.render((0,
                                _t.jsx)(X, {
                                    children: (0,
                                    _t.jsx)(OL, {
                                        set: J,
                                        children: (0,
                                        _t.jsx)(lt.Suspense, {
                                            fallback: (0,
                                            _t.jsx)(IL, {
                                                set: te
                                            }),
                                            children: t ?? null
                                        })
                                    })
                                }))
                            }
                            Te()
                        }
                    }
                    ),
                    lt.useEffect( () => {
                        const se = U.current;
                        if (se)
                            return () => pA(se)
                    }
                    , []),
                    (0,
                    _t.jsx)("div", {
                        ref: W,
                        style: {
                            position: "relative",
                            width: "100%",
                            height: "100%",
                            overflow: "hidden",
                            pointerEvents: p ? "none" : "auto",
                            ...r
                        },
                        ...B,
                        children: (0,
                        _t.jsx)("div", {
                            ref: G,
                            style: {
                                width: "100%",
                                height: "100%"
                            },
                            children: (0,
                            _t.jsx)("canvas", {
                                ref: U,
                                style: {
                                    display: "block"
                                },
                                children: n
                            })
                        })
                    })
                }
                function CU(e) {
                    return (0,
                    _t.jsx)(WE, {
                        children: (0,
                        _t.jsx)(wU, {
                            ...e
                        })
                    })
                }
                function SA(e) {
                    const t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
                    return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : [255, 255, 255]
                }
                function RU(e, t, n) {
                    return "#" + [e, t, n].map(a => {
                        const r = Math.round(a).toString(16);
                        return r.length === 1 ? "0" + r : r
                    }
                    ).join("").toUpperCase()
                }
                function xA(e, t, n) {
                    const [a,r,c] = SA(e)
                      , [f,p,m] = SA(t);
                    return RU(a + (f - a) * n, r + (p - r) * n, c + (m - c) * n)
                }
                const Si = Ao.gizmoRuntime.tweaks({
                    backgroundColor: {
                        index: 0,
                        name: "Background",
                        type: "color",
                        value: "#000000"
                    },
                    trailLength: {
                        index: 1,
                        name: "Trail Length",
                        type: "slider",
                        value: 40,
                        min: 5,
                        max: 50,
                        step: 1
                    },
                    fadeOutDuration: {
                        index: 2,
                        name: "Fade Duration",
                        type: "slider",
                        value: 1.8,
                        min: .3,
                        max: 3,
                        step: .1
                    },
                    colorCycleSpeed: {
                        index: 3,
                        name: "Color Cycle Speed",
                        type: "slider",
                        value: 1.3,
                        min: .5,
                        max: 5,
                        step: .1
                    },
                    rotationSensitivity: {
                        index: 4,
                        name: "Sensitivity",
                        type: "slider",
                        value: .045,
                        min: .01,
                        max: .08,
                        step: .005
                    },
                    cubeSize: {
                        index: 5,
                        name: "Cube Size",
                        type: "slider",
                        value: 2.7,
                        min: 1,
                        max: 4,
                        step: .1
                    },
                    trailOpacity: {
                        index: 6,
                        name: "Trail Visibility",
                        type: "slider",
                        value: 1,
                        min: 0,
                        max: 1,
                        step: .05
                    },
                    vertexSize: {
                        index: 7,
                        name: "Vertex Size",
                        type: "slider",
                        value: .049999997,
                        min: .03,
                        max: .3,
                        step: .02
                    },
                    lineThickness: {
                        index: 8,
                        name: "Line Thickness",
                        type: "slider",
                        value: 5,
                        min: .5,
                        max: 5,
                        step: .5
                    },
                    cameraDistance: {
                        index: 9,
                        name: "Zoom",
                        type: "slider",
                        value: 10,
                        min: 5,
                        max: 20,
                        step: 1
                    },
                    rotationMomentum: {
                        index: 10,
                        name: "Rotation Momentum",
                        type: "slider",
                        value: .29999998,
                        min: 0,
                        max: .3,
                        step: .02
                    },
                    audioVolume: {
                        index: 11,
                        name: "Audio Volume",
                        type: "slider",
                        value: .2,
                        min: 0,
                        max: 1,
                        step: .05
                    },
                    ambientLightIntensity: {
                        index: 12,
                        name: "Lighting Brightness",
                        type: "slider",
                        value: .5,
                        min: 0,
                        max: 1,
                        step: .1
                    },
                    rotationSmoothing: {
                        index: 13,
                        name: "Rotation Smoothing",
                        type: "slider",
                        value: .03,
                        min: .01,
                        max: .3,
                        step: .02
                    },
                    trailStartOpacity: {
                        index: 14,
                        name: "Trail Brightness",
                        type: "slider",
                        value: 1,
                        min: .3,
                        max: 1,
                        step: .05
                    },
                    starCount: {
                        index: 15,
                        name: "Star Count",
                        type: "slider",
                        value: 1500,
                        min: 100,
                        max: 2e3,
                        step: 100
                    },
                    shootingStarFrequency: {
                        index: 16,
                        name: "Shooting Star Frequency",
                        type: "slider",
                        value: .08,
                        min: .005,
                        max: .15,
                        step: .005
                    },
                    instructionText: {
                        index: 17,
                        name: "Instruction",
                        type: "text",
                        value: "drag to rotate",
                        group: "ui"
                    },
                    instructionColor: {
                        index: 18,
                        name: "Instruction Color",
                        type: "color",
                        value: "#FFFFFF",
                        group: "ui"
                    },
                    instructionSize: {
                        index: 19,
                        name: "Instruction Size",
                        type: "slider",
                        value: 12,
                        min: 10,
                        max: 32,
                        step: 1,
                        group: "ui"
                    },
                    showInstruction: {
                        index: 20,
                        name: "Show Instruction",
                        type: "toggle",
                        value: !0,
                        group: "ui"
                    },
                    selectedShape: {
                        index: 21,
                        name: "Shape",
                        type: "text",
                        value: "cube",
                        group: "shape"
                    }
                })
                  , jn = {
                    rotation: new es(0,0,0),
                    targetRotation: new es(0,0,0),
                    rotationVelocity: new es(0,0,0),
                    isDragging: !1,
                    lastTouch: {
                        x: 0,
                        y: 0
                    }
                };
                function DU({colorScheme: e, shapeType: t}) {
                    const n = (0,
                    lt.useRef)(null)
                      , [a,r] = (0,
                    lt.useState)([])
                      , [c,f] = (0,
                    lt.useState)("#E432B7")
                      , p = (0,
                    lt.useRef)(0)
                      , m = Si.cubeSize.useState()
                      , g = Si.trailLength.useState()
                      , v = Si.fadeOutDuration.useState()
                      , _ = Si.colorCycleSpeed.useState()
                      , x = Si.rotationSensitivity.useState()
                      , M = Si.trailOpacity.useState()
                      , C = Si.vertexSize.useState()
                      , R = Si.lineThickness.useState()
                      , A = Si.rotationMomentum.useState()
                      , E = Si.rotationSmoothing.useState()
                      , N = Si.trailStartOpacity.useState()
                      , I = {
                        rainbow: ["#E93323", "#E432B7", "#2227F5", "#53B5F9", "#75F94C", "#EFB63F", "#8762F6", "#FFDD46"],
                        pastel: ["#FFB3BA", "#FFCCCB", "#FFFFCC", "#CCFFCC", "#CCF2FF", "#E1CCFF", "#FFCCF2", "#FFE1CC"],
                        blackWhite: ["#FFFFFF", "#000000"],
                        purpleGradient: ["#8762F6", "#B59FFF", "#8762F6", "#B59FFF"],
                        cycleAll: ["#E93323", "#E432B7", "#2227F5", "#53B5F9", "#75F94C", "#EFB63F", "#8762F6", "#FFDD46"]
                    }
                      , L = I[e] || I.rainbow
                      , {vertices: k, edges: B} = (0,
                    lt.useMemo)( () => {
                        const U = m / 2;
                        if (t === "pyramid")
                            return {
                                vertices: [[-U, -U, -U], [U, -U, -U], [U, -U, U], [-U, -U, U], [0, U * 1.5, 0]].map(W => new Y(...W)),
                                edges: [[0, 1], [1, 2], [2, 3], [3, 0], [0, 4], [1, 4], [2, 4], [3, 4]]
                            };
                        if (t === "pentagon") {
                            const W = [];
                            for (let q = 0; q < 5; q++) {
                                const te = q / 5 * Math.PI * 2;
                                W.push(new Y(Math.cos(te) * U,U,Math.sin(te) * U))
                            }
                            for (let q = 0; q < 5; q++) {
                                const te = q / 5 * Math.PI * 2;
                                W.push(new Y(Math.cos(te) * U,-U,Math.sin(te) * U))
                            }
                            const K = [];
                            for (let q = 0; q < 5; q++)
                                K.push([q, (q + 1) % 5]);
                            for (let q = 0; q < 5; q++)
                                K.push([q + 5, (q + 1) % 5 + 5]);
                            for (let q = 0; q < 5; q++)
                                K.push([q, q + 5]);
                            return {
                                vertices: W,
                                edges: K
                            }
                        } else if (t === "star") {
                            const W = [];
                            for (let q = 0; q < 10; q++) {
                                const te = q / 10 * Math.PI * 2
                                  , ce = q % 2 === 0 ? U * 1.2 : U * .5;
                                W.push(new Y(Math.cos(te) * ce,U,Math.sin(te) * ce))
                            }
                            for (let q = 0; q < 10; q++) {
                                const te = q / 10 * Math.PI * 2
                                  , ce = q % 2 === 0 ? U * 1.2 : U * .5;
                                W.push(new Y(Math.cos(te) * ce,-U,Math.sin(te) * ce))
                            }
                            const K = [];
                            for (let q = 0; q < 10; q++)
                                K.push([q, (q + 1) % 10]);
                            for (let q = 0; q < 10; q++)
                                K.push([q + 10, (q + 1) % 10 + 10]);
                            for (let q = 0; q < 10; q++)
                                K.push([q, q + 10]);
                            return {
                                vertices: W,
                                edges: K
                            }
                        } else if (t === "circle") {
                            const W = [];
                            for (let q = 0; q < 12; q++) {
                                const te = q / 12 * Math.PI * 2;
                                W.push(new Y(Math.cos(te) * U,U,Math.sin(te) * U))
                            }
                            for (let q = 0; q < 12; q++) {
                                const te = q / 12 * Math.PI * 2;
                                W.push(new Y(Math.cos(te) * U,-U,Math.sin(te) * U))
                            }
                            const K = [];
                            for (let q = 0; q < 12; q++)
                                K.push([q, (q + 1) % 12]);
                            for (let q = 0; q < 12; q++)
                                K.push([q + 12, (q + 1) % 12 + 12]);
                            for (let q = 0; q < 12; q++)
                                K.push([q, q + 12]);
                            return {
                                vertices: W,
                                edges: K
                            }
                        } else if (t === "hexagon") {
                            const W = [];
                            for (let q = 0; q < 6; q++) {
                                const te = q / 6 * Math.PI * 2;
                                W.push(new Y(Math.cos(te) * U,U,Math.sin(te) * U))
                            }
                            for (let q = 0; q < 6; q++) {
                                const te = q / 6 * Math.PI * 2;
                                W.push(new Y(Math.cos(te) * U,-U,Math.sin(te) * U))
                            }
                            const K = [];
                            for (let q = 0; q < 6; q++)
                                K.push([q, (q + 1) % 6]);
                            for (let q = 0; q < 6; q++)
                                K.push([q + 6, (q + 1) % 6 + 6]);
                            for (let q = 0; q < 6; q++)
                                K.push([q, q + 6]);
                            return {
                                vertices: W,
                                edges: K
                            }
                        } else if (t === "heart") {
                            const W = []
                              , K = [];
                            K.push([.35, .8]),
                            K.push([.5, .95]),
                            K.push([.65, .8]),
                            K.push([.75, .6]),
                            K.push([.8, .4]),
                            K.push([.7, .2]),
                            K.push([.5, 0]),
                            K.push([.3, -.2]),
                            K.push([0, -.35]),
                            K.push([-.3, -.2]),
                            K.push([-.5, 0]),
                            K.push([-.7, .2]),
                            K.push([-.8, .4]),
                            K.push([-.75, .6]),
                            K.push([-.65, .8]),
                            K.push([-.5, .95]),
                            K.push([-.35, .8]);
                            for (const [ce,J] of K)
                                W.push(new Y(ce * U,U,J * U));
                            for (const [ce,J] of K)
                                W.push(new Y(ce * U,-U,J * U));
                            const q = []
                              , te = K.length;
                            for (let ce = 0; ce < te; ce++)
                                q.push([ce, (ce + 1) % te]);
                            for (let ce = 0; ce < te; ce++)
                                q.push([ce + te, (ce + 1) % te + te]);
                            for (let ce = 0; ce < te; ce++)
                                q.push([ce, ce + te]);
                            return {
                                vertices: W,
                                edges: q
                            }
                        } else
                            return {
                                vertices: [[-U, -U, -U], [U, -U, -U], [U, U, -U], [-U, U, -U], [-U, -U, U], [U, -U, U], [U, U, U], [-U, U, U]].map(W => new Y(...W)),
                                edges: [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]]
                            }
                    }
                    , [m, t]);
                    my( (U, W) => {
                        if (n.current) {
                            jn.isDragging || (jn.rotationVelocity.x *= 1 - A,
                            jn.rotationVelocity.y *= 1 - A,
                            jn.targetRotation.x += jn.rotationVelocity.x * W * 60,
                            jn.targetRotation.y += jn.rotationVelocity.y * W * 60),
                            jn.rotation.x += (jn.targetRotation.x - jn.rotation.x) * E,
                            jn.rotation.y += (jn.targetRotation.y - jn.rotation.y) * E,
                            n.current.rotation.copy(jn.rotation),
                            r(Q => [jn.rotation.clone(), ...Q].slice(0, Math.floor(g))),
                            p.current += W * _;
                            const K = L.length * 2
                              , q = p.current % K / K
                              , te = Math.floor(q * L.length)
                              , ce = (te + 1) % L.length
                              , J = q * L.length % 1;
                            f(xA(L[te], L[ce], J))
                        }
                    }
                    );
                    const X = U => {
                        jn.isDragging = !0,
                        jn.lastTouch = {
                            x: "touches"in U ? U.touches[0].clientX : U.clientX,
                            y: "touches"in U ? U.touches[0].clientY : U.clientY
                        },
                        Ao.gizmoRuntime.performHaptic("light")
                    }
                      , G = U => {
                        if (!jn.isDragging)
                            return;
                        const W = "touches"in U ? U.touches[0].clientX : U.clientX
                          , K = "touches"in U ? U.touches[0].clientY : U.clientY
                          , q = W - jn.lastTouch.x
                          , te = K - jn.lastTouch.y
                          , ce = q * x
                          , J = te * x;
                        jn.targetRotation.y += ce,
                        jn.targetRotation.x += J,
                        jn.rotationVelocity.y = ce / .016,
                        jn.rotationVelocity.x = J / .016,
                        jn.lastTouch = {
                            x: W,
                            y: K
                        }
                    }
                      , P = () => {
                        jn.isDragging = !1
                    }
                    ;
                    return (0,
                    _t.jsxs)("group", {
                        onPointerDown: X,
                        onPointerMove: G,
                        onPointerUp: P,
                        onPointerLeave: P,
                        children: [(0,
                        _t.jsxs)("group", {
                            ref: n,
                            children: [B.map( ([U,W], K) => (0,
                            _t.jsx)(bA, {
                                start: k[U],
                                end: k[W],
                                color: "#FFFFFF",
                                opacity: 1,
                                linewidth: R
                            }, `edge-${K}`)), k.map( (U, W) => (0,
                            _t.jsxs)("mesh", {
                                position: U,
                                children: [(0,
                                _t.jsx)("sphereGeometry", {
                                    args: [C, 16, 16]
                                }), (0,
                                _t.jsx)("meshBasicMaterial", {
                                    color: "#FFFFFF"
                                })]
                            }, `vert-${W}`))]
                        }), a.map( (U, W) => {
                            if (W === 0)
                                return null;
                            const K = Math.max(1, v * 60)
                              , q = Math.max(0, 1 - W / K) * N;
                            return q <= 0 ? null : (0,
                            _t.jsx)("group", {
                                rotation: U,
                                children: B.map( ([te,ce], J) => (0,
                                _t.jsx)(bA, {
                                    start: k[te],
                                    end: k[ce],
                                    color: c,
                                    opacity: q * M,
                                    linewidth: R
                                }, `trail-edge-${W}-${J}`))
                            }, `trail-${W}`)
                        }
                        )]
                    })
                }
                function NU({shapeType: e, colorScheme: t}) {
                    const n = (0,
                    lt.useRef)(null)
                      , a = Si.colorCycleSpeed.useState()
                      , r = (0,
                    lt.useRef)(0)
                      , c = {
                        rainbow: ["#E93323", "#E432B7", "#2227F5", "#53B5F9", "#75F94C", "#EFB63F", "#8762F6", "#FFDD46"],
                        pastel: ["#FFB3BA", "#FFCCCB", "#FFFFCC", "#CCFFCC", "#CCF2FF", "#E1CCFF", "#FFCCF2", "#FFE1CC"],
                        blackWhite: ["#FFFFFF", "#000000"],
                        purpleGradient: ["#8762F6", "#B59FFF", "#8762F6", "#B59FFF"],
                        cycleAll: ["#E93323", "#E432B7", "#2227F5", "#53B5F9", "#75F94C", "#EFB63F", "#8762F6", "#FFDD46"]
                    }
                      , f = c[t] || c.rainbow
                      , p = (0,
                    lt.useMemo)( () => {
                        const v = [];
                        for (let _ = 0; _ < 6; _++) {
                            const x = _ / 6 * Math.PI * 2
                              , M = 14;
                            v.push({
                                id: _,
                                position: new Y(Math.cos(x) * M,(Math.random() - .5) * 8,Math.sin(x) * M),
                                scale: .8 + Math.random() * .6,
                                rotationSpeed: Math.random() * .02 + .01
                            })
                        }
                        return v
                    }
                    , [])
                      , m = (0,
                    lt.useRef)(p.map( () => new es));
                    my( (v, _) => {
                        if (n.current) {
                            n.current.rotation.copy(jn.rotation),
                            r.current += _ * a;
                            const x = f.length * 2
                              , M = r.current % x / x
                              , C = Math.floor(M * f.length)
                              , R = (C + 1) % f.length
                              , A = M * f.length % 1
                              , E = xA(f[C], f[R], A);
                            n.current.children.forEach( (N, I) => {
                                if (I < m.current.length) {
                                    const L = m.current[I];
                                    L.x += p[I].rotationSpeed * _ * 60,
                                    L.y += p[I].rotationSpeed * _ * 60 * .7,
                                    L.z += p[I].rotationSpeed * _ * 60 * .5,
                                    N.rotation.copy(L),
                                    N.material.color.setStyle(E)
                                }
                            }
                            )
                        }
                    }
                    );
                    const g = v => {
                        switch (v) {
                        case "pyramid":
                            return (0,
                            _t.jsx)("coneGeometry", {
                                args: [1, 1.5, 4]
                            });
                        case "pentagon":
                            return (0,
                            _t.jsx)("cylinderGeometry", {
                                args: [1, 1, 1, 5]
                            });
                        case "star":
                            return (0,
                            _t.jsx)("boxGeometry", {
                                args: [1, 1, 1]
                            });
                        case "circle":
                            return (0,
                            _t.jsx)("cylinderGeometry", {
                                args: [1, 1, 1, 32]
                            });
                        case "hexagon":
                            return (0,
                            _t.jsx)("cylinderGeometry", {
                                args: [1, 1, 1, 6]
                            });
                        case "heart":
                            return (0,
                            _t.jsx)("boxGeometry", {
                                args: [1, 1, 1]
                            });
                        default:
                            return (0,
                            _t.jsx)("boxGeometry", {
                                args: [1, 1, 1]
                            })
                        }
                    }
                    ;
                    return (0,
                    _t.jsx)("group", {
                        ref: n,
                        children: p.map(v => (0,
                        _t.jsxs)("mesh", {
                            position: v.position,
                            scale: v.scale,
                            children: [g(e), (0,
                            _t.jsx)("meshBasicMaterial", {
                                color: "#FFFFFF",
                                wireframe: !0,
                                opacity: .6,
                                transparent: !0
                            })]
                        }, `cube-${v.id}`))
                    })
                }
                function bA({start: e, end: t, color: n, opacity: a, linewidth: r=2}) {
                    const c = (0,
                    lt.useMemo)( () => [e, t], [e, t]);
                    return (0,
                    _t.jsx)("line", {
                        geometry: (0,
                        lt.useMemo)( () => new Xt().setFromPoints(c), [c]),
                        children: (0,
                        _t.jsx)("lineBasicMaterial", {
                            color: n,
                            transparent: !0,
                            opacity: a,
                            linewidth: r
                        })
                    })
                }
                function LU() {
                    const e = (0,
                    lt.useRef)(null)
                      , t = (0,
                    lt.useRef)([])
                      , n = Si.starCount.useState()
                      , {positions: a} = (0,
                    lt.useMemo)( () => {
                        const r = new Float32Array(n * 3)
                          , c = [];
                        for (let f = 0; f < n; f++)
                            r[f * 3] = (Math.random() - .5) * 100,
                            r[f * 3 + 1] = (Math.random() - .5) * 100,
                            r[f * 3 + 2] = (Math.random() - .5) * 100,
                            c[f] = Math.random() * .5 + .5;
                        return t.current = c,
                        {
                            positions: r
                        }
                    }
                    , []);
                    return my( () => {
                        if (e.current)
                            for (let r = 0; r < n; r++)
                                t.current[r] += (Math.random() - .5) * .05,
                                t.current[r] = Math.max(.2, Math.min(1, t.current[r]))
                    }
                    ),
                    (0,
                    _t.jsx)("points", {
                        ref: e,
                        geometry: (0,
                        lt.useMemo)( () => {
                            const r = new Xt;
                            return r.setAttribute("position", new Vn(a,3)),
                            r
                        }
                        , [a]),
                        children: (0,
                        _t.jsx)("pointsMaterial", {
                            size: .15,
                            color: "#FFFFFF",
                            transparent: !0,
                            sizeAttenuation: !0
                        })
                    })
                }
                function UU() {
                    const e = (0,
                    lt.useRef)(null)
                      , t = Si.shootingStarFrequency.useState()
                      , n = (0,
                    lt.useRef)([])
                      , a = (0,
                    lt.useRef)(0);
                    return my( (r, c) => {
                        if (e.current) {
                            if (a.current += c,
                            Math.random() < t) {
                                const f = Math.random() * Math.PI * 2
                                  , p = new Y(Math.cos(f) * 50,(Math.random() - .5) * 60,Math.sin(f) * 50)
                                  , m = new Y((Math.random() - .5) * 30,(Math.random() - .5) * 20,(Math.random() - .5) * 30).normalize().multiplyScalar(40);
                                n.current.push({
                                    position: p,
                                    velocity: m,
                                    life: 1
                                })
                            }
                            n.current = n.current.filter(f => (f.position.addScaledVector(f.velocity, c),
                            f.life -= c * .5,
                            f.life > 0)),
                            e.current.children.forEach( (f, p) => {
                                if (p < n.current.length) {
                                    const m = n.current[p];
                                    f.position.copy(m.position);
                                    const g = f.material;
                                    g.opacity = m.life * .8,
                                    g.color.setStyle("#FFFFFF")
                                }
                            }
                            )
                        }
                    }
                    ),
                    (0,
                    _t.jsx)("group", {
                        ref: e,
                        children: Array.from({
                            length: 15
                        }).map( (r, c) => (0,
                        _t.jsxs)("mesh", {
                            children: [(0,
                            _t.jsx)("sphereGeometry", {
                                args: [.15, 6, 6]
                            }), (0,
                            _t.jsx)("meshBasicMaterial", {
                                color: "#FFFFFF",
                                transparent: !0,
                                opacity: 0
                            })]
                        }, `meteor-${c}`))
                    })
                }
                function IU() {
                    const e = Si.backgroundColor.useState()
                      , t = Si.instructionText.useState()
                      , n = Si.instructionColor.useState()
                      , a = Si.instructionSize.useState()
                      , r = Si.showInstruction.useState()
                      , c = Si.audioVolume.useState()
                      , f = Si.ambientLightIntensity.useState()
                      , p = Si.cameraDistance.useState()
                      , [m,g] = (0,
                    lt.useState)(!0)
                      , [v,_] = (0,
                    lt.useState)(!1)
                      , [x,M] = (0,
                    lt.useState)(!1)
                      , [C,R] = (0,
                    lt.useState)("rainbow")
                      , [A,E] = (0,
                    lt.useState)("cube")
                      , [N,I] = (0,
                    lt.useState)(!0)
                      , L = (0,
                    lt.useRef)(null)
                      , k = Si.selectedShape.useState();
                    return (0,
                    lt.useEffect)( () => {
                        L.current && (L.current.volume = c)
                    }
                    , [c]),
                    (0,
                    lt.useEffect)( () => {
                        if (!r)
                            return;
                        const B = setTimeout( () => {
                            g(!1)
                        }
                        , 5e3);
                        return () => clearTimeout(B)
                    }
                    , [r]),
                    (0,
                    _t.jsxs)("div", {
                        className: "h-screen w-screen overflow-hidden relative",
                        style: {
                            background: e
                        },
                        children: [(0,
                        _t.jsx)("audio", {
                            ref: L,
                            autoPlay: !0,
                            loop: !0,
                            crossOrigin: "anonymous",
                            style: {
                                display: "none"
                            },
                            children: (0,
                            _t.jsx)("source", {
                                src: "https://content.gizmo.party/a7d9b155-7143-4f11-a5ac-b56fed4b60b4",
                                type: "audio/mp4"
                            })
                        }), r && m && (0,
                        _t.jsxs)("div", {
                            className: "absolute bottom-8 right-8 pointer-events-none z-10 text-xs",
                            style: {
                                color: n,
                                fontSize: `${a}px`,
                                fontFamily: "sans-serif",
                                opacity: .8,
                                animation: "fadeOut 0.5s ease-in forwards",
                                animationDelay: "4.5s"
                            },
                            children: [(0,
                            _t.jsx)("style", {
                                children: `
            @keyframes fadeOut {
              from { opacity: 0.8; }
              to { opacity: 0; }
            }
          `
                            }), t]
                        }), (0,
                        _t.jsxs)(CU, {
                            camera: {
                                position: [0, 0, p],
                                fov: 45
                            },
                            children: [(0,
                            _t.jsx)("ambientLight", {
                                intensity: f
                            }), N && (0,
                            _t.jsx)(LU, {}), N && (0,
                            _t.jsx)(UU, {}), (0,
                            _t.jsx)(DU, {
                                colorScheme: C,
                                shapeType: A || k
                            }), N && (0,
                            _t.jsx)(NU, {
                                shapeType: A || k,
                                colorScheme: C
                            })]
                        }), (0,
                        _t.jsxs)("div", {
                            className: "absolute top-8 left-8 z-50",
                            children: [(0,
                            _t.jsx)("button", {
                                onClick: () => _(!v),
                                className: "w-10 h-10 rounded-full flex items-center justify-center",
                                style: {
                                    fontSize: "28px",
                                    lineHeight: "1",
                                    fontWeight: "300",
                                    color: "#FFFFFF",
                                    letterSpacing: "-2px"
                                },
                                children: "+"
                            }), v && (0,
                            _t.jsxs)("div", {
                                className: "absolute top-12 left-0 bg-black bg-opacity-90 rounded-lg p-2 flex flex-col gap-1 min-h-fit",
                                children: [(0,
                                _t.jsx)("button", {
                                    onClick: () => {
                                        R("rainbow"),
                                        _(!1),
                                        Ao.gizmoRuntime.performHaptic("light")
                                    }
                                    ,
                                    className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left lowercase",
                                    style: {
                                        fontSize: "10px"
                                    },
                                    children: "rainbow"
                                }), (0,
                                _t.jsx)("button", {
                                    onClick: () => {
                                        R("pastel"),
                                        _(!1),
                                        Ao.gizmoRuntime.performHaptic("light")
                                    }
                                    ,
                                    className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left lowercase",
                                    style: {
                                        fontSize: "10px"
                                    },
                                    children: "pastel"
                                }), (0,
                                _t.jsx)("button", {
                                    onClick: () => {
                                        R("blackWhite"),
                                        _(!1),
                                        Ao.gizmoRuntime.performHaptic("light")
                                    }
                                    ,
                                    className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left lowercase",
                                    style: {
                                        fontSize: "10px"
                                    },
                                    children: "black & white"
                                }), (0,
                                _t.jsx)("button", {
                                    onClick: () => {
                                        R("purpleGradient"),
                                        _(!1),
                                        Ao.gizmoRuntime.performHaptic("light")
                                    }
                                    ,
                                    className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left lowercase",
                                    style: {
                                        fontSize: "10px"
                                    },
                                    children: "purple gradient"
                                }), (0,
                                _t.jsx)("button", {
                                    onClick: () => {
                                        R("cycleAll"),
                                        _(!1),
                                        Ao.gizmoRuntime.performHaptic("light")
                                    }
                                    ,
                                    className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left lowercase",
                                    style: {
                                        fontSize: "10px"
                                    },
                                    children: "cycle all"
                                }), (0,
                                _t.jsx)("div", {
                                    className: "border-t border-white border-opacity-20 my-1"
                                }), (0,
                                _t.jsx)("button", {
                                    onClick: () => {
                                        I(!N),
                                        Ao.gizmoRuntime.performHaptic("light")
                                    }
                                    ,
                                    className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left lowercase",
                                    style: {
                                        fontSize: "10px"
                                    },
                                    children: N ? "simple" : "full"
                                })]
                            })]
                        }), (0,
                        _t.jsx)("div", {
                            className: "absolute top-8 right-8 z-50",
                            children: (0,
                            _t.jsxs)("button", {
                                onClick: () => {
                                    const B = ["cube", "pyramid", "pentagon", "star", "circle", "hexagon"];
                                    E(B[(B.indexOf(A) + 1) % B.length]),
                                    Ao.gizmoRuntime.performHaptic("light")
                                }
                                ,
                                className: "text-white text-xs px-2 py-1 rounded hover:bg-white hover:bg-opacity-10 text-left",
                                style: {
                                    fontSize: "16px",
                                    minWidth: "40px",
                                    textAlign: "center",
                                    height: "40px",
                                    display: "flex",
                                    alignItems: "center",
                                    justifyContent: "center",
                                    background: "none",
                                    border: "none"
                                },
                                children: [A === "cube" && "\u25A2", A === "pyramid" && "\u25B3", A === "pentagon" && "\u2B20", A === "star" && "\u2605", A === "circle" && "\u25CF", A === "hexagon" && "\u2B21"]
                            })
                        })]
                    })
                }
                window.React = lt.default,
                window.gizmoRuntime = Ao.gizmoRuntime;
                var OU = class extends lt.Component {
                    render() {
                        return (0,
                        _t.jsx)(IU, {})
                    }
                }
                ;
                tw.createRoot(document.getElementById("application")).render((0,
                _t.jsx)(OU, {}));

                //# sourceMappingURL=app.js.map
            </script>
        </div>
    </body>
</html>
